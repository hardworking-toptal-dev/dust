"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bignumber.js";
exports.ids = ["vendor-chunks/bignumber.js"];
exports.modules = {

/***/ "(ssr)/../node_modules/bignumber.js/bignumber.mjs":
/*!**************************************************!*\
  !*** ../node_modules/bignumber.js/bignumber.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *      bignumber.js v9.1.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */ var isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = \"[BigNumber Error] \", tooManyDigits = bignumberError + \"Number primitive has more than 15 significant digits: \", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\nPOWS_TEN = [\n    1,\n    10,\n    100,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n    1e11,\n    1e12,\n    1e13\n], SQRT_BASE = 1e7, // EDITABLE\n// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\n// the arguments to toExponential, toFixed, toFormat, and toPrecision.\nMAX = 1E9; // 0 to MAX_INT32\n/*\r\n * Create and return a BigNumber constructor.\r\n */ function clone(configObject) {\n    var div, convertBase, parseNumeric, P = BigNumber.prototype = {\n        constructor: BigNumber,\n        toString: null,\n        valueOf: null\n    }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\n    // The default values below must be integers within the inclusive ranges stated.\n    // The values can also be changed at run-time using BigNumber.set.\n    // The maximum number of decimal places for operations involving division.\n    DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\n    // UP         0 Away from zero.\n    // DOWN       1 Towards zero.\n    // CEIL       2 Towards +Infinity.\n    // FLOOR      3 Towards -Infinity.\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n    // The exponent value at and beneath which toString returns exponential notation.\n    // Number type: -7\n    TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.\n    // Number type: 21\n    TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // Number type: -324  (5e-324)\n    MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.\n    // Number type:  308  (1.7976931348623157e+308)\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\n    MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.\n    CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN      1 The remainder has the same sign as the dividend.\n    //             This modulo mode is commonly known as 'truncated division' and is\n    //             equivalent to (a % n) in JavaScript.\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\n    //             The remainder is always positive.\n    //\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\n    // modes are commonly used for the modulus operation.\n    // Although the other rounding modes can also be used, they may not give useful results.\n    MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\n    POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.\n    FORMAT = {\n        prefix: \"\",\n        groupSize: 3,\n        secondaryGroupSize: 0,\n        groupSeparator: \",\",\n        decimalSeparator: \".\",\n        fractionGroupSize: 0,\n        fractionGroupSeparator: \"\\xa0\",\n        suffix: \"\"\n    }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\n    // '-', '.', whitespace, or repeated character.\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n    ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\", alphabetHasNormalDecimalDigits = true;\n    //------------------------------------------------------------------------------------------\n    // CONSTRUCTOR\n    /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */ function BigNumber(v, b) {\n        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;\n        // Enable constructor call without `new`.\n        if (!(x instanceof BigNumber)) return new BigNumber(v, b);\n        if (b == null) {\n            if (v && v._isBigNumber === true) {\n                x.s = v.s;\n                if (!v.c || v.e > MAX_EXP) {\n                    x.c = x.e = null;\n                } else if (v.e < MIN_EXP) {\n                    x.c = [\n                        x.e = 0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.c = v.c.slice();\n                }\n                return;\n            }\n            if ((isNum = typeof v == \"number\") && v * 0 == 0) {\n                // Use `1 / n` to handle minus zero also.\n                x.s = 1 / v < 0 ? (v = -v, -1) : 1;\n                // Fast path for integers, where n < 2147483648 (2**31).\n                if (v === ~~v) {\n                    for(e = 0, i = v; i >= 10; i /= 10, e++);\n                    if (e > MAX_EXP) {\n                        x.c = x.e = null;\n                    } else {\n                        x.e = e;\n                        x.c = [\n                            v\n                        ];\n                    }\n                    return;\n                }\n                str = String(v);\n            } else {\n                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\n                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\n            }\n            // Decimal point?\n            if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n            // Exponential form?\n            if ((i = str.search(/e/i)) > 0) {\n                // Determine exponent.\n                if (e < 0) e = i;\n                e += +str.slice(i + 1);\n                str = str.substring(0, i);\n            } else if (e < 0) {\n                // Integer.\n                e = str.length;\n            }\n        } else {\n            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n            intCheck(b, 2, ALPHABET.length, \"Base\");\n            // Allow exponential notation to be used with base 10 argument, while\n            // also rounding to DECIMAL_PLACES as with other bases.\n            if (b == 10 && alphabetHasNormalDecimalDigits) {\n                x = new BigNumber(v);\n                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\n            }\n            str = String(v);\n            if (isNum = typeof v == \"number\") {\n                // Avoid potential interpretation of Infinity and NaN as base 44+ values.\n                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\n                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\n                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, \"\").length > 15) {\n                    throw Error(tooManyDigits + v);\n                }\n            } else {\n                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\n            }\n            alphabet = ALPHABET.slice(0, b);\n            e = i = 0;\n            // Check that str is a valid base b number.\n            // Don't use RegExp, so alphabet can contain special characters.\n            for(len = str.length; i < len; i++){\n                if (alphabet.indexOf(c = str.charAt(i)) < 0) {\n                    if (c == \".\") {\n                        // If '.' is not the first character and it has not be found before.\n                        if (i > e) {\n                            e = len;\n                            continue;\n                        }\n                    } else if (!caseChanged) {\n                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.\n                        if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {\n                            caseChanged = true;\n                            i = -1;\n                            e = 0;\n                            continue;\n                        }\n                    }\n                    return parseNumeric(x, String(v), isNum, b);\n                }\n            }\n            // Prevent later check for length on converted number.\n            isNum = false;\n            str = convertBase(str, b, 10, x.s);\n            // Decimal point?\n            if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n            else e = str.length;\n        }\n        // Determine leading zeros.\n        for(i = 0; str.charCodeAt(i) === 48; i++);\n        // Determine trailing zeros.\n        for(len = str.length; str.charCodeAt(--len) === 48;);\n        if (str = str.slice(i, ++len)) {\n            len -= i;\n            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n            if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\n                throw Error(tooManyDigits + x.s * v);\n            }\n            // Overflow?\n            if ((e = e - i - 1) > MAX_EXP) {\n                // Infinity.\n                x.c = x.e = null;\n            // Underflow?\n            } else if (e < MIN_EXP) {\n                // Zero.\n                x.c = [\n                    x.e = 0\n                ];\n            } else {\n                x.e = e;\n                x.c = [];\n                // Transform base\n                // e is the base 10 exponent.\n                // i is where to slice str to get the first element of the coefficient array.\n                i = (e + 1) % LOG_BASE;\n                if (e < 0) i += LOG_BASE; // i < 1\n                if (i < len) {\n                    if (i) x.c.push(+str.slice(0, i));\n                    for(len -= LOG_BASE; i < len;){\n                        x.c.push(+str.slice(i, i += LOG_BASE));\n                    }\n                    i = LOG_BASE - (str = str.slice(i)).length;\n                } else {\n                    i -= len;\n                }\n                for(; i--; str += \"0\");\n                x.c.push(+str);\n            }\n        } else {\n            // Zero.\n            x.c = [\n                x.e = 0\n            ];\n        }\n    }\n    // CONSTRUCTOR PROPERTIES\n    BigNumber.clone = clone;\n    BigNumber.ROUND_UP = 0;\n    BigNumber.ROUND_DOWN = 1;\n    BigNumber.ROUND_CEIL = 2;\n    BigNumber.ROUND_FLOOR = 3;\n    BigNumber.ROUND_HALF_UP = 4;\n    BigNumber.ROUND_HALF_DOWN = 5;\n    BigNumber.ROUND_HALF_EVEN = 6;\n    BigNumber.ROUND_HALF_CEIL = 7;\n    BigNumber.ROUND_HALF_FLOOR = 8;\n    BigNumber.EUCLID = 9;\n    /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */ BigNumber.config = BigNumber.set = function(obj) {\n        var p, v;\n        if (obj != null) {\n            if (typeof obj == \"object\") {\n                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\n                // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"DECIMAL_PLACES\")) {\n                    v = obj[p];\n                    intCheck(v, 0, MAX, p);\n                    DECIMAL_PLACES = v;\n                }\n                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\n                // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"ROUNDING_MODE\")) {\n                    v = obj[p];\n                    intCheck(v, 0, 8, p);\n                    ROUNDING_MODE = v;\n                }\n                // EXPONENTIAL_AT {number|number[]}\n                // Integer, -MAX to MAX inclusive or\n                // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\n                // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"EXPONENTIAL_AT\")) {\n                    v = obj[p];\n                    if (v && v.pop) {\n                        intCheck(v[0], -MAX, 0, p);\n                        intCheck(v[1], 0, MAX, p);\n                        TO_EXP_NEG = v[0];\n                        TO_EXP_POS = v[1];\n                    } else {\n                        intCheck(v, -MAX, MAX, p);\n                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\n                    }\n                }\n                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\n                // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\n                if (obj.hasOwnProperty(p = \"RANGE\")) {\n                    v = obj[p];\n                    if (v && v.pop) {\n                        intCheck(v[0], -MAX, -1, p);\n                        intCheck(v[1], 1, MAX, p);\n                        MIN_EXP = v[0];\n                        MAX_EXP = v[1];\n                    } else {\n                        intCheck(v, -MAX, MAX, p);\n                        if (v) {\n                            MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\n                        } else {\n                            throw Error(bignumberError + p + \" cannot be zero: \" + v);\n                        }\n                    }\n                }\n                // CRYPTO {boolean} true or false.\n                // '[BigNumber Error] CRYPTO not true or false: {v}'\n                // '[BigNumber Error] crypto unavailable'\n                if (obj.hasOwnProperty(p = \"CRYPTO\")) {\n                    v = obj[p];\n                    if (v === !!v) {\n                        if (v) {\n                            if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                                CRYPTO = v;\n                            } else {\n                                CRYPTO = !v;\n                                throw Error(bignumberError + \"crypto unavailable\");\n                            }\n                        } else {\n                            CRYPTO = v;\n                        }\n                    } else {\n                        throw Error(bignumberError + p + \" not true or false: \" + v);\n                    }\n                }\n                // MODULO_MODE {number} Integer, 0 to 9 inclusive.\n                // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"MODULO_MODE\")) {\n                    v = obj[p];\n                    intCheck(v, 0, 9, p);\n                    MODULO_MODE = v;\n                }\n                // POW_PRECISION {number} Integer, 0 to MAX inclusive.\n                // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"POW_PRECISION\")) {\n                    v = obj[p];\n                    intCheck(v, 0, MAX, p);\n                    POW_PRECISION = v;\n                }\n                // FORMAT {object}\n                // '[BigNumber Error] FORMAT not an object: {v}'\n                if (obj.hasOwnProperty(p = \"FORMAT\")) {\n                    v = obj[p];\n                    if (typeof v == \"object\") FORMAT = v;\n                    else throw Error(bignumberError + p + \" not an object: \" + v);\n                }\n                // ALPHABET {string}\n                // '[BigNumber Error] ALPHABET invalid: {v}'\n                if (obj.hasOwnProperty(p = \"ALPHABET\")) {\n                    v = obj[p];\n                    // Disallow if less than two characters,\n                    // or if it contains '+', '-', '.', whitespace, or a repeated character.\n                    if (typeof v == \"string\" && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\n                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == \"0123456789\";\n                        ALPHABET = v;\n                    } else {\n                        throw Error(bignumberError + p + \" invalid: \" + v);\n                    }\n                }\n            } else {\n                // '[BigNumber Error] Object expected: {v}'\n                throw Error(bignumberError + \"Object expected: \" + obj);\n            }\n        }\n        return {\n            DECIMAL_PLACES: DECIMAL_PLACES,\n            ROUNDING_MODE: ROUNDING_MODE,\n            EXPONENTIAL_AT: [\n                TO_EXP_NEG,\n                TO_EXP_POS\n            ],\n            RANGE: [\n                MIN_EXP,\n                MAX_EXP\n            ],\n            CRYPTO: CRYPTO,\n            MODULO_MODE: MODULO_MODE,\n            POW_PRECISION: POW_PRECISION,\n            FORMAT: FORMAT,\n            ALPHABET: ALPHABET\n        };\n    };\n    /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */ BigNumber.isBigNumber = function(v) {\n        if (!v || v._isBigNumber !== true) return false;\n        if (!BigNumber.DEBUG) return true;\n        var i, n, c = v.c, e = v.e, s = v.s;\n        out: if (({}).toString.call(c) == \"[object Array]\") {\n            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\n                // If the first element is zero, the BigNumber value must be zero.\n                if (c[0] === 0) {\n                    if (e === 0 && c.length === 1) return true;\n                    break out;\n                }\n                // Calculate number of digits that c[0] should have, based on the exponent.\n                i = (e + 1) % LOG_BASE;\n                if (i < 1) i += LOG_BASE;\n                // Calculate number of digits of c[0].\n                //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\n                if (String(c[0]).length == i) {\n                    for(i = 0; i < c.length; i++){\n                        n = c[i];\n                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\n                    }\n                    // Last element cannot be zero, unless it is the only element.\n                    if (n !== 0) return true;\n                }\n            }\n        // Infinity/NaN\n        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\n            return true;\n        }\n        throw Error(bignumberError + \"Invalid BigNumber: \" + v);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.maximum = BigNumber.max = function() {\n        return maxOrMin(arguments, -1);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.minimum = BigNumber.min = function() {\n        return maxOrMin(arguments, 1);\n    };\n    /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */ BigNumber.random = function() {\n        var pow2_53 = 0x20000000000000;\n        // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\n        // Check if Math.random() produces more than 32 bits of randomness.\n        // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\n        // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\n        var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {\n            return mathfloor(Math.random() * pow2_53);\n        } : function() {\n            return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);\n        };\n        return function(dp) {\n            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);\n            if (dp == null) dp = DECIMAL_PLACES;\n            else intCheck(dp, 0, MAX);\n            k = mathceil(dp / LOG_BASE);\n            if (CRYPTO) {\n                // Browsers supporting crypto.getRandomValues.\n                if (crypto.getRandomValues) {\n                    a = crypto.getRandomValues(new Uint32Array(k *= 2));\n                    for(; i < k;){\n                        // 53 bits:\n                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\n                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000\n                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\n                        //                                     11111 11111111 11111111\n                        // 0x20000 is 2^21.\n                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);\n                        // Rejection sampling:\n                        // 0 <= v < 9007199254740992\n                        // Probability that v >= 9e15, is\n                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\n                        if (v >= 9e15) {\n                            b = crypto.getRandomValues(new Uint32Array(2));\n                            a[i] = b[0];\n                            a[i + 1] = b[1];\n                        } else {\n                            // 0 <= v <= 8999999999999999\n                            // 0 <= (v % 1e14) <= 99999999999999\n                            c.push(v % 1e14);\n                            i += 2;\n                        }\n                    }\n                    i = k / 2;\n                // Node.js supporting crypto.randomBytes.\n                } else if (crypto.randomBytes) {\n                    // buffer\n                    a = crypto.randomBytes(k *= 7);\n                    for(; i < k;){\n                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\n                        // 0x100000000 is 2^32, 0x1000000 is 2^24\n                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111\n                        // 0 <= v < 9007199254740992\n                        v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\n                        if (v >= 9e15) {\n                            crypto.randomBytes(7).copy(a, i);\n                        } else {\n                            // 0 <= (v % 1e14) <= 99999999999999\n                            c.push(v % 1e14);\n                            i += 7;\n                        }\n                    }\n                    i = k / 7;\n                } else {\n                    CRYPTO = false;\n                    throw Error(bignumberError + \"crypto unavailable\");\n                }\n            }\n            // Use Math.random.\n            if (!CRYPTO) {\n                for(; i < k;){\n                    v = random53bitInt();\n                    if (v < 9e15) c[i++] = v % 1e14;\n                }\n            }\n            k = c[--i];\n            dp %= LOG_BASE;\n            // Convert trailing digits to zeros according to dp.\n            if (k && dp) {\n                v = POWS_TEN[LOG_BASE - dp];\n                c[i] = mathfloor(k / v) * v;\n            }\n            // Remove trailing elements which are zero.\n            for(; c[i] === 0; c.pop(), i--);\n            // Zero?\n            if (i < 0) {\n                c = [\n                    e = 0\n                ];\n            } else {\n                // Remove leading elements which are zero and adjust exponent accordingly.\n                for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\n                // Count the digits of the first element of c to determine leading zeros, and...\n                for(i = 1, v = c[0]; v >= 10; v /= 10, i++);\n                // adjust the exponent accordingly.\n                if (i < LOG_BASE) e -= LOG_BASE - i;\n            }\n            rand.e = e;\n            rand.c = c;\n            return rand;\n        };\n    }();\n    /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.sum = function() {\n        var i = 1, args = arguments, sum = new BigNumber(args[0]);\n        for(; i < args.length;)sum = sum.plus(args[i++]);\n        return sum;\n    };\n    // PRIVATE FUNCTIONS\n    // Called by BigNumber and BigNumber.prototype.toString.\n    convertBase = function() {\n        var decimal = \"0123456789\";\n        /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */ function toBaseOut(str, baseIn, baseOut, alphabet) {\n            var j, arr = [\n                0\n            ], arrL, i = 0, len = str.length;\n            for(; i < len;){\n                for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);\n                arr[0] += alphabet.indexOf(str.charAt(i++));\n                for(j = 0; j < arr.length; j++){\n                    if (arr[j] > baseOut - 1) {\n                        if (arr[j + 1] == null) arr[j + 1] = 0;\n                        arr[j + 1] += arr[j] / baseOut | 0;\n                        arr[j] %= baseOut;\n                    }\n                }\n            }\n            return arr.reverse();\n        }\n        // Convert a numeric string of baseIn to a numeric string of baseOut.\n        // If the caller is toString, we are converting from base 10 to baseOut.\n        // If the caller is BigNumber, we are converting from baseIn to base 10.\n        return function(str, baseIn, baseOut, sign, callerIsToString) {\n            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf(\".\"), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;\n            // Non-integer.\n            if (i >= 0) {\n                k = POW_PRECISION;\n                // Unlimited precision.\n                POW_PRECISION = 0;\n                str = str.replace(\".\", \"\");\n                y = new BigNumber(baseIn);\n                x = y.pow(str.length - i);\n                POW_PRECISION = k;\n                // Convert str as if an integer, then restore the fraction part by dividing the\n                // result by its base raised to a power.\n                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, \"0\"), 10, baseOut, decimal);\n                y.e = y.c.length;\n            }\n            // Convert the number as integer.\n            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));\n            // xc now represents str as an integer and converted to baseOut. e is the exponent.\n            e = k = xc.length;\n            // Remove trailing zeros.\n            for(; xc[--k] == 0; xc.pop());\n            // Zero?\n            if (!xc[0]) return alphabet.charAt(0);\n            // Does str represent an integer? If so, no need for the division.\n            if (i < 0) {\n                --e;\n            } else {\n                x.c = xc;\n                x.e = e;\n                // The sign is needed for correct rounding.\n                x.s = sign;\n                x = div(x, y, dp, rm, baseOut);\n                xc = x.c;\n                r = x.r;\n                e = x.e;\n            }\n            // xc now represents str converted to baseOut.\n            // THe index of the rounding digit.\n            d = e + dp + 1;\n            // The rounding digit: the digit to the right of the digit that may be rounded up.\n            i = xc[d];\n            // Look at the rounding digits and mode to determine whether to round up.\n            k = baseOut / 2;\n            r = r || d < 0 || xc[d + 1] != null;\n            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));\n            // If the index of the rounding digit is not greater than zero, or xc represents\n            // zero, then the result of the base conversion is zero or, if rounding up, a value\n            // such as 0.00001.\n            if (d < 1 || !xc[0]) {\n                // 1^-dp or 0\n                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\n            } else {\n                // Truncate xc to the required number of decimal places.\n                xc.length = d;\n                // Round up?\n                if (r) {\n                    // Rounding up may mean the previous digit has to be rounded up and so on.\n                    for(--baseOut; ++xc[--d] > baseOut;){\n                        xc[d] = 0;\n                        if (!d) {\n                            ++e;\n                            xc = [\n                                1\n                            ].concat(xc);\n                        }\n                    }\n                }\n                // Determine trailing zeros.\n                for(k = xc.length; !xc[--k];);\n                // E.g. [4, 11, 15] becomes 4bf.\n                for(i = 0, str = \"\"; i <= k; str += alphabet.charAt(xc[i++]));\n                // Add leading zeros, decimal point and trailing zeros as required.\n                str = toFixedPoint(str, e, alphabet.charAt(0));\n            }\n            // The caller will add the sign.\n            return str;\n        };\n    }();\n    // Perform division in the specified base. Called by div and convertBase.\n    div = function() {\n        // Assume non-zero x and k.\n        function multiply(x, k, base) {\n            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;\n            for(x = x.slice(); i--;){\n                xlo = x[i] % SQRT_BASE;\n                xhi = x[i] / SQRT_BASE | 0;\n                m = khi * xlo + xhi * klo;\n                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;\n                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\n                x[i] = temp % base;\n            }\n            if (carry) x = [\n                carry\n            ].concat(x);\n            return x;\n        }\n        function compare(a, b, aL, bL) {\n            var i, cmp;\n            if (aL != bL) {\n                cmp = aL > bL ? 1 : -1;\n            } else {\n                for(i = cmp = 0; i < aL; i++){\n                    if (a[i] != b[i]) {\n                        cmp = a[i] > b[i] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            return cmp;\n        }\n        function subtract(a, b, aL, base) {\n            var i = 0;\n            // Subtract b from a.\n            for(; aL--;){\n                a[aL] -= i;\n                i = a[aL] < b[aL] ? 1 : 0;\n                a[aL] = i * base + a[aL] - b[aL];\n            }\n            // Remove leading zeros.\n            for(; !a[0] && a.length > 1; a.splice(0, 1));\n        }\n        // x: dividend, y: divisor.\n        return function(x, y, dp, rm, base) {\n            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;\n            // Either NaN, Infinity or 0?\n            if (!xc || !xc[0] || !yc || !yc[0]) {\n                return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.\n                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\n                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);\n            }\n            q = new BigNumber(s);\n            qc = q.c = [];\n            e = x.e - y.e;\n            s = dp + e + 1;\n            if (!base) {\n                base = BASE;\n                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\n                s = s / LOG_BASE | 0;\n            }\n            // Result exponent may be one less then the current value of e.\n            // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n            for(i = 0; yc[i] == (xc[i] || 0); i++);\n            if (yc[i] > (xc[i] || 0)) e--;\n            if (s < 0) {\n                qc.push(1);\n                more = true;\n            } else {\n                xL = xc.length;\n                yL = yc.length;\n                i = 0;\n                s += 2;\n                // Normalise xc and yc so highest order digit of yc is >= base / 2.\n                n = mathfloor(base / (yc[0] + 1));\n                // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\n                // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\n                if (n > 1) {\n                    yc = multiply(yc, n, base);\n                    xc = multiply(xc, n, base);\n                    yL = yc.length;\n                    xL = xc.length;\n                }\n                xi = yL;\n                rem = xc.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL; rem[remL++] = 0);\n                yz = yc.slice();\n                yz = [\n                    0\n                ].concat(yz);\n                yc0 = yc[0];\n                if (yc[1] >= base / 2) yc0++;\n                // Not necessary, but to prevent trial digit n > base, when using base 3.\n                // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\n                do {\n                    n = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yc, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, n.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // n is how many times the divisor goes into the current remainder.\n                        n = mathfloor(rem0 / yc0);\n                        //  Algorithm:\n                        //  product = divisor multiplied by trial digit (n).\n                        //  Compare product and remainder.\n                        //  If product is greater than remainder:\n                        //    Subtract divisor from product, decrement trial digit.\n                        //  Subtract product from remainder.\n                        //  If product was less than remainder at the last compare:\n                        //    Compare new remainder and divisor.\n                        //    If remainder is greater than divisor:\n                        //      Subtract divisor from remainder, increment trial digit.\n                        if (n > 1) {\n                            // n may be > base only when base is 3.\n                            if (n >= base) n = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiply(yc, n, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            // If product > remainder then trial digit n too high.\n                            // n is 1 too high about 5% of the time, and is not known to have\n                            // ever been more than 1 too high.\n                            while(compare(prod, rem, prodL, remL) == 1){\n                                n--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yc, prodL, base);\n                                prodL = prod.length;\n                                cmp = 1;\n                            }\n                        } else {\n                            // n is 0 or 1, cmp is -1.\n                            // If n is 0, there is no need to compare yc and rem again below,\n                            // so change cmp to 1 to avoid it.\n                            // If n is 1, leave cmp as -1, so yc and rem are compared again.\n                            if (n == 0) {\n                                // divisor < remainder, so n must be at least 1.\n                                cmp = n = 1;\n                            }\n                            // product = divisor\n                            prod = yc.slice();\n                            prodL = prod.length;\n                        }\n                        if (prodL < remL) prod = [\n                            0\n                        ].concat(prod);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        remL = rem.length;\n                        // If product was < remainder.\n                        if (cmp == -1) {\n                            // Compare divisor and new remainder.\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            // Trial digit n too low.\n                            // n is 1 too low about 5% of the time, and very rarely 2 too low.\n                            while(compare(yc, rem, yL, remL) < 1){\n                                n++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yc, remL, base);\n                                remL = rem.length;\n                            }\n                        }\n                    } else if (cmp === 0) {\n                        n++;\n                        rem = [\n                            0\n                        ];\n                    } // else cmp === 1 and n will be 0\n                    // Add the next digit, n, to the result array.\n                    qc[i++] = n;\n                    // Update the remainder.\n                    if (rem[0]) {\n                        rem[remL++] = xc[xi] || 0;\n                    } else {\n                        rem = [\n                            xc[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] != null) && s--);\n                more = rem[0] != null;\n                // Leading zero?\n                if (!qc[0]) qc.splice(0, 1);\n            }\n            if (base == BASE) {\n                // To calculate q.e, first get the number of digits of qc[0].\n                for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);\n                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\n            // Caller is convertBase.\n            } else {\n                q.e = e;\n                q.r = +more;\n            }\n            return q;\n        };\n    }();\n    /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */ function format(n, i, rm, id) {\n        var c0, e, ne, len, str;\n        if (rm == null) rm = ROUNDING_MODE;\n        else intCheck(rm, 0, 8);\n        if (!n.c) return n.toString();\n        c0 = n.c[0];\n        ne = n.e;\n        if (i == null) {\n            str = coeffToString(n.c);\n            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, \"0\");\n        } else {\n            n = round(new BigNumber(n), i, rm);\n            // n.e may have changed if the value was rounded up.\n            e = n.e;\n            str = coeffToString(n.c);\n            len = str.length;\n            // toPrecision returns exponential notation if the number of significant digits\n            // specified is less than the number of digits necessary to represent the integer\n            // part of the value in fixed-point notation.\n            // Exponential notation.\n            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\n                // Append zeros?\n                for(; len < i; str += \"0\", len++);\n                str = toExponential(str, e);\n            // Fixed-point notation.\n            } else {\n                i -= ne;\n                str = toFixedPoint(str, e, \"0\");\n                // Append zeros?\n                if (e + 1 > len) {\n                    if (--i > 0) for(str += \".\"; i--; str += \"0\");\n                } else {\n                    i += e - len;\n                    if (i > 0) {\n                        if (e + 1 == len) str += \".\";\n                        for(; i--; str += \"0\");\n                    }\n                }\n            }\n        }\n        return n.s < 0 && c0 ? \"-\" + str : str;\n    }\n    // Handle BigNumber.max and BigNumber.min.\n    // If any number is NaN, return NaN.\n    function maxOrMin(args, n) {\n        var k, y, i = 1, x = new BigNumber(args[0]);\n        for(; i < args.length; i++){\n            y = new BigNumber(args[i]);\n            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\n                x = y;\n            }\n        }\n        return x;\n    }\n    /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */ function normalise(n, c, e) {\n        var i = 1, j = c.length;\n        // Remove trailing zeros.\n        for(; !c[--j]; c.pop());\n        // Calculate the base 10 exponent. First get the number of digits of c[0].\n        for(j = c[0]; j >= 10; j /= 10, i++);\n        // Overflow?\n        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\n            // Infinity.\n            n.c = n.e = null;\n        // Underflow?\n        } else if (e < MIN_EXP) {\n            // Zero.\n            n.c = [\n                n.e = 0\n            ];\n        } else {\n            n.e = e;\n            n.c = c;\n        }\n        return n;\n    }\n    // Handle values that fail the validity test in BigNumber.\n    parseNumeric = function() {\n        var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, dotAfter = /^([^.]+)\\.$/, dotBefore = /^\\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n        return function(x, str, isNum, b) {\n            var base, s = isNum ? str : str.replace(whitespaceOrPlus, \"\");\n            // No exception on ±Infinity or NaN.\n            if (isInfinityOrNaN.test(s)) {\n                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\n            } else {\n                if (!isNum) {\n                    // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\n                    s = s.replace(basePrefix, function(m, p1, p2) {\n                        base = (p2 = p2.toLowerCase()) == \"x\" ? 16 : p2 == \"b\" ? 2 : 8;\n                        return !b || b == base ? p1 : m;\n                    });\n                    if (b) {\n                        base = b;\n                        // E.g. '1.' to '1', '.1' to '0.1'\n                        s = s.replace(dotAfter, \"$1\").replace(dotBefore, \"0.$1\");\n                    }\n                    if (str != s) return new BigNumber(s, base);\n                }\n                // '[BigNumber Error] Not a number: {n}'\n                // '[BigNumber Error] Not a base {b} number: {n}'\n                if (BigNumber.DEBUG) {\n                    throw Error(bignumberError + \"Not a\" + (b ? \" base \" + b : \"\") + \" number: \" + str);\n                }\n                // NaN\n                x.s = null;\n            }\n            x.c = x.e = null;\n        };\n    }();\n    /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */ function round(x, sd, rm, r) {\n        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;\n        // if x is not Infinity or NaN...\n        if (xc) {\n            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\n            // n is a base 1e14 number, the value of the element of array x.c containing rd.\n            // ni is the index of n within x.c.\n            // d is the number of digits of n.\n            // i is the index of rd within n including leading zeros.\n            // j is the actual index of rd within n (if < 0, rd is a leading zero).\n            out: {\n                // Get the number of digits of the first element of xc.\n                for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);\n                i = sd - d;\n                // If the rounding digit is in the first element of xc...\n                if (i < 0) {\n                    i += LOG_BASE;\n                    j = sd;\n                    n = xc[ni = 0];\n                    // Get the rounding digit at index j of n.\n                    rd = mathfloor(n / pows10[d - j - 1] % 10);\n                } else {\n                    ni = mathceil((i + 1) / LOG_BASE);\n                    if (ni >= xc.length) {\n                        if (r) {\n                            // Needed by sqrt.\n                            for(; xc.length <= ni; xc.push(0));\n                            n = rd = 0;\n                            d = 1;\n                            i %= LOG_BASE;\n                            j = i - LOG_BASE + 1;\n                        } else {\n                            break out;\n                        }\n                    } else {\n                        n = k = xc[ni];\n                        // Get the number of digits of n.\n                        for(d = 1; k >= 10; k /= 10, d++);\n                        // Get the index of rd within n.\n                        i %= LOG_BASE;\n                        // Get the index of rd within n, adjusted for leading zeros.\n                        // The number of leading zeros of n is given by LOG_BASE - d.\n                        j = i - LOG_BASE + d;\n                        // Get the rounding digit at index j of n.\n                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\n                    }\n                }\n                r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?\n                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\n                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n                if (sd < 1 || !xc[0]) {\n                    xc.length = 0;\n                    if (r) {\n                        // Convert sd to decimal places.\n                        sd -= x.e + 1;\n                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\n                        x.e = -sd || 0;\n                    } else {\n                        // Zero.\n                        xc[0] = x.e = 0;\n                    }\n                    return x;\n                }\n                // Remove excess digits.\n                if (i == 0) {\n                    xc.length = ni;\n                    k = 1;\n                    ni--;\n                } else {\n                    xc.length = ni + 1;\n                    k = pows10[LOG_BASE - i];\n                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                    // j > 0 means i > number of leading zeros of n.\n                    xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\n                }\n                // Round up?\n                if (r) {\n                    for(;;){\n                        // If the digit to be rounded up is in the first element of xc...\n                        if (ni == 0) {\n                            // i will be the length of xc[0] before k is added.\n                            for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);\n                            j = xc[0] += k;\n                            for(k = 1; j >= 10; j /= 10, k++);\n                            // if i != k the length has increased.\n                            if (i != k) {\n                                x.e++;\n                                if (xc[0] == BASE) xc[0] = 1;\n                            }\n                            break;\n                        } else {\n                            xc[ni] += k;\n                            if (xc[ni] != BASE) break;\n                            xc[ni--] = 0;\n                            k = 1;\n                        }\n                    }\n                }\n                // Remove trailing zeros.\n                for(i = xc.length; xc[--i] === 0; xc.pop());\n            }\n            // Overflow? Infinity.\n            if (x.e > MAX_EXP) {\n                x.c = x.e = null;\n            // Underflow? Zero.\n            } else if (x.e < MIN_EXP) {\n                x.c = [\n                    x.e = 0\n                ];\n            }\n        }\n        return x;\n    }\n    function valueOf(n) {\n        var str, e = n.e;\n        if (e === null) return n.toString();\n        str = coeffToString(n.c);\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, \"0\");\n        return n.s < 0 ? \"-\" + str : str;\n    }\n    // PROTOTYPE/INSTANCE METHODS\n    /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */ P.absoluteValue = P.abs = function() {\n        var x = new BigNumber(this);\n        if (x.s < 0) x.s = 1;\n        return x;\n    };\n    /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */ P.comparedTo = function(y, b) {\n        return compare(this, new BigNumber(y, b));\n    };\n    /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.decimalPlaces = P.dp = function(dp, rm) {\n        var c, n, v, x = this;\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(new BigNumber(x), dp + x.e + 1, rm);\n        }\n        if (!(c = x.c)) return null;\n        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last number.\n        if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);\n        if (n < 0) n = 0;\n        return n;\n    };\n    /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */ P.dividedBy = P.div = function(y, b) {\n        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */ P.dividedToIntegerBy = P.idiv = function(y, b) {\n        return div(this, new BigNumber(y, b), 0, 1);\n    };\n    /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */ P.exponentiatedBy = P.pow = function(n, m) {\n        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;\n        n = new BigNumber(n);\n        // Allow NaN and ±Infinity, but not other non-integers.\n        if (n.c && !n.isInteger()) {\n            throw Error(bignumberError + \"Exponent not an integer: \" + valueOf(n));\n        }\n        if (m != null) m = new BigNumber(m);\n        // Exponent of MAX_SAFE_INTEGER is 15.\n        nIsBig = n.e > 14;\n        // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\n        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\n            // The sign of the result of pow when x is negative depends on the evenness of n.\n            // If +n overflows to ±Infinity, the evenness of n would be not be known.\n            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\n            return m ? y.mod(m) : y;\n        }\n        nIsNeg = n.s < 0;\n        if (m) {\n            // x % m returns NaN if abs(m) is zero, or m is NaN.\n            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\n            isModExp = !nIsNeg && x.isInteger() && m.isInteger();\n            if (isModExp) x = x.mod(m);\n        // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\n        // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\n        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\n            // If x is negative and n is odd, k = -0, else k = 0.\n            k = x.s < 0 && isOdd(n) ? -0 : 0;\n            // If x >= 1, k = ±Infinity.\n            if (x.e > -1) k = 1 / k;\n            // If n is negative return ±0, else return ±Infinity.\n            return new BigNumber(nIsNeg ? 1 / k : k);\n        } else if (POW_PRECISION) {\n            // Truncating each coefficient array to a length of k after each multiplication\n            // equates to truncating significant digits to POW_PRECISION + [28, 41],\n            // i.e. there will be a minimum of 28 guard digits retained.\n            k = mathceil(POW_PRECISION / LOG_BASE + 2);\n        }\n        if (nIsBig) {\n            half = new BigNumber(0.5);\n            if (nIsNeg) n.s = 1;\n            nIsOdd = isOdd(n);\n        } else {\n            i = Math.abs(+valueOf(n));\n            nIsOdd = i % 2;\n        }\n        y = new BigNumber(ONE);\n        // Performs 54 loop iterations for n of 9007199254740991.\n        for(;;){\n            if (nIsOdd) {\n                y = y.times(x);\n                if (!y.c) break;\n                if (k) {\n                    if (y.c.length > k) y.c.length = k;\n                } else if (isModExp) {\n                    y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\n                }\n            }\n            if (i) {\n                i = mathfloor(i / 2);\n                if (i === 0) break;\n                nIsOdd = i % 2;\n            } else {\n                n = n.times(half);\n                round(n, n.e + 1, 1);\n                if (n.e > 14) {\n                    nIsOdd = isOdd(n);\n                } else {\n                    i = +valueOf(n);\n                    if (i === 0) break;\n                    nIsOdd = i % 2;\n                }\n            }\n            x = x.times(x);\n            if (k) {\n                if (x.c && x.c.length > k) x.c.length = k;\n            } else if (isModExp) {\n                x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\n            }\n        }\n        if (isModExp) return y;\n        if (nIsNeg) y = ONE.div(y);\n        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */ P.integerValue = function(rm) {\n        var n = new BigNumber(this);\n        if (rm == null) rm = ROUNDING_MODE;\n        else intCheck(rm, 0, 8);\n        return round(n, n.e + 1, rm);\n    };\n    /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isEqualTo = P.eq = function(y, b) {\n        return compare(this, new BigNumber(y, b)) === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */ P.isFinite = function() {\n        return !!this.c;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isGreaterThan = P.gt = function(y, b) {\n        return compare(this, new BigNumber(y, b)) > 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {\n        return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */ P.isInteger = function() {\n        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isLessThan = P.lt = function(y, b) {\n        return compare(this, new BigNumber(y, b)) < 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */ P.isLessThanOrEqualTo = P.lte = function(y, b) {\n        return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */ P.isNaN = function() {\n        return !this.s;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */ P.isNegative = function() {\n        return this.s < 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */ P.isPositive = function() {\n        return this.s > 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */ P.isZero = function() {\n        return !!this.c && this.c[0] == 0;\n    };\n    /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */ P.minus = function(y, b) {\n        var i, j, t, xLTy, x = this, a = x.s;\n        y = new BigNumber(y, b);\n        b = y.s;\n        // Either NaN?\n        if (!a || !b) return new BigNumber(NaN);\n        // Signs differ?\n        if (a != b) {\n            y.s = -b;\n            return x.plus(y);\n        }\n        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n        if (!xe || !ye) {\n            // Either Infinity?\n            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\n            // Either zero?\n            if (!xc[0] || !yc[0]) {\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                ROUNDING_MODE == 3 ? -0 : 0);\n            }\n        }\n        xe = bitFloor(xe);\n        ye = bitFloor(ye);\n        xc = xc.slice();\n        // Determine which is the bigger number.\n        if (a = xe - ye) {\n            if (xLTy = a < 0) {\n                a = -a;\n                t = xc;\n            } else {\n                ye = xe;\n                t = yc;\n            }\n            t.reverse();\n            // Prepend zeros to equalise exponents.\n            for(b = a; b--; t.push(0));\n            t.reverse();\n        } else {\n            // Exponents equal. Check digit by digit.\n            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\n            for(a = b = 0; b < j; b++){\n                if (xc[b] != yc[b]) {\n                    xLTy = xc[b] < yc[b];\n                    break;\n                }\n            }\n        }\n        // x < y? Point xc to the array of the bigger number.\n        if (xLTy) {\n            t = xc;\n            xc = yc;\n            yc = t;\n            y.s = -y.s;\n        }\n        b = (j = yc.length) - (i = xc.length);\n        // Append zeros to xc if shorter.\n        // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\n        if (b > 0) for(; b--; xc[i++] = 0);\n        b = BASE - 1;\n        // Subtract yc from xc.\n        for(; j > a;){\n            if (xc[--j] < yc[j]) {\n                for(i = j; i && !xc[--i]; xc[i] = b);\n                --xc[i];\n                xc[j] += BASE;\n            }\n            xc[j] -= yc[j];\n        }\n        // Remove leading zeros and adjust exponent accordingly.\n        for(; xc[0] == 0; xc.splice(0, 1), --ye);\n        // Zero?\n        if (!xc[0]) {\n            // Following IEEE 754 (2008) 6.3,\n            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n            y.s = ROUNDING_MODE == 3 ? -1 : 1;\n            y.c = [\n                y.e = 0\n            ];\n            return y;\n        }\n        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n        // for finite x and y.\n        return normalise(y, xc, ye);\n    };\n    /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */ P.modulo = P.mod = function(y, b) {\n        var q, s, x = this;\n        y = new BigNumber(y, b);\n        // Return NaN if x is Infinity or NaN, or y is NaN or zero.\n        if (!x.c || !y.s || y.c && !y.c[0]) {\n            return new BigNumber(NaN);\n        // Return x if y is Infinity or x is zero.\n        } else if (!y.c || x.c && !x.c[0]) {\n            return new BigNumber(x);\n        }\n        if (MODULO_MODE == 9) {\n            // Euclidian division: q = sign(y) * floor(x / abs(y))\n            // r = x - qy    where  0 <= r < abs(y)\n            s = y.s;\n            y.s = 1;\n            q = div(x, y, 0, 3);\n            y.s = s;\n            q.s *= s;\n        } else {\n            q = div(x, y, 0, MODULO_MODE);\n        }\n        y = x.minus(q.times(y));\n        // To match JavaScript %, ensure sign of zero is sign of dividend.\n        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\n        return y;\n    };\n    /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */ P.multipliedBy = P.times = function(y, b) {\n        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;\n        // Either NaN, ±Infinity or ±0?\n        if (!xc || !yc || !xc[0] || !yc[0]) {\n            // Return NaN if either is NaN, or one is 0 and the other is Infinity.\n            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\n                y.c = y.e = y.s = null;\n            } else {\n                y.s *= x.s;\n                // Return ±Infinity if either is ±Infinity.\n                if (!xc || !yc) {\n                    y.c = y.e = null;\n                // Return ±0 if either is ±0.\n                } else {\n                    y.c = [\n                        0\n                    ];\n                    y.e = 0;\n                }\n            }\n            return y;\n        }\n        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\n        y.s *= x.s;\n        xcL = xc.length;\n        ycL = yc.length;\n        // Ensure xc points to longer array and xcL to its length.\n        if (xcL < ycL) {\n            zc = xc;\n            xc = yc;\n            yc = zc;\n            i = xcL;\n            xcL = ycL;\n            ycL = i;\n        }\n        // Initialise the result array with zeros.\n        for(i = xcL + ycL, zc = []; i--; zc.push(0));\n        base = BASE;\n        sqrtBase = SQRT_BASE;\n        for(i = ycL; --i >= 0;){\n            c = 0;\n            ylo = yc[i] % sqrtBase;\n            yhi = yc[i] / sqrtBase | 0;\n            for(k = xcL, j = i + k; j > i;){\n                xlo = xc[--k] % sqrtBase;\n                xhi = xc[k] / sqrtBase | 0;\n                m = yhi * xlo + xhi * ylo;\n                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;\n                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\n                zc[j--] = xlo % base;\n            }\n            zc[j] = c;\n        }\n        if (c) {\n            ++e;\n        } else {\n            zc.splice(0, 1);\n        }\n        return normalise(y, zc, e);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */ P.negated = function() {\n        var x = new BigNumber(this);\n        x.s = -x.s || null;\n        return x;\n    };\n    /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */ P.plus = function(y, b) {\n        var t, x = this, a = x.s;\n        y = new BigNumber(y, b);\n        b = y.s;\n        // Either NaN?\n        if (!a || !b) return new BigNumber(NaN);\n        // Signs differ?\n        if (a != b) {\n            y.s = -b;\n            return x.minus(y);\n        }\n        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n        if (!xe || !ye) {\n            // Return ±Infinity if either ±Infinity.\n            if (!xc || !yc) return new BigNumber(a / 0);\n            // Either zero?\n            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\n        }\n        xe = bitFloor(xe);\n        ye = bitFloor(ye);\n        xc = xc.slice();\n        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n        if (a = xe - ye) {\n            if (a > 0) {\n                ye = xe;\n                t = yc;\n            } else {\n                a = -a;\n                t = xc;\n            }\n            t.reverse();\n            for(; a--; t.push(0));\n            t.reverse();\n        }\n        a = xc.length;\n        b = yc.length;\n        // Point xc to the longer array, and b to the shorter length.\n        if (a - b < 0) {\n            t = yc;\n            yc = xc;\n            xc = t;\n            b = a;\n        }\n        // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\n        for(a = 0; b;){\n            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\n            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\n        }\n        if (a) {\n            xc = [\n                a\n            ].concat(xc);\n            ++ye;\n        }\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n        // ye = MAX_EXP + 1 possible\n        return normalise(y, xc, ye);\n    };\n    /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */ P.precision = P.sd = function(sd, rm) {\n        var c, n, v, x = this;\n        if (sd != null && sd !== !!sd) {\n            intCheck(sd, 1, MAX);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(new BigNumber(x), sd, rm);\n        }\n        if (!(c = x.c)) return null;\n        v = c.length - 1;\n        n = v * LOG_BASE + 1;\n        if (v = c[v]) {\n            // Subtract the number of trailing zeros of the last element.\n            for(; v % 10 == 0; v /= 10, n--);\n            // Add the number of digits of the first element.\n            for(v = c[0]; v >= 10; v /= 10, n++);\n        }\n        if (sd && x.e + 1 > n) n = x.e + 1;\n        return n;\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */ P.shiftedBy = function(k) {\n        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n        return this.times(\"1e\" + k);\n    };\n    /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */ P.squareRoot = P.sqrt = function() {\n        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber(\"0.5\");\n        // Negative/NaN/Infinity/zero?\n        if (s !== 1 || !c || !c[0]) {\n            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\n        }\n        // Initial estimate.\n        s = Math.sqrt(+valueOf(x));\n        // Math.sqrt underflow/overflow?\n        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n        if (s == 0 || s == 1 / 0) {\n            n = coeffToString(c);\n            if ((n.length + e) % 2 == 0) n += \"0\";\n            s = Math.sqrt(+n);\n            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\n            if (s == 1 / 0) {\n                n = \"5e\" + e;\n            } else {\n                n = s.toExponential();\n                n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n            }\n            r = new BigNumber(n);\n        } else {\n            r = new BigNumber(s + \"\");\n        }\n        // Check for zero.\n        // r could be zero if MIN_EXP is changed after the this value was created.\n        // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n        // coeffToString to throw.\n        if (r.c[0]) {\n            e = r.e;\n            s = e + dp;\n            if (s < 3) s = 0;\n            // Newton-Raphson iteration.\n            for(;;){\n                t = r;\n                r = half.times(t.plus(div(x, t, dp, 1)));\n                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\n                    // The exponent of r may here be one less than the final result exponent,\n                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\n                    // are indexed correctly.\n                    if (r.e < e) --s;\n                    n = n.slice(s - 3, s + 1);\n                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\n                    // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\n                    // iteration.\n                    if (n == \"9999\" || !rep && n == \"4999\") {\n                        // On the first iteration only, check to see if rounding up gives the\n                        // exact result as the nines may infinitely repeat.\n                        if (!rep) {\n                            round(t, t.e + DECIMAL_PLACES + 2, 0);\n                            if (t.times(t).eq(x)) {\n                                r = t;\n                                break;\n                            }\n                        }\n                        dp += 4;\n                        s += 4;\n                        rep = 1;\n                    } else {\n                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\n                        // result. If not, then there are further digits and m will be truthy.\n                        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                            // Truncate to the first rounding digit.\n                            round(r, r.e + DECIMAL_PLACES + 2, 1);\n                            m = !r.times(r).eq(x);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.toExponential = function(dp, rm) {\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            dp++;\n        }\n        return format(this, dp, rm, 1);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.toFixed = function(dp, rm) {\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            dp = dp + this.e + 1;\n        }\n        return format(this, dp, rm);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */ P.toFormat = function(dp, rm, format) {\n        var str, x = this;\n        if (format == null) {\n            if (dp != null && rm && typeof rm == \"object\") {\n                format = rm;\n                rm = null;\n            } else if (dp && typeof dp == \"object\") {\n                format = dp;\n                dp = rm = null;\n            } else {\n                format = FORMAT;\n            }\n        } else if (typeof format != \"object\") {\n            throw Error(bignumberError + \"Argument not an object: \" + format);\n        }\n        str = x.toFixed(dp, rm);\n        if (x.c) {\n            var i, arr = str.split(\".\"), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || \"\", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;\n            if (g2) {\n                i = g1;\n                g1 = g2;\n                g2 = i;\n                len -= i;\n            }\n            if (g1 > 0 && len > 0) {\n                i = len % g1 || g1;\n                intPart = intDigits.substr(0, i);\n                for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);\n                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\n                if (isNeg) intPart = \"-\" + intPart;\n            }\n            str = fractionPart ? intPart + (format.decimalSeparator || \"\") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp(\"\\\\d{\" + g2 + \"}\\\\B\", \"g\"), \"$&\" + (format.fractionGroupSeparator || \"\")) : fractionPart) : intPart;\n        }\n        return (format.prefix || \"\") + str + (format.suffix || \"\");\n    };\n    /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */ P.toFraction = function(md) {\n        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;\n        if (md != null) {\n            n = new BigNumber(md);\n            // Throw if md is less than one or is not an integer, unless it is Infinity.\n            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\n                throw Error(bignumberError + \"Argument \" + (n.isInteger() ? \"out of range: \" : \"not an integer: \") + valueOf(n));\n            }\n        }\n        if (!xc) return new BigNumber(x);\n        d = new BigNumber(ONE);\n        n1 = d0 = new BigNumber(ONE);\n        d1 = n0 = new BigNumber(ONE);\n        s = coeffToString(xc);\n        // Determine initial denominator.\n        // d is a power of 10 and the minimum max denominator that specifies the value exactly.\n        e = d.e = s.length - x.e - 1;\n        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\n        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;\n        exp = MAX_EXP;\n        MAX_EXP = 1 / 0;\n        n = new BigNumber(s);\n        // n0 = d1 = 0\n        n0.c[0] = 0;\n        for(;;){\n            q = div(n, d, 0, 1);\n            d2 = d0.plus(q.times(d1));\n            if (d2.comparedTo(md) == 1) break;\n            d0 = d1;\n            d1 = d2;\n            n1 = n0.plus(q.times(d2 = n1));\n            n0 = d2;\n            d = n.minus(q.times(d2 = d));\n            n = d2;\n        }\n        d2 = div(md.minus(d0), d1, 0, 1);\n        n0 = n0.plus(d2.times(n1));\n        d0 = d0.plus(d2.times(d1));\n        n0.s = n1.s = x.s;\n        e = e * 2;\n        // Determine which fraction is closer to x, n0/d0 or n1/d1\n        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [\n            n1,\n            d1\n        ] : [\n            n0,\n            d0\n        ];\n        MAX_EXP = exp;\n        return r;\n    };\n    /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */ P.toNumber = function() {\n        return +valueOf(this);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */ P.toPrecision = function(sd, rm) {\n        if (sd != null) intCheck(sd, 1, MAX);\n        return format(this, sd, rm, 2);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */ P.toString = function(b) {\n        var str, n = this, s = n.s, e = n.e;\n        // Infinity or NaN?\n        if (e === null) {\n            if (s) {\n                str = \"Infinity\";\n                if (s < 0) str = \"-\" + str;\n            } else {\n                str = \"NaN\";\n            }\n        } else {\n            if (b == null) {\n                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, \"0\");\n            } else if (b === 10 && alphabetHasNormalDecimalDigits) {\n                n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\n                str = toFixedPoint(coeffToString(n.c), n.e, \"0\");\n            } else {\n                intCheck(b, 2, ALPHABET.length, \"Base\");\n                str = convertBase(toFixedPoint(coeffToString(n.c), e, \"0\"), 10, b, s, true);\n            }\n            if (s < 0 && n.c[0]) str = \"-\" + str;\n        }\n        return str;\n    };\n    /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */ P.valueOf = P.toJSON = function() {\n        return valueOf(this);\n    };\n    P._isBigNumber = true;\n    P[Symbol.toStringTag] = \"BigNumber\";\n    // Node.js v10.12.0+\n    P[Symbol.for(\"nodejs.util.inspect.custom\")] = P.valueOf;\n    if (configObject != null) BigNumber.set(configObject);\n    return BigNumber;\n}\n// PRIVATE HELPER FUNCTIONS\n// These functions don't need access to variables,\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\nfunction bitFloor(n) {\n    var i = n | 0;\n    return n > 0 || n === i ? i : i - 1;\n}\n// Return a coefficient array as a string of base 10 digits.\nfunction coeffToString(a) {\n    var s, z, i = 1, j = a.length, r = a[0] + \"\";\n    for(; i < j;){\n        s = a[i++] + \"\";\n        z = LOG_BASE - s.length;\n        for(; z--; s = \"0\" + s);\n        r += s;\n    }\n    // Determine trailing zeros.\n    for(j = r.length; r.charCodeAt(--j) === 48;);\n    return r.slice(0, j + 1 || 1);\n}\n// Compare the value of BigNumbers x and y.\nfunction compare(x, y) {\n    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either NaN?\n    if (!i || !j) return null;\n    a = xc && !xc[0];\n    b = yc && !yc[0];\n    // Either zero?\n    if (a || b) return a ? b ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    a = i < 0;\n    b = k == l;\n    // Either Infinity?\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\n    // Compare exponents.\n    if (!b) return k > l ^ a ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\n}\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */ function intCheck(n, min, max, name) {\n    if (n < min || n > max || n !== mathfloor(n)) {\n        throw Error(bignumberError + (name || \"Argument\") + (typeof n == \"number\" ? n < min || n > max ? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \") + String(n));\n    }\n}\n// Assumes finite n.\nfunction isOdd(n) {\n    var k = n.c.length - 1;\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\n}\nfunction toExponential(str, e) {\n    return (str.length > 1 ? str.charAt(0) + \".\" + str.slice(1) : str) + (e < 0 ? \"e\" : \"e+\") + e;\n}\nfunction toFixedPoint(str, e, z) {\n    var len, zs;\n    // Negative exponent?\n    if (e < 0) {\n        // Prepend zeros.\n        for(zs = z + \".\"; ++e; zs += z);\n        str = zs + str;\n    // Positive exponent\n    } else {\n        len = str.length;\n        // Append zeros.\n        if (++e > len) {\n            for(zs = z, e -= len; --e; zs += z);\n            str += zs;\n        } else if (e < len) {\n            str = str.slice(0, e) + \".\" + str.slice(e);\n        }\n    }\n    return str;\n}\n// EXPORT\nvar BigNumber = clone();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigNumber);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDQyxHQUdELElBQ0VBLFlBQVksOENBQ1pDLFdBQVdDLEtBQUtDLElBQUksRUFDcEJDLFlBQVlGLEtBQUtHLEtBQUssRUFFdEJDLGlCQUFpQixzQkFDakJDLGdCQUFnQkQsaUJBQWlCLDBEQUVqQ0UsT0FBTyxNQUNQQyxXQUFXLElBQ1hDLG1CQUFtQixrQkFDbkIsd0RBQXdEO0FBQ3hEQyxXQUFXO0lBQUM7SUFBRztJQUFJO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFNO0lBQU07SUFBTTtDQUFLLEVBQ2xGQyxZQUFZLEtBRVosV0FBVztBQUNYLDBGQUEwRjtBQUMxRixzRUFBc0U7QUFDdEVDLE1BQU0sS0FBdUMsaUJBQWlCO0FBR2hFOztDQUVDLEdBQ0QsU0FBU0MsTUFBTUMsWUFBWTtJQUN6QixJQUFJQyxLQUFLQyxhQUFhQyxjQUNwQkMsSUFBSUMsVUFBVUMsU0FBUyxHQUFHO1FBQUVDLGFBQWFGO1FBQVdHLFVBQVU7UUFBTUMsU0FBUztJQUFLLEdBQ2xGQyxNQUFNLElBQUlMLFVBQVUsSUFHcEIsd0ZBQXdGO0lBR3hGLGdGQUFnRjtJQUNoRixrRUFBa0U7SUFFbEUsMEVBQTBFO0lBQzFFTSxpQkFBaUIsSUFFakIsbUZBQW1GO0lBQ25GLCtFQUErRTtJQUMvRSwrQkFBK0I7SUFDL0IsNkJBQTZCO0lBQzdCLGtDQUFrQztJQUNsQyxrQ0FBa0M7SUFDbEMsOERBQThEO0lBQzlELGdFQUFnRTtJQUNoRSxrRkFBa0Y7SUFDbEYsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RUMsZ0JBQWdCLEdBRWhCLDZDQUE2QztJQUU3QyxpRkFBaUY7SUFDakYsa0JBQWtCO0lBQ2xCQyxhQUFhLENBQUMsR0FFZCwrRUFBK0U7SUFDL0Us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O0FBR0EsU0FBUzZELGNBQWN0SCxHQUFHLEVBQUVKLENBQUM7SUFDM0IsT0FBTyxDQUFDSSxJQUFJWSxNQUFNLEdBQUcsSUFBSVosSUFBSWlCLE1BQU0sQ0FBQyxLQUFLLE1BQU1qQixJQUFJSSxLQUFLLENBQUMsS0FBS0osR0FBRSxJQUM5REosQ0FBQUEsSUFBSSxJQUFJLE1BQU0sSUFBRyxJQUFLQTtBQUMxQjtBQUdBLFNBQVNxRixhQUFhakYsR0FBRyxFQUFFSixDQUFDLEVBQUVvTixDQUFDO0lBQzdCLElBQUlqTixLQUFLb047SUFFVCxxQkFBcUI7SUFDckIsSUFBSXZOLElBQUksR0FBRztRQUVULGlCQUFpQjtRQUNqQixJQUFLdU4sS0FBS0gsSUFBSSxLQUFLLEVBQUVwTixHQUFHdU4sTUFBTUg7UUFDOUJoTixNQUFNbU4sS0FBS25OO0lBRWIsb0JBQW9CO0lBQ3BCLE9BQU87UUFDTEQsTUFBTUMsSUFBSVksTUFBTTtRQUVoQixnQkFBZ0I7UUFDaEIsSUFBSSxFQUFFaEIsSUFBSUcsS0FBSztZQUNiLElBQUtvTixLQUFLSCxHQUFHcE4sS0FBS0csS0FBSyxFQUFFSCxHQUFHdU4sTUFBTUg7WUFDbENoTixPQUFPbU47UUFDVCxPQUFPLElBQUl2TixJQUFJRyxLQUFLO1lBQ2xCQyxNQUFNQSxJQUFJSSxLQUFLLENBQUMsR0FBR1IsS0FBSyxNQUFNSSxJQUFJSSxLQUFLLENBQUNSO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPSTtBQUNUO0FBR0EsU0FBUztBQUdGLElBQUluQyxZQUFZTixRQUFRO0FBRS9CLGlFQUFlTSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLm1qcz9hMDVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjEuMlxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxudmFyXHJcbiAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgQkFTRSA9IDFlMTQsXHJcbiAgTE9HX0JBU0UgPSAxNCxcclxuICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gIC8vIEVESVRBQkxFXHJcbiAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgIC8vXHJcbiAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgRk9STUFUID0ge1xyXG4gICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICBzdWZmaXg6ICcnXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICpcclxuICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgKlxyXG4gICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICpcclxuICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAqXHJcbiAgICogRS5nLlxyXG4gICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAqXHJcbiAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICB2YXIgcCwgdjtcclxuXHJcbiAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAqXHJcbiAgICogdiB7YW55fVxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHZhciBpLCBuLFxyXG4gICAgICBjID0gdi5jLFxyXG4gICAgICBlID0gdi5lLFxyXG4gICAgICBzID0gdi5zO1xyXG5cclxuICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBFcnJvclxyXG4gICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIC0xKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGMgPSBbXSxcclxuICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByYW5kLmUgPSBlO1xyXG4gICAgICByYW5kLmMgPSBjO1xyXG4gICAgICByZXR1cm4gcmFuZDtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gICAvKlxyXG4gICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSA9IDEsXHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgIHJldHVybiBzdW07XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgIHZhciBqLFxyXG4gICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICBhcnJMLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIC0tZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgciA9IHgucjtcclxuICAgICAgICBlID0geC5lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcTtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAqXHJcbiAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgYzAgPSBuLmNbMF07XHJcbiAgICBuZSA9IG4uZTtcclxuXHJcbiAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbikge1xyXG4gICAgdmFyIGssIHksXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICB4ID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcbiAgICAgIGlmICgheS5zIHx8IChrID0gY29tcGFyZSh4LCB5KSkgPT09IG4gfHwgayA9PT0gMCAmJiB4LnMgPT09IG4pIHtcclxuICAgICAgICB4ID0geTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgdmFyIGkgPSAxLFxyXG4gICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAvLyBPdmVyZmxvdz9cclxuICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgIC8vIFVuZGVyZmxvdz9cclxuICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4uZSA9IGU7XHJcbiAgICAgIG4uYyA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOYU5cclxuICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICByZCA9IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICovXHJcbiAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVyblxyXG4gICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICovXHJcbiAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgKlxyXG4gICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLyAwID0gSVxyXG4gICAqICBuIC8gTiA9IE5cclxuICAgKiAgbiAvIEkgPSAwXHJcbiAgICogIDAgLyBuID0gMFxyXG4gICAqICAwIC8gMCA9IE5cclxuICAgKiAgMCAvIE4gPSBOXHJcbiAgICogIDAgLyBJID0gMFxyXG4gICAqICBOIC8gbiA9IE5cclxuICAgKiAgTiAvIDAgPSBOXHJcbiAgICogIE4gLyBOID0gTlxyXG4gICAqICBOIC8gSSA9IE5cclxuICAgKiAgSSAvIG4gPSBJXHJcbiAgICogIEkgLyAwID0gSVxyXG4gICAqICBJIC8gTiA9IE5cclxuICAgKiAgSSAvIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAqXHJcbiAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICpcclxuICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICpcclxuICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICovXHJcbiAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyBuLnMgKiAoMiAtIGlzT2RkKG4pKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgfVxyXG5cclxuICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgaWYgKG0pIHtcclxuXHJcbiAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSkge1xyXG4gICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICovXHJcbiAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5zO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLSAwID0gblxyXG4gICAqICBuIC0gTiA9IE5cclxuICAgKiAgbiAtIEkgPSAtSVxyXG4gICAqICAwIC0gbiA9IC1uXHJcbiAgICogIDAgLSAwID0gMFxyXG4gICAqICAwIC0gTiA9IE5cclxuICAgKiAgMCAtIEkgPSAtSVxyXG4gICAqICBOIC0gbiA9IE5cclxuICAgKiAgTiAtIDAgPSBOXHJcbiAgICogIE4gLSBOID0gTlxyXG4gICAqICBOIC0gSSA9IE5cclxuICAgKiAgSSAtIG4gPSBJXHJcbiAgICogIEkgLSAwID0gSVxyXG4gICAqICBJIC0gTiA9IE5cclxuICAgKiAgSSAtIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICBiID0geS5zO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jO1xyXG5cclxuICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgIGEgPSAtYTtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICBpZiAoeExUeSkge1xyXG4gICAgICB0ID0geGM7XHJcbiAgICAgIHhjID0geWM7XHJcbiAgICAgIHljID0gdDtcclxuICAgICAgeS5zID0gLXkucztcclxuICAgIH1cclxuXHJcbiAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBxLCBzLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgIHMgPSB5LnM7XHJcbiAgICAgIHkucyA9IDE7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgIHkucyA9IHM7XHJcbiAgICAgIHEucyAqPSBzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeS5zICo9IHgucztcclxuICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgIHpjID0geGM7XHJcbiAgICAgIHhjID0geWM7XHJcbiAgICAgIHljID0gemM7XHJcbiAgICAgIGkgPSB4Y0w7XHJcbiAgICAgIHhjTCA9IHljTDtcclxuICAgICAgeWNMID0gaTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICBiYXNlID0gQkFTRTtcclxuICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgIGMgPSAwO1xyXG4gICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHpjW2pdID0gYztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYykge1xyXG4gICAgICArK2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICovXHJcbiAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKyAwID0gblxyXG4gICAqICBuICsgTiA9IE5cclxuICAgKiAgbiArIEkgPSBJXHJcbiAgICogIDAgKyBuID0gblxyXG4gICAqICAwICsgMCA9IDBcclxuICAgKiAgMCArIE4gPSBOXHJcbiAgICogIDAgKyBJID0gSVxyXG4gICAqICBOICsgbiA9IE5cclxuICAgKiAgTiArIDAgPSBOXHJcbiAgICogIE4gKyBOID0gTlxyXG4gICAqICBOICsgSSA9IE5cclxuICAgKiAgSSArIG4gPSBJXHJcbiAgICogIEkgKyAwID0gSVxyXG4gICAqICBJICsgTiA9IE5cclxuICAgKiAgSSArIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIHQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBhID0geC5zO1xyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgYiA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgIHkucyA9IC1iO1xyXG4gICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jO1xyXG5cclxuICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgIH1cclxuXHJcbiAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYSA9IHhjLmxlbmd0aDtcclxuICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICB0ID0geWM7XHJcbiAgICAgIHljID0geGM7XHJcbiAgICAgIHhjID0gdDtcclxuICAgICAgYiA9IGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGEpIHtcclxuICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgKyt5ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgKlxyXG4gICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICovXHJcbiAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgKlxyXG4gICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAqL1xyXG4gIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAqICBzcXJ0KE4pID0gIE5cclxuICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAqICBzcXJ0KEkpID0gIElcclxuICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICogIHNxcnQoLTApID0gLTBcclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKi9cclxuICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYyA9IHguYyxcclxuICAgICAgcyA9IHgucyxcclxuICAgICAgZSA9IHguZSxcclxuICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgZSA9IHIuZTtcclxuICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICB0ID0gcjtcclxuICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGRwKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKi9cclxuICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICpcclxuICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICpcclxuICAgKiBGT1JNQVQgPSB7XHJcbiAgICogICBwcmVmaXg6ICcnLFxyXG4gICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgKiAgIHN1ZmZpeDogJydcclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAqL1xyXG4gIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgaWYgKHguYykge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChnMikge1xyXG4gICAgICAgIGkgPSBnMTtcclxuICAgICAgICBnMSA9IGcyO1xyXG4gICAgICAgIGcyID0gaTtcclxuICAgICAgICBsZW4gLT0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgIDogaW50UGFydDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgKlxyXG4gICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICovXHJcbiAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICB4YyA9IHguYztcclxuXHJcbiAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgZm9yICg7IDspICB7XHJcbiAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgZDAgPSBkMTtcclxuICAgICAgZDEgPSBkMjtcclxuICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICBuMCA9IGQyO1xyXG4gICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICBuID0gZDI7XHJcbiAgICB9XHJcblxyXG4gICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICovXHJcbiAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICovXHJcbiAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgKi9cclxuICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIG4gPSB0aGlzLFxyXG4gICAgICBzID0gbi5zLFxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICovXHJcbiAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICBQW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQmlnTnVtYmVyJztcclxuXHJcbiAgLy8gTm9kZS5qcyB2MTAuMTIuMCtcclxuICBQW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gUC52YWx1ZU9mO1xyXG5cclxuICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgcmV0dXJuIEJpZ051bWJlcjtcclxufVxyXG5cclxuXHJcbi8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICB2YXIgaSA9IG4gfCAwO1xyXG4gIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbmZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gIHZhciBzLCB6LFxyXG4gICAgaSA9IDEsXHJcbiAgICBqID0gYS5sZW5ndGgsXHJcbiAgICByID0gYVswXSArICcnO1xyXG5cclxuICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgIHIgKz0gcztcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG59XHJcblxyXG5cclxuLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG5mdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICB2YXIgYSwgYixcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWMgPSB5LmMsXHJcbiAgICBpID0geC5zLFxyXG4gICAgaiA9IHkucyxcclxuICAgIGsgPSB4LmUsXHJcbiAgICBsID0geS5lO1xyXG5cclxuICAvLyBFaXRoZXIgTmFOP1xyXG4gIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICBhID0gaSA8IDA7XHJcbiAgYiA9IGsgPT0gbDtcclxuXHJcbiAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICB0aHJvdyBFcnJvclxyXG4gICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG5mdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgdmFyIGxlbiwgenM7XHJcblxyXG4gIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICBzdHIgKz0genM7XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbi8vIEVYUE9SVFxyXG5cclxuXHJcbmV4cG9ydCB2YXIgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpZ051bWJlcjtcclxuIl0sIm5hbWVzIjpbImlzTnVtZXJpYyIsIm1hdGhjZWlsIiwiTWF0aCIsImNlaWwiLCJtYXRoZmxvb3IiLCJmbG9vciIsImJpZ251bWJlckVycm9yIiwidG9vTWFueURpZ2l0cyIsIkJBU0UiLCJMT0dfQkFTRSIsIk1BWF9TQUZFX0lOVEVHRVIiLCJQT1dTX1RFTiIsIlNRUlRfQkFTRSIsIk1BWCIsImNsb25lIiwiY29uZmlnT2JqZWN0IiwiZGl2IiwiY29udmVydEJhc2UiLCJwYXJzZU51bWVyaWMiLCJQIiwiQmlnTnVtYmVyIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJ0b1N0cmluZyIsInZhbHVlT2YiLCJPTkUiLCJERUNJTUFMX1BMQUNFUyIsIlJPVU5ESU5HX01PREUiLCJUT19FWFBfTkVHIiwiVE9fRVhQX1BPUyIsIk1JTl9FWFAiLCJNQVhfRVhQIiwiQ1JZUFRPIiwiTU9EVUxPX01PREUiLCJQT1dfUFJFQ0lTSU9OIiwiRk9STUFUIiwicHJlZml4IiwiZ3JvdXBTaXplIiwic2Vjb25kYXJ5R3JvdXBTaXplIiwiZ3JvdXBTZXBhcmF0b3IiLCJkZWNpbWFsU2VwYXJhdG9yIiwiZnJhY3Rpb25Hcm91cFNpemUiLCJmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIiwic3VmZml4IiwiQUxQSEFCRVQiLCJhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMiLCJ2IiwiYiIsImFscGhhYmV0IiwiYyIsImNhc2VDaGFuZ2VkIiwiZSIsImkiLCJpc051bSIsImxlbiIsInN0ciIsIngiLCJfaXNCaWdOdW1iZXIiLCJzIiwic2xpY2UiLCJTdHJpbmciLCJ0ZXN0IiwiY2hhckNvZGVBdCIsImluZGV4T2YiLCJyZXBsYWNlIiwic2VhcmNoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiaW50Q2hlY2siLCJyb3VuZCIsIkRFQlVHIiwiRXJyb3IiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwicHVzaCIsIlJPVU5EX1VQIiwiUk9VTkRfRE9XTiIsIlJPVU5EX0NFSUwiLCJST1VORF9GTE9PUiIsIlJPVU5EX0hBTEZfVVAiLCJST1VORF9IQUxGX0RPV04iLCJST1VORF9IQUxGX0VWRU4iLCJST1VORF9IQUxGX0NFSUwiLCJST1VORF9IQUxGX0ZMT09SIiwiRVVDTElEIiwiY29uZmlnIiwic2V0Iiwib2JqIiwicCIsImhhc093blByb3BlcnR5IiwicG9wIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tQnl0ZXMiLCJFWFBPTkVOVElBTF9BVCIsIlJBTkdFIiwiaXNCaWdOdW1iZXIiLCJuIiwib3V0IiwiY2FsbCIsIm1heGltdW0iLCJtYXgiLCJtYXhPck1pbiIsImFyZ3VtZW50cyIsIm1pbmltdW0iLCJtaW4iLCJyYW5kb20iLCJwb3cyXzUzIiwicmFuZG9tNTNiaXRJbnQiLCJkcCIsImEiLCJrIiwicmFuZCIsIlVpbnQzMkFycmF5IiwiY29weSIsInNwbGljZSIsInN1bSIsImFyZ3MiLCJwbHVzIiwiZGVjaW1hbCIsInRvQmFzZU91dCIsImJhc2VJbiIsImJhc2VPdXQiLCJqIiwiYXJyIiwiYXJyTCIsInJldmVyc2UiLCJzaWduIiwiY2FsbGVySXNUb1N0cmluZyIsImQiLCJyIiwieGMiLCJ5Iiwicm0iLCJwb3ciLCJ0b0ZpeGVkUG9pbnQiLCJjb2VmZlRvU3RyaW5nIiwiY29uY2F0IiwibXVsdGlwbHkiLCJiYXNlIiwibSIsInRlbXAiLCJ4bG8iLCJ4aGkiLCJjYXJyeSIsImtsbyIsImtoaSIsImNvbXBhcmUiLCJhTCIsImJMIiwiY21wIiwic3VidHJhY3QiLCJtb3JlIiwicHJvZCIsInByb2RMIiwicSIsInFjIiwicmVtIiwicmVtTCIsInJlbTAiLCJ4aSIsInhMIiwieWMwIiwieUwiLCJ5eiIsInljIiwiTmFOIiwiYml0Rmxvb3IiLCJmb3JtYXQiLCJpZCIsImMwIiwibmUiLCJ0b0V4cG9uZW50aWFsIiwibm9ybWFsaXNlIiwiYmFzZVByZWZpeCIsImRvdEFmdGVyIiwiZG90QmVmb3JlIiwiaXNJbmZpbml0eU9yTmFOIiwid2hpdGVzcGFjZU9yUGx1cyIsImlzTmFOIiwicDEiLCJwMiIsInNkIiwibmkiLCJyZCIsInBvd3MxMCIsImFic29sdXRlVmFsdWUiLCJhYnMiLCJjb21wYXJlZFRvIiwiZGVjaW1hbFBsYWNlcyIsImRpdmlkZWRCeSIsImRpdmlkZWRUb0ludGVnZXJCeSIsImlkaXYiLCJleHBvbmVudGlhdGVkQnkiLCJoYWxmIiwiaXNNb2RFeHAiLCJuSXNCaWciLCJuSXNOZWciLCJuSXNPZGQiLCJpc0ludGVnZXIiLCJpc09kZCIsIm1vZCIsInRpbWVzIiwiaW50ZWdlclZhbHVlIiwiaXNFcXVhbFRvIiwiZXEiLCJpc0Zpbml0ZSIsImlzR3JlYXRlclRoYW4iLCJndCIsImlzR3JlYXRlclRoYW5PckVxdWFsVG8iLCJndGUiLCJpc0xlc3NUaGFuIiwibHQiLCJpc0xlc3NUaGFuT3JFcXVhbFRvIiwibHRlIiwiaXNOZWdhdGl2ZSIsImlzUG9zaXRpdmUiLCJpc1plcm8iLCJtaW51cyIsInQiLCJ4TFR5IiwieGUiLCJ5ZSIsIm1vZHVsbyIsIm11bHRpcGxpZWRCeSIsInhjTCIsInljTCIsInlsbyIsInloaSIsInpjIiwic3FydEJhc2UiLCJuZWdhdGVkIiwicHJlY2lzaW9uIiwic2hpZnRlZEJ5Iiwic3F1YXJlUm9vdCIsInNxcnQiLCJyZXAiLCJ0b0ZpeGVkIiwidG9Gb3JtYXQiLCJzcGxpdCIsImcxIiwiZzIiLCJpbnRQYXJ0IiwiZnJhY3Rpb25QYXJ0IiwiaXNOZWciLCJpbnREaWdpdHMiLCJzdWJzdHIiLCJSZWdFeHAiLCJ0b0ZyYWN0aW9uIiwibWQiLCJkMCIsImQxIiwiZDIiLCJleHAiLCJuMCIsIm4xIiwidG9OdW1iZXIiLCJ0b1ByZWNpc2lvbiIsInRvSlNPTiIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiZm9yIiwieiIsImwiLCJuYW1lIiwienMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/bignumber.js/bignumber.mjs\n");

/***/ })

};
;