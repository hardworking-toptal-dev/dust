"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethereumjs";
exports.ids = ["vendor-chunks/@ethereumjs"];
exports.modules = {

/***/ "(ssr)/../node_modules/@ethereumjs/rlp/dist/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/@ethereumjs/rlp/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RLP = exports.utils = exports.decode = exports.encode = void 0;\n/**\n * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * This function takes in data, converts it to Uint8Array if not,\n * and adds a length for recursion.\n * @param input Will be converted to Uint8Array\n * @returns Uint8Array of encoded data\n **/ function encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        let outputLength = 0;\n        for(let i = 0; i < input.length; i++){\n            const encoded = encode(input[i]);\n            output.push(encoded);\n            outputLength += encoded.length;\n        }\n        return concatBytes(encodeLength(outputLength, 192), ...output);\n    }\n    const inputBuf = toBytes(input);\n    if (inputBuf.length === 1 && inputBuf[0] < 128) {\n        return inputBuf;\n    }\n    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);\n}\nexports.encode = encode;\n/**\n * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.\n * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.\n * @param input\n * @param start\n * @param end\n */ function safeSlice(input, start, end) {\n    if (end > input.length) {\n        throw new Error(\"invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds\");\n    }\n    return input.slice(start, end);\n}\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n */ function decodeLength(v) {\n    if (v[0] === 0) {\n        throw new Error(\"invalid RLP: extra zeros\");\n    }\n    return parseHexByte(bytesToHex(v));\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Uint8Array.from([\n            len + offset\n        ]);\n    }\n    const hexLength = numberToHex(len);\n    const lLength = hexLength.length / 2;\n    const firstByte = numberToHex(offset + 55 + lLength);\n    return Uint8Array.from(hexToBytes(firstByte + hexLength));\n}\nfunction decode(input, stream = false) {\n    if (typeof input === \"undefined\" || input === null || input.length === 0) {\n        return Uint8Array.from([]);\n    }\n    const inputBytes = toBytes(input);\n    const decoded = _decode(inputBytes);\n    if (stream) {\n        return decoded;\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error(\"invalid RLP: remainder must be zero\");\n    }\n    return decoded.data;\n}\nexports.decode = decode;\n/** Decode an input with RLP */ function _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.slice(1)\n        };\n    } else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Uint8Array.from([]);\n        } else {\n            data = safeSlice(input, 1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error(\"invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed\");\n        }\n        return {\n            data,\n            remainder: input.slice(length)\n        };\n    } else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error(\"invalid RLP: not enough bytes for string length\");\n        }\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length <= 55) {\n            throw new Error(\"invalid RLP: expected string length to be greater than 55\");\n        }\n        data = safeSlice(input, llength, length + llength);\n        return {\n            data,\n            remainder: input.slice(length + llength)\n        };\n    } else if (firstByte <= 0xf7) {\n        // a list between 0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = safeSlice(input, 1, length);\n        while(innerRemainder.length){\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(length)\n        };\n    } else {\n        // a list over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length < 56) {\n            throw new Error(\"invalid RLP: encoded list too short\");\n        }\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error(\"invalid RLP: total length is larger than the data\");\n        }\n        innerRemainder = safeSlice(input, llength, totalLength);\n        while(innerRemainder.length){\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(totalLength)\n        };\n    }\n}\nconst cachedHexes = Array.from({\n    length: 256\n}, (_v, i)=>i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(uint8a) {\n    // Pre-caching chars with `cachedHexes` speeds this up 6x\n    let hex = \"\";\n    for(let i = 0; i < uint8a.length; i++){\n        hex += cachedHexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction parseHexByte(hexByte) {\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte)) throw new Error(\"Invalid byte sequence\");\n    return byte;\n}\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToBytes: expected string, got \" + typeof hex);\n    }\n    if (hex.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n    const array = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        array[i] = parseHexByte(hex.slice(j, j + 2));\n    }\n    return array;\n}\n/** Concatenates two Uint8Arrays into one. */ function concatBytes(...arrays) {\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction utf8ToBytes(utf) {\n    return new TextEncoder().encode(utf);\n}\n/** Transform an integer into its hexadecimal value */ function numberToHex(integer) {\n    if (integer < 0) {\n        throw new Error(\"Invalid integer as argument, must be unsigned!\");\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\n/** Pad a string to be even */ function padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\n/** Check if a string is prefixed by 0x */ function isHexPrefixed(str) {\n    return str.length >= 2 && str[0] === \"0\" && str[1] === \"x\";\n}\n/** Removes 0x from a given String */ function stripHexPrefix(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform anything into a Uint8Array */ function toBytes(v) {\n    if (v instanceof Uint8Array) {\n        return v;\n    }\n    if (typeof v === \"string\") {\n        if (isHexPrefixed(v)) {\n            return hexToBytes(padToEven(stripHexPrefix(v)));\n        }\n        return utf8ToBytes(v);\n    }\n    if (typeof v === \"number\" || typeof v === \"bigint\") {\n        if (!v) {\n            return Uint8Array.from([]);\n        }\n        return hexToBytes(numberToHex(v));\n    }\n    if (v === null || v === undefined) {\n        return Uint8Array.from([]);\n    }\n    throw new Error(\"toBytes: received unsupported type \" + typeof v);\n}\nexports.utils = {\n    bytesToHex,\n    concatBytes,\n    hexToBytes,\n    utf8ToBytes\n};\nexports.RLP = {\n    encode,\n    decode\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3JscC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLGFBQWEsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUNyRTs7Ozs7O0VBTUUsR0FDRixTQUFTSyxPQUFPQyxLQUFLO0lBQ2pCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN0QixNQUFNRyxTQUFTLEVBQUU7UUFDakIsSUFBSUMsZUFBZTtRQUNuQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsTUFBTU0sTUFBTSxFQUFFRCxJQUFLO1lBQ25DLE1BQU1FLFVBQVVSLE9BQU9DLEtBQUssQ0FBQ0ssRUFBRTtZQUMvQkYsT0FBT0ssSUFBSSxDQUFDRDtZQUNaSCxnQkFBZ0JHLFFBQVFELE1BQU07UUFDbEM7UUFDQSxPQUFPRyxZQUFZQyxhQUFhTixjQUFjLFNBQVNEO0lBQzNEO0lBQ0EsTUFBTVEsV0FBV0MsUUFBUVo7SUFDekIsSUFBSVcsU0FBU0wsTUFBTSxLQUFLLEtBQUtLLFFBQVEsQ0FBQyxFQUFFLEdBQUcsS0FBSztRQUM1QyxPQUFPQTtJQUNYO0lBQ0EsT0FBT0YsWUFBWUMsYUFBYUMsU0FBU0wsTUFBTSxFQUFFLE1BQU1LO0FBQzNEO0FBQ0FqQixjQUFjLEdBQUdLO0FBQ2pCOzs7Ozs7Q0FNQyxHQUNELFNBQVNjLFVBQVViLEtBQUssRUFBRWMsS0FBSyxFQUFFQyxHQUFHO0lBQ2hDLElBQUlBLE1BQU1mLE1BQU1NLE1BQU0sRUFBRTtRQUNwQixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQSxPQUFPaEIsTUFBTWlCLEtBQUssQ0FBQ0gsT0FBT0M7QUFDOUI7QUFDQTs7O0NBR0MsR0FDRCxTQUFTRyxhQUFhQyxDQUFDO0lBQ25CLElBQUlBLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUNaLE1BQU0s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RTtBQUNBekIsYUFBYSxHQUFHO0lBQ1oyQjtJQUNBWjtJQUNBcUI7SUFDQWdDO0FBQ0o7QUFDQXBFLFdBQVcsR0FBRztJQUFFSztJQUFRRDtBQUFPLEdBQy9CLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvcmxwL2Rpc3QvaW5kZXguanM/Y2Q5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkxQID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG4vKipcbiAqIFJMUCBFbmNvZGluZyBiYXNlZCBvbiBodHRwczovL2V0aGVyZXVtLm9yZy9lbi9kZXZlbG9wZXJzL2RvY3MvZGF0YS1zdHJ1Y3R1cmVzLWFuZC1lbmNvZGluZy9ybHAvXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGRhdGEsIGNvbnZlcnRzIGl0IHRvIFVpbnQ4QXJyYXkgaWYgbm90LFxuICogYW5kIGFkZHMgYSBsZW5ndGggZm9yIHJlY3Vyc2lvbi5cbiAqIEBwYXJhbSBpbnB1dCBXaWxsIGJlIGNvbnZlcnRlZCB0byBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBVaW50OEFycmF5IG9mIGVuY29kZWQgZGF0YVxuICoqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBsZXQgb3V0cHV0TGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZShpbnB1dFtpXSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGVkKTtcbiAgICAgICAgICAgIG91dHB1dExlbmd0aCArPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKG91dHB1dExlbmd0aCwgMTkyKSwgLi4ub3V0cHV0KTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCdWYgPSB0b0J5dGVzKGlucHV0KTtcbiAgICBpZiAoaW5wdXRCdWYubGVuZ3RoID09PSAxICYmIGlucHV0QnVmWzBdIDwgMTI4KSB7XG4gICAgICAgIHJldHVybiBpbnB1dEJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKGVuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBTbGljZXMgYSBVaW50OEFycmF5LCB0aHJvd3MgaWYgdGhlIHNsaWNlIGdvZXMgb3V0LW9mLWJvdW5kcyBvZiB0aGUgVWludDhBcnJheS5cbiAqIEUuZy4gYHNhZmVTbGljZShoZXhUb0J5dGVzKCdhYScpLCAxLCAyKWAgd2lsbCB0aHJvdy5cbiAqIEBwYXJhbSBpbnB1dFxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKi9cbmZ1bmN0aW9uIHNhZmVTbGljZShpbnB1dCwgc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUCAoc2FmZVNsaWNlKTogZW5kIHNsaWNlIG9mIFVpbnQ4QXJyYXkgb3V0LW9mLWJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG4vKipcbiAqIFBhcnNlIGludGVnZXJzLiBDaGVjayBpZiB0aGVyZSBpcyBubyBsZWFkaW5nIHplcm9zXG4gKiBAcGFyYW0gdiBUaGUgdmFsdWUgdG8gcGFyc2VcbiAqL1xuZnVuY3Rpb24gZGVjb2RlTGVuZ3RoKHYpIHtcbiAgICBpZiAodlswXSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHRyYSB6ZXJvcycpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VIZXhCeXRlKGJ5dGVzVG9IZXgodikpO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGxlbiwgb2Zmc2V0KSB7XG4gICAgaWYgKGxlbiA8IDU2KSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW2xlbiArIG9mZnNldF0pO1xuICAgIH1cbiAgICBjb25zdCBoZXhMZW5ndGggPSBudW1iZXJUb0hleChsZW4pO1xuICAgIGNvbnN0IGxMZW5ndGggPSBoZXhMZW5ndGgubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBudW1iZXJUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGV4VG9CeXRlcyhmaXJzdEJ5dGUgKyBoZXhMZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCwgc3RyZWFtID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Qnl0ZXMgPSB0b0J5dGVzKGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShpbnB1dEJ5dGVzKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHJlbWFpbmRlciBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqIERlY29kZSBhbiBpbnB1dCB3aXRoIFJMUCAqL1xuZnVuY3Rpb24gX2RlY29kZShpbnB1dCkge1xuICAgIGxldCBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkO1xuICAgIGNvbnN0IGRlY29kZWQgPSBbXTtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgICAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgZW5jb2Rpbmc6IGludmFsaWQgcHJlZml4LCBzaW5nbGUgYnl0ZSA8IDB4ODAgYXJlIG5vdCBwcmVmaXhlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgICAgICAvLyBzdHJpbmcgaXMgZ3JlYXRlciB0aGFuIDU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB0aGUgdmFsdWUgKDB4YjcgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBsZW5ndGgpLFxuICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoLCBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGI2O1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIC0gMSA8IGxsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZyBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4cGVjdGVkIHN0cmluZyBsZW5ndGggdG8gYmUgZ3JlYXRlciB0aGFuIDU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgbGVuZ3RoICsgbGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgLy8gYSBsaXN0IGJldHdlZW4gMC01NSBieXRlcyBsb25nXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3Qgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPCA1Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZW5jb2RlZCBsaXN0IHRvbyBzaG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gbGxlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiB0b3RhbCBsZW5ndGggaXMgbGFyZ2VyIHRoYW4gdGhlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgdG90YWxMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCBjYWNoZWRIZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBQcmUtY2FjaGluZyBjaGFycyB3aXRoIGBjYWNoZWRIZXhlc2Agc3BlZWRzIHRoaXMgdXAgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGNhY2hlZEhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBwYXJzZUhleEJ5dGUoaGV4Qnl0ZSkge1xuICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgcmV0dXJuIGJ5dGU7XG59XG4vLyBDYWNoaW5nIHNsb3dzIGl0IGRvd24gMi0zeFxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgYXJyYXlbaV0gPSBwYXJzZUhleEJ5dGUoaGV4LnNsaWNlKGosIGogKyAyKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKiBDb25jYXRlbmF0ZXMgdHdvIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHV0Zikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodXRmKTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuZnVuY3Rpb24gbnVtYmVyVG9IZXgoaW50ZWdlcikge1xuICAgIGlmIChpbnRlZ2VyIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBhcyBhcmd1bWVudCwgbXVzdCBiZSB1bnNpZ25lZCEnKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gaW50ZWdlci50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJSAyID8gYDAke2hleH1gIDogaGV4O1xufVxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4oYSkge1xuICAgIHJldHVybiBhLmxlbmd0aCAlIDIgPyBgMCR7YX1gIDogYTtcbn1cbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSAyICYmIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuLyoqIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4vKiogVHJhbnNmb3JtIGFueXRoaW5nIGludG8gYSBVaW50OEFycmF5ICovXG5mdW5jdGlvbiB0b0J5dGVzKHYpIHtcbiAgICBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleCh2KSk7XG4gICAgfVxuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b0J5dGVzOiByZWNlaXZlZCB1bnN1cHBvcnRlZCB0eXBlICcgKyB0eXBlb2Ygdik7XG59XG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGJ5dGVzVG9IZXgsXG4gICAgY29uY2F0Qnl0ZXMsXG4gICAgaGV4VG9CeXRlcyxcbiAgICB1dGY4VG9CeXRlcyxcbn07XG5leHBvcnRzLlJMUCA9IHsgZW5jb2RlLCBkZWNvZGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJMUCIsInV0aWxzIiwiZGVjb2RlIiwiZW5jb2RlIiwiaW5wdXQiLCJBcnJheSIsImlzQXJyYXkiLCJvdXRwdXQiLCJvdXRwdXRMZW5ndGgiLCJpIiwibGVuZ3RoIiwiZW5jb2RlZCIsInB1c2giLCJjb25jYXRCeXRlcyIsImVuY29kZUxlbmd0aCIsImlucHV0QnVmIiwidG9CeXRlcyIsInNhZmVTbGljZSIsInN0YXJ0IiwiZW5kIiwiRXJyb3IiLCJzbGljZSIsImRlY29kZUxlbmd0aCIsInYiLCJwYXJzZUhleEJ5dGUiLCJieXRlc1RvSGV4IiwibGVuIiwib2Zmc2V0IiwiVWludDhBcnJheSIsImZyb20iLCJoZXhMZW5ndGgiLCJudW1iZXJUb0hleCIsImxMZW5ndGgiLCJmaXJzdEJ5dGUiLCJoZXhUb0J5dGVzIiwic3RyZWFtIiwiaW5wdXRCeXRlcyIsImRlY29kZWQiLCJfZGVjb2RlIiwicmVtYWluZGVyIiwiZGF0YSIsImxsZW5ndGgiLCJpbm5lclJlbWFpbmRlciIsImQiLCJ0b3RhbExlbmd0aCIsImNhY2hlZEhleGVzIiwiX3YiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwidWludDhhIiwiaGV4IiwiaGV4Qnl0ZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwiVHlwZUVycm9yIiwiYXJyYXkiLCJqIiwiYXJyYXlzIiwicmVkdWNlIiwiYSIsImFyciIsInJlc3VsdCIsInBhZCIsInNldCIsInV0ZjhUb0J5dGVzIiwidXRmIiwiVGV4dEVuY29kZXIiLCJpbnRlZ2VyIiwicGFkVG9FdmVuIiwiaXNIZXhQcmVmaXhlZCIsInN0ciIsInN0cmlwSGV4UHJlZml4IiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/rlp/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/account.js":
/*!********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/account.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = __webpack_require__(/*! @ethereumjs/rlp */ \"(ssr)/../node_modules/@ethereumjs/rlp/dist/index.js\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/../node_modules/ethereum-cryptography/keccak.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/../node_modules/ethereum-cryptography/secp256k1.js\");\nconst utils_1 = __webpack_require__(/*! ethereum-cryptography/utils */ \"(ssr)/../node_modules/ethereum-cryptography/utils.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/@ethereumjs/util/dist/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/../node_modules/@ethereumjs/util/dist/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/../node_modules/@ethereumjs/util/dist/internal.js\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */ constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL){\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error(\"Invalid serialized account input. Must be array\");\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error(\"nonce must be greater than zero\");\n        }\n        if (this.balance < _0n) {\n            throw new Error(\"balance must be greater than zero\");\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error(\"storageRoot must have a length of 32\");\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error(\"codeHash must have a length of 32\");\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */ raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */ serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */ isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */ isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ const isValidAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */ const toChecksumAddress = function(hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = \"\";\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + \"0x\";\n    }\n    const buf = Buffer.from(prefix + address, \"utf8\");\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = \"0x\";\n    for(let i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ const generateAddress = function(from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([\n            from,\n            null\n        ])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([\n        from,\n        nonce\n    ])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ const generateAddress2 = function(from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error(\"Expected from to be of length 20\");\n    }\n    if (salt.length !== 32) {\n        throw new Error(\"Expected salt to be of length 32\");\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        from,\n        salt,\n        (0, keccak_1.keccak256)(initCode)\n    ]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ const isValidPrivate = function(privateKey) {\n    return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const isValidPublic = function(publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([\n                Buffer.from([\n                    4\n                ]),\n                publicKey\n            ]));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const pubToAddress = function(pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error(\"Expected pubKey to be of length 64\");\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToPublic = function(privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToAddress = function(privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */ const importPublic = function(publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */ const zeroAddress = function() {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */ const isZeroAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */ function accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0EseUJBQXlCLEdBQUdBLDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHQSxvQkFBb0IsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLDhCQUE4QixHQUFHQSx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQ25kLE1BQU1vQixRQUFRQyxtQkFBT0EsQ0FBQyw0RUFBaUI7QUFDdkMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsMkZBQThCO0FBQ3ZELE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLGlHQUFpQztBQUM3RCxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyx5RkFBNkI7QUFDckQsTUFBTUksVUFBVUosbUJBQU9BLENBQUMscUVBQVM7QUFDakMsTUFBTUssY0FBY0wsbUJBQU9BLENBQUMsNkVBQWE7QUFDekMsTUFBTU0sWUFBWU4sbUJBQU9BLENBQUMseUVBQVc7QUFDckMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsMkVBQVk7QUFDdkMsTUFBTVEsTUFBTUMsT0FBTztBQUNuQixNQUFNWDtJQUNGOzs7S0FHQyxHQUNEWSxZQUFZQyxRQUFRSCxHQUFHLEVBQUVJLFVBQVVKLEdBQUcsRUFBRUssY0FBY1IsWUFBWVMsYUFBYSxFQUFFQyxXQUFXVixZQUFZVyxjQUFjLENBQUU7UUFDcEgsSUFBSSxDQUFDTCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUks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OEIsTUFBTSxDQUFDdEMsWUFBWVMsYUFBYSxJQUFJeUUsZ0JBQWdCMUU7UUFDekYsSUFBR1QsUUFBUXNCLFdBQVcsRUFBRVgsVUFBVTRCLE1BQU0sQ0FBQ3RDLFlBQVlXLGNBQWMsSUFBSXVFLGdCQUFnQnhFO0tBQzNGO0FBQ0w7QUFDQXBDLHlCQUF5QixHQUFHRztBQUM1Qjs7OztDQUlDLEdBQ0QsU0FBU0QsaUJBQWlCeUcsSUFBSSxFQUFFRSxjQUFjLElBQUk7SUFDOUMsTUFBTUMsY0FBY0QsY0FBY3pHLG9CQUFvQnVHLFFBQVFBO0lBQzlELE9BQU8sQ0FBQyxHQUFHbEYsUUFBUXNCLFdBQVcsRUFBRTNCLE1BQU00QixHQUFHLENBQUNhLE1BQU0sQ0FBQ2lEO0FBQ3JEO0FBQ0E5Ryx3QkFBd0IsR0FBR0Usa0JBQzNCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2FjY291bnQuanM/ZDI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWNjb3VudEJvZHlUb1JMUCA9IGV4cG9ydHMuYWNjb3VudEJvZHlUb1NsaW0gPSBleHBvcnRzLmFjY291bnRCb2R5RnJvbVNsaW0gPSBleHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzID0gZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IHJscF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3JscFwiKTtcbmNvbnN0IGtlY2Nha18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWtcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvdXRpbHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jbGFzcyBBY2NvdW50IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFzc2lnbnMgYW5kIHZhbGlkYXRlcyB0aGUgdmFsdWVzLlxuICAgICAqIFVzZSB0aGUgc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgYW4gQWNjb3VudCBmcm9tIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub25jZSA9IF8wbiwgYmFsYW5jZSA9IF8wbiwgc3RvcmFnZVJvb3QgPSBjb25zdGFudHNfMS5LRUNDQUsyNTZfUkxQLCBjb2RlSGFzaCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKSB7XG4gICAgICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgdGhpcy5iYWxhbmNlID0gYmFsYW5jZTtcbiAgICAgICAgdGhpcy5zdG9yYWdlUm9vdCA9IHN0b3JhZ2VSb290O1xuICAgICAgICB0aGlzLmNvZGVIYXNoID0gY29kZUhhc2g7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYWNjb3VudERhdGEpIHtcbiAgICAgICAgY29uc3QgeyBub25jZSwgYmFsYW5jZSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoIH0gPSBhY2NvdW50RGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5vbmNlICE9PSB1bmRlZmluZWQgPyAoMCwgYnl0ZXNfMS5idWZmZXJUb0JpZ0ludCkoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKG5vbmNlKSkgOiB1bmRlZmluZWQsIGJhbGFuY2UgIT09IHVuZGVmaW5lZCA/ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYmFsYW5jZSkpIDogdW5kZWZpbmVkLCBzdG9yYWdlUm9vdCAhPT0gdW5kZWZpbmVkID8gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHN0b3JhZ2VSb290KSA6IHVuZGVmaW5lZCwgY29kZUhhc2ggIT09IHVuZGVmaW5lZCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShjb2RlSGFzaCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50KHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gKDAsIGJ5dGVzXzEuYXJyVG9CdWZBcnIpKHJscF8xLlJMUC5kZWNvZGUoVWludDhBcnJheS5mcm9tKHNlcmlhbGl6ZWQpKSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXplZCBhY2NvdW50IGlucHV0LiBNdXN0IGJlIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVZhbHVlc0FycmF5KHZhbHVlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVmFsdWVzQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IFtub25jZSwgYmFsYW5jZSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoXSA9IHZhbHVlcztcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KCgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShub25jZSksICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShiYWxhbmNlKSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoKTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub25jZSA8IF8wbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZSA8IF8wbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWxhbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdG9yYWdlUm9vdC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JhZ2VSb290IG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAzMicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvZGVIYXNoLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29kZUhhc2ggbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBBcnJheSBvZiB0aGUgcmF3IEJ1ZmZlcnMgZm9yIHRoZSBhY2NvdW50LCBpbiBvcmRlci5cbiAgICAgKi9cbiAgICByYXcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoMCwgYnl0ZXNfMS5iaWdJbnRUb1VucGFkZGVkQnVmZmVyKSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgICgwLCBieXRlc18xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMuYmFsYW5jZSksXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VSb290LFxuICAgICAgICAgICAgdGhpcy5jb2RlSGFzaCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUkxQIHNlcmlhbGl6YXRpb24gb2YgdGhlIGFjY291bnQgYXMgYSBgQnVmZmVyYC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShybHBfMS5STFAuZW5jb2RlKCgwLCBieXRlc18xLmJ1ZkFyclRvQXJyKSh0aGlzLnJhdygpKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGEgY29udHJhY3QuXG4gICAgICovXG4gICAgaXNDb250cmFjdCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvZGVIYXNoLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQm9vbGVhbmAgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjY291bnQgaXMgZW1wdHkgY29tcGx5aW5nIHRvIHRoZSBkZWZpbml0aW9uIG9mXG4gICAgICogYWNjb3VudCBlbXB0aW5lc3MgaW4gW0VJUC0xNjFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTYxKTpcbiAgICAgKiBcIkFuIGFjY291bnQgaXMgY29uc2lkZXJlZCBlbXB0eSB3aGVuIGl0IGhhcyBubyBjb2RlIGFuZCB6ZXJvIG5vbmNlIGFuZCB6ZXJvIGJhbGFuY2UuXCJcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlID09PSBfMG4gJiYgdGhpcy5ub25jZSA9PT0gXzBuICYmIHRoaXMuY29kZUhhc2guZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnQgPSBBY2NvdW50O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vLlxuICovXG5jb25zdCBpc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGhleEFkZHJlc3MpO1xufTtcbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBpc1ZhbGlkQWRkcmVzcztcbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogSWYgYW4gZWlwMTE5MUNoYWluSWQgaXMgcHJvdmlkZWQsIHRoZSBjaGFpbklkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNoZWNrc3VtIGNhbGN1bGF0aW9uLiBUaGlzXG4gKiBoYXMgdGhlIGVmZmVjdCBvZiBjaGVja3N1bW1lZCBhZGRyZXNzZXMgZm9yIG9uZSBjaGFpbiBoYXZpbmcgaW52YWxpZCBjaGVja3N1bXMgZm9yIG90aGVycy5cbiAqIEZvciBtb3JlIGRldGFpbHMgc2VlIFtFSVAtMTE5MV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkxKS5cbiAqXG4gKiBXQVJOSU5HOiBDaGVja3N1bXMgd2l0aCBhbmQgd2l0aG91dCB0aGUgY2hhaW5JZCB3aWxsIGRpZmZlciBhbmQgdGhlIEVJUC0xMTkxIGNoZWNrc3VtIGlzIG5vdFxuICogYmFja3dhcmRzIGNvbXBhdGlibGUgdG8gdGhlIG9yaWdpbmFsIHdpZGVseSBhZG9wdGVkIGNoZWNrc3VtIGZvcm1hdCBzdGFuZGFyZCBpbnRyb2R1Y2VkIGluXG4gKiBbRUlQLTU1XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTU1KSwgc28gdGhpcyB3aWxsIGJyZWFrIGluIGV4aXN0aW5nIGFwcGxpY2F0aW9ucy5cbiAqIFVzYWdlIG9mIHRoaXMgRUlQIGlzIHRoZXJlZm9yZSBkaXNjb3VyYWdlZCB1bmxlc3MgeW91IGhhdmUgYSB2ZXJ5IHRhcmdldGVkIHVzZSBjYXNlLlxuICovXG5jb25zdCB0b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGhleEFkZHJlc3MpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoaGV4QWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgaWYgKGVpcDExOTFDaGFpbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoZWlwMTE5MUNoYWluSWQpKTtcbiAgICAgICAgcHJlZml4ID0gY2hhaW5JZC50b1N0cmluZygpICsgJzB4JztcbiAgICB9XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocHJlZml4ICsgYWRkcmVzcywgJ3V0ZjgnKTtcbiAgICBjb25zdCBoYXNoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoYnVmKSk7XG4gICAgbGV0IHJldCA9ICcweCc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IHRvQ2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxuICovXG5jb25zdCBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKShoZXhBZGRyZXNzKSAmJiAoMCwgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcykoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpID09PSBoZXhBZGRyZXNzO1xufTtcbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGlzVmFsaWRDaGVja3N1bUFkZHJlc3M7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICovXG5jb25zdCBnZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShmcm9tKTtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShub25jZSk7XG4gICAgaWYgKCgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShub25jZSkgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHJscF8xLlJMUC5lbmNvZGUoKDAsIGJ5dGVzXzEuYnVmQXJyVG9BcnIpKFtmcm9tLCBudWxsXSkpKSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHJscF8xLlJMUC5lbmNvZGUoKDAsIGJ5dGVzXzEuYnVmQXJyVG9BcnIpKFtmcm9tLCBub25jZV0pKSkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3M7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBzYWx0IEEgc2FsdFxuICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAqL1xuY29uc3QgZ2VuZXJhdGVBZGRyZXNzMiA9IGZ1bmN0aW9uIChmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHNhbHQpO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGluaXRDb2RlKTtcbiAgICBpZiAoZnJvbS5sZW5ndGggIT09IDIwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZnJvbSB0byBiZSBvZiBsZW5ndGggMjAnKTtcbiAgICB9XG4gICAgaWYgKHNhbHQubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNhbHQgdG8gYmUgb2YgbGVuZ3RoIDMyJyk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb20sIHNhbHQsICgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKGluaXRDb2RlKV0pKTtcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGFkZHJlc3MpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZ2VuZXJhdGVBZGRyZXNzMjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmNvbnN0IGlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBpc1ZhbGlkUHJpdmF0ZTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGNoZWNrcyB3aGV0aGVyIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNhbml0aXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGlzVmFsaWRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmNvbnN0IHB1YlRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJLZXkpO1xuICAgIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJLZXkgPSBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHViS2V5KS50b1Jhd0J5dGVzKGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgIGlmIChwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHB1YktleSB0byBiZSBvZiBsZW5ndGggNjQnKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHB1YktleSkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBwdWJUb0FkZHJlc3M7XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHByaXZhdGVLZXkpO1xuICAgIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoZmFsc2UpLnNsaWNlKDEpKTtcbn07XG5leHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IHByaXZhdGVUb1B1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuY29uc3QgcHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcykoKDAsIGV4cG9ydHMucHJpdmF0ZVRvUHVibGljKShwcml2YXRlS2V5KSk7XG59O1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gcHJpdmF0ZVRvQWRkcmVzcztcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmNvbnN0IGltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHVibGljS2V5KS50b1Jhd0J5dGVzKGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBpbXBvcnRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICAgIGNvbnN0IGFkZHIgPSAoMCwgYnl0ZXNfMS56ZXJvcykoYWRkcmVzc0xlbmd0aCk7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShhZGRyKTtcbn07XG5leHBvcnRzLnplcm9BZGRyZXNzID0gemVyb0FkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgemVyb0FkZHIgPSAoMCwgZXhwb3J0cy56ZXJvQWRkcmVzcykoKTtcbiAgICByZXR1cm4gemVyb0FkZHIgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gaXNaZXJvQWRkcmVzcztcbmZ1bmN0aW9uIGFjY291bnRCb2R5RnJvbVNsaW0oYm9keSkge1xuICAgIGNvbnN0IFtub25jZSwgYmFsYW5jZSwgc3RvcmFnZVJvb3QsIGNvZGVIYXNoXSA9IGJvZHk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGJhbGFuY2UsXG4gICAgICAgICgwLCBieXRlc18xLmFyclRvQnVmQXJyKShzdG9yYWdlUm9vdCkubGVuZ3RoID09PSAwID8gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X1JMUCA6IHN0b3JhZ2VSb290LFxuICAgICAgICAoMCwgYnl0ZXNfMS5hcnJUb0J1ZkFycikoY29kZUhhc2gpLmxlbmd0aCA9PT0gMCA/IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMIDogY29kZUhhc2gsXG4gICAgXTtcbn1cbmV4cG9ydHMuYWNjb3VudEJvZHlGcm9tU2xpbSA9IGFjY291bnRCb2R5RnJvbVNsaW07XG5jb25zdCBlbXB0eVVpbnQ4QXJyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5mdW5jdGlvbiBhY2NvdW50Qm9keVRvU2xpbShib2R5KSB7XG4gICAgY29uc3QgW25vbmNlLCBiYWxhbmNlLCBzdG9yYWdlUm9vdCwgY29kZUhhc2hdID0gYm9keTtcbiAgICByZXR1cm4gW1xuICAgICAgICBub25jZSxcbiAgICAgICAgYmFsYW5jZSxcbiAgICAgICAgKDAsIGJ5dGVzXzEuYXJyVG9CdWZBcnIpKHN0b3JhZ2VSb290KS5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X1JMUCkgPyBlbXB0eVVpbnQ4QXJyIDogc3RvcmFnZVJvb3QsXG4gICAgICAgICgwLCBieXRlc18xLmFyclRvQnVmQXJyKShjb2RlSGFzaCkuZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKSA/IGVtcHR5VWludDhBcnIgOiBjb2RlSGFzaCxcbiAgICBdO1xufVxuZXhwb3J0cy5hY2NvdW50Qm9keVRvU2xpbSA9IGFjY291bnRCb2R5VG9TbGltO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHNsaW0gYWNjb3VudCAocGVyIHNuYXAgcHJvdG9jb2wgc3BlYykgdG8gdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGFjY291bnRcbiAqIEBwYXJhbSBib2R5IEFycmF5IG9mIDQgQnVmZmVyLWxpa2UgaXRlbXMgdG8gcmVwcmVzZW50IHRoZSBhY2NvdW50XG4gKiBAcmV0dXJucyBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBhY2NvdW50XG4gKi9cbmZ1bmN0aW9uIGFjY291bnRCb2R5VG9STFAoYm9keSwgY291bGRCZVNsaW0gPSB0cnVlKSB7XG4gICAgY29uc3QgYWNjb3VudEJvZHkgPSBjb3VsZEJlU2xpbSA/IGFjY291bnRCb2R5RnJvbVNsaW0oYm9keSkgOiBib2R5O1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5hcnJUb0J1ZkFycikocmxwXzEuUkxQLmVuY29kZShhY2NvdW50Qm9keSkpO1xufVxuZXhwb3J0cy5hY2NvdW50Qm9keVRvUkxQID0gYWNjb3VudEJvZHlUb1JMUDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWNjb3VudEJvZHlUb1JMUCIsImFjY291bnRCb2R5VG9TbGltIiwiYWNjb3VudEJvZHlGcm9tU2xpbSIsImlzWmVyb0FkZHJlc3MiLCJ6ZXJvQWRkcmVzcyIsImltcG9ydFB1YmxpYyIsInByaXZhdGVUb0FkZHJlc3MiLCJwcml2YXRlVG9QdWJsaWMiLCJwdWJsaWNUb0FkZHJlc3MiLCJwdWJUb0FkZHJlc3MiLCJpc1ZhbGlkUHVibGljIiwiaXNWYWxpZFByaXZhdGUiLCJnZW5lcmF0ZUFkZHJlc3MyIiwiZ2VuZXJhdGVBZGRyZXNzIiwiaXNWYWxpZENoZWNrc3VtQWRkcmVzcyIsInRvQ2hlY2tzdW1BZGRyZXNzIiwiaXNWYWxpZEFkZHJlc3MiLCJBY2NvdW50IiwicmxwXzEiLCJyZXF1aXJlIiwia2VjY2FrXzEiLCJzZWNwMjU2azFfMSIsInV0aWxzXzEiLCJieXRlc18xIiwiY29uc3RhbnRzXzEiLCJoZWxwZXJzXzEiLCJpbnRlcm5hbF8xIiwiXzBuIiwiQmlnSW50IiwiY29uc3RydWN0b3IiLCJub25jZSIsImJhbGFuY2UiLCJzdG9yYWdlUm9vdCIsIktFQ0NBSzI1Nl9STFAiLCJjb2RlSGFzaCIsIktFQ0NBSzI1Nl9OVUxMIiwiX3ZhbGlkYXRlIiwiZnJvbUFjY291bnREYXRhIiwiYWNjb3VudERhdGEiLCJ1bmRlZmluZWQiLCJidWZmZXJUb0JpZ0ludCIsInRvQnVmZmVyIiwiZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50Iiwic2VyaWFsaXplZCIsInZhbHVlcyIsImFyclRvQnVmQXJyIiwiUkxQIiwiZGVjb2RlIiwiVWludDhBcnJheSIsImZyb20iLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImZyb21WYWx1ZXNBcnJheSIsImxlbmd0aCIsInJhdyIsImJpZ0ludFRvVW5wYWRkZWRCdWZmZXIiLCJzZXJpYWxpemUiLCJCdWZmZXIiLCJlbmNvZGUiLCJidWZBcnJUb0FyciIsImlzQ29udHJhY3QiLCJlcXVhbHMiLCJpc0VtcHR5IiwiaGV4QWRkcmVzcyIsImFzc2VydElzU3RyaW5nIiwiZSIsInRlc3QiLCJlaXAxMTkxQ2hhaW5JZCIsImFzc2VydElzSGV4U3RyaW5nIiwiYWRkcmVzcyIsInN0cmlwSGV4UHJlZml4IiwidG9Mb3dlckNhc2UiLCJwcmVmaXgiLCJjaGFpbklkIiwidG9TdHJpbmciLCJidWYiLCJoYXNoIiwiYnl0ZXNUb0hleCIsImtlY2NhazI1NiIsInJldCIsImkiLCJwYXJzZUludCIsInRvVXBwZXJDYXNlIiwiYXNzZXJ0SXNCdWZmZXIiLCJzbGljZSIsInNhbHQiLCJpbml0Q29kZSIsImNvbmNhdCIsInByaXZhdGVLZXkiLCJzZWNwMjU2azEiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Iiwic2FuaXRpemUiLCJQcm9qZWN0aXZlUG9pbnQiLCJmcm9tSGV4IiwicHViS2V5IiwidG9SYXdCeXRlcyIsImZyb21Qcml2YXRlS2V5IiwiYWRkcmVzc0xlbmd0aCIsImFkZHIiLCJ6ZXJvcyIsImJ1ZmZlclRvSGV4IiwiemVyb0FkZHIiLCJib2R5IiwiZW1wdHlVaW50OEFyciIsImNvdWxkQmVTbGltIiwiYWNjb3VudEJvZHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/address.js":
/*!********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/address.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Address = void 0;\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/../node_modules/@ethereumjs/util/dist/account.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\");\n/**\n * Handling and generating Ethereum addresses\n */ class Address {\n    constructor(buf){\n        if (buf.length !== 20) {\n            throw new Error(\"Invalid address length\");\n        }\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */ static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */ static fromString(str) {\n        if (!(0, account_1.isValidAddress)(str)) {\n            throw new Error(\"Invalid address\");\n        }\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */ static fromPublicKey(pubKey) {\n        if (!Buffer.isBuffer(pubKey)) {\n            throw new Error(\"Public key should be Buffer\");\n        }\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */ static fromPrivateKey(privateKey) {\n        if (!Buffer.isBuffer(privateKey)) {\n            throw new Error(\"Private key should be Buffer\");\n        }\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */ static generate(from, nonce) {\n        if (typeof nonce !== \"bigint\") {\n            throw new Error(\"Expected nonce to be a bigint\");\n        }\n        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */ static generate2(from, salt, initCode) {\n        if (!Buffer.isBuffer(salt)) {\n            throw new Error(\"Expected salt to be a Buffer\");\n        }\n        if (!Buffer.isBuffer(initCode)) {\n            throw new Error(\"Expected initCode to be a Buffer\");\n        }\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */ equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */ isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */ isPrecompileOrSystemAddress() {\n        const address = (0, bytes_1.bufferToBigInt)(this.buf);\n        const rangeMin = BigInt(0);\n        const rangeMax = BigInt(\"0xffff\");\n        return address >= rangeMin && address <= rangeMax;\n    }\n    /**\n     * Returns hex encoding of address.\n     */ toString() {\n        return \"0x\" + this.buf.toString(\"hex\");\n    }\n    /**\n     * Returns Buffer representation of address.\n     */ toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRyxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxxRUFBUztBQUNqQzs7Q0FFQyxHQUNELE1BQU1GO0lBQ0ZJLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLElBQUlBLElBQUlDLE1BQU0sS0FBSyxJQUFJO1lBQ25CLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtJQUNmO0lBQ0E7O0tBRUMsR0FDRCxPQUFPRyxPQUFPO1FBQ1YsT0FBTyxJQUFJUixRQUFRLENBQUMsR0FBR0csUUFBUU0sS0FBSyxFQUFFO0lBQzFDO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0MsV0FBV0MsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQyxDQUFDLEdBQUdWLFVBQVVXLGNBQWMsRUFBRUQsTUFBTTtZQUNyQyxNQUFNLElBQUlKLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUlQLFFBQVEsQ0FBQyxHQUFHRyxRQUFRVSxRQUFRLEVBQUVGO0lBQzdDO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0csY0FBY0MsTUFBTSxFQUFFO1FBQ3pCLElBQUksQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDRixTQUFTO1lBQzFCLE1BQU0sSUFBSVIsTUFBTTtRQUNwQjtRQUNBLE1BQU1GLE1BQU0sQ0FBQyxHQUFHSixVQUFVaUIsWUFBWSxFQUFFSDtRQUN4QyxPQUFPLElBQUlmLFFBQVFLO0lBQ3ZCO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT2MsZUFBZUMsVUFBVSxFQUFFO1FBQzlCLElBQUksQ0FBQ0osT0FBT0MsUUFBUSxDQUFDRyxhQUFhO1lBQzlCLE1BQU0sSUFBSWIsTUFBTTtRQUNwQjtRQUNBLE1BQU1GLE1BQU0sQ0FBQyxHQUFHSixVQUFVb0IsZ0JBQWdCLEVBQUVEO1FBQzVDLE9BQU8sSUFBSXBCLFFBQVFLO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU9pQixTQUFTQyxJQUFJLEVBQUVDLEtBQUssRUFBRTtRQUN6QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUMzQixNQUFNLElBQUlqQixNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJUCxRQUFRLENBQUMsR0FBR0MsVUFBVXdCLGVBQWUsRUFBRUYsS0FBS2xCLEdBQUcsRUFBRSxDQUFDLEdBQUdGLFFBQVF1QixjQUFjLEVBQUVGO0lBQzVGO0lBQ0E7Ozs7O0tBS0MsR0FDRCxPQUFPRyxVQUFVSixJQUFJLEVBQUVLLElBQUksRUFBRUMsUUFBUSxFQUFFO1FBQ25DLElBQUksQ0FBQ2IsT0FBT0MsUUFBUSxDQUFDVyxPQUFPO1lBQ3hCLE1BQU0sSUFBSXJCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNTLE9BQU9DLFFBQVEsQ0FBQ1ksV0FBVztZQUM1QixNQUFNLElBQUl0QixNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJUCxRQUFRLENBQUMsR0FBR0MsVUFBVTZCLGdCQUFnQixFQUFFUCxLQUFLbEIsR0FBRyxFQUFFdUIsTUFBTUM7SUFDdkU7SUFDQTs7S0FFQyxHQUNERSxPQUFPQyxPQUFPLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQzNCLEdBQUcsQ0FBQzBCLE1BQU0sQ0FBQ0MsUUFBUTNCLEdBQUc7SUFDdEM7SUFDQTs7S0FFQyxHQUNENEIsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDRixNQUFNLENBQUMvQixRQUFRUSxJQUFJO0lBQ25DO0lBQ0E7OztLQUdDLEdBQ0QwQiw4QkFBOEI7UUFDMUIsTUFBTUYsVUFBVSxDQUFDLEdBQUc3QixRQUFRZ0MsY0FBYyxFQUFFLElBQUksQ0FBQzlCLEdBQUc7UUFDcEQsTUFBTStCLFdBQVdDLE9BQU87UUFDeEIsTUFBTUMsV0FBV0QsT0FBTztRQUN4QixPQUFPTCxXQUFXSSxZQUFZSixXQUFXTTtJQUM3QztJQUNBOztLQUVDLEdBQ0RDLFdBQVc7UUFDUCxPQUFPLE9BQU8sSUFBSSxDQUFDbEMsR0FBRyxDQUFDa0MsUUFBUSxDQUFDO0lBQ3BDO0lBQ0E7O0tBRUMsR0FDRDFCLFdBQVc7UUFDUCxPQUFPRyxPQUFPTyxJQUFJLENBQUMsSUFBSSxDQUFDbEIsR0FBRztJQUMvQjtBQUNKO0FBQ0FQLGVBQWUsR0FBR0UsU0FDbEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvYWRkcmVzcy5qcz9mYTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogSGFuZGxpbmcgYW5kIGdlbmVyYXRpbmcgRXRoZXJldW0gYWRkcmVzc2VzXG4gKi9cbmNsYXNzIEFkZHJlc3Mge1xuICAgIGNvbnN0cnVjdG9yKGJ1Zikge1xuICAgICAgICBpZiAoYnVmLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICovXG4gICAgc3RhdGljIHplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS56ZXJvcykoMjApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBZGRyZXNzIG9iamVjdCBmcm9tIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzdHIgLSBIZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgIGlmICghKDAsIGFjY291bnRfMS5pc1ZhbGlkQWRkcmVzcykoc3RyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHN0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAgICAgKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVB1YmxpY0tleShwdWJLZXkpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHViS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQdWJsaWMga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSAoMCwgYWNjb3VudF8xLnB1YlRvQWRkcmVzcykocHViS2V5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGJ1Zik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSAoMCwgYWNjb3VudF8xLnByaXZhdGVUb0FkZHJlc3MpKHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlKGZyb20sIG5vbmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9uY2UgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbmNlIHRvIGJlIGEgYmlnaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBhY2NvdW50XzEuZ2VuZXJhdGVBZGRyZXNzKShmcm9tLmJ1ZiwgKDAsIGJ5dGVzXzEuYmlnSW50VG9CdWZmZXIpKG5vbmNlKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBjb250cmFjdCBjcmVhdGVkIHVzaW5nIENSRUFURTIuXG4gICAgICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBzYWx0IEEgc2FsdFxuICAgICAqIEBwYXJhbSBpbml0Q29kZSBUaGUgaW5pdCBjb2RlIG9mIHRoZSBjb250cmFjdCBiZWluZyBjcmVhdGVkXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlMihmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzYWx0IHRvIGJlIGEgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaW5pdENvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluaXRDb2RlIHRvIGJlIGEgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBhY2NvdW50XzEuZ2VuZXJhdGVBZGRyZXNzMikoZnJvbS5idWYsIHNhbHQsIGluaXRDb2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIGFkZHJlc3MgZXF1YWwgdG8gYW5vdGhlci5cbiAgICAgKi9cbiAgICBlcXVhbHMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuZXF1YWxzKGFkZHJlc3MuYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyB6ZXJvLlxuICAgICAqL1xuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEFkZHJlc3MuemVybygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBhZGRyZXNzIGlzIGluIHRoZSBhZGRyZXNzIHJhbmdlIGRlZmluZWRcbiAgICAgKiBieSBFSVAtMTM1MlxuICAgICAqL1xuICAgIGlzUHJlY29tcGlsZU9yU3lzdGVtQWRkcmVzcygpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KSh0aGlzLmJ1Zik7XG4gICAgICAgIGNvbnN0IHJhbmdlTWluID0gQmlnSW50KDApO1xuICAgICAgICBjb25zdCByYW5nZU1heCA9IEJpZ0ludCgnMHhmZmZmJyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzID49IHJhbmdlTWluICYmIGFkZHJlc3MgPD0gcmFuZ2VNYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGV4IGVuY29kaW5nIG9mIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgdGhpcy5idWYudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzcyA9IEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFkZHJlc3MiLCJhY2NvdW50XzEiLCJyZXF1aXJlIiwiYnl0ZXNfMSIsImNvbnN0cnVjdG9yIiwiYnVmIiwibGVuZ3RoIiwiRXJyb3IiLCJ6ZXJvIiwiemVyb3MiLCJmcm9tU3RyaW5nIiwic3RyIiwiaXNWYWxpZEFkZHJlc3MiLCJ0b0J1ZmZlciIsImZyb21QdWJsaWNLZXkiLCJwdWJLZXkiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInB1YlRvQWRkcmVzcyIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsInByaXZhdGVUb0FkZHJlc3MiLCJnZW5lcmF0ZSIsImZyb20iLCJub25jZSIsImdlbmVyYXRlQWRkcmVzcyIsImJpZ0ludFRvQnVmZmVyIiwiZ2VuZXJhdGUyIiwic2FsdCIsImluaXRDb2RlIiwiZ2VuZXJhdGVBZGRyZXNzMiIsImVxdWFscyIsImFkZHJlc3MiLCJpc1plcm8iLCJpc1ByZWNvbXBpbGVPclN5c3RlbUFkZHJlc3MiLCJidWZmZXJUb0JpZ0ludCIsInJhbmdlTWluIiwiQmlnSW50IiwicmFuZ2VNYXgiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/address.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/asyncEventEmitter.js":
/*!******************************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/asyncEventEmitter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsyncEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks){\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            } else {\n                await new Promise((resolve, reject)=>{\n                    task.call(context, data, (error)=>{\n                        if (error) {\n                            reject(error);\n                        } else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        } catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === \"function\") {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === \"newListener\" || event === \"removeListener\") {\n            data = {\n                event: data,\n                fn: callback\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [\n            listeners\n        ];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== \"function\") {\n            throw new TypeError(\"listener must be a function\");\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function(e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        } else {\n            g = function(e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== \"function\") {\n            throw new TypeError(\"listener must be a function\");\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [\n                listeners\n            ];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, \"after\");\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === \"after\" ? 1 : 0;\n        // Contract\n        if (typeof listener !== \"function\") {\n            throw new TypeError(\"listener must be a function\");\n        }\n        if (typeof target !== \"function\") {\n            throw new TypeError(\"target must be a function\");\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [\n                listeners\n            ];\n        }\n        index = listeners.length;\n        for(i = listeners.length; i--;){\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter; //# sourceMappingURL=asyncEventEmitter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hc3luY0V2ZW50RW1pdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7O0NBT0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHLEtBQUs7QUFDakMsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsZUFBZUMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDM0MsSUFBSUM7SUFDSixXQUFXLE1BQU1DLFFBQVFILE1BQU87UUFDNUIsSUFBSTtZQUNBLElBQUlHLEtBQUtDLE1BQU0sR0FBRyxHQUFHO2dCQUNqQixNQUFNO2dCQUNORCxLQUFLRSxJQUFJLENBQUNOLFNBQVNFO1lBQ3ZCLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJSyxRQUFRLENBQUNDLFNBQVNDO29CQUN4QkwsS0FBS0UsSUFBSSxDQUFDTixTQUFTRSxNQUFNLENBQUNDO3dCQUN0QixJQUFJQSxPQUFPOzRCQUNQTSxPQUFPTjt3QkFDWCxPQUNLOzRCQUNESzt3QkFDSjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0osRUFDQSxPQUFPRSxHQUFHO1lBQ05QLFFBQVFPO1FBQ1o7SUFDSjtJQUNBLElBQUlQLE9BQU87UUFDUCxNQUFNQTtJQUNWO0FBQ0o7QUFDQSxNQUFNUCwwQkFBMEJDLFNBQVNjLFlBQVk7SUFDakRDLEtBQUtDLEtBQUssRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDakIsSUFBSSxDQUFDWixNQUFNYSxTQUFTLEdBQUdEO1FBQ3ZCLE1BQU1FLE9BQU8sSUFBSTtRQUNqQixJQUFJQyxZQUFZRCxLQUFLRSxPQUFPLENBQUNMLE1BQU0sSUFBSSxFQUFFO1FBQ3pDLHlCQUF5QjtRQUN6QixJQUFJRSxhQUFhSSxhQUFhLE9BQU9qQixTQUFTLFlBQVk7WUFDdERhLFdBQVdiO1lBQ1hBLE9BQU9pQjtRQUNYO1FBQ0Esc0VBQXNFO1FBQ3RFLElBQUlOLFVBQVUsaUJBQWlCQSxVQUFVLGtCQUFrQjtZQUN2RFgsT0FBTztnQkFDSFcsT0FBT1g7Z0JBQ1BrQixJQUFJTDtZQUNSO1lBQ0FBLFdBQVdJO1FBQ2Y7UUFDQSx1REFBdUQ7UUFDdkRGLFlBQVlJLE1BQU1DLE9BQU8sQ0FBQ0wsYUFBYUEsWUFBWTtZQUFDQTtTQUFVO1FBQzlEbEIsWUFBWWlCLE1BQU1DLFVBQVVNLEtBQUssSUFBSXJCLE1BQU1zQixJQUFJLENBQUNULFVBQVVVLEtBQUssQ0FBQ1Y7UUFDaEUsT0FBT0MsS0FBS1UsYUFBYSxDQUFDYixTQUFTO0lBQ3ZDO0lBQ0FjLEtBQUtkLEtBQUssRUFBRWUsUUFBUSxFQUFFO1FBQ2xCLE1BQU1aLE9BQU8sSUFBSTtRQUNqQixJQUFJYTtRQUNKLElBQUksT0FBT0QsYUFBYSxZQUFZO1lBQ2hDLE1BQU0sSUFBSUUsVUFBVTtRQUN4QjtRQUNBLDRCQUE0QjtRQUM1QixJQUFJRixTQUFTdkIsTUFBTSxJQUFJLEdBQUc7WUFDdEJ3QixJQUFJLFNBQVVuQixDQUFDLEVBQUVxQixJQUFJO2dCQUNqQmYsS0FBS2dCLGNBQWMsQ0FBQ25CLE9BQU9nQjtnQkFDM0IsS0FBS0QsU0FBU2xCLEdBQUdxQjtZQUNyQjtRQUNKLE9BQ0s7WUFDREYsSUFBSSxTQUFVbkIsQ0FBQztnQkFDWE0sS0FBS2dCLGNBQWMsQ0FBQ25CLE9BQU9nQjtnQkFDM0IsS0FBS0QsU0FBU2xCLEdBQUdtQjtZQUNyQjtRQUNKO1FBQ0FiLEtBQUtpQixFQUFFLENBQUNwQixPQUFPZ0I7UUFDZixPQUFPYjtJQUNYO0lBQ0FrQixNQUFNckIsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDbkIsSUFBSVgsWUFBWSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0wsTUFBTSxJQUFJLEVBQUU7UUFDekMsV0FBVztRQUNYLElBQUksT0FBT2UsYUFBYSxZQUFZO1lBQ2hDLE1BQU0sSUFBSUUsVUFBVTtRQUN4QjtRQUNBLG9DQUFvQztRQUNwQyxJQUFJLENBQUNULE1BQU1DLE9BQU8sQ0FBQ0wsWUFBWTs7WUFFM0IsSUFBSSxDQUFDQyxPQUFPLENBQUNMLE1BQU0sR0FBR0ksWUFBWTtnQkFBQ0E7YUFBVTtRQUNqRDtRQUNBQSxVQUFVa0IsT0FBTyxDQUFDUDtRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBUSxPQUFPdkIsS0FBSyxFQUFFd0IsTUFBTSxFQUFFVCxRQUFRLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUNVLGFBQWEsQ0FBQ3pCLE9BQU93QixRQUFRVDtJQUM3QztJQUNBVyxNQUFNMUIsS0FBSyxFQUFFd0IsTUFBTSxFQUFFVCxRQUFRLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUNVLGFBQWEsQ0FBQ3pCLE9BQU93QixRQUFRVCxVQUFVO0lBQ3ZEO0lBQ0FVLGNBQWN6QixLQUFLLEVBQUV3QixNQUFNLEVBQUVULFFBQVEsRUFBRVUsYUFBYSxFQUFFO1FBQ2xELElBQUlyQixZQUFZLElBQUksQ0FBQ0MsT0FBTyxDQUFDTCxNQUFNLElBQUksRUFBRTtRQUN6QyxJQUFJMkI7UUFDSixJQUFJQztRQUNKLE1BQU1DLE1BQU1KLGtCQUFrQixVQUFVLElBQUk7UUFDNUMsV0FBVztRQUNYLElBQUksT0FBT1YsYUFBYSxZQUFZO1lBQ2hDLE1BQU0sSUFBSUUsVUFBVTtRQUN4QjtRQUNBLElBQUksT0FBT08sV0FBVyxZQUFZO1lBQzlCLE1BQU0sSUFBSVAsVUFBVTtRQUN4QjtRQUNBLG9DQUFvQztRQUNwQyxJQUFJLENBQUNULE1BQU1DLE9BQU8sQ0FBQ0wsWUFBWTs7WUFFM0IsSUFBSSxDQUFDQyxPQUFPLENBQUNMLE1BQU0sR0FBR0ksWUFBWTtnQkFBQ0E7YUFBVTtRQUNqRDtRQUNBd0IsUUFBUXhCLFVBQVVaLE1BQU07UUFDeEIsSUFBS21DLElBQUl2QixVQUFVWixNQUFNLEVBQUVtQyxLQUFNO1lBQzdCLElBQUl2QixTQUFTLENBQUN1QixFQUFFLEtBQUtILFFBQVE7Z0JBQ3pCSSxRQUFRRCxJQUFJRTtnQkFDWjtZQUNKO1FBQ0o7UUFDQXpCLFVBQVUwQixNQUFNLENBQUNGLE9BQU8sR0FBR2I7UUFDM0IsT0FBTyxJQUFJO0lBQ2Y7SUFDQUssR0FBR3BCLEtBQUssRUFBRWUsUUFBUSxFQUFFO1FBQ2hCLE9BQU8sS0FBSyxDQUFDSyxHQUFHcEIsT0FBT2U7SUFDM0I7SUFDQWdCLFlBQVkvQixLQUFLLEVBQUVlLFFBQVEsRUFBRTtRQUN6QixPQUFPLEtBQUssQ0FBQ2dCLFlBQVkvQixPQUFPZTtJQUNwQztJQUNBaUIsZ0JBQWdCaEMsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUNpQixnQkFBZ0JoQyxPQUFPZTtJQUN4QztJQUNBa0Isb0JBQW9CakMsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDakMsT0FBTyxLQUFLLENBQUNrQixvQkFBb0JqQyxPQUFPZTtJQUM1QztJQUNBbUIsbUJBQW1CbEMsS0FBSyxFQUFFO1FBQ3RCLE9BQU8sS0FBSyxDQUFDa0MsbUJBQW1CbEM7SUFDcEM7SUFDQW1CLGVBQWVuQixLQUFLLEVBQUVlLFFBQVEsRUFBRTtRQUM1QixPQUFPLEtBQUssQ0FBQ0ksZUFBZW5CLE9BQU9lO0lBQ3ZDO0lBQ0FvQixhQUFhO1FBQ1QsT0FBTyxLQUFLLENBQUNBO0lBQ2pCO0lBQ0EvQixVQUFVSixLQUFLLEVBQUU7UUFDYixPQUFPLEtBQUssQ0FBQ0ksVUFBVUo7SUFDM0I7SUFDQWEsY0FBY2IsS0FBSyxFQUFFO1FBQ2pCLE9BQU8sS0FBSyxDQUFDYSxjQUFjYjtJQUMvQjtJQUNBb0Msa0JBQWtCO1FBQ2QsT0FBTyxLQUFLLENBQUNBO0lBQ2pCO0lBQ0FDLGdCQUFnQkMsWUFBWSxFQUFFO1FBQzFCLE9BQU8sS0FBSyxDQUFDRCxnQkFBZ0JDO0lBQ2pDO0FBQ0o7QUFDQXpELHlCQUF5QixHQUFHRSxtQkFDNUIsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvYXN5bmNFdmVudEVtaXR0ZXIuanM/Nzk2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUG9ydGVkIHRvIFR5cGVzY3JpcHQgZnJvbSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBiZWxvdzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9haHVsdGdyZW4vYXN5bmMtZXZlbnRlbWl0dGVyIC0tIE1JVCBsaWNlbnNlZFxuICpcbiAqIFR5cGUgRGVmaW5pdGlvbnMgYmFzZWQgb24gd29yayBieTogcGF0YXJhcG9sdyA8aHR0cHM6Ly9naXRodWIuY29tL3BhdGFyYXBvbHc+IC0tIE1JVCBsaWNlbnNlZFxuICogdGhhdCB3YXMgY29udHJpYnV0ZWQgdG8gRGVmaW5pdGVseSBUeXBlZCBiZWxvdzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL3RyZWUvbWFzdGVyL3R5cGVzL2FzeW5jLWV2ZW50ZW1pdHRlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jRXZlbnRFbWl0dGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuYXN5bmMgZnVuY3Rpb24gcnVuSW5TZXJpZXMoY29udGV4dCwgdGFza3MsIGRhdGEpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgZm9yIGF3YWl0IChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGFzay5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgLy9zeW5jXG4gICAgICAgICAgICAgICAgdGFzay5jYWxsKGNvbnRleHQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGwoY29udGV4dCwgZGF0YSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5jbGFzcyBBc3luY0V2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBsZXQgW2RhdGEsIGNhbGxiYWNrXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgbGlzdGVuZXJzID0gc2VsZi5fZXZlbnRzW2V2ZW50XSA/PyBbXTtcbiAgICAgICAgLy8gT3B0aW9uYWwgZGF0YSBhcmd1bWVudFxuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBvZiBpbnRlcm5hbCBuZXdMaXN0ZW5lciBhbmQgcmVtb3ZlTGlzdGVuZXIgZXZlbnRzXG4gICAgICAgIGlmIChldmVudCA9PT0gJ25ld0xpc3RlbmVyJyB8fCBldmVudCA9PT0gJ3JlbW92ZUxpc3RlbmVyJykge1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogZGF0YSxcbiAgICAgICAgICAgICAgICBmbjogY2FsbGJhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBzaW5nbGUgbGlzdGVuZXIgaXMganVzdCBhIGZ1bmN0aW9uIG5vdCBhbiBhcnJheS4uLlxuICAgICAgICBsaXN0ZW5lcnMgPSBBcnJheS5pc0FycmF5KGxpc3RlbmVycykgPyBsaXN0ZW5lcnMgOiBbbGlzdGVuZXJzXTtcbiAgICAgICAgcnVuSW5TZXJpZXMoc2VsZiwgbGlzdGVuZXJzLnNsaWNlKCksIGRhdGEpLnRoZW4oY2FsbGJhY2spLmNhdGNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHNlbGYubGlzdGVuZXJDb3VudChldmVudCkgPiAwO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGc7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhY2sgdG8gc3VwcG9ydCBzZXQgYXJpdHlcbiAgICAgICAgaWYgKGxpc3RlbmVyLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBnID0gZnVuY3Rpb24gKGUsIG5leHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBnKTtcbiAgICAgICAgICAgICAgICB2b2lkIGxpc3RlbmVyKGUsIG5leHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGcpO1xuICAgICAgICAgICAgICAgIHZvaWQgbGlzdGVuZXIoZSwgZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYub24oZXZlbnQsIGcpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgZmlyc3QoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdID8/IFtdO1xuICAgICAgICAvLyBDb250cmFjdFxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBhbHdheXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBsaXN0ZW5lcnMgPSBbbGlzdGVuZXJzXTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiZWZvcmUoZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlT3JBZnRlcihldmVudCwgdGFyZ2V0LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGFmdGVyKGV2ZW50LCB0YXJnZXQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZU9yQWZ0ZXIoZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIsICdhZnRlcicpO1xuICAgIH1cbiAgICBiZWZvcmVPckFmdGVyKGV2ZW50LCB0YXJnZXQsIGxpc3RlbmVyLCBiZWZvcmVPckFmdGVyKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdID8/IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBjb25zdCBhZGQgPSBiZWZvcmVPckFmdGVyID09PSAnYWZ0ZXInID8gMSA6IDA7XG4gICAgICAgIC8vIENvbnRyYWN0XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGlzdGVuZXJzIGFyZSBub3QgYWx3YXlzIGFuIGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gbGlzdGVuZXJzID0gW2xpc3RlbmVyc107XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGkgKyBhZGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZXZlbnROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmV2ZW50TmFtZXMoKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lcnMoZXZlbnQpO1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgICB9XG4gICAgZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHNldE1heExpc3RlbmVycyhtYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldE1heExpc3RlbmVycyhtYXhMaXN0ZW5lcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXN5bmNFdmVudEVtaXR0ZXIgPSBBc3luY0V2ZW50RW1pdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jRXZlbnRFbWl0dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzeW5jRXZlbnRFbWl0dGVyIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwicnVuSW5TZXJpZXMiLCJjb250ZXh0IiwidGFza3MiLCJkYXRhIiwiZXJyb3IiLCJ0YXNrIiwibGVuZ3RoIiwiY2FsbCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZSIsIkV2ZW50RW1pdHRlciIsImVtaXQiLCJldmVudCIsImFyZ3MiLCJjYWxsYmFjayIsInNlbGYiLCJsaXN0ZW5lcnMiLCJfZXZlbnRzIiwidW5kZWZpbmVkIiwiZm4iLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInRoZW4iLCJjYXRjaCIsImxpc3RlbmVyQ291bnQiLCJvbmNlIiwibGlzdGVuZXIiLCJnIiwiVHlwZUVycm9yIiwibmV4dCIsInJlbW92ZUxpc3RlbmVyIiwib24iLCJmaXJzdCIsInVuc2hpZnQiLCJiZWZvcmUiLCJ0YXJnZXQiLCJiZWZvcmVPckFmdGVyIiwiYWZ0ZXIiLCJpIiwiaW5kZXgiLCJhZGQiLCJzcGxpY2UiLCJhZGRMaXN0ZW5lciIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJldmVudE5hbWVzIiwiZ2V0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwibWF4TGlzdGVuZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/asyncEventEmitter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js":
/*!******************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/bytes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/../node_modules/@ethereumjs/util/dist/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/../node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */ const intToHex = function(i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */ const intToBuffer = function(i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), \"hex\");\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ const zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */ const setLength = function(msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthLeft = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthRight = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ const stripZeros = function(a) {\n    let first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */ const unpadBuffer = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */ const unpadArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */ const unpadHexString = function(a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return \"0x\" + stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */ const toBuffer = function(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === \"string\") {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), \"hex\");\n    }\n    if (typeof v === \"number\") {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (typeof v === \"bigint\") {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2) n = \"0\" + n;\n        return Buffer.from(n, \"hex\");\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error(\"invalid type\");\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ const bufferToHex = function(buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Converts a {@link Buffer} to a {@link bigint}\n */ function bufferToBigInt(buf) {\n    const hex = (0, exports.bufferToHex)(buf);\n    if (hex === \"0x\") {\n        return BigInt(0);\n    }\n    return BigInt(hex);\n}\nexports.bufferToBigInt = bufferToBigInt;\n/**\n * Converts a {@link bigint} to a {@link Buffer}\n */ function bigIntToBuffer(num) {\n    return (0, exports.toBuffer)(\"0x\" + num.toString(16));\n}\nexports.bigIntToBuffer = bigIntToBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ const bufferToInt = function(buf) {\n    const res = Number(bufferToBigInt(buf));\n    if (!Number.isSafeInteger(res)) throw new Error(\"Number exceeds 53 bits\");\n    return res;\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ const fromSigned = function(num) {\n    return BigInt.asIntN(256, bufferToBigInt(num));\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ const toUnsigned = function(num) {\n    return bigIntToBuffer(BigInt.asUintN(256, num));\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ const addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : \"0x\" + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Shortens a string  or buffer's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000…'\n */ function short(buffer, maxLength = 50) {\n    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString(\"hex\") : buffer;\n    if (bufferStr.length <= maxLength) {\n        return bufferStr;\n    }\n    return bufferStr.slice(0, maxLength) + \"…\";\n}\nexports.short = short;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */ const toUtf8 = function(hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid non-even hex string input for toUtf8() provided\");\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, \"\"), \"hex\");\n    return bufferVal.toString(\"utf8\");\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ const baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString(\"hex\")}`;\n    } else if (ba instanceof Array) {\n        const array = [];\n        for(let i = 0; i < ba.length; i++){\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */ const validateNoLeadingZeroes = function(values) {\n    for (const [k, v] of Object.entries(values)){\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString(\"hex\")}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a)=>arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr ?? []);\n    }\n    return arr.map((a)=>bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr;\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n */ const bigIntToHex = (num)=>{\n    return \"0x\" + num.toString(16);\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert value from bigint to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */ function bigIntToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)(bigIntToBuffer(value));\n}\nexports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;\nfunction intToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));\n}\nexports.intToUnpaddedBuffer = intToUnpaddedBuffer; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLDhCQUE4QixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSwrQkFBK0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0EsYUFBYSxHQUFHQSxvQkFBb0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHNCQUFzQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUM1akIsTUFBTTJCLFlBQVlDLG1CQUFPQSxDQUFDLHlFQUFXO0FBQ3JDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDJFQUFZO0FBQ3ZDOzs7O0NBSUMsR0FDRCxNQUFNRixXQUFXLFNBQVVJLENBQUM7SUFDeEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FBRztRQUNuQyxNQUFNLElBQUlHLE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRUgsRUFBRSxDQUFDO0lBQzVEO0lBQ0EsT0FBTyxDQUFDLEVBQUUsRUFBRUEsRUFBRUksUUFBUSxDQUFDLElBQUksQ0FBQztBQUNoQztBQUNBbEMsZ0JBQWdCLEdBQUcwQjtBQUNuQjs7OztDQUlDLEdBQ0QsTUFBTUQsY0FBYyxTQUFVSyxDQUFDO0lBQzNCLE1BQU1LLE1BQU0sQ0FBQyxHQUFHbkMsUUFBUTBCLFFBQVEsRUFBRUk7SUFDbEMsT0FBT00sT0FBT0MsSUFBSSxDQUFDLENBQUMsR0FBR1IsV0FBV1MsU0FBUyxF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Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9ieXRlcy5qcz9iNWFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnRUb1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iaWdJbnRUb1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iaWdJbnRUb0hleCA9IGV4cG9ydHMuYnVmQXJyVG9BcnIgPSBleHBvcnRzLmFyclRvQnVmQXJyID0gZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLnRvVXRmOCA9IGV4cG9ydHMuc2hvcnQgPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9JbnQgPSBleHBvcnRzLmJpZ0ludFRvQnVmZmVyID0gZXhwb3J0cy5idWZmZXJUb0JpZ0ludCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLnRvQnVmZmVyID0gZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IGV4cG9ydHMudW5wYWRBcnJheSA9IGV4cG9ydHMudW5wYWRCdWZmZXIgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IGV4cG9ydHMuaW50VG9CdWZmZXIgPSBleHBvcnRzLmludFRvSGV4ID0gdm9pZCAwO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBpbnRUb0hleCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpKSB8fCBpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIGFuIGludmFsaWQgaW50ZWdlciB0eXBlOiAke2l9YCk7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2kudG9TdHJpbmcoMTYpfWA7XG59O1xuZXhwb3J0cy5pbnRUb0hleCA9IGludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5jb25zdCBpbnRUb0J1ZmZlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgY29uc3QgaGV4ID0gKDAsIGV4cG9ydHMuaW50VG9IZXgpKGkpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn07XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICovXG5jb25zdCB6ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuZXhwb3J0cy56ZXJvcyA9IHplcm9zO1xuLyoqXG4gKiBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIFRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBpbnB1dCBpZiBpdHMgbGVuZ3RoIGV4Y2VlZHMgYGxlbmd0aGAuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHJpZ2h0IHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgZXhwb3J0cy56ZXJvcykobGVuZ3RoKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG4vKipcbiAqIExlZnQgUGFkcyBhIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobXNnKTtcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCBmYWxzZSk7XG59O1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gc2V0TGVuZ3RoTGVmdDtcbi8qKlxuICogUmlnaHQgUGFkcyBhIGBCdWZmZXJgIHdpdGggdHJhaWxpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBpdCB0cnVuY2F0ZXMgdGhlIGVuZCBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBzZXRMZW5ndGhSaWdodDtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAsIGBTdHJpbmdgIG9yIGBOdW1iZXJbXWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmNvbnN0IHN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICAgIGxldCBmaXJzdCA9IGFbMF07XG4gICAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgICAgIGZpcnN0ID0gYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYC5cbiAqIEBwYXJhbSBhIChCdWZmZXIpXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHVucGFkQnVmZmVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkQnVmZmVyID0gdW5wYWRCdWZmZXI7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhbiBgQXJyYXlgIChvZiBudW1iZXJzKS5cbiAqIEBwYXJhbSBhIChudW1iZXJbXSlcbiAqIEByZXR1cm4gKG51bWJlcltdKVxuICovXG5jb25zdCB1bnBhZEFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRBcnJheSA9IHVucGFkQXJyYXk7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGhleC1wcmVmaXhlZCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBhIChTdHJpbmcpXG4gKiBAcmV0dXJuIChTdHJpbmcpXG4gKi9cbmNvbnN0IHVucGFkSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShhKTtcbiAgICBhID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGEpO1xuICAgIHJldHVybiAoJzB4JyArIHN0cmlwWmVyb3MoYSkpO1xufTtcbmV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSB1bnBhZEhleFN0cmluZztcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC5cbiAqIElucHV0cyBzdXBwb3J0ZWQ6IGBCdWZmZXJgLCBgU3RyaW5nYCAoaGV4LXByZWZpeGVkKSwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQmlnSW50YCBhbmQgb3RoZXIgb2JqZWN0c1xuICogd2l0aCBhIGB0b0FycmF5KClgIG9yIGB0b0J1ZmZlcigpYCBtZXRob2QuXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWVcbiAqL1xuY29uc3QgdG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKHYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogJHt2fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KSh2KSksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaW50VG9CdWZmZXIpKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGlmICh2IDwgQmlnSW50KDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IG5lZ2F0aXZlIGJpZ2ludCB0byBidWZmZXIuIEdpdmVuOiAke3Z9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoICUgMilcbiAgICAgICAgICAgIG4gPSAnMCcgKyBuO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obiwgJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodi50b0FycmF5KSB7XG4gICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9XG4gICAgaWYgKHYudG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9CdWZmZXIoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG59O1xuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBgMHhgLXByZWZpeGVkIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuY29uc3QgYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gKDAsIGV4cG9ydHMudG9CdWZmZXIpKGJ1Zik7XG4gICAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBidWZmZXJUb0hleDtcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgQnVmZmVyfSB0byBhIHtAbGluayBiaWdpbnR9XG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmlnSW50KGJ1Zikge1xuICAgIGNvbnN0IGhleCA9ICgwLCBleHBvcnRzLmJ1ZmZlclRvSGV4KShidWYpO1xuICAgIGlmIChoZXggPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChoZXgpO1xufVxuZXhwb3J0cy5idWZmZXJUb0JpZ0ludCA9IGJ1ZmZlclRvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBiaWdpbnR9IHRvIGEge0BsaW5rIEJ1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CdWZmZXIobnVtKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnRvQnVmZmVyKSgnMHgnICsgbnVtLnRvU3RyaW5nKDE2KSk7XG59XG5leHBvcnRzLmJpZ0ludFRvQnVmZmVyID0gYmlnSW50VG9CdWZmZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmNvbnN0IGJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGNvbnN0IHJlcyA9IE51bWJlcihidWZmZXJUb0JpZ0ludChidWYpKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIGV4Y2VlZHMgNTMgYml0cycpO1xuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGJ1ZmZlclRvSW50O1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCaWdJbnRgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW0gU2lnbmVkIGludGVnZXIgdmFsdWVcbiAqL1xuY29uc3QgZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gQmlnSW50LmFzSW50TigyNTYsIGJ1ZmZlclRvQmlnSW50KG51bSkpO1xufTtcbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZyb21TaWduZWQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJpZ0ludGAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW1cbiAqL1xuY29uc3QgdG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gYmlnSW50VG9CdWZmZXIoQmlnSW50LmFzVWludE4oMjU2LCBudW0pKTtcbn07XG5leHBvcnRzLnRvVW5zaWduZWQgPSB0b1Vuc2lnbmVkO1xuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKi9cbmNvbnN0IGFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbnRlcm5hbF8xLmlzSGV4UHJlZml4ZWQpKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gYWRkSGV4UHJlZml4O1xuLyoqXG4gKiBTaG9ydGVucyBhIHN0cmluZyAgb3IgYnVmZmVyJ3MgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBtYXhMZW5ndGggKGRlZmF1bHQgNTApLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIElucHV0OiAgJzY1NzQ2ODY1NzI2NTc1NmQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBPdXRwdXQ6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMOKApidcbiAqL1xuZnVuY3Rpb24gc2hvcnQoYnVmZmVyLCBtYXhMZW5ndGggPSA1MCkge1xuICAgIGNvbnN0IGJ1ZmZlclN0ciA9IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpID8gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSA6IGJ1ZmZlcjtcbiAgICBpZiAoYnVmZmVyU3RyLmxlbmd0aCA8PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclN0ci5zbGljZSgwLCBtYXhMZW5ndGgpICsgJ+KApic7XG59XG5leHBvcnRzLnNob3J0ID0gc2hvcnQ7XG4vKipcbiAqIFJldHVybnMgdGhlIHV0Zjggc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZyb20gYSBoZXggc3RyaW5nLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIElucHV0IDE6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICogSW5wdXQgMjogJzY1NzQ2ODY1NzI2NTc1NmQnXG4gKiBJbnB1dCAzOiAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjU3NDY4NjU3MjY1NzU2ZCdcbiAqXG4gKiBPdXRwdXQgKGFsbCAzIGlucHV0IHZhcmlhbnRzKTogJ2V0aGVyZXVtJ1xuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGhleCBzdHJpbmdzXG4gKiByZXByZXNlbnRpbmcgcXVhbnRpdGllcyBpbiBib3RoIGJpZyBlbmRpYW4gb3IgbGl0dGxlIGVuZGlhbiBub3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIEhleCBzdHJpbmcsIHNob3VsZCBiZSBgMHhgIHByZWZpeGVkXG4gKiBAcmV0dXJuIFV0Zjggc3RyaW5nXG4gKi9cbmNvbnN0IHRvVXRmOCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBjb25zdCB6ZXJvc1JlZ2V4cCA9IC9eKDAwKSt8KDAwKSskL2c7XG4gICAgaGV4ID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGhleCk7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub24tZXZlbiBoZXggc3RyaW5nIGlucHV0IGZvciB0b1V0ZjgoKSBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJWYWwgPSBCdWZmZXIuZnJvbShoZXgucmVwbGFjZSh6ZXJvc1JlZ2V4cCwgJycpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIGJ1ZmZlclZhbC50b1N0cmluZygndXRmOCcpO1xufTtcbmV4cG9ydHMudG9VdGY4ID0gdG9VdGY4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTi5cbiAqIEBwYXJhbSBiYSAoQnVmZmVyfEFycmF5KVxuICogQHJldHVybiAoQXJyYXl8U3RyaW5nfG51bGwpXG4gKi9cbmNvbnN0IGJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7YmEudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaCgoMCwgZXhwb3J0cy5iYVRvSlNPTikoYmFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbmV4cG9ydHMuYmFUb0pTT04gPSBiYVRvSlNPTjtcbi8qKlxuICogQ2hlY2tzIHByb3ZpZGVkIEJ1ZmZlcnMgZm9yIGxlYWRpbmcgemVyb2VzIGFuZCB0aHJvd3MgaWYgZm91bmQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogVmFsaWQgdmFsdWVzOiAweDEsIDB4LCAweDAxLCAweDEyMzRcbiAqIEludmFsaWQgdmFsdWVzOiAweDAsIDB4MDAsIDB4MDAxLCAweDAwMDFcbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHZhbGlkYXRpbmcgdGhhdCBSTFAgZW5jb2RlZCBpbnRlZ2VycyBjb21wbHkgd2l0aCB0aGUgcnVsZSB0aGF0IGFsbFxuICogaW50ZWdlciB2YWx1ZXMgZW5jb2RlZCB0byBSTFAgbXVzdCBiZSBpbiB0aGUgbW9zdCBjb21wYWN0IGZvcm0gYW5kIGNvbnRhaW4gbm8gbGVhZGluZyB6ZXJvIGJ5dGVzXG4gKiBAcGFyYW0gdmFsdWVzIEFuIG9iamVjdCBjb250YWluaW5nIHN0cmluZyBrZXlzIGFuZCBCdWZmZXIgdmFsdWVzXG4gKiBAdGhyb3dzIGlmIGFueSBwcm92aWRlZCB2YWx1ZSBpcyBmb3VuZCB0byBoYXZlIGxlYWRpbmcgemVybyBieXRlc1xuICovXG5jb25zdCB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdi5sZW5ndGggPiAwICYmIHZbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrfSBjYW5ub3QgaGF2ZSBsZWFkaW5nIHplcm9lcywgcmVjZWl2ZWQ6ICR7di50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzO1xuZnVuY3Rpb24gYXJyVG9CdWZBcnIoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBhcnJUb0J1ZkFycihhKSk7XG59XG5leHBvcnRzLmFyclRvQnVmQXJyID0gYXJyVG9CdWZBcnI7XG5mdW5jdGlvbiBidWZBcnJUb0FycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFyciA/PyBbXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBidWZBcnJUb0FycihhKSk7XG59XG5leHBvcnRzLmJ1ZkFyclRvQXJyID0gYnVmQXJyVG9BcnI7XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIGJpZ2ludH0gdG8gYSBgMHhgIHByZWZpeGVkIGhleCBzdHJpbmdcbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAobnVtKSA9PiB7XG4gICAgcmV0dXJuICcweCcgKyBudW0udG9TdHJpbmcoMTYpO1xufTtcbmV4cG9ydHMuYmlnSW50VG9IZXggPSBiaWdJbnRUb0hleDtcbi8qKlxuICogQ29udmVydCB2YWx1ZSBmcm9tIGJpZ2ludCB0byBhbiB1bnBhZGRlZCBCdWZmZXJcbiAqICh1c2VmdWwgZm9yIFJMUCB0cmFuc3BvcnQpXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY29udmVydFxuICovXG5mdW5jdGlvbiBiaWdJbnRUb1VucGFkZGVkQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnVucGFkQnVmZmVyKShiaWdJbnRUb0J1ZmZlcih2YWx1ZSkpO1xufVxuZXhwb3J0cy5iaWdJbnRUb1VucGFkZGVkQnVmZmVyID0gYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcjtcbmZ1bmN0aW9uIGludFRvVW5wYWRkZWRCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudW5wYWRCdWZmZXIpKCgwLCBleHBvcnRzLmludFRvQnVmZmVyKSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5pbnRUb1VucGFkZGVkQnVmZmVyID0gaW50VG9VbnBhZGRlZEJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImludFRvVW5wYWRkZWRCdWZmZXIiLCJiaWdJbnRUb1VucGFkZGVkQnVmZmVyIiwiYmlnSW50VG9IZXgiLCJidWZBcnJUb0FyciIsImFyclRvQnVmQXJyIiwidmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMiLCJiYVRvSlNPTiIsInRvVXRmOCIsInNob3J0IiwiYWRkSGV4UHJlZml4IiwidG9VbnNpZ25lZCIsImZyb21TaWduZWQiLCJidWZmZXJUb0ludCIsImJpZ0ludFRvQnVmZmVyIiwiYnVmZmVyVG9CaWdJbnQiLCJidWZmZXJUb0hleCIsInRvQnVmZmVyIiwidW5wYWRIZXhTdHJpbmciLCJ1bnBhZEFycmF5IiwidW5wYWRCdWZmZXIiLCJzZXRMZW5ndGhSaWdodCIsInNldExlbmd0aExlZnQiLCJ6ZXJvcyIsImludFRvQnVmZmVyIiwiaW50VG9IZXgiLCJoZWxwZXJzXzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSIsImkiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJ0b1N0cmluZyIsImhleCIsIkJ1ZmZlciIsImZyb20iLCJwYWRUb0V2ZW4iLCJzbGljZSIsImJ5dGVzIiwiYWxsb2NVbnNhZmUiLCJmaWxsIiwic2V0TGVuZ3RoIiwibXNnIiwibGVuZ3RoIiwicmlnaHQiLCJidWYiLCJjb3B5IiwiYXNzZXJ0SXNCdWZmZXIiLCJzdHJpcFplcm9zIiwiYSIsImZpcnN0IiwiYXNzZXJ0SXNBcnJheSIsImFzc2VydElzSGV4U3RyaW5nIiwic3RyaXBIZXhQcmVmaXgiLCJ2IiwidW5kZWZpbmVkIiwiaXNCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiLCJVaW50OEFycmF5IiwiaXNIZXhTdHJpbmciLCJCaWdJbnQiLCJuIiwidG9BcnJheSIsIm51bSIsInJlcyIsImFzSW50TiIsImFzVWludE4iLCJzdHIiLCJpc0hleFByZWZpeGVkIiwiYnVmZmVyIiwibWF4TGVuZ3RoIiwiYnVmZmVyU3RyIiwiemVyb3NSZWdleHAiLCJidWZmZXJWYWwiLCJyZXBsYWNlIiwiYmEiLCJhcnJheSIsInB1c2giLCJ2YWx1ZXMiLCJrIiwiZW50cmllcyIsImFyciIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/constants.js":
/*!**********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/../node_modules/ethereum-cryptography/secp256k1.js\");\n/**\n * 2^64-1\n */ exports.MAX_UINT64 = BigInt(\"0xffffffffffffffff\");\n/**\n * The max integer that the evm can handle (2^256-1)\n */ exports.MAX_INTEGER = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */ exports.MAX_INTEGER_BIGINT = BigInt(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\");\nexports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */ exports.TWO_POW256 = BigInt(\"0x10000000000000000000000000000000000000000000000000000000000000000\");\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, \"hex\");\n/**\n *  RLP encoded empty string\n */ exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([\n    0x80\n]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSx3QkFBd0IsR0FBR0EscUJBQXFCLEdBQUdBLHVCQUF1QixHQUFHQSwyQkFBMkIsR0FBR0EsNkJBQTZCLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0Esa0JBQWtCLEdBQUdBLDZCQUE2QixHQUFHQSx1QkFBdUIsR0FBR0EsMEJBQTBCLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ2pZLE1BQU1nQixXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxpR0FBaUM7QUFDN0Q7O0NBRUMsR0FDRGpCLGtCQUFrQixHQUFHbUIsT0FBTztBQUM1Qjs7Q0FFQyxHQUNEbkIsbUJBQW1CLEdBQUdtQixPQUFPO0FBQzdCOzs7O0NBSUMsR0FDRG5CLDBCQUEwQixHQUFHbUIsT0FBTztBQUNwQ25CLHVCQUF1QixHQUFHa0IsWUFBWUUsU0FBUyxDQUFDQyxLQUFLLENBQUNDLENBQUM7QUFDdkR0Qiw2QkFBNkIsR0FBR2tCLFlBQVlFLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxDQUFDLEdBQUdILE9BQU87QUFDdkU7O0NBRUMsR0FDRG5CLGtCQUFrQixHQUFHbUIsT0FBTztBQUM1Qjs7Q0FFQyxHQUNEbkIsd0JBQXdCLEdBQUc7QUFDM0I7O0NBRUMsR0FDREEsc0JBQXNCLEdBQUdnQixTQUFTTyxNQUFNLENBQUNDLElBQUksQ0FBQ3hCLFFBQVFTLGdCQUFnQixFQUFFO0FBQ3hFOztDQUVDLEdBQ0RULDZCQUE2QixHQUFHO0FBQ2hDOztDQUVDLEdBQ0RBLDJCQUEyQixHQUFHZ0IsU0FBU08sTUFBTSxDQUFDQyxJQUFJLENBQUN4QixRQUFRTyxxQkFBcUIsRUFBRTtBQUNsRjs7Q0FFQyxHQUNEUCx1QkFBdUIsR0FBRztBQUMxQjs7Q0FFQyxHQUNEQSxxQkFBcUIsR0FBR2dCLFNBQVNPLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDeEIsUUFBUUssZUFBZSxFQUFFO0FBQ3RFOztDQUVDLEdBQ0RMLHdCQUF3QixHQUFHZ0IsU0FBU08sTUFBTSxDQUFDQyxJQUFJLENBQUM7SUFBQztDQUFLO0FBQ3REeEIsbUNBQW1DLEdBQUcsSUFDdEMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvY29uc3RhbnRzLmpzPzFmM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1BWF9XSVRIRFJBV0FMU19QRVJfUEFZTE9BRCA9IGV4cG9ydHMuUkxQX0VNUFRZX1NUUklORyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gZXhwb3J0cy5UV09fUE9XMjU2ID0gZXhwb3J0cy5TRUNQMjU2SzFfT1JERVJfRElWXzIgPSBleHBvcnRzLlNFQ1AyNTZLMV9PUkRFUiA9IGV4cG9ydHMuTUFYX0lOVEVHRVJfQklHSU5UID0gZXhwb3J0cy5NQVhfSU5URUdFUiA9IGV4cG9ydHMuTUFYX1VJTlQ2NCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG4vKipcbiAqIDJeNjQtMVxuICovXG5leHBvcnRzLk1BWF9VSU5UNjQgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpO1xuLyoqXG4gKiBUaGUgbWF4IGludGVnZXIgdGhhdCB0aGUgZXZtIGNhbiBoYW5kbGUgKDJeMjU2LTEpXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuLyoqXG4gKiBUaGUgbWF4IGludGVnZXIgdGhhdCB0aGUgZXZtIGNhbiBoYW5kbGUgKDJeMjU2LTEpIGFzIGEgYmlnaW50XG4gKiAyXjI1Ni0xIGVxdWFscyB0byAzNDAyODIzNjY5MjA5Mzg0NjM0NjMzNzQ2MDc0MzE3NjgyMTE0NTVcbiAqIFdlIHVzZSBsaXRlcmFsIHZhbHVlIGluc3RlYWQgb2YgY2FsY3VsYXRlZCB2YWx1ZSBmb3IgY29tcGF0aWJpbGl0eSBpc3N1ZS5cbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUl9CSUdJTlQgPSBCaWdJbnQoJzExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMzEyOTYzOTkzNScpO1xuZXhwb3J0cy5TRUNQMjU2SzFfT1JERVIgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuQ1VSVkUubjtcbmV4cG9ydHMuU0VDUDI1NksxX09SREVSX0RJVl8yID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLkNVUlZFLm4gLyBCaWdJbnQoMik7XG4vKipcbiAqIDJeMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSAnYzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5XG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TLCAnaGV4Jyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MsICdoZXgnKTtcbi8qKlxuICogIFJMUCBlbmNvZGVkIGVtcHR5IHN0cmluZ1xuICovXG5leHBvcnRzLlJMUF9FTVBUWV9TVFJJTkcgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShbMHg4MF0pO1xuZXhwb3J0cy5NQVhfV0lUSERSQVdBTFNfUEVSX1BBWUxPQUQgPSAxNjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNQVhfV0lUSERSQVdBTFNfUEVSX1BBWUxPQUQiLCJSTFBfRU1QVFlfU1RSSU5HIiwiS0VDQ0FLMjU2X1JMUCIsIktFQ0NBSzI1Nl9STFBfUyIsIktFQ0NBSzI1Nl9STFBfQVJSQVkiLCJLRUNDQUsyNTZfUkxQX0FSUkFZX1MiLCJLRUNDQUsyNTZfTlVMTCIsIktFQ0NBSzI1Nl9OVUxMX1MiLCJUV09fUE9XMjU2IiwiU0VDUDI1NksxX09SREVSX0RJVl8yIiwiU0VDUDI1NksxX09SREVSIiwiTUFYX0lOVEVHRVJfQklHSU5UIiwiTUFYX0lOVEVHRVIiLCJNQVhfVUlOVDY0IiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwic2VjcDI1NmsxXzEiLCJCaWdJbnQiLCJzZWNwMjU2azEiLCJDVVJWRSIsIm4iLCJCdWZmZXIiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/encoding.js":
/*!*********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/encoding.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */ const hasTerminator = (nibbles)=>{\n    return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes)=>{\n    for(let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2){\n        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];\n    }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = (nibbles)=>{\n    let terminator = 0;\n    if ((0, exports.hasTerminator)(nibbles)) {\n        terminator = 1;\n        // Remove the terminator from the sequence\n        nibbles = nibbles.subarray(0, nibbles.length - 1);\n    }\n    const buf = new Uint8Array(nibbles.length / 2 + 1);\n    // Shift the terminator info into the first nibble of buf[0]\n    buf[0] = terminator << 5;\n    // If odd length, then add that flag into the first nibble and put the odd nibble to\n    // second part of buf[0] which otherwise will be left padded with a 0\n    if ((nibbles.length & 1) === 1) {\n        buf[0] |= 1 << 4;\n        buf[0] |= nibbles[0];\n        nibbles = nibbles.subarray(1);\n    }\n    // create bytes out of the rest even nibbles\n    (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n    return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = (str)=>{\n    const l = str.length * 2 + 1;\n    const nibbles = new Uint8Array(l);\n    for(let i = 0; i < str.length; i++){\n        const b = str[i];\n        nibbles[i * 2] = b / 16;\n        nibbles[i * 2 + 1] = b % 16;\n    }\n    // This will get removed from calling function if the first nibble\n    // indicates that terminator is not present\n    nibbles[l - 1] = 16;\n    return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = (compact)=>{\n    if (compact.length === 0) {\n        return compact;\n    }\n    let base = (0, exports.bytesToNibbles)(compact);\n    // delete terminator flag if terminator flag was not in first nibble\n    if (base[0] < 2) {\n        base = base.subarray(0, base.length - 1);\n    }\n    // chop the terminator nibble and the even padding (if there is one)\n    // i.e.  chop 2 left nibbles when even else 1 when odd\n    const chop = 2 - (base[0] & 1);\n    return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles; /**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */  //\n //\n // export const getPathTo = (tillBytes: number, key: Buffer) => {\n //   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n //   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n //   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n //   hexNibbles[hexNibbles.length - 1] = 0\n //   const compactBytes = nibblesToCompactBytes(hexNibbles)\n //   return [Buffer.from(compactBytes)]\n // }\n //# sourceMappingURL=encoding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUdBLHNCQUFzQixHQUFHQSw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDL0ksd0dBQXdHO0FBQ3hHOzs7OztDQUtDLEdBQ0QsTUFBTU0sZ0JBQWdCLENBQUNDO0lBQ25CLE9BQU9BLFFBQVFDLE1BQU0sR0FBRyxLQUFLRCxPQUFPLENBQUNBLFFBQVFDLE1BQU0sR0FBRyxFQUFFLEtBQUs7QUFDakU7QUFDQVIscUJBQXFCLEdBQUdNO0FBQ3hCLE1BQU1ELGlCQUFpQixDQUFDRSxTQUFTRTtJQUM3QixJQUFLLElBQUlDLEtBQUssR0FBR0MsS0FBSyxHQUFHQSxLQUFLSixRQUFRQyxNQUFNLEVBQUVFLE1BQU0sR0FBR0MsTUFBTSxFQUFHO1FBQzVERixLQUFLLENBQUNDLEdBQUcsR0FBRyxPQUFRLENBQUNDLEdBQUcsSUFBSSxJQUFLSixPQUFPLENBQUNJLEtBQUssRUFBRTtJQUNwRDtBQUNKO0FBQ0FYLHNCQUFzQixHQUFHSztBQUN6QixNQUFNRCx3QkFBd0IsQ0FBQ0c7SUFDM0IsSUFBSUssYUFBYTtJQUNqQixJQUFJLENBQUMsR0FBR1osUUFBUU0sYUFBYSxFQUFFQyxVQUFVO1FBQ3JDSyxhQUFhO1FBQ2IsMENBQTBDO1FBQzFDTCxVQUFVQSxRQUFRTSxRQUFRLENBQUMsR0FBR04sUUFBUUMsTUFBTSxHQUFHO0lBQ25EO0lBQ0EsTUFBTU0sTUFBTSxJQUFJQyxXQUFXUixRQUFRQyxNQUFNLEdBQUcsSUFBSTtJQUNoRCw0REFBNEQ7SUFDNURNLEdBQUcsQ0FBQyxFQUFFLEdBQUdGLGNBQWM7SUFDdkIsb0ZBQW9GO0lBQ3BGLHFFQUFxRTtJQUNyRSxJQUFJLENBQUNMLFFBQVFDLE1BQU0sR0FBRyxPQUFPLEdBQUc7UUFDNUJNLEdBQUcsQ0FBQyxFQUFFLElBQUksS0FBSztRQUNmQSxHQUFHLENBQUMsRUFBRSxJQUFJUCxPQUFPLENBQUMsRUFBRTtRQUNwQkEsVUFBVUEsUUFBUU0sUUFBUSxDQUFDO0lBQy9CO0lBQ0EsNENBQTRDO0lBQzNDLElBQUdiLFFBQVFLLGNBQWMsRUFBRUUsU0FBU08sSUFBSUQsUUFBUSxDQUFDO0lBQ2xELE9BQU9DO0FBQ1g7QUFDQWQsNkJBQTZCLEdBQUdJO0FBQ2hDLE1BQU1ELGlCQUFpQixDQUFDYTtJQUNwQixNQUFNQyxJQUFJRCxJQUFJUixNQUFNLEdBQUcsSUFBSTtJQUMzQixNQUFNRCxVQUFVLElBQUlRLFdBQVdFO0lBQy9CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixJQUFJUixNQUFNLEVBQUVVLElBQUs7UUFDakMsTUFBTUMsSUFBSUgsR0FBRyxDQUFDRSxFQUFFO1FBQ2hCWCxPQUFPLENBQUNXLElBQUksRUFBRSxHQUFHQyxJQUFJO1FBQ3JCWixPQUFPLENBQUNXLElBQUksSUFBSSxFQUFFLEdBQUdDLElBQUk7SUFDN0I7SUFDQSxrRUFBa0U7SUFDbEUsMkNBQTJDO0lBQzNDWixPQUFPLENBQUNVLElBQUksRUFBRSxHQUFHO0lBQ2pCLE9BQU9WO0FBQ1g7QUFDQVAsc0JBQXNCLEdBQUdHO0FBQ3pCLE1BQU1ELHdCQUF3QixDQUFDa0I7SUFDM0IsSUFBSUEsUUFBUVosTUFBTSxLQUFLLEdBQUc7UUFDdEIsT0FBT1k7SUFDWDtJQUNBLElBQUlDLE9BQU8sQ0FBQyxHQUFHckIsUUFBUUcsY0FBYyxFQUFFaUI7SUFDdkMsb0VBQW9FO0lBQ3BFLElBQUlDLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRztRQUNiQSxPQUFPQSxLQUFLUixRQUFRLENBQUMsR0FBR1EsS0FBS2IsTUFBTSxHQUFHO0lBQzFDO0lBQ0Esb0VBQW9FO0lBQ3BFLHNEQUFzRDtJQUN0RCxNQUFNYyxPQUFPLElBQUtELENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUc7SUFDNUIsT0FBT0EsS0FBS1IsUUFBUSxDQUFDUztBQUN6QjtBQUNBdEIsNkJBQTZCLEdBQUdFLHVCQUNoQzs7Ozs7O0NBTUMsSUFDRCxFQUFFO0NBQ0YsRUFBRTtDQUNGLGlFQUFpRTtDQUNqRSxrRUFBa0U7Q0FDbEUsc0dBQXNHO0NBQ3RHLCtGQUErRjtDQUMvRiwwQ0FBMEM7Q0FDMUMsMkRBQTJEO0NBQzNELHVDQUF1QztDQUN2QyxJQUFJO0NBQ0osb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvZW5jb2RpbmcuanM/OTJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGFjdEJ5dGVzVG9OaWJibGVzID0gZXhwb3J0cy5ieXRlc1RvTmliYmxlcyA9IGV4cG9ydHMubmliYmxlc1RvQ29tcGFjdEJ5dGVzID0gZXhwb3J0cy5uaWJibGVzVG9CeXRlcyA9IGV4cG9ydHMuaGFzVGVybWluYXRvciA9IHZvaWQgMDtcbi8vIFJlZmVyZW5jZTogaHR0cHM6Ly9ldGhlcmV1bS5vcmcvZW4vZGV2ZWxvcGVycy9kb2NzL2RhdGEtc3RydWN0dXJlcy1hbmQtZW5jb2RpbmcvcGF0cmljaWEtbWVya2xlLXRyaWUvXG4vKipcbiAqXG4gKiBAcGFyYW0gcyBieXRlIHNlcXVlbmNlXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgaW5wdXQgaGV4IG5pYmJsZSBzZXF1ZW5jZSBoYXMgdGVybWluYXRvciBpbmRpY2F0aW5nIGxlYWYtbm9kZVxuICogICAgICAgICAgdGVybWluYXRvciBpcyByZXByZXNlbnRlZCB3aXRoIDE2IGJlY2F1c2UgYSBuaWJibGUgcmFuZ2VzIGZyb20gMCAtIDE1KGYpXG4gKi9cbmNvbnN0IGhhc1Rlcm1pbmF0b3IgPSAobmliYmxlcykgPT4ge1xuICAgIHJldHVybiBuaWJibGVzLmxlbmd0aCA+IDAgJiYgbmliYmxlc1tuaWJibGVzLmxlbmd0aCAtIDFdID09PSAxNjtcbn07XG5leHBvcnRzLmhhc1Rlcm1pbmF0b3IgPSBoYXNUZXJtaW5hdG9yO1xuY29uc3QgbmliYmxlc1RvQnl0ZXMgPSAobmliYmxlcywgYnl0ZXMpID0+IHtcbiAgICBmb3IgKGxldCBiaSA9IDAsIG5pID0gMDsgbmkgPCBuaWJibGVzLmxlbmd0aDsgYmkgKz0gMSwgbmkgKz0gMikge1xuICAgICAgICBieXRlc1tiaV0gPSAobmliYmxlc1tuaV0gPDwgNCkgfCBuaWJibGVzW25pICsgMV07XG4gICAgfVxufTtcbmV4cG9ydHMubmliYmxlc1RvQnl0ZXMgPSBuaWJibGVzVG9CeXRlcztcbmNvbnN0IG5pYmJsZXNUb0NvbXBhY3RCeXRlcyA9IChuaWJibGVzKSA9PiB7XG4gICAgbGV0IHRlcm1pbmF0b3IgPSAwO1xuICAgIGlmICgoMCwgZXhwb3J0cy5oYXNUZXJtaW5hdG9yKShuaWJibGVzKSkge1xuICAgICAgICB0ZXJtaW5hdG9yID0gMTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZXJtaW5hdG9yIGZyb20gdGhlIHNlcXVlbmNlXG4gICAgICAgIG5pYmJsZXMgPSBuaWJibGVzLnN1YmFycmF5KDAsIG5pYmJsZXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KG5pYmJsZXMubGVuZ3RoIC8gMiArIDEpO1xuICAgIC8vIFNoaWZ0IHRoZSB0ZXJtaW5hdG9yIGluZm8gaW50byB0aGUgZmlyc3QgbmliYmxlIG9mIGJ1ZlswXVxuICAgIGJ1ZlswXSA9IHRlcm1pbmF0b3IgPDwgNTtcbiAgICAvLyBJZiBvZGQgbGVuZ3RoLCB0aGVuIGFkZCB0aGF0IGZsYWcgaW50byB0aGUgZmlyc3QgbmliYmxlIGFuZCBwdXQgdGhlIG9kZCBuaWJibGUgdG9cbiAgICAvLyBzZWNvbmQgcGFydCBvZiBidWZbMF0gd2hpY2ggb3RoZXJ3aXNlIHdpbGwgYmUgbGVmdCBwYWRkZWQgd2l0aCBhIDBcbiAgICBpZiAoKG5pYmJsZXMubGVuZ3RoICYgMSkgPT09IDEpIHtcbiAgICAgICAgYnVmWzBdIHw9IDEgPDwgNDtcbiAgICAgICAgYnVmWzBdIHw9IG5pYmJsZXNbMF07XG4gICAgICAgIG5pYmJsZXMgPSBuaWJibGVzLnN1YmFycmF5KDEpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYnl0ZXMgb3V0IG9mIHRoZSByZXN0IGV2ZW4gbmliYmxlc1xuICAgICgwLCBleHBvcnRzLm5pYmJsZXNUb0J5dGVzKShuaWJibGVzLCBidWYuc3ViYXJyYXkoMSkpO1xuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy5uaWJibGVzVG9Db21wYWN0Qnl0ZXMgPSBuaWJibGVzVG9Db21wYWN0Qnl0ZXM7XG5jb25zdCBieXRlc1RvTmliYmxlcyA9IChzdHIpID0+IHtcbiAgICBjb25zdCBsID0gc3RyLmxlbmd0aCAqIDIgKyAxO1xuICAgIGNvbnN0IG5pYmJsZXMgPSBuZXcgVWludDhBcnJheShsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiID0gc3RyW2ldO1xuICAgICAgICBuaWJibGVzW2kgKiAyXSA9IGIgLyAxNjtcbiAgICAgICAgbmliYmxlc1tpICogMiArIDFdID0gYiAlIDE2O1xuICAgIH1cbiAgICAvLyBUaGlzIHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSBjYWxsaW5nIGZ1bmN0aW9uIGlmIHRoZSBmaXJzdCBuaWJibGVcbiAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0ZXJtaW5hdG9yIGlzIG5vdCBwcmVzZW50XG4gICAgbmliYmxlc1tsIC0gMV0gPSAxNjtcbiAgICByZXR1cm4gbmliYmxlcztcbn07XG5leHBvcnRzLmJ5dGVzVG9OaWJibGVzID0gYnl0ZXNUb05pYmJsZXM7XG5jb25zdCBjb21wYWN0Qnl0ZXNUb05pYmJsZXMgPSAoY29tcGFjdCkgPT4ge1xuICAgIGlmIChjb21wYWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcGFjdDtcbiAgICB9XG4gICAgbGV0IGJhc2UgPSAoMCwgZXhwb3J0cy5ieXRlc1RvTmliYmxlcykoY29tcGFjdCk7XG4gICAgLy8gZGVsZXRlIHRlcm1pbmF0b3IgZmxhZyBpZiB0ZXJtaW5hdG9yIGZsYWcgd2FzIG5vdCBpbiBmaXJzdCBuaWJibGVcbiAgICBpZiAoYmFzZVswXSA8IDIpIHtcbiAgICAgICAgYmFzZSA9IGJhc2Uuc3ViYXJyYXkoMCwgYmFzZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLy8gY2hvcCB0aGUgdGVybWluYXRvciBuaWJibGUgYW5kIHRoZSBldmVuIHBhZGRpbmcgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICAvLyBpLmUuICBjaG9wIDIgbGVmdCBuaWJibGVzIHdoZW4gZXZlbiBlbHNlIDEgd2hlbiBvZGRcbiAgICBjb25zdCBjaG9wID0gMiAtIChiYXNlWzBdICYgMSk7XG4gICAgcmV0dXJuIGJhc2Uuc3ViYXJyYXkoY2hvcCk7XG59O1xuZXhwb3J0cy5jb21wYWN0Qnl0ZXNUb05pYmJsZXMgPSBjb21wYWN0Qnl0ZXNUb05pYmJsZXM7XG4vKipcbiAqIEEgdGVzdCBoZWxwZXIgdG8gZ2VuZXJhdGVzIGNvbXBhY3QgcGF0aCBmb3IgYSBzdWJzZXQgb2Yga2V5IGJ5dGVzXG4gKlxuICogVE9ETzogQ29tbWVudGluZyB0aGUgY29kZSBmb3Igbm93IGFzIHRoaXMgc2VlbXMgdG8gYmUgaGVscGVyIGZ1bmN0aW9uXG4gKiAoZnJvbSBnZXRoIGNvZGViYXNlIClcbiAqXG4gKi9cbi8vXG4vL1xuLy8gZXhwb3J0IGNvbnN0IGdldFBhdGhUbyA9ICh0aWxsQnl0ZXM6IG51bWJlciwga2V5OiBCdWZmZXIpID0+IHtcbi8vICAgY29uc3QgaGV4TmliYmxlcyA9IGJ5dGVzVG9OaWJibGVzKGtleSkuc3ViYXJyYXkoMCwgdGlsbEJ5dGVzKVxuLy8gICAvLyBSZW1vdmUgdGhlIHRlcm1pbmF0b3IgaWYgaXRzIHRoZXJlLCBhbHRob3VnaCBpdCB3b3VsZCBiZSB0aGVyZSBvbmx5IGlmIHRpbGxCeXRlcyA+PSBrZXkubGVuZ3RoXG4vLyAgIC8vIFRoaXMgc2VlbXMgdG8gYmUgYSB0ZXN0IGhlbHBlciB0byBnZW5lcmF0ZSBwYXRocyBzbyBjb3JyZWN0bmVzcyBvZiB0aGlzIGlzbid0IG5lY2Vzc2FyeVxuLy8gICBoZXhOaWJibGVzW2hleE5pYmJsZXMubGVuZ3RoIC0gMV0gPSAwXG4vLyAgIGNvbnN0IGNvbXBhY3RCeXRlcyA9IG5pYmJsZXNUb0NvbXBhY3RCeXRlcyhoZXhOaWJibGVzKVxuLy8gICByZXR1cm4gW0J1ZmZlci5mcm9tKGNvbXBhY3RCeXRlcyldXG4vLyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGluZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjb21wYWN0Qnl0ZXNUb05pYmJsZXMiLCJieXRlc1RvTmliYmxlcyIsIm5pYmJsZXNUb0NvbXBhY3RCeXRlcyIsIm5pYmJsZXNUb0J5dGVzIiwiaGFzVGVybWluYXRvciIsIm5pYmJsZXMiLCJsZW5ndGgiLCJieXRlcyIsImJpIiwibmkiLCJ0ZXJtaW5hdG9yIiwic3ViYXJyYXkiLCJidWYiLCJVaW50OEFycmF5Iiwic3RyIiwibCIsImkiLCJiIiwiY29tcGFjdCIsImJhc2UiLCJjaG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/encoding.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/helpers.js":
/*!********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/helpers.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/../node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */ const assertIsHexString = function(input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */ const assertIsBuffer = function(input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */ const assertIsArray = function(input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */ const assertIsString = function(input) {\n    if (typeof input !== \"string\") {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBRyxLQUFLO0FBQzNHLE1BQU1NLGFBQWFDLG1CQUFPQSxDQUFDLDJFQUFZO0FBQ3ZDOzs7Q0FHQyxHQUNELE1BQU1GLG9CQUFvQixTQUFVRyxLQUFLO0lBQ3JDLElBQUksQ0FBQyxDQUFDLEdBQUdGLFdBQVdHLFdBQVcsRUFBRUQsUUFBUTtRQUNyQyxNQUFNRSxNQUFNLENBQUMsaUVBQWlFLEVBQUVGLE1BQU0sQ0FBQztRQUN2RixNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYseUJBQXlCLEdBQUdLO0FBQzVCOzs7Q0FHQyxHQUNELE1BQU1ELGlCQUFpQixTQUFVSSxLQUFLO0lBQ2xDLElBQUksQ0FBQ0ksT0FBT0MsUUFBUSxDQUFDTCxRQUFRO1FBQ3pCLE1BQU1FLE1BQU0sQ0FBQyxnREFBZ0QsRUFBRUYsTUFBTSxDQUFDO1FBQ3RFLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVixzQkFBc0IsR0FBR0k7QUFDekI7OztDQUdDLEdBQ0QsTUFBTUQsZ0JBQWdCLFNBQVVLLEtBQUs7SUFDakMsSUFBSSxDQUFDTSxNQUFNQyxPQUFPLENBQUNQLFFBQVE7UUFDdkIsTUFBTUUsTUFBTSxDQUFDLHVEQUF1RCxFQUFFRixNQUFNLENBQUM7UUFDN0UsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHFCQUFxQixHQUFHRztBQUN4Qjs7O0NBR0MsR0FDRCxNQUFNRCxpQkFBaUIsU0FBVU0sS0FBSztJQUNsQyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUMzQixNQUFNRSxNQUFNLENBQUMsaURBQWlELEVBQUVGLE1BQU0sQ0FBQztRQUN2RSxNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYsc0JBQXNCLEdBQUdFLGdCQUN6QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9oZWxwZXJzLmpzPzQ2YjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0FycmF5ID0gZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG4vKipcbiAqIFRocm93cyBpZiBhIHN0cmluZyBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGNoZWNrIGhleCBwcmVmaXggb2ZcbiAqL1xuY29uc3QgYXNzZXJ0SXNIZXhTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNCdWZmZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgQnVmZmVyIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSBhc3NlcnRJc0J1ZmZlcjtcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhbiBhcnJheVxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNBcnJheSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgbnVtYmVyIGFycmF5cyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzQXJyYXkgPSBhc3NlcnRJc0FycmF5O1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdmFsdWUgdG8gY2hlY2tcbiAqL1xuY29uc3QgYXNzZXJ0SXNTdHJpbmcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBhc3NlcnRJc1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXNzZXJ0SXNTdHJpbmciLCJhc3NlcnRJc0FycmF5IiwiYXNzZXJ0SXNCdWZmZXIiLCJhc3NlcnRJc0hleFN0cmluZyIsImludGVybmFsXzEiLCJyZXF1aXJlIiwiaW5wdXQiLCJpc0hleFN0cmluZyIsIm1zZyIsIkVycm9yIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/index.js":
/*!******************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/@ethereumjs/util/dist/constants.js\"), exports);\n/**\n * Units helpers\n */ __exportStar(__webpack_require__(/*! ./units */ \"(ssr)/../node_modules/@ethereumjs/util/dist/units.js\"), exports);\n/**\n * Account class and helper functions\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/../node_modules/@ethereumjs/util/dist/account.js\"), exports);\n/**\n * Address type\n */ __exportStar(__webpack_require__(/*! ./address */ \"(ssr)/../node_modules/@ethereumjs/util/dist/address.js\"), exports);\n/**\n * Withdrawal type\n */ __exportStar(__webpack_require__(/*! ./withdrawal */ \"(ssr)/../node_modules/@ethereumjs/util/dist/withdrawal.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/../node_modules/@ethereumjs/util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\"), exports);\n/**\n * Helpful TypeScript types\n */ __exportStar(__webpack_require__(/*! ./types */ \"(ssr)/../node_modules/@ethereumjs/util/dist/types.js\"), exports);\n/**\n * Helper function for working with compact encoding\n */ __exportStar(__webpack_require__(/*! ./encoding */ \"(ssr)/../node_modules/@ethereumjs/util/dist/encoding.js\"), exports);\n/**\n * Export ethjs-util methods\n */ __exportStar(__webpack_require__(/*! ./asyncEventEmitter */ \"(ssr)/../node_modules/@ethereumjs/util/dist/asyncEventEmitter.js\"), exports);\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/../node_modules/@ethereumjs/util/dist/internal.js\");\nObject.defineProperty(exports, \"arrayContainsArray\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.arrayContainsArray;\n    }\n}));\nObject.defineProperty(exports, \"fromAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromAscii;\n    }\n}));\nObject.defineProperty(exports, \"fromUtf8\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromUtf8;\n    }\n}));\nObject.defineProperty(exports, \"getBinarySize\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getBinarySize;\n    }\n}));\nObject.defineProperty(exports, \"getKeys\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getKeys;\n    }\n}));\nObject.defineProperty(exports, \"isHexPrefixed\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexPrefixed;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"padToEven\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.padToEven;\n    }\n}));\nObject.defineProperty(exports, \"stripHexPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.stripHexPrefix;\n    }\n}));\nObject.defineProperty(exports, \"toAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.toAscii;\n    }\n}));\n__exportStar(__webpack_require__(/*! ./lock */ \"(ssr)/../node_modules/@ethereumjs/util/dist/lock.js\"), exports);\n__exportStar(__webpack_require__(/*! ./provider */ \"(ssr)/../node_modules/@ethereumjs/util/dist/provider.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLElBQUssSUFBSSxJQUFJLENBQUNBLFlBQVksSUFBSyxTQUFTWixDQUFDLEVBQUVhLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLZCxFQUFHLElBQUljLE1BQU0sYUFBYSxDQUFDakIsT0FBT2tCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUlsQixnQkFBZ0JpQixVQUFTYixHQUFHYztBQUMzSDtBQUNBakIsOENBQTZDO0lBQUVxQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETCxlQUFlLEdBQUdBLHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSxlQUFlLEdBQUdBLHFCQUFxQixHQUFHQSxnQkFBZ0IsR0FBR0EsaUJBQWlCLEdBQUdBLDBCQUEwQixHQUFHLEtBQUs7QUFDaE87O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLDZFQUFhLEdBQUdoQjtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMscUVBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyx5RUFBVyxHQUFHaEI7QUFDbkM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLHlFQUFXLEdBQUdoQjtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsK0VBQWMsR0FBR2hCO0FBQ3RDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyw2RUFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLHFFQUFTLEdBQUdoQjtBQUNqQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMscUVBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywyRUFBWSxHQUFHaEI7QUFDcEM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLDZGQUFxQixHQUFHaEI7QUFDN0MsSUFBSWlCLGFBQWFELG1CQUFPQSxDQUFDLDJFQUFZO0FBQ3JDaEMsc0RBQXFEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXRixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0SS9CLDZDQUE0QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0gsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIOUIsNENBQTJDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXSixRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEg3QixpREFBZ0Q7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdMLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1SDVCLDJDQUEwQztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV04sT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hIM0IsaURBQWdEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXUCxhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDNUgxQiwrQ0FBOEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdSLFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SHpCLDZDQUE0QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1QsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIeEIsa0RBQWlEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXVixjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUh2QiwyQ0FBMEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdYLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNoSFAsYUFBYWlCLG1CQUFPQSxDQUFDLG1FQUFRLEdBQUdoQjtBQUNoQ0QsYUFBYWlCLG1CQUFPQSxDQUFDLDJFQUFZLEdBQUdoQixVQUNwQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbmRleC5qcz8zMTg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvQXNjaWkgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5wYWRUb0V2ZW4gPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFByZWZpeGVkID0gZXhwb3J0cy5nZXRLZXlzID0gZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSB2b2lkIDA7XG4vKipcbiAqIENvbnN0YW50c1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVW5pdHMgaGVscGVyc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdW5pdHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBBY2NvdW50IGNsYXNzIGFuZCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY2NvdW50XCIpLCBleHBvcnRzKTtcbi8qKlxuICogQWRkcmVzcyB0eXBlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogV2l0aGRyYXdhbCB0eXBlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93aXRoZHJhd2FsXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRUNEU0Egc2lnbmF0dXJlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduYXR1cmVcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBCdWZmZXJzLCBieXRlIGFycmF5cywgZXRjLlxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIZWxwZnVsIFR5cGVTY3JpcHQgdHlwZXNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggY29tcGFjdCBlbmNvZGluZ1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jb2RpbmdcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFeHBvcnQgZXRoanMtdXRpbCBtZXRob2RzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3luY0V2ZW50RW1pdHRlclwiKSwgZXhwb3J0cyk7XG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXJyYXlDb250YWluc0FycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmFycmF5Q29udGFpbnNBcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21Bc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5mcm9tQXNjaWk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tVXRmOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5mcm9tVXRmODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJpbmFyeVNpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZ2V0QmluYXJ5U2l6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEtleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZ2V0S2V5czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGV4UHJlZml4ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhQcmVmaXhlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGV4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFkVG9FdmVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnBhZFRvRXZlbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwSGV4UHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Bc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS50b0FzY2lpOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvY2tcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwidG9Bc2NpaSIsInN0cmlwSGV4UHJlZml4IiwicGFkVG9FdmVuIiwiaXNIZXhTdHJpbmciLCJpc0hleFByZWZpeGVkIiwiZ2V0S2V5cyIsImdldEJpbmFyeVNpemUiLCJmcm9tVXRmOCIsImZyb21Bc2NpaSIsImFycmF5Q29udGFpbnNBcnJheSIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/internal.js":
/*!*********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/internal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */ function isHexPrefixed(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === \"0\" && str[1] === \"x\";\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */ const stripHexPrefix = (str)=>{\n    if (typeof str !== \"string\") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */ function padToEven(value) {\n    let a = value;\n    if (typeof a !== \"string\") {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2) a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */ function getBinarySize(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n    }\n    return Buffer.byteLength(str, \"utf8\");\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */ function arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some === true ? \"some\" : \"every\"]((value)=>superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */ function toAscii(hex) {\n    let str = \"\";\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") i = 2;\n    for(; i < l; i += 2){\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */ function fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, \"utf8\");\n    return `0x${padToEven(str.toString(\"hex\")).replace(/^0+|0+$/g, \"\")}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */ function fromAscii(stringValue) {\n    let hex = \"\";\n    for(let i = 0; i < stringValue.length; i++){\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */ function getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for(let i = 0; i < params.length; i++){\n        let value = params[i][key];\n        if (allowEmpty === true && !value) {\n            value = \"\";\n        } else if (typeof value !== \"string\") {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n    if (typeof length !== \"undefined\" && length > 0 && value.length !== 2 + 2 * length) return false;\n    return true;\n}\nexports.isHexString = isHexString; //# sourceMappingURL=internal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGVBQWUsR0FBR0EsMEJBQTBCLEdBQUdBLHFCQUFxQixHQUFHQSxpQkFBaUIsR0FBR0Esc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDaE87Ozs7O0NBS0MsR0FDRCxTQUFTVyxjQUFjQyxHQUFHO0lBQ3RCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQ3pCLE1BQU0sSUFBSUMsTUFBTSxDQUFDLDJEQUEyRCxFQUFFLE9BQU9ELElBQUksQ0FBQztJQUM5RjtJQUNBLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSztBQUN4QztBQUNBWixxQkFBcUIsR0FBR1c7QUFDeEI7Ozs7Q0FJQyxHQUNELE1BQU1ELGlCQUFpQixDQUFDRTtJQUNwQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlDLE1BQU0sQ0FBQyx1REFBdUQsRUFBRSxPQUFPRCxJQUFJLENBQUM7SUFDMUYsT0FBT0QsY0FBY0MsT0FBT0EsSUFBSUUsS0FBSyxDQUFDLEtBQUtGO0FBQy9DO0FBQ0FaLHNCQUFzQixHQUFHVTtBQUN6Qjs7OztDQUlDLEdBQ0QsU0FBU0QsVUFBVVIsS0FBSztJQUNwQixJQUFJYyxJQUFJZDtJQUNSLElBQUksT0FBT2MsTUFBTSxVQUFVO1FBQ3ZCLE1BQU0sSUFBSUYsTUFBTSxDQUFDLGtEQUFrRCxFQUFFLE9BQU9FLEVBQUUsQ0FBQztJQUNuRjtJQUNBLElBQUlBLEVBQUVDLE1BQU0sR0FBRyxHQUNYRCxJQUFJLENBQUMsQ0FBQyxFQUFFQSxFQUFFLENBQUM7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QUlDLGVBQWUsUUFBUSxDQUFDekMsT0FBTztZQUMvQkEsUUFBUTtRQUNaLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDaEMsTUFBTSxJQUFJWSxNQUFNLENBQUMsK0NBQStDLEVBQUUsT0FBT1osTUFBTSxDQUFDO1FBQ3BGO1FBQ0EwQyxPQUFPQyxJQUFJLENBQUMzQztJQUNoQjtJQUNBLE9BQU8wQztBQUNYO0FBQ0EzQyxlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFlBQVlELEtBQUssRUFBRWUsTUFBTTtJQUM5QixJQUFJLE9BQU9mLFVBQVUsWUFBWSxDQUFDQSxNQUFNNEMsS0FBSyxDQUFDLHFCQUMxQyxPQUFPO0lBQ1gsSUFBSSxPQUFPN0IsV0FBVyxlQUFlQSxTQUFTLEtBQUtmLE1BQU1lLE1BQU0sS0FBSyxJQUFJLElBQUlBLFFBQ3hFLE9BQU87SUFDWCxPQUFPO0FBQ1g7QUFDQWhCLG1CQUFtQixHQUFHRSxhQUN0QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9pbnRlcm5hbC5qcz9hZTkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcblRoZSBNSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTYgTmljayBEb2Rzb24uIG5pY2tkb2Rzb24uY29tXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRLZXlzID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy50b0FzY2lpID0gZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSB2b2lkIDA7XG4vKipcbiAqIFJldHVybnMgYSBgQm9vbGVhbmAgb24gd2hldGhlciBvciBub3QgdGhlIGEgYFN0cmluZ2Agc3RhcnRzIHdpdGggJzB4J1xuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJuIGEgYm9vbGVhbiBpZiBpdCBpcyBvciBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAdGhyb3dzIGlmIHRoZSBzdHIgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2lzSGV4UHJlZml4ZWRdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJbMF0gPT09ICcwJyAmJiBzdHJbMV0gPT09ICd4Jztcbn1cbmV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IGlzSGV4UHJlZml4ZWQ7XG4vKipcbiAqIFJlbW92ZXMgJzB4JyBmcm9tIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgcHJlc2VudFxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHZhbHVlXG4gKiBAcmV0dXJucyB0aGUgc3RyaW5nIHdpdGhvdXQgMHggcHJlZml4XG4gKi9cbmNvbnN0IHN0cmlwSGV4UHJlZml4ID0gKHN0cikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbc3RyaXBIZXhQcmVmaXhdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59O1xuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgICBsZXQgYSA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbcGFkVG9FdmVuXSB2YWx1ZSBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIGF9YCk7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAlIDIpXG4gICAgICAgIGEgPSBgMCR7YX1gO1xuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5wYWRUb0V2ZW4gPSBwYWRUb0V2ZW47XG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEJpbmFyeVNpemVdIG1ldGhvZCByZXF1aXJlcyBpbnB1dCB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5leHBvcnRzLmdldEJpbmFyeVNpemUgPSBnZXRCaW5hcnlTaXplO1xuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0gc3VwZXJzZXRcbiAqIEBwYXJhbSBzdWJzZXRcbiAqXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdXBlcnNldCcgdG8gYmUgYW4gYXJyYXksIGdvdCB0eXBlICcke3R5cGVvZiBzdXBlcnNldH0nYCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYXJyYXlDb250YWluc0FycmF5XSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgJ3N1YnNldCcgdG8gYmUgYW4gYXJyYXksIGdvdCB0eXBlICcke3R5cGVvZiBzdWJzZXR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2V0W3NvbWUgPT09IHRydWUgPyAnc29tZScgOiAnZXZlcnknXSgodmFsdWUpID0+IHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDApO1xufVxuZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBhcnJheUNvbnRhaW5zQXJyYXk7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXRzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4JylcbiAgICAgICAgaSA9IDI7XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnRvQXNjaWkgPSB0b0FzY2lpO1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHJpbmdcbiAqIEBwYXJhbSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gICAgY29uc3Qgc3RyID0gQnVmZmVyLmZyb20oc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG4gICAgcmV0dXJuIGAweCR7cGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpfWA7XG59XG5leHBvcnRzLmZyb21VdGY4ID0gZnJvbVV0Zjg7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBwYXJhbSAgc3RyaW5nXG4gKiBAcGFyYW0gIG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zICBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjb25zdCBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyBgMCR7bn1gIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4fWA7XG59XG5leHBvcnRzLmZyb21Bc2NpaSA9IGZyb21Bc2NpaTtcbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGdldEtleXMoW3thOiAnMScsIGI6ICcyJ30sIHthOiAnMycsIGI6ICc0J31dLCAnYScpID0+IFsnMScsICczJ11cbiAqYGBgYFxuICogQHBhcmFtICBwYXJhbXNcbiAqIEBwYXJhbSAga2V5XG4gKiBAcGFyYW0gIGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRLZXlzXSBtZXRob2QgZXhwZWN0cyBpbnB1dCAncGFyYW1zJyB0byBiZSBhbiBhcnJheSwgZ290ICR7dHlwZW9mIHBhcmFtc31gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdrZXknIHRvIGJlIHR5cGUgJ3N0cmluZycsIGdvdCAke3R5cGVvZiBwYXJhbXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldO1xuICAgICAgICBpZiAoYWxsb3dFbXB0eSA9PT0gdHJ1ZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFiaSAtIGV4cGVjdGVkIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0S2V5cyA9IGdldEtleXM7XG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAgdmFsdWVcbiAqIEBwYXJhbSAgbGVuZ3RoXG4gKiBAcmV0dXJucyAgb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJiBsZW5ndGggPiAwICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzSGV4U3RyaW5nIiwiZ2V0S2V5cyIsImZyb21Bc2NpaSIsImZyb21VdGY4IiwidG9Bc2NpaSIsImFycmF5Q29udGFpbnNBcnJheSIsImdldEJpbmFyeVNpemUiLCJwYWRUb0V2ZW4iLCJzdHJpcEhleFByZWZpeCIsImlzSGV4UHJlZml4ZWQiLCJzdHIiLCJFcnJvciIsInNsaWNlIiwiYSIsImxlbmd0aCIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJzdXBlcnNldCIsInN1YnNldCIsInNvbWUiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIiwiaGV4IiwiaSIsImwiLCJzdWJzdHJpbmciLCJjb2RlIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHJpbmdWYWx1ZSIsImZyb20iLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJjaGFyQ29kZUF0IiwibiIsInBhcmFtcyIsImtleSIsImFsbG93RW1wdHkiLCJyZXN1bHQiLCJwdXNoIiwibWF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/internal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/lock.js":
/*!*****************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/lock.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor(){\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */ async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver)=>this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */ release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Lock.permits should never be > 0 when there is someone waiting.\");\n        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock; //# sourceMappingURL=lock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9sb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxZQUFZLEdBQUcsS0FBSztBQUNwQiw4RkFBOEY7QUFDOUYsTUFBTUU7SUFDRkMsYUFBYztRQUNWLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxFQUFFO0lBQ2xDO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTUMsVUFBVTtRQUNaLElBQUksSUFBSSxDQUFDRixPQUFPLEdBQUcsR0FBRztZQUNsQixJQUFJLENBQUNBLE9BQU8sSUFBSTtZQUNoQixPQUFPRyxRQUFRQyxPQUFPLENBQUM7UUFDM0I7UUFDQSw2RkFBNkY7UUFDN0Ysc0RBQXNEO1FBQ3RELE9BQU8sSUFBSUQsUUFBUSxDQUFDRSxXQUFhLElBQUksQ0FBQ0osb0JBQW9CLENBQUNLLElBQUksQ0FBQ0Q7SUFDcEU7SUFDQTs7O0tBR0MsR0FDREUsVUFBVTtRQUNOLElBQUksQ0FBQ1AsT0FBTyxJQUFJO1FBQ2hCLElBQUksSUFBSSxDQUFDQSxPQUFPLEdBQUcsS0FBSyxJQUFJLENBQUNDLG9CQUFvQixDQUFDTyxNQUFNLEdBQUcsR0FBRztZQUMxRCxzQ0FBc0M7WUFDdENDLFFBQVFDLElBQUksQ0FBQztRQUNqQixPQUNLLElBQUksSUFBSSxDQUFDVixPQUFPLEtBQUssS0FBSyxJQUFJLENBQUNDLG9CQUFvQixDQUFDTyxNQUFNLEdBQUcsR0FBRztZQUNqRSxxRkFBcUY7WUFDckYseUVBQXlFO1lBQ3pFLElBQUksQ0FBQ1IsT0FBTyxJQUFJO1lBQ2hCLE1BQU1XLGVBQWUsSUFBSSxDQUFDVixvQkFBb0IsQ0FBQ1csS0FBSztZQUNwRCxJQUFJRCxjQUFjO2dCQUNkQSxhQUFhO1lBQ2pCO1FBQ0o7SUFDSjtBQUNKO0FBQ0FmLFlBQVksR0FBR0UsTUFDZixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9sb2NrLmpzPzg1MDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvY2sgPSB2b2lkIDA7XG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vanNvZW5kZXJtYW5uL3NlbWFwaG9yZS1hc3luYy1hd2FpdC9ibG9iL21hc3Rlci9zcmMvU2VtYXBob3JlLnRzXG5jbGFzcyBMb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wZXJtaXRzID0gMTtcbiAgICAgICAgdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB1c2VkIHRvIHdhaXQgZm9yIGEgcGVybWl0IHRvIGJlY29tZSBhdmFpbGFibGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBhd2FpdGVkIG9uLlxuICAgICAqIEByZXR1cm5zICBBIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIHdoZW4gZXhlY3V0aW9uIGlzIGFsbG93ZWQgdG8gcHJvY2VlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhY3F1aXJlKCkge1xuICAgICAgICBpZiAodGhpcy5wZXJtaXRzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXRzIC09IDE7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHBlcm1pdCBhdmFpbGFibGUsIHdlIHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBzZW1hcGhvcmUgZ2V0c1xuICAgICAgICAvLyBzaWduYWxlZCBlbm91Z2ggdGltZXMgdGhhdCBwZXJtaXRzIGlzIGVxdWFsIHRvIG9uZS5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlcikgPT4gdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5wdXNoKHJlc29sdmVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluY3JlYXNlcyB0aGUgbnVtYmVyIG9mIHBlcm1pdHMgYnkgb25lLiBJZiB0aGVyZSBhcmUgb3RoZXIgZnVuY3Rpb25zIHdhaXRpbmcsIG9uZSBvZiB0aGVtIHdpbGxcbiAgICAgKiBjb250aW51ZSB0byBleGVjdXRlIGluIGEgZnV0dXJlIGl0ZXJhdGlvbiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAgICAgKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnBlcm1pdHMgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMucGVybWl0cyA+IDEgJiYgdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NrLnBlcm1pdHMgc2hvdWxkIG5ldmVyIGJlID4gMCB3aGVuIHRoZXJlIGlzIHNvbWVvbmUgd2FpdGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlcm1pdHMgPT09IDEgJiYgdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBzb21lb25lIGVsc2Ugd2FpdGluZywgaW1tZWRpYXRlbHkgY29uc3VtZSB0aGUgcGVybWl0IHRoYXQgd2FzIHJlbGVhc2VkXG4gICAgICAgICAgICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24gYW5kIGxldCB0aGUgd2FpdGluZyBmdW5jdGlvbiByZXN1bWUuXG4gICAgICAgICAgICB0aGlzLnBlcm1pdHMgLT0gMTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRSZXNvbHZlciA9IHRoaXMucHJvbWlzZVJlc29sdmVyUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0UmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb2x2ZXIodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxvY2sgPSBMb2NrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMb2NrIiwiY29uc3RydWN0b3IiLCJwZXJtaXRzIiwicHJvbWlzZVJlc29sdmVyUXVldWUiLCJhY3F1aXJlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXNvbHZlciIsInB1c2giLCJyZWxlYXNlIiwibGVuZ3RoIiwiY29uc29sZSIsIndhcm4iLCJuZXh0UmVzb2x2ZXIiLCJzaGlmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/lock.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/provider.js":
/*!*********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/provider.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getProvider = exports.fetchFromProvider = void 0;\nconst micro_ftch_1 = __webpack_require__(/*! micro-ftch */ \"(ssr)/../node_modules/micro-ftch/index.js\");\nconst fetchFromProvider = async (url, params)=>{\n    const res = await (0, micro_ftch_1.default)(url, {\n        headers: {\n            \"content-type\": \"application/json\"\n        },\n        type: \"json\",\n        data: {\n            method: params.method,\n            params: params.params,\n            jsonrpc: \"2.0\",\n            id: 1\n        }\n    });\n    return res.result;\n};\nexports.fetchFromProvider = fetchFromProvider;\nconst getProvider = (provider)=>{\n    if (typeof provider === \"string\") {\n        return provider;\n    } else if (provider?.connection?.url !== undefined) {\n        return provider.connection.url;\n    } else {\n        throw new Error(\"Must provide valid provider URL or Web3Provider\");\n    }\n};\nexports.getProvider = getProvider; //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDdkQsTUFBTUksZUFBZUMsbUJBQU9BLENBQUMsNkRBQVk7QUFDekMsTUFBTUYsb0JBQW9CLE9BQU9HLEtBQUtDO0lBQ2xDLE1BQU1DLE1BQU0sTUFBTSxDQUFDLEdBQUdKLGFBQWFLLE9BQU8sRUFBRUgsS0FBSztRQUM3Q0ksU0FBUztZQUNMLGdCQUFnQjtRQUNwQjtRQUNBQyxNQUFNO1FBQ05DLE1BQU07WUFDRkMsUUFBUU4sT0FBT00sTUFBTTtZQUNyQk4sUUFBUUEsT0FBT0EsTUFBTTtZQUNyQk8sU0FBUztZQUNUQyxJQUFJO1FBQ1I7SUFDSjtJQUNBLE9BQU9QLElBQUlRLE1BQU07QUFDckI7QUFDQWhCLHlCQUF5QixHQUFHRztBQUM1QixNQUFNRCxjQUFjLENBQUNlO0lBQ2pCLElBQUksT0FBT0EsYUFBYSxVQUFVO1FBQzlCLE9BQU9BO0lBQ1gsT0FDSyxJQUFJQSxVQUFVQyxZQUFZWixRQUFRYSxXQUFXO1FBQzlDLE9BQU9GLFNBQVNDLFVBQVUsQ0FBQ1osR0FBRztJQUNsQyxPQUNLO1FBQ0QsTUFBTSxJQUFJYyxNQUFNO0lBQ3BCO0FBQ0o7QUFDQXBCLG1CQUFtQixHQUFHRSxhQUN0QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9wcm92aWRlci5qcz8yZDdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQcm92aWRlciA9IGV4cG9ydHMuZmV0Y2hGcm9tUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBtaWNyb19mdGNoXzEgPSByZXF1aXJlKFwibWljcm8tZnRjaFwiKTtcbmNvbnN0IGZldGNoRnJvbVByb3ZpZGVyID0gYXN5bmMgKHVybCwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgKDAsIG1pY3JvX2Z0Y2hfMS5kZWZhdWx0KSh1cmwsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcy5wYXJhbXMsXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiByZXMucmVzdWx0O1xufTtcbmV4cG9ydHMuZmV0Y2hGcm9tUHJvdmlkZXIgPSBmZXRjaEZyb21Qcm92aWRlcjtcbmNvbnN0IGdldFByb3ZpZGVyID0gKHByb3ZpZGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm92aWRlcj8uY29ubmVjdGlvbj8udXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmNvbm5lY3Rpb24udXJsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgdmFsaWQgcHJvdmlkZXIgVVJMIG9yIFdlYjNQcm92aWRlcicpO1xuICAgIH1cbn07XG5leHBvcnRzLmdldFByb3ZpZGVyID0gZ2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRQcm92aWRlciIsImZldGNoRnJvbVByb3ZpZGVyIiwibWljcm9fZnRjaF8xIiwicmVxdWlyZSIsInVybCIsInBhcmFtcyIsInJlcyIsImRlZmF1bHQiLCJoZWFkZXJzIiwidHlwZSIsImRhdGEiLCJtZXRob2QiLCJqc29ucnBjIiwiaWQiLCJyZXN1bHQiLCJwcm92aWRlciIsImNvbm5lY3Rpb24iLCJ1bmRlZmluZWQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/provider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/signature.js":
/*!**********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/signature.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/../node_modules/ethereum-cryptography/keccak.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/../node_modules/ethereum-cryptography/secp256k1.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/@ethereumjs/util/dist/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/../node_modules/@ethereumjs/util/dist/helpers.js\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */ function ecsign(msgHash, privateKey, chainId) {\n    const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);\n    const buf = sig.toCompactRawBytes();\n    const r = Buffer.from(buf.slice(0, 32));\n    const s = Buffer.from(buf.slice(32, 64));\n    const v = chainId === undefined ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);\n    return {\n        r,\n        s,\n        v\n    };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    if (v === BigInt(0) || v === BigInt(1)) return v;\n    if (chainId === undefined) {\n        return v - BigInt(27);\n    }\n    return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */ const ecrecover = function(msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32)\n    ], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));\n    const senderPubKey = sig.recoverPublicKey(msgHash);\n    return Buffer.from(senderPubKey.toRawBytes(false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */ const toRpcSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32),\n        (0, bytes_1.toBuffer)(v)\n    ]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */ const toCompactSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    let ss = s;\n    if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(ss, 32)\n    ]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */ const fromRpcSig = function(sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n    } else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n        s[0] &= 0x7f;\n    } else {\n        throw new Error(\"Invalid signature length\");\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v = v + BigInt(27);\n    }\n    return {\n        v,\n        r,\n        s\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n    const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n    if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {\n        return false;\n    }\n    if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ const hashPersonalMessage = function(message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, \"utf-8\");\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([\n        prefix,\n        message\n    ])));\n};\nexports.hashPersonalMessage = hashPersonalMessage; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0Esa0JBQWtCLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ2xLLE1BQU1TLFdBQVdDLG1CQUFPQSxDQUFDLDJGQUE4QjtBQUN2RCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxpR0FBaUM7QUFDN0QsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMscUVBQVM7QUFDakMsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUMsNkVBQWE7QUFDekMsTUFBTUksWUFBWUosbUJBQU9BLENBQUMseUVBQVc7QUFDckM7Ozs7O0NBS0MsR0FDRCxTQUFTRixPQUFPTyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsT0FBTztJQUN4QyxNQUFNQyxNQUFNUCxZQUFZUSxTQUFTLENBQUNDLElBQUksQ0FBQ0wsU0FBU0M7SUFDaEQsTUFBTUssTUFBTUgsSUFBSUksaUJBQWlCO0lBQ2pDLE1BQU1DLElBQUlDLE9BQU9DLElBQUksQ0FBQ0osSUFBSUssS0FBSyxDQUFDLEdBQUc7SUFDbkMsTUFBTUMsSUFBSUgsT0FBT0MsSUFBSSxDQUFDSixJQUFJSyxLQUFLLENBQUMsSUFBSTtJQUNwQyxNQUFNRSxJQUFJWCxZQUFZWSxZQUNoQkMsT0FBT1osSUFBSWEsUUFBUSxHQUFHLE1BQ3RCRCxPQUFPWixJQUFJYSxRQUFRLEdBQUcsTUFBTUQsT0FBT2IsV0FBV2EsT0FBTztJQUMzRCxPQUFPO1FBQUVQO1FBQUdJO1FBQUdDO0lBQUU7QUFDckI7QUFDQTVCLGNBQWMsR0FBR1E7QUFDakIsU0FBU3dCLHFCQUFxQkosQ0FBQyxFQUFFWCxPQUFPO0lBQ3BDLElBQUlXLE1BQU1FLE9BQU8sTUFBTUYs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QUFZMEMscUJBQXFCLEVBQUU7UUFDbEUsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0F2RCx3QkFBd0IsR0FBR0c7QUFDM0I7Ozs7O0NBS0MsR0FDRCxNQUFNRCxzQkFBc0IsU0FBVXNELE9BQU87SUFDeEMsSUFBRzFDLFVBQVUyQyxjQUFjLEVBQUVEO0lBQzlCLE1BQU1FLFNBQVNsQyxPQUFPQyxJQUFJLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRStCLFFBQVFSLE1BQU0sQ0FBQyxDQUFDLEVBQUU7SUFDaEYsT0FBT3hCLE9BQU9DLElBQUksQ0FBQyxDQUFDLEdBQUdoQixTQUFTa0QsU0FBUyxFQUFFbkMsT0FBT1csTUFBTSxDQUFDO1FBQUN1QjtRQUFRRjtLQUFRO0FBQzlFO0FBQ0F4RCwyQkFBMkIsR0FBR0UscUJBQzlCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3NpZ25hdHVyZS5qcz85ODEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZXhwb3J0cy5mcm9tUnBjU2lnID0gZXhwb3J0cy50b0NvbXBhY3RTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcbmNvbnN0IGtlY2Nha18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWtcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBFQ0RTQSBzaWduYXR1cmUgb2YgYSBtZXNzYWdlIGhhc2guXG4gKlxuICogSWYgYGNoYWluSWRgIGlzIHByb3ZpZGVkIGFzc3VtZSBhbiBFSVAtMTU1LXN0eWxlIHNpZ25hdHVyZSBhbmQgY2FsY3VsYXRlIHRoZSBgdmAgdmFsdWVcbiAqIGFjY29yZGluZ2x5LCBvdGhlcndpc2UgcmV0dXJuIGEgXCJzdGF0aWNcIiBgdmAganVzdCBkZXJpdmVkIGZyb20gdGhlIGByZWNvdmVyeWAgYml0XG4gKi9cbmZ1bmN0aW9uIGVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5LCBjaGFpbklkKSB7XG4gICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgY29uc3QgYnVmID0gc2lnLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgY29uc3QgciA9IEJ1ZmZlci5mcm9tKGJ1Zi5zbGljZSgwLCAzMikpO1xuICAgIGNvbnN0IHMgPSBCdWZmZXIuZnJvbShidWYuc2xpY2UoMzIsIDY0KSk7XG4gICAgY29uc3QgdiA9IGNoYWluSWQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IEJpZ0ludChzaWcucmVjb3ZlcnkgKyAyNylcbiAgICAgICAgOiBCaWdJbnQoc2lnLnJlY292ZXJ5ICsgMzUpICsgQmlnSW50KGNoYWluSWQpICogQmlnSW50KDIpO1xuICAgIHJldHVybiB7IHIsIHMsIHYgfTtcbn1cbmV4cG9ydHMuZWNzaWduID0gZWNzaWduO1xuZnVuY3Rpb24gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkge1xuICAgIGlmICh2ID09PSBCaWdJbnQoMCkgfHwgdiA9PT0gQmlnSW50KDEpKVxuICAgICAgICByZXR1cm4gdjtcbiAgICBpZiAoY2hhaW5JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2IC0gQmlnSW50KDI3KTtcbiAgICB9XG4gICAgcmV0dXJuIHYgLSAoY2hhaW5JZCAqIEJpZ0ludCgyKSArIEJpZ0ludCgzNSkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgcmV0dXJuIHJlY292ZXJ5ID09PSBCaWdJbnQoMCkgfHwgcmVjb3ZlcnkgPT09IEJpZ0ludCgxKTtcbn1cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZS5cbiAqIE5PVEU6IEFjY2VwdHMgYHYgPT09IDAgfCB2ID09PSAxYCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnNcbiAqIEByZXR1cm5zIFJlY292ZXJlZCBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IGVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMildLCA2NCk7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnbmF0dXJlKS5hZGRSZWNvdmVyeUJpdChOdW1iZXIocmVjb3ZlcnkpKTtcbiAgICBjb25zdCBzZW5kZXJQdWJLZXkgPSBzaWcucmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VuZGVyUHViS2V5LnRvUmF3Qnl0ZXMoZmFsc2UpLnNsaWNlKDEpKTtcbn07XG5leHBvcnRzLmVjcmVjb3ZlciA9IGVjcmVjb3Zlcjtcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kLlxuICogTk9URTogQWNjZXB0cyBgdiA9PT0gMCB8IHYgPT09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmNvbnN0IHRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkocywgMzIpLCAoMCwgYnl0ZXNfMS50b0J1ZmZlcikodildKSk7XG59O1xuZXhwb3J0cy50b1JwY1NpZyA9IHRvUnBjU2lnO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBDb21wYWN0IFNpZ25hdHVyZSBSZXByZXNlbnRhdGlvbiAoRUlQLTIwOTgpLlxuICogTk9URTogQWNjZXB0cyBgdiA9PT0gMCB8IHYgPT09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmNvbnN0IHRvQ29tcGFjdFNpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIGxldCBzcyA9IHM7XG4gICAgaWYgKCh2ID4gQmlnSW50KDI4KSAmJiB2ICUgQmlnSW50KDIpID09PSBCaWdJbnQoMSkpIHx8IHYgPT09IEJpZ0ludCgxKSB8fCB2ID09PSBCaWdJbnQoMjgpKSB7XG4gICAgICAgIHNzID0gQnVmZmVyLmZyb20ocyk7XG4gICAgICAgIHNzWzBdIHw9IDB4ODA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzcywgMzIpXSkpO1xufTtcbmV4cG9ydHMudG9Db21wYWN0U2lnID0gdG9Db21wYWN0U2lnO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICpcbiAqIE5PVEU6IEZvciBhbiBleHRyYWN0ZWQgYHZgIHZhbHVlIDwgMjcgKHNlZSBHZXRoIGJ1ZyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTMpXG4gKiBgdiArIDI3YCBpcyByZXR1cm5lZCBmb3IgdGhlIGB2YCB2YWx1ZVxuICogTk9URTogQWZ0ZXIgRUlQMTU1OSwgYHZgIGNvdWxkIGJlIGAwYCBvciBgMWAgYnV0IHRoaXMgZnVuY3Rpb24gYXNzdW1lc1xuICogaXQncyBhIHNpZ25lZCBtZXNzYWdlIChFSVAtMTkxIG9yIEVJUC03MTIpIGFkZGluZyBgMjdgIGF0IHRoZSBlbmQuIFJlbW92ZSBpZiBuZWVkZWQuXG4gKi9cbmNvbnN0IGZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgY29uc3QgYnVmID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHNpZyk7XG4gICAgbGV0IHI7XG4gICAgbGV0IHM7XG4gICAgbGV0IHY7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPj0gNjUpIHtcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShidWYuc2xpY2UoNjQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgLy8gQ29tcGFjdCBTaWduYXR1cmUgUmVwcmVzZW50YXRpb24gKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjA5OClcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9IEJpZ0ludCgoMCwgYnl0ZXNfMS5idWZmZXJUb0ludCkoYnVmLnNsaWNlKDMyLCAzMykpID4+IDcpO1xuICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgIH1cbiAgICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgICBpZiAodiA8IDI3KSB7XG4gICAgICAgIHYgPSB2ICsgQmlnSW50KDI3KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdixcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICB9O1xufTtcbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZyb21ScGNTaWc7XG4vKipcbiAqIFZhbGlkYXRlIGEgRUNEU0Egc2lnbmF0dXJlLlxuICogTk9URTogQWNjZXB0cyBgdiA9PT0gMCB8IHYgPT09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkT3JMYXRlciA9IHRydWUsIGNoYWluSWQpIHtcbiAgICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJCaWdJbnQgPSAoMCwgYnl0ZXNfMS5idWZmZXJUb0JpZ0ludCkocik7XG4gICAgY29uc3Qgc0JpZ0ludCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShzKTtcbiAgICBpZiAockJpZ0ludCA9PT0gQmlnSW50KDApIHx8XG4gICAgICAgIHJCaWdJbnQgPj0gY29uc3RhbnRzXzEuU0VDUDI1NksxX09SREVSIHx8XG4gICAgICAgIHNCaWdJbnQgPT09IEJpZ0ludCgwKSB8fFxuICAgICAgICBzQmlnSW50ID49IGNvbnN0YW50c18xLlNFQ1AyNTZLMV9PUkRFUikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChob21lc3RlYWRPckxhdGVyICYmIHNCaWdJbnQgPj0gY29uc3RhbnRzXzEuU0VDUDI1NksxX09SREVSX0RJVl8yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gaXNWYWxpZFNpZ25hdHVyZTtcbi8qKlxuICogUmV0dXJucyB0aGUga2VjY2FrLTI1NiBoYXNoIG9mIGBtZXNzYWdlYCwgcHJlZml4ZWQgd2l0aCB0aGUgaGVhZGVyIHVzZWQgYnkgdGhlIGBldGhfc2lnbmAgUlBDIGNhbGwuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGZlZCBpbnRvIGBlY3NpZ25gIHRvIHByb2R1Y2UgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoZSBgZXRoX3NpZ25gXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICogdXNlZCB0byBwcm9kdWNlIHRoZSBzaWduYXR1cmUuXG4gKi9cbmNvbnN0IGhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHByZWZpeCA9IEJ1ZmZlci5mcm9tKGBcXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJHttZXNzYWdlLmxlbmd0aH1gLCAndXRmLTgnKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpKTtcbn07XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBoYXNoUGVyc29uYWxNZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJpc1ZhbGlkU2lnbmF0dXJlIiwiZnJvbVJwY1NpZyIsInRvQ29tcGFjdFNpZyIsInRvUnBjU2lnIiwiZWNyZWNvdmVyIiwiZWNzaWduIiwia2VjY2FrXzEiLCJyZXF1aXJlIiwic2VjcDI1NmsxXzEiLCJieXRlc18xIiwiY29uc3RhbnRzXzEiLCJoZWxwZXJzXzEiLCJtc2dIYXNoIiwicHJpdmF0ZUtleSIsImNoYWluSWQiLCJzaWciLCJzZWNwMjU2azEiLCJzaWduIiwiYnVmIiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyIiwiQnVmZmVyIiwiZnJvbSIsInNsaWNlIiwicyIsInYiLCJ1bmRlZmluZWQiLCJCaWdJbnQiLCJyZWNvdmVyeSIsImNhbGN1bGF0ZVNpZ1JlY292ZXJ5IiwiaXNWYWxpZFNpZ1JlY292ZXJ5Iiwic2lnbmF0dXJlIiwiY29uY2F0Iiwic2V0TGVuZ3RoTGVmdCIsIkVycm9yIiwiU2lnbmF0dXJlIiwiZnJvbUNvbXBhY3QiLCJhZGRSZWNvdmVyeUJpdCIsIk51bWJlciIsInNlbmRlclB1YktleSIsInJlY292ZXJQdWJsaWNLZXkiLCJ0b1Jhd0J5dGVzIiwiYnVmZmVyVG9IZXgiLCJ0b0J1ZmZlciIsInNzIiwibGVuZ3RoIiwiYnVmZmVyVG9CaWdJbnQiLCJidWZmZXJUb0ludCIsImhvbWVzdGVhZE9yTGF0ZXIiLCJyQmlnSW50Iiwic0JpZ0ludCIsIlNFQ1AyNTZLMV9PUkRFUiIsIlNFQ1AyNTZLMV9PUkRFUl9ESVZfMiIsIm1lc3NhZ2UiLCJhc3NlcnRJc0J1ZmZlciIsInByZWZpeCIsImtlY2NhazI1NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/signature.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/types.js":
/*!******************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/../node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Type output options\n */ var TypeOutput;\n(function(TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === \"string\" && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    } else if (typeof input === \"number\" && !Number.isSafeInteger(input)) {\n        throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch(outputType){\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number:\n            {\n                const bigInt = (0, bytes_1.bufferToBigInt)(output);\n                if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                    throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n                }\n                return Number(bigInt);\n            }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error(\"unknown outputType\");\n    }\n}\nexports.toType = toType; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzNDLE1BQU1JLFVBQVVDLG1CQUFPQSxDQUFDLHFFQUFTO0FBQ2pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDJFQUFZO0FBQ3ZDOztDQUVDLEdBQ0QsSUFBSUY7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDdEQsR0FBR0EsYUFBYUgsUUFBUUcsVUFBVSxJQUFLSCxDQUFBQSxrQkFBa0IsR0FBRyxDQUFDO0FBQzdELFNBQVNFLE9BQU9LLEtBQUssRUFBRUMsVUFBVTtJQUM3QixJQUFJRCxVQUFVLE1BQU07UUFDaEIsT0FBTztJQUNYO0lBQ0EsSUFBSUEsVUFBVUUsV0FBVztRQUNyQixPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFPRixVQUFVLFlBQVksQ0FBQyxDQUFDLEdBQUdELFdBQVdJLFdBQVcsRUFBRUgsUUFBUTtRQUNsRSxNQUFNLElBQUlJLE1BQU0sQ0FBQyxtREFBbUQsRUFBRUosTUFBTSxDQUFDO0lBQ2pGLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0ssT0FBT0MsYUFBYSxDQUFDTixRQUFRO1FBQ2hFLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUNBLE1BQU1HLFNBQVMsQ0FBQyxHQUFHVixRQUFRVyxRQUFRLEVBQUVSO0lBQ3JDLE9BQVFDO1FBQ0osS0FBS0wsV0FBV2EsTUFBTTtZQUNsQixPQUFPRjtRQUNYLEtBQUtYLFdBQVdjLE1BQU07WUFDbEIsT0FBTyxDQUFDLEdBQUdiLFFBQVFjLGNBQWMsRUFBRUo7UUFDdkMsS0FBS1gsV0FBV1MsTUFBTTtZQUFFO2dCQUNwQixNQUFNTyxTQUFTLENBQUMsR0FBR2YsUUFBUWMsY0FBYyxFQUFFSjtnQkFDM0MsSUFBSUssU0FBU0YsT0FBT0wsT0FBT1EsZ0JBQWdCLEdBQUc7b0JBQzFDLE1BQU0sSUFBSVQsTUFBTTtnQkFDcEI7Z0JBQ0EsT0FBT0MsT0FBT087WUFDbEI7UUFDQSxLQUFLaEIsV0FBV2tCLGlCQUFpQjtZQUM3QixPQUFPLENBQUMsR0FBR2pCLFFBQVFrQixXQUFXLEVBQUVSO1FBQ3BDO1lBQ0ksTUFBTSxJQUFJSCxNQUFNO0lBQ3hCO0FBQ0o7QUFDQVgsY0FBYyxHQUFHRSxRQUNqQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC90eXBlcy5qcz81OTUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1R5cGUgPSBleHBvcnRzLlR5cGVPdXRwdXQgPSB2b2lkIDA7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG4vKipcbiAqIFR5cGUgb3V0cHV0IG9wdGlvbnNcbiAqL1xudmFyIFR5cGVPdXRwdXQ7XG4oZnVuY3Rpb24gKFR5cGVPdXRwdXQpIHtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJOdW1iZXJcIl0gPSAwXSA9IFwiTnVtYmVyXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQmlnSW50XCJdID0gMV0gPSBcIkJpZ0ludFwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIkJ1ZmZlclwiXSA9IDJdID0gXCJCdWZmZXJcIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJQcmVmaXhlZEhleFN0cmluZ1wiXSA9IDNdID0gXCJQcmVmaXhlZEhleFN0cmluZ1wiO1xufSkoVHlwZU91dHB1dCA9IGV4cG9ydHMuVHlwZU91dHB1dCB8fCAoZXhwb3J0cy5UeXBlT3V0cHV0ID0ge30pKTtcbmZ1bmN0aW9uIHRvVHlwZShpbnB1dCwgb3V0cHV0VHlwZSkge1xuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKShpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHN0cmluZyBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYSAweC1wcmVmaXgsIGdpdmVuOiAke2lucHV0fWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNTYWZlSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIGlucHV0IHR5cGUpJyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShpbnB1dCk7XG4gICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgVHlwZU91dHB1dC5CdWZmZXI6XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICBjYXNlIFR5cGVPdXRwdXQuQmlnSW50OlxuICAgICAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShvdXRwdXQpO1xuICAgICAgICBjYXNlIFR5cGVPdXRwdXQuTnVtYmVyOiB7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnQgPSAoMCwgYnl0ZXNfMS5idWZmZXJUb0JpZ0ludCkob3V0cHV0KTtcbiAgICAgICAgICAgIGlmIChiaWdJbnQgPiBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIG91dHB1dCB0eXBlKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihiaWdJbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVHlwZU91dHB1dC5QcmVmaXhlZEhleFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkob3V0cHV0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBvdXRwdXRUeXBlJyk7XG4gICAgfVxufVxuZXhwb3J0cy50b1R5cGUgPSB0b1R5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0b1R5cGUiLCJUeXBlT3V0cHV0IiwiYnl0ZXNfMSIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIiwiaW5wdXQiLCJvdXRwdXRUeXBlIiwidW5kZWZpbmVkIiwiaXNIZXhTdHJpbmciLCJFcnJvciIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJvdXRwdXQiLCJ0b0J1ZmZlciIsIkJ1ZmZlciIsIkJpZ0ludCIsImJ1ZmZlclRvQmlnSW50IiwiYmlnSW50IiwiTUFYX1NBRkVfSU5URUdFUiIsIlByZWZpeGVkSGV4U3RyaW5nIiwiYnVmZmVyVG9IZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/units.js":
/*!******************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/units.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GWEI_TO_WEI = void 0;\n/** Easy conversion from Gwei to wei */ exports.GWEI_TO_WEI = BigInt(1000000000); //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC91bml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQixxQ0FBcUMsR0FDckNBLG1CQUFtQixHQUFHRyxPQUFPLGFBQzdCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3VuaXRzLmpzP2EyNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdXRUlfVE9fV0VJID0gdm9pZCAwO1xuLyoqIEVhc3kgY29udmVyc2lvbiBmcm9tIEd3ZWkgdG8gd2VpICovXG5leHBvcnRzLkdXRUlfVE9fV0VJID0gQmlnSW50KDEwMDAwMDAwMDApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pdHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiR1dFSV9UT19XRUkiLCJCaWdJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/units.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@ethereumjs/util/dist/withdrawal.js":
/*!***********************************************************!*\
  !*** ../node_modules/@ethereumjs/util/dist/withdrawal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Withdrawal = void 0;\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/../node_modules/@ethereumjs/util/dist/address.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/../node_modules/@ethereumjs/util/dist/bytes.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/@ethereumjs/util/dist/types.js\");\n/**\n * Representation of EIP-4895 withdrawal data\n */ class Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */ constructor(index, validatorIndex, address, /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */ amount){\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({\n            index,\n            validatorIndex,\n            address,\n            amount\n        });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */ static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        } else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [\n            indexBuffer,\n            validatorIndexBuffer,\n            addressBuffer,\n            amountBuffer\n        ];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: \"0x\" + this.address.buf.toString(\"hex\"),\n            amount: (0, bytes_1.bigIntToHex)(this.amount)\n        };\n    }\n}\nexports.Withdrawal = Withdrawal; //# sourceMappingURL=withdrawal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC93aXRoZHJhd2FsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1HLFlBQVlDLG1CQUFPQSxDQUFDLHlFQUFXO0FBQ3JDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLHFFQUFTO0FBQ2pDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHFFQUFTO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUY7SUFDRjs7OztLQUlDLEdBQ0RLLFlBQVlDLEtBQUssRUFBRUMsY0FBYyxFQUFFQyxPQUFPLEVBQzFDOztLQUVDLEdBQ0RDLE1BQU0sQ0FBRTtRQUNKLElBQUksQ0FBQ0gsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR0E7SUFDbEI7SUFDQSxPQUFPQyxtQkFBbUJDLGNBQWMsRUFBRTtRQUN0QyxNQUFNLEVBQUVMLE9BQU9NLFNBQVMsRUFBRUwsZ0JBQWdCTSxrQkFBa0IsRUFBRUwsU0FBU00sV0FBVyxFQUFFTCxRQUFRTSxVQUFVLEVBQUcsR0FBR0o7UUFDNUcsTUFBTUwsUUFBUSxDQUFDLEdBQUdGLFFBQVFZLE1BQU0sRUFBRUosV0FBV1IsUUFBUWEsVUFBVSxDQUFDQyxNQUFNO1FBQ3RFLE1BQU1YLGlCQUFpQixDQUFDLEdBQUdILFFBQVFZLE1BQU0sRUFBRUgsb0JBQW9CVCxRQUFRYSxVQUFVLENBQUNDLE1BQU07UUFDeEYsTUFBTVYsVUFBVSxJQUFJUCxVQUFVa0IsT0FBTyxDQUFDLENBQUMsR0FBR2YsUUFBUVksTUFBTSxFQUFFRixhQUFhVixRQUFRYSxVQUFVLENBQUNHLE1BQU07UUFDaEcsTUFBTVgsU0FBUyxDQUFDLEdBQUdMLFFBQVFZLE1BQU0sRUFBRUQsWUFBWVgsUUFBUWEsVUFBVSxDQUFDQyxNQUFNO1FBQ3hFLE9BQU8sSUFBSWxCLFdBQVdNLE9BQU9DLGdCQUFnQkMsU0FBU0M7SUFDMUQ7SUFDQSxPQUFPWSxnQkFBZ0JDLGVBQWUsRUFBRTtRQUNwQyxJQUFJQSxnQkFBZ0JDLE1BQU0sS0FBSyxHQUFHO1lBQzlCLE1BQU1DLE1BQU0sQ0FBQyxpREFBaUQsRUFBRUYsZ0JBQWdCQyxNQUFNLENBQUMsQ0FBQztRQUM1RjtRQUNBLE1BQU0sQ0FBQ2pCLE9BQU9DLGdCQUFnQkMsU0FBU0MsT0FBTyxHQUFHYTtRQUNqRCxPQUFPdEIsV0FBV1Usa0JBQWtCLENBQUM7WUFBRUo7WUFBT0M7WUFBZ0JDO1lBQVNDO1FBQU87SUFDbEY7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT2dCLGNBQWNDLFVBQVUsRUFBRTtRQUM3QixNQUFNLEVBQUVwQixLQUFLLEVBQUVDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUUsR0FBR2lCO1FBQ25ELE1BQU1DLGNBQWMsQ0FBQyxHQUFHdkIsUUFBUVksTUFBTSxFQUFFVixPQUFPRixRQUFRYSxVQUFVLENBQUNDLE1BQU0sTUFBTUEsT0FBTyxLQUMvRUUsT0FBT1EsS0FBSyxDQUFDLEtBQ2IsQ0FBQyxHQUFHeEIsUUFBUVksTUFBTSxFQUFFVixPQUFPRixRQUFRYSxVQUFVLENBQUNHLE1BQU07UUFDMUQsTUFBTVMsdUJBQXVCLENBQUMsR0FBR3pCLFFBQVFZLE1BQU0sRUFBRVQsZ0JBQWdCSCxRQUFRYSxVQUFVLENBQUNDLE1BQU0sTUFBTUEsT0FBTyxLQUNqR0UsT0FBT1EsS0FBSyxDQUFDLEtBQ2IsQ0FBQyxHQUFHeEIsUUFBUVksTUFBTSxFQUFFVCxnQkFBZ0JILFFBQVFhLFVBQVUsQ0FBQ0csTUFBTTtRQUNuRSxJQUFJVTtRQUNKLElBQUl0QixtQkFBbUJQLFVBQVVrQixPQUFPLEVBQUU7WUFDdENXLGdCQUFnQnRCLFFBQVF1QixHQUFHO1FBQy9CLE9BQ0s7WUFDREQsZ0JBQWdCLENBQUMsR0FBRzFCLFFBQVFZLE1BQU0sRUFBRVIsU0FBU0osUUFBUWEsVUFBVSxDQUFDRyxNQUFNO1FBQzFFO1FBQ0EsTUFBTVksZUFBZSxDQUFDLEdBQUc1QixRQUFRWSxNQUFNLEVBQUVQLFFBQVFMLFFBQVFhLFVBQVUsQ0FBQ0MsTUFBTSxNQUFNQSxPQUFPLEtBQ2pGRSxPQUFPUSxLQUFLLENBQUMsS0FDYixDQUFDLEdBQUd4QixRQUFRWSxNQUFNLEVBQUVQLFFBQVFMLFFBQVFhLFVBQVUsQ0FBQ0csTUFBTTtRQUMzRCxPQUFPO1lBQUNPO1lBQWFFO1lBQXNCQztZQUFlRTtTQUFhO0lBQzNFO0lBQ0FDLE1BQU07UUFDRixPQUFPakMsV0FBV3lCLGFBQWEsQ0FBQyxJQUFJO0lBQ3hDO0lBQ0FTLFVBQVU7UUFDTixPQUFPO1lBQ0g1QixPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsU0FBUyxJQUFJLENBQUNBLE9BQU8sQ0FBQ3VCLEdBQUc7WUFDekJ0QixRQUFRLElBQUksQ0FBQ0EsTUFBTTtRQUN2QjtJQUNKO0lBQ0EwQixTQUFTO1FBQ0wsT0FBTztZQUNIN0IsT0FBTyxDQUFDLEdBQUdILFFBQVFpQyxXQUFXLEVBQUUsSUFBSSxDQUFDOUIsS0FBSztZQUMxQ0MsZ0JBQWdCLENBQUMsR0FBR0osUUFBUWlDLFdBQVcsRUFBRSxJQUFJLENBQUM3QixjQUFjO1lBQzVEQyxTQUFTLE9BQU8sSUFBSSxDQUFDQSxPQUFPLENBQUN1QixHQUFHLENBQUNNLFFBQVEsQ0FBQztZQUMxQzVCLFFBQVEsQ0FBQyxHQUFHTixRQUFRaUMsV0FBVyxFQUFFLElBQUksQ0FBQzNCLE1BQU07UUFDaEQ7SUFDSjtBQUNKO0FBQ0FYLGtCQUFrQixHQUFHRSxZQUNyQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC93aXRoZHJhd2FsLmpzPzdmODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldpdGhkcmF3YWwgPSB2b2lkIDA7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBFSVAtNDg5NSB3aXRoZHJhd2FsIGRhdGFcbiAqL1xuY2xhc3MgV2l0aGRyYXdhbCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciBhc3NpZ25zIGFuZCB2YWxpZGF0ZXMgdGhlIHZhbHVlcy5cbiAgICAgKiBVc2UgdGhlIHN0YXRpYyBmYWN0b3J5IG1ldGhvZHMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGEgV2l0aGRyYXdhbCBvYmplY3QgZnJvbSB2YXJ5aW5nIGRhdGEgdHlwZXMuXG4gICAgICogSXRzIGFtb3VudCBpcyBpbiBHd2VpIHRvIG1hdGNoIENMIHJlcHJlc2VudGF0aW9uIGFuZCBmb3IgZXZlbnR1YWwgc3N6IHdpdGhkcmF3YWxzUm9vdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgXG4gICAgLyoqXG4gICAgICogd2l0aGRyYXdhbCBhbW91bnQgaW4gR3dlaSB0byBtYXRjaCB0aGUgQ0wgcmVwZXNlbnRhdGlvbiBhbmQgZXZlbnR1YWxseSBzc3ogd2l0aGRyYXdhbHNSb290XG4gICAgICovXG4gICAgYW1vdW50KSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy52YWxpZGF0b3JJbmRleCA9IHZhbGlkYXRvckluZGV4O1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21XaXRoZHJhd2FsRGF0YSh3aXRoZHJhd2FsRGF0YSkge1xuICAgICAgICBjb25zdCB7IGluZGV4OiBpbmRleERhdGEsIHZhbGlkYXRvckluZGV4OiB2YWxpZGF0b3JJbmRleERhdGEsIGFkZHJlc3M6IGFkZHJlc3NEYXRhLCBhbW91bnQ6IGFtb3VudERhdGEsIH0gPSB3aXRoZHJhd2FsRGF0YTtcbiAgICAgICAgY29uc3QgaW5kZXggPSAoMCwgdHlwZXNfMS50b1R5cGUpKGluZGV4RGF0YSwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvckluZGV4ID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2YWxpZGF0b3JJbmRleERhdGEsIHR5cGVzXzEuVHlwZU91dHB1dC5CaWdJbnQpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gbmV3IGFkZHJlc3NfMS5BZGRyZXNzKCgwLCB0eXBlc18xLnRvVHlwZSkoYWRkcmVzc0RhdGEsIHR5cGVzXzEuVHlwZU91dHB1dC5CdWZmZXIpKTtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gKDAsIHR5cGVzXzEudG9UeXBlKShhbW91bnREYXRhLCB0eXBlc18xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBXaXRoZHJhd2FsKGluZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgYW1vdW50KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh3aXRoZHJhd2FsQXJyYXkpIHtcbiAgICAgICAgaWYgKHdpdGhkcmF3YWxBcnJheS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIHdpdGhkcmF3YWxBcnJheSBsZW5ndGggZXhwZWN0ZWQ9NCBhY3R1YWw9JHt3aXRoZHJhd2FsQXJyYXkubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpbmRleCwgdmFsaWRhdG9ySW5kZXgsIGFkZHJlc3MsIGFtb3VudF0gPSB3aXRoZHJhd2FsQXJyYXk7XG4gICAgICAgIHJldHVybiBXaXRoZHJhd2FsLmZyb21XaXRoZHJhd2FsRGF0YSh7IGluZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgYW1vdW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgd2l0aGRyYXdhbCB0byBhIGJ1ZmZlciBhcnJheVxuICAgICAqIEBwYXJhbSB3aXRoZHJhd2FsIHRoZSB3aXRoZHJhd2FsIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyBidWZmZXIgYXJyYXkgb2YgdGhlIHdpdGhkcmF3YWxcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9CdWZmZXJBcnJheSh3aXRoZHJhd2FsKSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXgsIHZhbGlkYXRvckluZGV4LCBhZGRyZXNzLCBhbW91bnQgfSA9IHdpdGhkcmF3YWw7XG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gKDAsIHR5cGVzXzEudG9UeXBlKShpbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCkgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgPyBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogKDAsIHR5cGVzXzEudG9UeXBlKShpbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvckluZGV4QnVmZmVyID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2YWxpZGF0b3JJbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCkgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgPyBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogKDAsIHR5cGVzXzEudG9UeXBlKSh2YWxpZGF0b3JJbmRleCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJ1ZmZlcik7XG4gICAgICAgIGxldCBhZGRyZXNzQnVmZmVyO1xuICAgICAgICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIGFkZHJlc3NfMS5BZGRyZXNzKSB7XG4gICAgICAgICAgICBhZGRyZXNzQnVmZmVyID0gYWRkcmVzcy5idWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzQnVmZmVyID0gKDAsIHR5cGVzXzEudG9UeXBlKShhZGRyZXNzLCB0eXBlc18xLlR5cGVPdXRwdXQuQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbW91bnRCdWZmZXIgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGFtb3VudCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCkgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgPyBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogKDAsIHR5cGVzXzEudG9UeXBlKShhbW91bnQsIHR5cGVzXzEuVHlwZU91dHB1dC5CdWZmZXIpO1xuICAgICAgICByZXR1cm4gW2luZGV4QnVmZmVyLCB2YWxpZGF0b3JJbmRleEJ1ZmZlciwgYWRkcmVzc0J1ZmZlciwgYW1vdW50QnVmZmVyXTtcbiAgICB9XG4gICAgcmF3KCkge1xuICAgICAgICByZXR1cm4gV2l0aGRyYXdhbC50b0J1ZmZlckFycmF5KHRoaXMpO1xuICAgIH1cbiAgICB0b1ZhbHVlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICB2YWxpZGF0b3JJbmRleDogdGhpcy52YWxpZGF0b3JJbmRleCxcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcy5idWYsXG4gICAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogKDAsIGJ5dGVzXzEuYmlnSW50VG9IZXgpKHRoaXMuaW5kZXgpLFxuICAgICAgICAgICAgdmFsaWRhdG9ySW5kZXg6ICgwLCBieXRlc18xLmJpZ0ludFRvSGV4KSh0aGlzLnZhbGlkYXRvckluZGV4KSxcbiAgICAgICAgICAgIGFkZHJlc3M6ICcweCcgKyB0aGlzLmFkZHJlc3MuYnVmLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgIGFtb3VudDogKDAsIGJ5dGVzXzEuYmlnSW50VG9IZXgpKHRoaXMuYW1vdW50KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLldpdGhkcmF3YWwgPSBXaXRoZHJhd2FsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aGRyYXdhbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJXaXRoZHJhd2FsIiwiYWRkcmVzc18xIiwicmVxdWlyZSIsImJ5dGVzXzEiLCJ0eXBlc18xIiwiY29uc3RydWN0b3IiLCJpbmRleCIsInZhbGlkYXRvckluZGV4IiwiYWRkcmVzcyIsImFtb3VudCIsImZyb21XaXRoZHJhd2FsRGF0YSIsIndpdGhkcmF3YWxEYXRhIiwiaW5kZXhEYXRhIiwidmFsaWRhdG9ySW5kZXhEYXRhIiwiYWRkcmVzc0RhdGEiLCJhbW91bnREYXRhIiwidG9UeXBlIiwiVHlwZU91dHB1dCIsIkJpZ0ludCIsIkFkZHJlc3MiLCJCdWZmZXIiLCJmcm9tVmFsdWVzQXJyYXkiLCJ3aXRoZHJhd2FsQXJyYXkiLCJsZW5ndGgiLCJFcnJvciIsInRvQnVmZmVyQXJyYXkiLCJ3aXRoZHJhd2FsIiwiaW5kZXhCdWZmZXIiLCJhbGxvYyIsInZhbGlkYXRvckluZGV4QnVmZmVyIiwiYWRkcmVzc0J1ZmZlciIsImJ1ZiIsImFtb3VudEJ1ZmZlciIsInJhdyIsInRvVmFsdWUiLCJ0b0pTT04iLCJiaWdJbnRUb0hleCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@ethereumjs/util/dist/withdrawal.js\n");

/***/ })

};
;