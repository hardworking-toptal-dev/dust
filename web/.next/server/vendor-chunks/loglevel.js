/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/loglevel";
exports.ids = ["vendor-chunks/loglevel"];
exports.modules = {

/***/ "(ssr)/../node_modules/loglevel/lib/loglevel.js":
/*!************************************************!*\
  !*** ../node_modules/loglevel/lib/loglevel.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function() {\n    \"use strict\";\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n    var _loggersByName = {};\n    var defaultLogger = null;\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \"function\") {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [\n                        obj,\n                        arguments\n                    ]);\n                };\n            }\n        }\n    }\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [\n                    console,\n                    arguments\n                ]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \"debug\") {\n            methodName = \"log\";\n        }\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \"trace\" && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \"log\");\n        } else {\n            return noop;\n        }\n    }\n    // These private functions always need `this` to be set properly\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */ var level = this.getLevel();\n        // Replace the actual methods.\n        for(var i = 0; i < logMethods.length; i++){\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function() {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */ var inheritedLevel;\n        /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */ var defaultLevel;\n        /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */ var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n            storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n            storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n            var storedLevel;\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n            // Fallback to cookies if local storage gives us nothing\n            if (typeof storedLevel === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var cookieName = encodeURIComponent(storageKey);\n                    var location = cookie.indexOf(cookieName + \"=\");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                    }\n                } catch (ignore) {}\n            }\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n            return storedLevel;\n        }\n        function clearPersistedLevel() {\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage.removeItem(storageKey);\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n            } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n            var level = input;\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                return level;\n            } else {\n                throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n            }\n        }\n        /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self.name = name;\n        self.levels = {\n            \"TRACE\": 0,\n            \"DEBUG\": 1,\n            \"INFO\": 2,\n            \"WARN\": 3,\n            \"ERROR\": 4,\n            \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function() {\n            if (userLevel != null) {\n                return userLevel;\n            } else if (defaultLevel != null) {\n                return defaultLevel;\n            } else {\n                return inheritedLevel;\n            }\n        };\n        self.setLevel = function(level, persist) {\n            userLevel = normalizeLevel(level);\n            if (persist !== false) {\n                persistLevelIfPossible(userLevel);\n            }\n            // NOTE: in v2, this should call rebuild(), which updates children.\n            return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function(level) {\n            defaultLevel = normalizeLevel(level);\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n        self.resetLevel = function() {\n            userLevel = null;\n            clearPersistedLevel();\n            replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function(persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function(persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function() {\n            if (defaultLogger !== self) {\n                inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n            }\n            replaceLoggingMethods.call(self);\n            if (defaultLogger === self) {\n                for(var childName in _loggersByName){\n                    _loggersByName[childName].rebuild();\n                }\n            }\n        };\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n            userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n    }\n    /*\n     *\n     * Top-level API\n     *\n     */ defaultLogger = new Logger();\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n    // Grab the current global log variable in case of overwrite\n    var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n        return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n    // ES6 default export, for compatibility\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQSxHQUNDLFVBQVVBLElBQUksRUFBRUMsVUFBVTtJQUN2QjtJQUNBLElBQUksSUFBMEMsRUFBRTtRQUM1Q0Msb0NBQU9ELFVBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3RCLE9BQU8sRUFJTjtBQUNMLEdBQUUsSUFBSSxFQUFFO0lBQ0o7SUFFQSwwREFBMEQ7SUFDMUQsSUFBSU0sT0FBTyxZQUFZO0lBQ3ZCLElBQUlDLGdCQUFnQjtJQUNwQixJQUFJQyxPQUFPLGdCQUFtQkQsaUJBQW1CLE9BQU9FLE9BQU9DLFNBQVMsS0FBS0gsaUJBQ3pFLGtCQUFrQkksSUFBSSxDQUFDRixPQUFPQyxTQUFTLENBQUNFLFNBQVM7SUFHckQsSUFBSUMsYUFBYTtRQUNiO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUVELElBQUlDLGlCQUFpQixDQUFDO0lBQ3RCLElBQUlDLGdCQUFnQjtJQUVwQixnRUFBZ0U7SUFDaEUsU0FBU0MsV0FBV0MsR0FBRyxFQUFFQyxVQUFVO1FBQy9CLElBQUlDLFNBQVNGLEdBQUcsQ0FBQ0MsV0FBVztRQUM1QixJQUFJLE9BQU9DLE9BQU9DLElBQUksS0FBSyxZQUFZO1lBQ25DLE9BQU9ELE9BQU9DLElBQUksQ0FBQ0g7UUFDdkIsT0FBTztZQUNILElBQUk7Z0JBQ0EsT0FBT0ksU0FBU0MsU0FBUyxDQUFDRixJQUFJLENBQUNHLElBQUksQ0FBQ0osUUFBUUY7WUFDaEQsRUFBRSxPQUFPTyxHQUFHO2dCQUNSLDZEQUE2RDtnQkFDN0QsT0FBTztvQkFDSCxPQUFPSCxTQUFTQyxTQUFTLENBQUNHLEtBQUssQ0FBQ0EsS0FBSyxDQUFDTixRQUFRO3dCQUFDRjt3QkFBS1M7cUJBQVU7Z0JBQ2xFO1lBQ0o7UUFDSjtJQUNKO0lBRUEsK0VBQStFO0lBQy9FLFNBQVNDO1FBQ0wsSUFBSUMsUUFBUXZCLEdBQUcs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QVN2RSxjQUFjLENBQUN3QixLQUFLO1FBQ2pDLElBQUksQ0FBQytDLFFBQVE7WUFDVEEsU0FBU3ZFLGNBQWMsQ0FBQ3dCLEtBQUssR0FBRyxJQUFJUSxPQUNoQ1IsTUFDQXZCLGNBQWNzQixhQUFhO1FBRW5DO1FBQ0EsT0FBT2dEO0lBQ1g7SUFFQSw0REFBNEQ7SUFDNUQsSUFBSUMsT0FBTyxnQkFBbUIvRSxnQkFBaUJFLE9BQU9KLEdBQUcsR0FBRzBCO0lBQzVEaEIsY0FBY3dFLFVBQVUsR0FBRztRQUN2QixJQUFJLGdCQUFrQmhGLGlCQUNmRSxPQUFPSixHQUFHLEtBQUtVLGVBQWU7WUFDakNOLE9BQU9KLEdBQUcsR0FBR2lGO1FBQ2pCO1FBRUEsT0FBT3ZFO0lBQ1g7SUFFQUEsY0FBY3lFLFVBQVUsR0FBRyxTQUFTQTtRQUNoQyxPQUFPMUU7SUFDWDtJQUVBLHdDQUF3QztJQUN4Q0MsYUFBYSxDQUFDLFVBQVUsR0FBR0E7SUFFM0IsT0FBT0E7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzgyYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG51bGw7XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMoKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuZ2V0TGV2ZWwoKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBhY3R1YWwgbWV0aG9kcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuXG4gICAgICAgIC8vIFJldHVybiBhbnkgaW1wb3J0YW50IHdhcm5pbmdzLlxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCB0aGlzLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgX2xldmVsLCBfbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBmYWN0b3J5KSB7XG4gICAgICAvLyBQcml2YXRlIGluc3RhbmNlIHZhcmlhYmxlcy5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxldmVsIGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IGxvZ2dlciAob3IgYSBnbG9iYWwgZGVmYXVsdCkuIFdlXG4gICAgICAgKiBjYWNoZSB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gZGVsZWdhdGluZyB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgc3RheXNcbiAgICAgICAqIGluIHN5bmMgd2l0aCB0aGUgYWN0dWFsIGxvZ2dpbmcgbWV0aG9kcyB0aGF0IHdlIGhhdmUgaW5zdGFsbGVkICh0aGVcbiAgICAgICAqIHBhcmVudCBjb3VsZCBjaGFuZ2UgbGV2ZWxzIGJ1dCB3ZSBtaWdodCBub3QgaGF2ZSByZWJ1aWx0IHRoZSBsb2dnZXJzXG4gICAgICAgKiBpbiB0aGlzIGNoaWxkIHlldCkuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB2YXIgaW5oZXJpdGVkTGV2ZWw7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGZvciB0aGlzIGxvZ2dlciwgaWYgYW55LiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgKiBgaW5oZXJpdGVkTGV2ZWxgLlxuICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICovXG4gICAgICB2YXIgZGVmYXVsdExldmVsO1xuICAgICAgLyoqXG4gICAgICAgKiBBIHVzZXItc3BlY2lmaWMgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgKiBgZGVmYXVsdExldmVsYC5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAqL1xuICAgICAgdmFyIHVzZXJMZXZlbDtcblxuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llTmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKGNvb2tpZU5hbWUgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5zbGljZShsb2NhdGlvbiArIGNvb2tpZU5hbWUubGVuZ3RoICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICApWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxldmVsKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gaW5wdXQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHVzZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckxldmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0ZWRMZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKHVzZXJMZXZlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTk9URTogaW4gdjIsIHRoaXMgc2hvdWxkIGNhbGwgcmVidWlsZCgpLCB3aGljaCB1cGRhdGVzIGNoaWxkcmVuLlxuICAgICAgICAgIHJldHVybiByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgZGVmYXVsdExldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG51bGw7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5yZWJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciA9PT0gc2VsZikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBjaGlsZE5hbWUgaW4gX2xvZ2dlcnNCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICBfbG9nZ2Vyc0J5TmFtZVtjaGlsZE5hbWVdLnJlYnVpbGQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgYWxsIHRoZSBpbnRlcm5hbCBsZXZlbHMuXG4gICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKFxuICAgICAgICAgIGRlZmF1bHRMb2dnZXIgPyBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkgOiBcIldBUk5cIlxuICAgICAgKTtcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwoaW5pdGlhbExldmVsKTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZGVmaW5pdGlvbiIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJsb2ciLCJub29wIiwidW5kZWZpbmVkVHlwZSIsImlzSUUiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwibG9nTWV0aG9kcyIsIl9sb2dnZXJzQnlOYW1lIiwiZGVmYXVsdExvZ2dlciIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyYWNlRm9ySUUiLCJjb25zb2xlIiwidHJhY2UiLCJyZWFsTWV0aG9kIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJnZXRMZXZlbCIsImkiLCJsZW5ndGgiLCJtZXRob2RGYWN0b3J5IiwibmFtZSIsImRlYnVnIiwibGV2ZWxzIiwiU0lMRU5UIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiX2xldmVsIiwiX2xvZ2dlck5hbWUiLCJMb2dnZXIiLCJmYWN0b3J5Iiwic2VsZiIsImluaGVyaXRlZExldmVsIiwiZGVmYXVsdExldmVsIiwidXNlckxldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwiY29va2llTmFtZSIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImNsZWFyUGVyc2lzdGVkTGV2ZWwiLCJyZW1vdmVJdGVtIiwibm9ybWFsaXplTGV2ZWwiLCJpbnB1dCIsIlR5cGVFcnJvciIsInNldExldmVsIiwicGVyc2lzdCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJyZWJ1aWxkIiwiY2hpbGROYW1lIiwiaW5pdGlhbExldmVsIiwiZ2V0TG9nZ2VyIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/loglevel/lib/loglevel.js\n");

/***/ })

};
;