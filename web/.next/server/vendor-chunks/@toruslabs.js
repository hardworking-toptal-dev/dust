/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toruslabs";
exports.ids = ["vendor-chunks/@toruslabs"];
exports.modules = {

/***/ "(ssr)/../node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACCOUNT_CATEGORY: () => (/* binding */ ACCOUNT_CATEGORY),\n/* harmony export */   ACTIVITY_ACTION: () => (/* binding */ ACTIVITY_ACTION),\n/* harmony export */   ACTIVITY_ACTION_ALL: () => (/* binding */ ACTIVITY_ACTION_ALL),\n/* harmony export */   ACTIVITY_ACTION_BURN: () => (/* binding */ ACTIVITY_ACTION_BURN),\n/* harmony export */   ACTIVITY_ACTION_RECEIVE: () => (/* binding */ ACTIVITY_ACTION_RECEIVE),\n/* harmony export */   ACTIVITY_ACTION_SEND: () => (/* binding */ ACTIVITY_ACTION_SEND),\n/* harmony export */   ACTIVITY_ACTION_TOPUP: () => (/* binding */ ACTIVITY_ACTION_TOPUP),\n/* harmony export */   ACTIVITY_PERIOD_ALL: () => (/* binding */ ACTIVITY_PERIOD_ALL),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_ONE: () => (/* binding */ ACTIVITY_PERIOD_MONTH_ONE),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_SIX: () => (/* binding */ ACTIVITY_PERIOD_MONTH_SIX),\n/* harmony export */   ACTIVITY_PERIOD_WEEK_ONE: () => (/* binding */ ACTIVITY_PERIOD_WEEK_ONE),\n/* harmony export */   ACTIVITY_STATUS_CANCELLED: () => (/* binding */ ACTIVITY_STATUS_CANCELLED),\n/* harmony export */   ACTIVITY_STATUS_CANCELLING: () => (/* binding */ ACTIVITY_STATUS_CANCELLING),\n/* harmony export */   ACTIVITY_STATUS_PENDING: () => (/* binding */ ACTIVITY_STATUS_PENDING),\n/* harmony export */   ACTIVITY_STATUS_SUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_SUCCESSFUL),\n/* harmony export */   ACTIVITY_STATUS_UNSUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_UNSUCCESSFUL),\n/* harmony export */   BROADCAST_CHANNELS: () => (/* binding */ BROADCAST_CHANNELS),\n/* harmony export */   BROADCAST_CHANNELS_MSGS: () => (/* binding */ BROADCAST_CHANNELS_MSGS),\n/* harmony export */   BaseBlockTracker: () => (/* binding */ BaseBlockTracker),\n/* harmony export */   BaseController: () => (/* binding */ BaseController),\n/* harmony export */   BaseCurrencyController: () => (/* binding */ BaseCurrencyController),\n/* harmony export */   BaseEmbedController: () => (/* binding */ BaseEmbedController),\n/* harmony export */   BaseKeyringController: () => (/* binding */ BaseKeyringController),\n/* harmony export */   BasePreferencesController: () => (/* binding */ BasePreferencesController),\n/* harmony export */   BaseTransactionStateManager: () => (/* binding */ BaseTransactionStateManager),\n/* harmony export */   BroadcastChannelHandler: () => (/* binding */ BroadcastChannelHandler),\n/* harmony export */   COMMUNICATION_JRPC_METHODS: () => (/* binding */ COMMUNICATION_JRPC_METHODS),\n/* harmony export */   COMMUNICATION_NOTIFICATIONS: () => (/* binding */ COMMUNICATION_NOTIFICATIONS),\n/* harmony export */   CommunicationWindowManager: () => (/* binding */ CommunicationWindowManager),\n/* harmony export */   DEFAULT_PREFERENCES: () => (/* binding */ DEFAULT_PREFERENCES),\n/* harmony export */   FEATURES_CONFIRM_WINDOW: () => (/* binding */ FEATURES_CONFIRM_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_POPUP_WINDOW: () => (/* binding */ FEATURES_DEFAULT_POPUP_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_WALLET_WINDOW: () => (/* binding */ FEATURES_DEFAULT_WALLET_WINDOW),\n/* harmony export */   FEATURES_PROVIDER_CHANGE_WINDOW: () => (/* binding */ FEATURES_PROVIDER_CHANGE_WINDOW),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   POPUP_LOADED: () => (/* binding */ POPUP_LOADED),\n/* harmony export */   POPUP_RESULT: () => (/* binding */ POPUP_RESULT),\n/* harmony export */   PROVIDER_JRPC_METHODS: () => (/* binding */ PROVIDER_JRPC_METHODS),\n/* harmony export */   PROVIDER_NOTIFICATIONS: () => (/* binding */ PROVIDER_NOTIFICATIONS),\n/* harmony export */   PopupHandler: () => (/* binding */ PopupHandler),\n/* harmony export */   PopupStoreChannel: () => (/* binding */ PopupStoreChannel),\n/* harmony export */   PopupWithBcHandler: () => (/* binding */ PopupWithBcHandler),\n/* harmony export */   RedirectHandler: () => (/* binding */ RedirectHandler),\n/* harmony export */   SETUP_COMPLETE: () => (/* binding */ SETUP_COMPLETE),\n/* harmony export */   StreamWindow: () => (/* binding */ StreamWindow),\n/* harmony export */   TRANSACTION_TYPES: () => (/* binding */ TRANSACTION_TYPES),\n/* harmony export */   TX_EVENTS: () => (/* binding */ TX_EVENTS),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   UserError: () => (/* binding */ UserError),\n/* harmony export */   addressSlicer: () => (/* binding */ addressSlicer),\n/* harmony export */   broadcastChannelOptions: () => (/* binding */ broadcastChannelOptions),\n/* harmony export */   concatSig: () => (/* binding */ concatSig),\n/* harmony export */   createChangeProviderMiddlewareMiddleware: () => (/* binding */ createChangeProviderMiddlewareMiddleware),\n/* harmony export */   createCommunicationMiddleware: () => (/* binding */ createCommunicationMiddleware),\n/* harmony export */   createEventEmitterProxy: () => (/* binding */ createEventEmitterProxy),\n/* harmony export */   createFetchConfigFromReq: () => (/* binding */ createFetchConfigFromReq),\n/* harmony export */   createFetchMiddleware: () => (/* binding */ createFetchMiddleware),\n/* harmony export */   createGenericJRPCMiddleware: () => (/* binding */ createGenericJRPCMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createOriginMiddleware: () => (/* binding */ createOriginMiddleware),\n/* harmony export */   createRandomId: () => (/* binding */ createRandomId),\n/* harmony export */   createSwappableProxy: () => (/* binding */ createSwappableProxy),\n/* harmony export */   createTopupMiddleware: () => (/* binding */ createTopupMiddleware),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatSmallNumbers: () => (/* binding */ formatSmallNumbers),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   getCustomDeviceInfo: () => (/* binding */ getCustomDeviceInfo),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getPopupFeatures: () => (/* binding */ getPopupFeatures),\n/* harmony export */   getTxStatusText: () => (/* binding */ getTxStatusText),\n/* harmony export */   handleRedirectParameters: () => (/* binding */ handleRedirectParameters),\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   intToHex: () => (/* binding */ intToHex),\n/* harmony export */   padWithZeroes: () => (/* binding */ padWithZeroes),\n/* harmony export */   providerAsMiddleware: () => (/* binding */ providerAsMiddleware),\n/* harmony export */   providerFromEngine: () => (/* binding */ providerFromEngine),\n/* harmony export */   providerFromMiddleware: () => (/* binding */ providerFromMiddleware),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   signMessage: () => (/* binding */ signMessage),\n/* harmony export */   significantDigits: () => (/* binding */ significantDigits),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeout: () => (/* binding */ timeout$1),\n/* harmony export */   transactionMatchesNetwork: () => (/* binding */ transactionMatchesNetwork)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eth-rpc-errors */ \"(ssr)/../node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var json_rpc_random_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-rpc-random-id */ \"(ssr)/../node_modules/json-rpc-random-id/index.js\");\n/* harmony import */ var json_rpc_random_id__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_rpc_random_id__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/../node_modules/@ethereumjs/util/dist/index.js\");\n/* harmony import */ var _ethereumjs_util__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/../node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! loglevel */ \"(ssr)/../node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @toruslabs/broadcast-channel */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/broadcast-channel.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/../node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bowser */ \"(ssr)/../node_modules/bowser/src/bowser.js\");\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/cloneDeep */ \"(ssr)/../node_modules/lodash/cloneDeep.js\");\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var lodash_pickBy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/pickBy */ \"(ssr)/../node_modules/lodash/pickBy.js\");\n/* harmony import */ var lodash_pickBy__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash_pickBy__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var lodash_omitBy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/omitBy */ \"(ssr)/../node_modules/lodash/omitBy.js\");\n/* harmony import */ var lodash_omitBy__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(lodash_omitBy__WEBPACK_IMPORTED_MODULE_11__);\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$3(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */ class BaseController extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.SafeEventEmitter {\n    /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor(_ref){\n        let { config = {}, state = {} } = _ref;\n        super();\n        // Use assign since generics can't be spread: https://git.io/vpRhY\n        /**\n     * Default options used to configure this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"defaultConfig\", {});\n        /**\n     * Default state set on this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"defaultState\", {});\n        /**\n     * Determines if listeners are notified of state changes\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"disabled\", false);\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"name\", \"BaseController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"initialConfig\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"initialState\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"internalConfig\", this.defaultConfig);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"internalState\", this.defaultState);\n        this.initialState = state;\n        this.initialConfig = config;\n    }\n    /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */ get config() {\n        return this.internalConfig;\n    }\n    /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */ get state() {\n        return this.internalState;\n    }\n    /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */ configure(config) {\n        let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        let fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        if (fullUpdate) {\n            this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n            for(const key in this.internalConfig){\n                if (typeof this.internalConfig[key] !== \"undefined\") {\n                    this[key] = this.internalConfig[key];\n                }\n            }\n        } else {\n            for(const key in config){\n                /* istanbul ignore else */ if (typeof this.internalConfig[key] !== \"undefined\") {\n                    this.internalConfig[key] = config[key];\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n    /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */ update(state) {\n        let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);\n        this.emit(\"store\", this.internalState);\n    }\n    /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */ initialize() {\n        this.internalState = this.defaultState;\n        this.internalConfig = this.defaultConfig;\n        this.configure(this.initialConfig);\n        this.update(this.initialState);\n        return this;\n    }\n}\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends BaseController {\n    constructor(_ref){\n        let { config = {}, state = {} } = _ref;\n        super({\n            config,\n            state\n        });\n        // config\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"name\", \"BaseBlockTracker\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_blockResetTimeout\", void 0);\n        this.defaultState = {\n            _currentBlock: {\n                idempotencyKey: \"\"\n            },\n            _isRunning: false\n        };\n        this.defaultConfig = {\n            blockResetDuration: 20 * sec\n        };\n        this.initialize();\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    isRunning() {\n        return this.state._isRunning;\n    }\n    getCurrentBlock() {\n        return this.state._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this.state._currentBlock) {\n            return this.state._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>{\n            this.once(\"latest\", (newState)=>{\n                if (newState._currentBlock) {\n                    resolve(newState._currentBlock);\n                }\n            });\n        });\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    /**\n   * To be implemented in subclass.\n   */ _start() {\n    // default behavior is noop\n    }\n    /**\n   * To be implemented in subclass.\n   */ _end() {\n    // default behavior is noop\n    }\n    _newPotentialLatest(newBlock) {\n        const currentBlock = this.state._currentBlock;\n        // only update if blok number is higher\n        if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotency\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"removeListener\", this._onRemoveListener);\n        this.on(\"newListener\", this._onNewListener);\n    }\n    _onNewListener() {\n        this._maybeStart();\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    _maybeStart() {\n        if (this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        this._start();\n    }\n    _maybeEnd() {\n        if (!this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = false;\n        this._setupBlockResetTimeout();\n        this._end();\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this.state._currentBlock;\n        this.update({\n            _currentBlock: newBlock\n        });\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this.update({\n            _currentBlock: {\n                idempotencyKey: \"\"\n            }\n        });\n    }\n}\nconst filterNoop = ()=>true;\nconst internalEvents = [\n    \"newListener\",\n    \"removeListener\"\n];\nconst externalEventFilter = (name)=>!internalEvents.includes(name);\nfunction getRawListeners(eventEmitter, name) {\n    // prefer native\n    return typeof eventEmitter.rawListeners !== \"undefined\" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);\n}\nfunction createEventEmitterProxy(initialTarget, opts) {\n    // parse options\n    const finalOpts = opts || {};\n    let eventFilter = finalOpts.eventFilter || filterNoop;\n    if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n    if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        const oldTarget = target;\n        target = newTarget;\n        oldTarget.eventNames().filter(eventFilter).forEach((name)=>{\n            getRawListeners(oldTarget, name).forEach((handler)=>newTarget.on(name, handler));\n        });\n        // remove old listeners\n        oldTarget.removeAllListeners();\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\nfunction createSwappableProxy(initialTarget) {\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        target = newTarget;\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\n// every ten minutes\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n    constructor(_ref){\n        let { config = {}, state } = _ref;\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            currentCurrency: \"usd\",\n            conversionRate: 0,\n            conversionDate: \"N/A\",\n            nativeCurrency: \"ETH\"\n        };\n        this.defaultConfig = {\n            pollInterval: POLLING_INTERVAL\n        };\n        this.initialize();\n    }\n    //\n    // PUBLIC METHODS\n    //\n    getNativeCurrency() {\n        return this.state.nativeCurrency;\n    }\n    setNativeCurrency(nativeCurrency) {\n        this.update({\n            nativeCurrency,\n            ticker: nativeCurrency\n        });\n    }\n    getCurrentCurrency() {\n        return this.state.currentCurrency;\n    }\n    setCurrentCurrency(currentCurrency) {\n        this.update({\n            currentCurrency\n        });\n    }\n    /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */ getConversionRate() {\n        return this.state.conversionRate;\n    }\n    setConversionRate(conversionRate) {\n        this.update({\n            conversionRate\n        });\n    }\n    /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */ getConversionDate() {\n        return this.state.conversionDate;\n    }\n    setConversionDate(conversionDate) {\n        this.update({\n            conversionDate\n        });\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$2(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nconst createRandomId = json_rpc_random_id__WEBPACK_IMPORTED_MODULE_3___default()();\nfunction providerFromEngine(engine) {\n    const provider = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.SafeEventEmitter();\n    // handle both rpc send methods\n    provider.sendAsync = async (req)=>{\n        const res = await engine.handle(req);\n        if (res.error) {\n            var _res$error, _res$error2;\n            const err = (0,eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.serializeError)(res.error, {\n                fallbackError: {\n                    message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n                    code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n                }\n            });\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.ethErrors.rpc.internal(err);\n        }\n        return res.result;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    provider.send = (req, callback)=>{\n        if (typeof callback !== \"function\") {\n            throw new Error('Must provide callback to \"send\" method.');\n        }\n        engine.handle(req, callback);\n    };\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            provider.emit(\"data\", null, message);\n        });\n    }\n    provider.request = async (args)=>{\n        const req = _objectSpread$2(_objectSpread$2({}, args), {}, {\n            id: createRandomId(),\n            jsonrpc: \"2.0\"\n        });\n        const res = await provider.sendAsync(req);\n        return res;\n    };\n    return provider;\n}\nfunction providerFromMiddleware(middleware) {\n    const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.JRPCEngine();\n    engine.push(middleware);\n    const provider = providerFromEngine(engine);\n    return provider;\n}\nfunction providerAsMiddleware(provider) {\n    return async (req, res, _next, end)=>{\n        // send request to provider\n        try {\n            const providerRes = await provider.sendAsync(req);\n            res.result = providerRes;\n            return end();\n        } catch (error) {\n            return end(error.message);\n        }\n    };\n}\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 700,\n    width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n    IFRAME_STATUS: \"iframe_status\",\n    // Tell embed to create the window\n    CREATE_WINDOW: \"create_window\",\n    // Tell embed to close the window\n    CLOSE_WINDOW: \"close_window\",\n    USER_LOGGED_IN: \"user_logged_in\",\n    USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n    LOGOUT: \"logout\",\n    WALLET_INSTANCE_ID: \"wallet_instance_id\",\n    USER_INFO: \"user_info\",\n    SET_PROVIDER: \"set_provider\",\n    TOPUP: \"topup\",\n    IFRAME_STATUS: \"iframe_status\",\n    // embed has opened the window as requested\n    OPENED_WINDOW: \"opened_window\",\n    // user has closed the window from embed's side\n    CLOSED_WINDOW: \"closed_window\",\n    GET_PROVIDER_STATE: \"get_provider_state\",\n    LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\"\n};\nconst PROVIDER_JRPC_METHODS = {\n    GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n    ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n    CHAIN_CHANGED: \"wallet_chain_changed\",\n    UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n    REDIRECT_CHANNEL: \"redirect_channel\",\n    PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n    TRANSACTION_CHANNEL: \"torus_channel\",\n    MESSAGE_CHANNEL: \"torus_message_channel\",\n    WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n    WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n    WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n    WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n    THEME_CHANGE: \"theme_change_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n    LOGOUT: \"logout\",\n    ACCOUNT_IMPORTED: \"account_imported\",\n    SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n    NETWORK_CHANGE: \"network_change\",\n    SET_THEME: \"set_theme\"\n};\nfunction createChangeProviderMiddlewareMiddleware(_ref) {\n    let { changeProvider } = _ref;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n        if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n        response.result = await changeProvider(request);\n    });\n}\nfunction createTopupMiddleware(_ref2) {\n    let { topup } = _ref2;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n        if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n        response.result = await topup(request);\n    });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== targetMethod) return next();\n        if (!handler) throw new Error(`CommunicationMiddleware - ${targetMethod} not provided`);\n        const result = await handler(request);\n        if (!result) {\n            return next();\n        }\n        response.result = result;\n        return undefined;\n    });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n    const { getUserInfo, getWalletInstanceId, topup, logout, changeProvider, setIFrameStatus, handleWindowRpc, getProviderState, loginWithPrivateKey } = providerHandlers;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.mergeMiddleware)([\n        createChangeProviderMiddlewareMiddleware({\n            changeProvider\n        }),\n        createTopupMiddleware({\n            topup\n        }),\n        (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createScaffoldMiddleware)({\n            [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n            [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n            [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n            [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n            // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n            [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\n            [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n            [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\n        }),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)\n    ]);\n}\nclass BaseEmbedController extends BaseController {\n    constructor(_ref){\n        let { config = {}, state } = _ref;\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_communicationProviderProxy\", void 0);\n        this.defaultState = {\n            buttonPosition: \"bottom-right\",\n            isIFrameFullScreen: true,\n            apiKey: \"torus-default\",\n            oauthModalVisibility: false,\n            loginInProgress: false,\n            dappMetadata: {\n                name: \"\",\n                icon: \"\"\n            }\n        };\n        this.initialize();\n    }\n    /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */ initializeProvider(handlers) {\n        const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.JRPCEngine();\n        const communicationMiddleware = createCommunicationMiddleware(handlers);\n        engine.push(communicationMiddleware);\n        const communicationProvider = providerFromEngine(engine);\n        this.setCommunicationProvider(communicationProvider);\n    }\n    setCommunicationProvider(communicationProvider) {\n        if (this._communicationProviderProxy) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this._communicationProviderProxy.setTarget(communicationProvider);\n        } else {\n            this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n        }\n    }\n}\nclass CommunicationWindowManager extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.SafeEventEmitter {\n    constructor(){\n        super(...arguments);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"handleWindowRpc\", (request, response, next, end)=>{\n            const { method, params } = request;\n            if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\n                const { windowId } = params;\n                // I've been informed that a window has been opened\n                this.emit(`${windowId}:opened`);\n                response.result = true;\n                end();\n            } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n                const { windowId } = params;\n                // I've been informed that a window has been closed\n                this.emit(`${windowId}:closed`);\n                response.result = true;\n                end();\n            } else {\n                next();\n            }\n        });\n    }\n}\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nconst getTxStatusText = (txStatus)=>{\n    switch(txStatus){\n        case \"rejected\":\n        case \"unapproved\":\n        case \"failed\":\n            return ACTIVITY_STATUS_UNSUCCESSFUL;\n        case \"confirmed\":\n            return ACTIVITY_STATUS_SUCCESSFUL;\n        case \"submitted\":\n            return ACTIVITY_STATUS_PENDING;\n        case \"cancelled\":\n            return ACTIVITY_STATUS_CANCELLED;\n        default:\n            return \"\";\n    }\n};\n/**\n * General utility functions\n */ function intToHex(i) {\n    const hex = i.toString(16);\n    return `0x${hex}`;\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */ const randomId = ()=>Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */ function padWithZeroes(hexString, targetLength) {\n    if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */ function concatSig(v, r, s) {\n    const rSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.fromSigned)(r);\n    const sSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.fromSigned)(s);\n    const vSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.bufferToBigInt)(v);\n    const rStr = padWithZeroes((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.toUnsigned)(rSig).toString(\"hex\"), 64);\n    const sStr = padWithZeroes((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.toUnsigned)(sSig).toString(\"hex\"), 64);\n    const vStr = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.stripHexPrefix)((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.bigIntToHex)(vSig));\n    return (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.addHexPrefix)(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n    return new Promise((resolve)=>{\n        const timeoutRef = window.setTimeout(()=>{\n            resolve();\n            window.clearTimeout(timeoutRef);\n        }, duration);\n    });\n}\nconst getHeaders = (jwt)=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwt}`,\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n};\n/**\n * Text/number formatting utilities\n */ const formatSmallNumbers = function(number) {\n    let currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"usd\";\n    let noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const finalNumber = bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.isBigNumber(number) ? number.toNumber() : number;\n    if (!Number.isFinite(finalNumber)) return \"\";\n    const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n    const tilde = value > 0 ? \"~ \" : \"\";\n    return `${currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde}${Number(value)} ${currency.toUpperCase()}`;\n};\nconst addressSlicer = function(address) {\n    let sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    if (address.length < 11) {\n        return address;\n    }\n    if (typeof address !== \"string\") return \"\";\n    return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;\n};\nconst significantDigits = function(number) {\n    let perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    let input = !bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.isBigNumber(number) ? new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(number) : number;\n    if (input.isZero()) return input;\n    if (perc) {\n        input = input.times(new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(100));\n    }\n    let depth;\n    if (input.gte(new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(1))) {\n        depth = length_;\n    } else {\n        depth = length_ - 1 + Math.ceil(Math.log10(new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(\"1\").div(input).toNumber()));\n    }\n    const shift = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(10).pow(new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(depth));\n    const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n    return roundedNumber;\n};\nconst formatDate = (inputDate)=>{\n    const monthList = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const date = new Date(inputDate);\n    const day = date.getDate();\n    const month = monthList[date.getMonth()];\n    const year = date.getFullYear();\n    return `${day} ${month} ${year}`;\n};\nconst formatTime = (time)=>{\n    return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */ const transactionMatchesNetwork = (transaction, chainId)=>{\n    if (typeof transaction.chainId !== \"undefined\") {\n        return transaction.chainId === chainId;\n    }\n    return false;\n};\n/**\n * Signing utils\n */ const hashMessage = (message)=>{\n    const bufferedMessage = Buffer.from(message, \"utf8\");\n    const el = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.hashPersonalMessage)(bufferedMessage);\n    return el;\n};\nconst signMessage = (privateKey, data)=>{\n    const privKey = Buffer.from(privateKey, \"hex\");\n    const message = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.stripHexPrefix)(data);\n    const msgSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.ecsign)(Buffer.from(message, \"hex\"), privKey);\n    const rawMsgSig = concatSig((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.bigIntToBuffer)(msgSig.v), msgSig.r, msgSig.s);\n    return rawMsgSig;\n};\n/**\n * popup handler utils\n */ function getPopupFeatures(_ref) {\n    let { width: w, height: h } = _ref;\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nconst broadcastChannelOptions = {\n    // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n    webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\nfunction getCustomDeviceInfo() {\n    var _navigator;\n    if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n        return {\n            browser: \"Brave\"\n        };\n    }\n}\nclass UserError extends Error {\n}\nconst handleRedirectParameters = (hash, queryParameters)=>{\n    const hashParameters = {};\n    const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);\n    hashUrl.searchParams.forEach((value, key)=>{\n        hashParameters[key] = value;\n    });\n    let instanceParameters = {};\n    let error = \"\";\n    if (!queryParameters.windowId) {\n        if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n            instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n            error = hashParameters.error_description || hashParameters.error || error;\n        } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n            instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n            if (queryParameters.error) error = queryParameters.error;\n        }\n    }\n    return {\n        error,\n        instanceParameters,\n        hashParameters\n    };\n};\nfunction sleep(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n}\nclass BaseKeyringController extends BaseController {\n    constructor(_ref){\n        var _state$wallets;\n        let { config = {}, state } = _ref;\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n        };\n        this.initialize();\n    }\n    // for signing auth message\n    signAuthMessage(address, message) {\n        const keyring = this.state.wallets.find((x)=>x.address === address);\n        if (!keyring) {\n            throw new Error(\"key does not exist\");\n        }\n        const hashedMessage = hashMessage(message).toString(\"hex\");\n        const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\n        return rawMessageSig;\n    }\n}\nconst RETRIABLE_ERRORS = [\n    // ignore server overload errors\n    \"Gateway timeout\",\n    \"ETIMEDOUT\",\n    // ignore server sent html error pages\n    // or truncated json responses\n    \"failed to parse response body\",\n    // ignore errors where http req failed to establish\n    \"Failed to fetch\"\n];\nfunction checkForHttpErrors(fetchRes) {\n    // check for errors\n    switch(fetchRes.status){\n        case 405:\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.ethErrors.rpc.methodNotFound();\n        case 418:\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.ethErrors.rpc.internal({\n                message: `Request is being rate limited.`\n            });\n        case 503:\n        case 504:\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.ethErrors.rpc.internal({\n                message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`\n            });\n    }\n}\nfunction timeout(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction parseResponse(fetchRes, body) {\n    // check for error code\n    if (fetchRes.status !== 200) {\n        throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.ethErrors.rpc.internal({\n            message: `Non-200 status code: '${fetchRes.status}'`,\n            data: body\n        });\n    }\n    // check for rpc error\n    if (body.error) {\n        throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_2__.ethErrors.rpc.internal({\n            data: body.error\n        });\n    }\n    // return successful result\n    return body.result;\n}\nfunction createFetchConfigFromReq(_ref) {\n    let { req, rpcTarget, originHttpHeaderKey } = _ref;\n    const parsedUrl = new URL(rpcTarget);\n    // prepare payload\n    // copy only canonical json rpc properties\n    const payload = {\n        id: req.id,\n        jsonrpc: req.jsonrpc,\n        method: req.method,\n        params: req.params\n    };\n    // extract 'origin' parameter from request\n    const originDomain = req.origin;\n    // serialize request body\n    const serializedPayload = JSON.stringify(payload);\n    // configure fetch params\n    const fetchParams = {\n        method: \"POST\",\n        headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\"\n        },\n        body: serializedPayload\n    };\n    // optional: add request origin as header\n    if (originHttpHeaderKey && originDomain) {\n        fetchParams.headers[originHttpHeaderKey] = originDomain;\n    }\n    return {\n        fetchUrl: parsedUrl.href,\n        fetchParams\n    };\n}\nfunction createFetchMiddleware(_ref2) {\n    let { rpcTarget, originHttpHeaderKey } = _ref2;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (req, res, _next)=>{\n        const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n            req,\n            rpcTarget,\n            originHttpHeaderKey\n        });\n        // attempt request multiple times\n        const maxAttempts = 5;\n        const retryInterval = 1000;\n        for(let attempt = 0; attempt < maxAttempts; attempt++){\n            try {\n                const fetchRes = await fetch(fetchUrl, fetchParams);\n                // check for http errrors\n                checkForHttpErrors(fetchRes);\n                // parse response body\n                const fetchBody = await fetchRes.json();\n                const result = parseResponse(fetchRes, fetchBody);\n                // set result and exit retry loop\n                res.result = result;\n                return;\n            } catch (err) {\n                const errMsg = err.toString();\n                const isRetriable = RETRIABLE_ERRORS.some((phrase)=>errMsg.includes(phrase));\n                // re-throw error if not retriable\n                if (!isRetriable) {\n                    throw err;\n                }\n            }\n            // delay before retrying\n            await timeout(retryInterval);\n        }\n    });\n}\nfunction createLoggerMiddleware(options) {\n    return function loggerMiddleware(request, response, next) {\n        next((callback)=>{\n            if (response.error) {\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().warn(\"Error in RPC response:\\n\", response);\n            }\n            if (request.isTorusInternal) return;\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(`RPC (${options.origin}):`, request, \"->\", response);\n            callback();\n        });\n    };\n}\nfunction createOriginMiddleware(options) {\n    return function originMiddleware(request, _, next) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        request.origin = options.origin;\n        next();\n    };\n}\nclass BroadcastChannelHandler {\n    constructor(channelPrefix){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"bc\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"channel\", void 0);\n        const queryParameters = new URLSearchParams(window.location.search);\n        const instanceId = queryParameters.get(\"instanceId\");\n        this.channel = `${channelPrefix}_${instanceId}`;\n        this.bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(this.channel, broadcastChannelOptions);\n    }\n    getMessageFromChannel() {\n        return new Promise((resolve, reject)=>{\n            this.bc.addEventListener(\"message\", async (ev)=>{\n                this.bc.close();\n                if (ev.error) {\n                    reject(ev.error);\n                } else {\n                    resolve(ev.data);\n                }\n            });\n            this.bc.postMessage({\n                data: {\n                    type: POPUP_LOADED\n                }\n            });\n        });\n    }\n}\nclass StreamWindow extends BaseController {\n    constructor(_ref){\n        let { config, state = {} } = _ref;\n        super({\n            config,\n            state\n        });\n        // if window has been closed by users\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"closed\", false);\n        this.initialize();\n    }\n    async open() {\n        return new Promise((resolve, reject)=>{\n            const { communicationEngine, communicationWindowManager } = this.config;\n            let popupSuccess = false;\n            communicationWindowManager.once(`${this.state.windowId}:closed`, ()=>{\n                this.closed = true;\n            });\n            // Window is not open yet\n            if (!this.state.windowId) {\n                this.update({\n                    windowId: randomId()\n                });\n                communicationWindowManager.once(`${this.state.windowId}:opened`, ()=>{\n                    resolve(this);\n                });\n                // Tell the other party to create a window by prompting the user to click on something\n                communicationEngine.emit(\"notification\", {\n                    method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\n                    params: {\n                        windowId: this.state.windowId,\n                        url: this.state.url.href\n                    }\n                });\n            } else {\n                // Send this window with `windowId` the url to open via bc\n                const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(this.state.windowId, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    try {\n                        loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(ev, `receiving data on channel: ${bc.name}`);\n                        const { error } = ev;\n                        if (error) {\n                            // Popup says some error. so, we say it's not really opened\n                            reject(new Error(error));\n                            return;\n                        }\n                        const { message } = ev.data;\n                        if (message === POPUP_LOADED) {\n                            popupSuccess = true;\n                            await bc.postMessage({\n                                data: {\n                                    url: this.state.url.href,\n                                    message: \"\" // No need of a msg\n                                }\n                            });\n                            resolve(this);\n                            bc.close();\n                        }\n                    } catch (error) {\n                        reject(error);\n                        bc.close();\n                        // Something went wrong. so, we close that window\n                        this.close();\n                    }\n                });\n                // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n                // we need backoff strategy\n                // we need to wait for first attempt to succeed/fail until the second attempt\n                // If we get 429, we need to wait for a while and then try again\n                const postMsg = async ()=>{\n                    // this never throws\n                    const localResponse = await bc.postMessage({\n                        data: {\n                            message: SETUP_COMPLETE\n                        }\n                    });\n                    return localResponse;\n                };\n                let currentDelay = bc.type === \"server\" ? 1000 : 200;\n                const recursiveFn = async ()=>{\n                    if (!popupSuccess && !this.closed) {\n                        const localResponse = await postMsg();\n                        if (bc.type === \"server\") {\n                            const serverResponse = localResponse;\n                            if (serverResponse.status >= 400) {\n                                // We need to wait for a while and then try again\n                                currentDelay = Math.round(currentDelay * 1.5);\n                            }\n                        }\n                        await sleep(currentDelay);\n                        await recursiveFn();\n                    }\n                };\n                recursiveFn();\n            }\n        });\n    }\n    close() {\n        const { communicationEngine } = this.config;\n        communicationEngine.emit(\"notification\", {\n            method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n            params: {\n                windowId: this.state.windowId\n            }\n        });\n    }\n}\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler.\n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\nStreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/ /**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */ class PopupHandler extends BaseController {\n    constructor(_ref){\n        let { config, state } = _ref;\n        super({\n            config,\n            state\n        });\n        // this.id = randomId()\n        // Add in dapp storage key to all popups as a hash parameter\n        this.defaultConfig = {\n            dappStorageKey: \"\",\n            features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n            target: \"_blank\",\n            communicationEngine: null,\n            communicationWindowManager: null\n        };\n        this.defaultState = {\n            windowTimer: null,\n            window: null,\n            iClosedWindow: false,\n            windowId: \"\",\n            url: state.url\n        };\n        this.initialize();\n        this._setupTimer();\n    }\n    async open() {\n        // if window is already open\n        const { target, features, dappStorageKey, communicationEngine, communicationWindowManager } = this.config;\n        const { windowId, url } = this.state;\n        if (dappStorageKey) {\n            const urlHashParams = new URLSearchParams(url.hash.slice(1));\n            urlHashParams.append(\"dappStorageKey\", dappStorageKey);\n            url.hash = urlHashParams.toString();\n            this.update({\n                url\n            });\n        }\n        // No window has been pre-opened\n        if (!windowId) {\n            // try to open a window first\n            let localWindow = window.open(url.href, target, features);\n            if (!localWindow) {\n                // if it's blocked, open StreamWindow\n                localWindow = new StreamWindow({\n                    config: {\n                        communicationEngine,\n                        communicationWindowManager\n                    },\n                    state: {\n                        url\n                    }\n                });\n                localWindow.open();\n            }\n            this.update({\n                window: localWindow\n            });\n            return;\n        }\n        // A window has been pre-opened with a query parameter `windowId`\n        const localWindow = new StreamWindow({\n            config: {\n                communicationEngine,\n                communicationWindowManager\n            },\n            state: {\n                url,\n                windowId\n            }\n        });\n        this.update({\n            window: localWindow\n        });\n        await localWindow.open();\n    }\n    close() {\n        this.update({\n            iClosedWindow: true\n        });\n        const { window: window1 } = this.state;\n        if (window1) window1.close();\n    }\n    _setupTimer() {\n        const timer = window.setInterval(()=>{\n            const { window: window1, windowTimer, iClosedWindow } = this.state;\n            if (window1 && window1.closed) {\n                if (windowTimer) clearInterval(windowTimer);\n                if (!iClosedWindow) {\n                    this.emit(\"close\");\n                }\n                this.update({\n                    iClosedWindow: false,\n                    window: null\n                });\n            }\n            if (window1 === null && windowTimer) clearInterval(windowTimer);\n        }, 500);\n        this.update({\n            windowTimer: timer\n        });\n    }\n}\nclass PopupStoreChannel {\n    constructor(_ref){\n        let { instanceId, handleLogout, handleAccountImport, handleNetworkChange, handleSelectedAddressChange, handleThemeChange } = _ref;\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"handleLogout\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"handleAccountImport\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"handleNetworkChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"handleThemeChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"handleSelectedAddressChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"instanceId\", void 0);\n        this.instanceId = instanceId;\n        this.handleLogout = handleLogout;\n        this.handleAccountImport = handleAccountImport;\n        this.handleNetworkChange = handleNetworkChange;\n        this.handleSelectedAddressChange = handleSelectedAddressChange;\n        this.handleThemeChange = handleThemeChange;\n    }\n    setupStoreChannels() {\n        this.logoutChannel();\n        this.importAccountChannel();\n        this.networkChangeChannel();\n        this.selectedAddressChangeChannel();\n        this.themeChangedChannel();\n    }\n    logoutChannel() {\n        const logoutChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        logoutChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data;\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"received logout message\", ev);\n            if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"Logging Out\");\n                this.handleLogout();\n            }\n        });\n    }\n    importAccountChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data2;\n            if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n                var _ev$data3;\n                this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n            }\n        });\n    }\n    networkChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data4;\n            if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n                var _ev$data5;\n                this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n            }\n        });\n    }\n    themeChangedChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${BROADCAST_CHANNELS.THEME_CHANGE}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data6;\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info({\n                ev\n            });\n            if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n                var _ev$data7;\n                this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n            }\n        });\n    }\n    selectedAddressChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data8;\n            if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n                var _ev$data9;\n                this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n            }\n        });\n    }\n}\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */ class PopupWithBcHandler extends PopupHandler {\n    constructor(_ref){\n        let { config, state, instanceId } = _ref;\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"bc\", void 0);\n        this.bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(instanceId, broadcastChannelOptions);\n    }\n    /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handle(successExtraFn) {\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                this.bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            this.bc.addEventListener(\"message\", async (ev)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(ev, `receiving data on channel: ${this.bc.name}`);\n                try {\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    if (successExtraFn) await successExtraFn.call(this, data);\n                    resolve(data);\n                } catch (error) {\n                    reject(error);\n                } finally{\n                    this.bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(`opened window ${this.bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n    /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handleWithHandshake(payload, successExtraFn) {\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                this.bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            this.bc.addEventListener(\"message\", async (ev)=>{\n                try {\n                    loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(ev, `receiving data on channel: ${this.bc.name}`);\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    // Do handshake\n                    const { type = \"\" } = data;\n                    if (type === POPUP_LOADED) {\n                        // Hack with generic to use the same type for both send and receive\n                        await this.bc.postMessage({\n                            data: payload\n                        });\n                    } else if (type === POPUP_RESULT) {\n                        if (successExtraFn) await successExtraFn.call(this, data);\n                        resolve(data);\n                        // Must only close the bc after result is done\n                        this.bc.close();\n                        this.close();\n                    }\n                } catch (error) {\n                    reject(error);\n                    this.bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(`opened window ${this.bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n}\nclass RedirectHandler {\n    constructor(){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"error\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"finalQueryParams\", {});\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"instanceParameters\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"hashParameters\", void 0);\n        const { hash } = window.location;\n        const queryParameters = new URLSearchParams(window.location.search);\n        queryParameters.forEach((value, key)=>{\n            this.finalQueryParams[key] = value;\n        });\n        const { error, instanceParameters, hashParameters } = handleRedirectParameters(hash, this.finalQueryParams);\n        this.error = error;\n        this.instanceParameters = instanceParameters;\n        this.hashParameters = hashParameters;\n    }\n    async handle() {\n        return new Promise((resolve, reject)=>{\n            const { finalQueryParams, instanceParameters, hashParameters, error } = this;\n            let bc;\n            try {\n                if (!finalQueryParams.windowId) {\n                    bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${instanceParameters.instanceId}`, broadcastChannelOptions);\n                    bc.addEventListener(\"message\", async (ev)=>{\n                        if (ev.error) {\n                            reject(ev.error);\n                            window.close();\n                        } else {\n                            resolve();\n                            bc.close();\n                            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"posted\", {\n                                finalQueryParams,\n                                hashParameters,\n                                instanceParameters\n                            });\n                        }\n                    });\n                    bc.postMessage({\n                        data: {\n                            instanceParams: instanceParameters,\n                            hashParams: hashParameters,\n                            queryParams: finalQueryParams\n                        },\n                        error\n                    });\n                    setTimeout(()=>{\n                        resolve();\n                        window.location.href = window.location.origin + window.location.search + window.location.hash;\n                    }, 5000);\n                } else {\n                    bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_12__.BroadcastChannel(`${finalQueryParams.windowId}`, broadcastChannelOptions);\n                    bc.addEventListener(\"message\", async (ev)=>{\n                        const { url, message } = ev.data;\n                        if (url) {\n                            resolve();\n                            window.location.href = url;\n                        } else if (message === SETUP_COMPLETE) {\n                            await bc.postMessage({\n                                data: {\n                                    windowId: finalQueryParams.windowId,\n                                    message: POPUP_LOADED\n                                }\n                            });\n                        }\n                        if (ev.error && ev.error !== \"\") {\n                            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(ev.error);\n                            resolve();\n                            bc.close();\n                        }\n                    });\n                }\n            } catch (err) {\n                loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(err, \"something went wrong\");\n                reject(err);\n                if (bc) bc.close();\n                window.close();\n            }\n        });\n    }\n}\nconst ACTIVITY_ACTION = {\n    ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n    ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n    ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n    ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n    NORMAL: \"normal\",\n    THRESHOLD: \"threshold\",\n    IMPORTED: \"imported\"\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\n// By default, poll every 3 minutes\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n    selectedCurrency: \"USD\",\n    theme: \"dark\",\n    locale: \"en-US\",\n    accountType: ACCOUNT_CATEGORY.NORMAL,\n    contacts: [],\n    jwtToken: \"\",\n    fetchedPastTx: [],\n    pastTransactions: [],\n    paymentTx: [],\n    defaultPublicAddress: \"\",\n    customTokens: [],\n    customNfts: [],\n    crashReport: true,\n    userInfo: {\n        aggregateVerifier: \"\",\n        email: \"\",\n        name: \"\",\n        profileImage: \"\",\n        typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n        verifier: \"\",\n        verifierId: \"\"\n    }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */ class BasePreferencesController extends BaseController {\n    /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor(_ref){\n        let { config, state, defaultPreferences, signAuthMessage } = _ref;\n        super({\n            config,\n            state\n        });\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"name\", \"PreferencesController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"iframeOrigin\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"signAuthMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"defaultPreferences\", void 0);\n        if (!config.api) {\n            throw new Error(\"PreferencesController - no api specified in config.\");\n        }\n        this.defaultState = {\n            identities: {},\n            selectedAddress: \"\",\n            lastErrorMessage: \"\",\n            lastSuccessMessage: \"\"\n        };\n        this.defaultConfig = {\n            api: config.api,\n            pollInterval: DEFAULT_INTERVAL\n        };\n        this.initialize();\n        this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);\n        this.signAuthMessage = signAuthMessage;\n    }\n    setIframeOrigin(origin) {\n        this.iframeOrigin = origin;\n    }\n    getAddressState(address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        return this.state.identities[selectedAddress];\n    }\n    /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */ setSelectedAddress(selectedAddress) {\n        this.update({\n            selectedAddress\n        });\n    }\n    async getUser(address) {\n        const user = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(`${this.config.api}/user?fetchTx=false`, this.headers(address), {\n            useAPIKey: true\n        });\n        return user.data;\n    }\n    async createUser(params) {\n        const { selectedCurrency, theme, verifier, verifierId, locale, address, idToken } = params;\n        const userPayload = {\n            default_currency: selectedCurrency,\n            theme,\n            verifier,\n            verifier_id: verifierId,\n            locale,\n            idToken\n        };\n        await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/user`, userPayload, this.headers(address), {\n            useAPIKey: true\n        });\n        this.updateState({\n            theme,\n            defaultPublicAddress: address,\n            selectedCurrency,\n            locale\n        }, address);\n    }\n    async storeUserLogin(params) {\n        const { verifierId, verifier, options, address, idToken } = params;\n        if (!options.rehydrate) {\n            const browser = bowser__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getParser(window.navigator.userAgent);\n            const specialBrowser = getCustomDeviceInfo();\n            const recordLoginPayload = {\n                os: browser.getOSName(),\n                os_version: browser.getOSVersion() || \"unidentified\",\n                browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n                browser_version: browser.getBrowserVersion() || \"unidentified\",\n                platform: browser.getPlatform().type || \"desktop\",\n                hostname: this.iframeOrigin,\n                verifier,\n                verifier_id: verifierId,\n                idToken\n            };\n            await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/user/recordLogin`, recordLoginPayload, this.headers(address), {\n                useAPIKey: true\n            });\n        }\n    }\n    async setCrashReport(isEnabled) {\n        var _this$getAddressState;\n        if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n        try {\n            await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(`${this.config.api}/user`, {\n                enable_crash_reporter: isEnabled\n            }, this.headers(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                crashReport: isEnabled\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\n            return false;\n        }\n    }\n    async setUserTheme(theme) {\n        var _this$getAddressState2;\n        if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n        try {\n            await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(`${this.config.api}/user`, {\n                theme\n            }, this.headers(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                theme\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\n            return false;\n        }\n    }\n    async setUserLocale(locale) {\n        var _this$getAddressState3;\n        if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n        try {\n            await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(`${this.config.api}/user`, {\n                locale\n            }, this.headers(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                locale\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to set locale\", error);\n            return false;\n        }\n    }\n    async setSelectedCurrency(payload) {\n        var _this$getAddressState4;\n        if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n        try {\n            await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(`${this.config.api}/user`, {\n                default_currency: payload.selectedCurrency\n            }, this.headers(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                selectedCurrency: payload.selectedCurrency\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\n            return false;\n        }\n    }\n    async addContact(contact) {\n        try {\n            var _this$getAddressState5;\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/contact`, contact, this.headers(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                contacts: [\n                    ...((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || [],\n                    response.data\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to add contact\", error);\n            return false;\n        }\n    }\n    async deleteContact(contactId) {\n        try {\n            var _this$getAddressState6;\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.remove)(`${this.config.api}/contact/${contactId}`, {}, this.headers(), {\n                useAPIKey: true\n            });\n            const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter((contact)=>contact.id !== response.data.id);\n            if (finalContacts) this.updateState({\n                contacts: [\n                    ...finalContacts\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to delete contact\", error);\n            return false;\n        }\n    }\n    async revokeDiscord(idToken) {\n        try {\n            const resp = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/revoke/discord`, {\n                token: idToken\n            }, this.headers(), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(resp);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\n        }\n    }\n    async patchPastTx(body, address) {\n        try {\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(`${this.config.api}/transaction`, body, this.headers(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"successfully patched\", response);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to patch tx\", error);\n        }\n    }\n    async postPastTx(tx, address) {\n        try {\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/transaction`, tx, this.headers(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"successfully posted tx\", response);\n            return response;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error, \"unable to insert transaction\");\n        }\n    }\n    async getWalletOrders(address) {\n        try {\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(`${this.config.api}/transaction`, this.headers(address), {\n                useAPIKey: true\n            });\n            return response.success ? response.data ? response.data : [] : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to get wallet orders tx\", error);\n            return [];\n        }\n    }\n    async getTopUpOrders(address) {\n        try {\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(`${this.config.commonApiHost}/transaction`, this.headers(address), {\n                useAPIKey: true\n            });\n            return response.data || [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to fetch past Top up orders\", error);\n        }\n    }\n    async getBillBoardData() {\n        try {\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(`${this.config.api}/billboard`, this.headers(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to get billboard data\", error);\n            return [];\n        }\n    }\n    async getMessageForSigning(publicAddress) {\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/auth/message`, {\n            public_address: publicAddress\n        }, {}, {\n            useAPIKey: true\n        });\n        return response.message;\n    }\n    async getTwitterId(payload) {\n        const res = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(`${this.config.api}/twitter?screen_name=${payload.nick}`, this.headers(), {\n            useAPIKey: true\n        });\n        return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;\n    }\n    async sendEmail(payload) {\n        return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/transaction/sendemail`, payload.emailObject, this.headers(), {\n            useAPIKey: true\n        });\n    }\n    async refreshJwt() {\n        const address = this.state.selectedAddress;\n        const messageToSign = await this.getMessageForSigning(address);\n        if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n        const signedMessage = this.signAuthMessage(address, messageToSign);\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/auth/verify`, {\n            public_address: address,\n            signed_message: signedMessage\n        }, {}, {\n            useAPIKey: true\n        });\n        this.updateState({\n            jwtToken: response.token\n        }, address);\n    }\n    async getDappList() {\n        try {\n            const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(`${this.config.api}/dapps`, this.headers(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to get billboard data\", error);\n            return [];\n        }\n    }\n    async init(address, userInfo, jwtToken) {\n        let response = {\n            token: jwtToken\n        };\n        if (this.getAddressState(address)) return;\n        if (!jwtToken) {\n            const messageToSign = await this.getMessageForSigning(address);\n            if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n            const signedMessage = this.signAuthMessage(address, messageToSign);\n            response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(`${this.config.api}/auth/verify`, {\n                public_address: address,\n                signed_message: signedMessage\n            }, {}, {\n                useAPIKey: true\n            });\n        }\n        this.updateState({\n            jwtToken: response.token,\n            userInfo\n        }, address);\n    }\n    updateState(preferences, address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        const currentState = this.getAddressState(selectedAddress) || lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_9___default()(this.defaultPreferences);\n        const mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);\n        this.update({\n            identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, {\n                [selectedAddress]: mergedState\n            })\n        });\n        return mergedState;\n    }\n    headers(address) {\n        var _this$getAddressState7;\n        const selectedAddress = address || this.state.selectedAddress;\n        return getHeaders(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\");\n    }\n}\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */ var TransactionStatus;\n(function(TransactionStatus) {\n    TransactionStatus[\"approved\"] = \"approved\";\n    TransactionStatus[\"cancelled\"] = \"cancelled\";\n    TransactionStatus[\"confirmed\"] = \"confirmed\";\n    TransactionStatus[\"failed\"] = \"failed\";\n    TransactionStatus[\"finalized\"] = \"finalized\";\n    TransactionStatus[\"processed\"] = \"processed\";\n    TransactionStatus[\"rejected\"] = \"rejected\";\n    TransactionStatus[\"signed\"] = \"signed\";\n    TransactionStatus[\"submitted\"] = \"submitted\";\n    TransactionStatus[\"unapproved\"] = \"unapproved\";\n    TransactionStatus[\"dropped\"] = \"dropped\";\n    TransactionStatus[\"expired\"] = \"expired\";\n})(TransactionStatus || (TransactionStatus = {}));\nconst TRANSACTION_TYPES = {\n    CONTRACT_INTERACTION: \"contractInteraction\",\n    DEPLOY_CONTRACT: \"contractDeployment\",\n    WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n    STANDARD_TRANSACTION: \"transaction\",\n    STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\" // specific to chains like solana and casper\n};\nconst TX_EVENTS = {\n    TX_WARNING: \"tx:warning\",\n    TX_ERROR: \"tx:error\",\n    TX_FAILED: \"tx:failed\",\n    TX_CONFIRMED: \"tx:confirmed\",\n    TX_DROPPED: \"tx:dropped\",\n    TX_EXPIRED: \"tx:expired\",\n    TX_STATUS_UPDATE: \"tx:status_update\",\n    TX_UNAPPROVED: \"tx:unapproved\"\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nclass BaseTransactionStateManager extends BaseController {\n    constructor(_ref){\n        let { config, state, getCurrentChainId } = _ref;\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getCurrentChainId\", void 0);\n        this.defaultConfig = {\n            txHistoryLimit: 40\n        };\n        this.defaultState = {\n            transactions: {},\n            unapprovedTxs: {},\n            currentNetworkTxsList: []\n        };\n        this.initialize();\n        this.getCurrentChainId = getCurrentChainId;\n    }\n    getUnapprovedTxList() {\n        const chainId = this.getCurrentChainId();\n        return lodash_pickBy__WEBPACK_IMPORTED_MODULE_10___default()(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n    }\n    getTransaction(txId) {\n        const { transactions } = this.state;\n        return transactions[txId];\n    }\n    updateTransaction(txMeta) {\n        // commit txMeta to state\n        const txId = txMeta.id;\n        txMeta.updated_at = new Date().toISOString();\n        this.update({\n            transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {\n                [txId]: txMeta\n            })\n        });\n    }\n    setTxStatusRejected(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.rejected);\n        this._deleteTransaction(txId);\n    }\n    /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */ setTxStatusUnapproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.unapproved);\n    }\n    setTxStatusApproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.approved);\n    }\n    setTxStatusSigned(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.signed);\n    }\n    setTxStatusSubmitted(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.submitted);\n    }\n    setTxStatusDropped(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.dropped);\n    }\n    setTxStatusExpired(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.expired);\n    }\n    setTxStatusConfirmed(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.confirmed);\n    }\n    setTxStatusFailed(txId, error_) {\n        const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n        const txMeta = this.getTransaction(txId);\n        txMeta.error = error;\n        this.updateTransaction(txMeta);\n        this._setTransactionStatus(txId, TransactionStatus.failed);\n    }\n    /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */ isFinalState(status) {\n        return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n    }\n    /**\n   * Filters out the unapproved transactions from state\n   */ clearUnapprovedTxs() {\n        this.update({\n            transactions: lodash_omitBy__WEBPACK_IMPORTED_MODULE_11___default()(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved)\n        });\n    }\n    /**\n   * will append new transactions to old txns.\n   */ _addTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, this.state.transactions)\n        });\n    }\n    /**\n   * will set new txns, override existing if any in state.\n   */ _setTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, {})\n        });\n    }\n    _deleteTransaction(targetTransactionId) {\n        const { transactions } = this.state;\n        delete transactions[targetTransactionId];\n        this.update({\n            transactions\n        });\n    }\n    _deleteTransactions(targetTransactionIds) {\n        const { transactions } = this.state;\n        targetTransactionIds.forEach((transactionId)=>{\n            delete transactions[transactionId];\n        });\n        this.update({\n            transactions\n        });\n    }\n    _setTransactionStatus(txId, status) {\n        const txMeta = this.getTransaction(txId);\n        if (!txMeta) {\n            return;\n        }\n        txMeta.status = status;\n        // only updating status so no validation required on txn.\n        this.updateTransaction(txMeta);\n        this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n            txId,\n            status\n        });\n        if (this.isFinalState(status)) {\n            this.emit(`${txMeta.id}:finished`, txMeta);\n        } else {\n            this.emit(`${txMeta.id}:${status}`, txId);\n        }\n    }\n}\n //# sourceMappingURL=baseControllers.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycy9kaXN0L2Jhc2VDb250cm9sbGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdUU7QUFDaEY7QUFDUjtBQUMrRztBQUN6SDtBQUNkO0FBQ3FDO0FBQ0c7QUFDdkM7QUFDdUI7QUFBQTtBQUFBO0FBRW5ELFNBQVM2QixVQUFVQyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBQVMsSUFBSUcsT0FBT0MscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFBU0Msa0JBQW1CSSxDQUFBQSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztZQUFJLE9BQU9KLE9BQU9LLHdCQUF3QixDQUFDUixRQUFRTyxLQUFLRSxVQUFVO1FBQUUsRUFBQyxHQUFJUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFBVTtJQUFFLE9BQU9IO0FBQU07QUFDdFYsU0FBU1UsZ0JBQWdCQyxNQUFNO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztRQUFFLElBQUlHLFNBQVMsUUFBUUYsU0FBUyxDQUFDRCxFQUFFLEdBQUdDLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJZixVQUFVSSxPQUFPYyxTQUFTLENBQUMsR0FBR0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFBSWpELDRFQUFlQSxDQUFDMkMsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1FBQUcsS0FBS2hCLE9BQU9pQix5QkFBeUIsR0FBR2pCLE9BQU9r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S0FBSztRQUNkLE9BQU9zb0IsWUFBWSxDQUFDcUMsb0JBQW9CO1FBQ3hDLElBQUksQ0FBQy9wQixNQUFNLENBQUM7WUFDVjBuQjtRQUNGO0lBQ0Y7SUFDQXNDLG9CQUFvQkMsb0JBQW9CLEVBQUU7UUFDeEMsTUFBTSxFQUNKdkMsWUFBWSxFQUNiLEdBQUcsSUFBSSxDQUFDdG9CLEtBQUs7UUFDZDZxQixxQkFBcUJ0ckIsT0FBTyxDQUFDdXJCLENBQUFBO1lBQzNCLE9BQU94QyxZQUFZLENBQUN3QyxjQUFjO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDbHFCLE1BQU0sQ0FBQztZQUNWMG5CO1FBQ0Y7SUFDRjtJQUNBWSxzQkFBc0JOLElBQUksRUFBRXRQLE1BQU0sRUFBRTtRQUNsQyxNQUFNd1AsU0FBUyxJQUFJLENBQUNILGNBQWMsQ0FBQ0M7UUFDbkMsSUFBSSxDQUFDRSxRQUFRO1lBQ1g7UUFDRjtRQUNBQSxPQUFPeFAsTUFBTSxHQUFHQTtRQUNoQix5REFBeUQ7UUFDekQsSUFBSSxDQUFDdVAsaUJBQWlCLENBQUNDO1FBQ3ZCLElBQUksQ0FBQ2pvQixJQUFJLENBQUMybUIsVUFBVU8sZ0JBQWdCLEVBQUU7WUFDcENhO1lBQ0F0UDtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUMrUSxZQUFZLENBQUMvUSxTQUFTO1lBQzdCLElBQUksQ0FBQ3pZLElBQUksQ0FBQyxDQUFDLEVBQUVpb0IsT0FBTzlnQixFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUU4Z0I7UUFDckMsT0FBTztZQUNMLElBQUksQ0FBQ2pvQixJQUFJLENBQUMsQ0FBQyxFQUFFaW9CLE9BQU85Z0IsRUFBRSxDQUFDLENBQUMsRUFBRXNSLE9BQU8sQ0FBQyxFQUFFc1A7UUFDdEM7SUFDRjtBQUNGO0FBRXF3RCxDQUNyd0QsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jhc2UtY29udHJvbGxlcnMvZGlzdC9iYXNlQ29udHJvbGxlcnMuZXNtLmpzPzQzNWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFNhZmVFdmVudEVtaXR0ZXIsIEpSUENFbmdpbmUsIGNyZWF0ZUFzeW5jTWlkZGxld2FyZSwgbWVyZ2VNaWRkbGV3YXJlLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUgfSBmcm9tICdAdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjJztcbmltcG9ydCB7IHNlcmlhbGl6ZUVycm9yLCBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgZ2V0Q3JlYXRlUmFuZG9tSWQgZnJvbSAnanNvbi1ycGMtcmFuZG9tLWlkJztcbmltcG9ydCB7IGZyb21TaWduZWQsIGJ1ZmZlclRvQmlnSW50LCB0b1Vuc2lnbmVkLCBzdHJpcEhleFByZWZpeCwgYmlnSW50VG9IZXgsIGFkZEhleFByZWZpeCwgaGFzaFBlcnNvbmFsTWVzc2FnZSwgZWNzaWduLCBiaWdJbnRUb0J1ZmZlciB9IGZyb20gJ0BldGhlcmV1bWpzL3V0aWwnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgQnJvYWRjYXN0Q2hhbm5lbCB9IGZyb20gJ0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwnO1xuaW1wb3J0IHsgZ2V0LCBwb3N0LCBwYXRjaCwgcmVtb3ZlIH0gZnJvbSAnQHRvcnVzbGFicy9odHRwLWhlbHBlcnMnO1xuaW1wb3J0IGJvd3NlciBmcm9tICdib3dzZXInO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCBwaWNrQnksIG9taXRCeSB9IGZyb20gJ2xvZGFzaCc7XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBjb25maWd1cmF0aW9uLCBzdGF0ZSBtYW5hZ2VtZW50LCBhbmQgc3Vic2NyaXB0aW9uc1xuICovXG5jbGFzcyBCYXNlQ29udHJvbGxlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIEJhc2VDb250cm9sbGVyIGluc3RhbmNlLiBCb3RoIGluaXRpYWwgc3RhdGUgYW5kIGluaXRpYWxcbiAgICogY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBkZWZhdWx0cyB1cG9uIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgY29uZmlnID0ge30sXG4gICAgICBzdGF0ZSA9IHt9XG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoKTtcbiAgICAvLyBVc2UgYXNzaWduIHNpbmNlIGdlbmVyaWNzIGNhbid0IGJlIHNwcmVhZDogaHR0cHM6Ly9naXQuaW8vdnBSaFlcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdENvbmZpZ1wiLCB7fSk7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdGF0ZSBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFN0YXRlXCIsIHt9KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGxpc3RlbmVycyBhcmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlc1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgXCJCYXNlQ29udHJvbGxlclwiKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsQ29uZmlnXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5pdGlhbFN0YXRlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJuYWxDb25maWdcIiwgdGhpcy5kZWZhdWx0Q29uZmlnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcm5hbFN0YXRlXCIsIHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuaW5pdGlhbENvbmZpZyA9IGNvbmZpZztcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMgLSBDdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDb25maWc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMgLSBDdXJyZW50IHN0YXRlXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyAtIE5ldyBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBjb25maWcgaW5zdGVhZCBvZiBtZXJnaW5nXG4gICAqIEBwYXJhbSBmdWxsVXBkYXRlIC0gQm9vbGVhbiB0aGF0IGRlZmluZXMgaWYgdGhlIHVwZGF0ZSBpcyBwYXJ0aWFsIG9yIG5vdFxuICAgKi9cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGxldCBvdmVyd3JpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGxldCBmdWxsVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIGlmIChmdWxsVXBkYXRlKSB7XG4gICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gb3ZlcndyaXRlID8gY29uZmlnIDogT2JqZWN0LmFzc2lnbih0aGlzLmludGVybmFsQ29uZmlnLCBjb25maWcpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pbnRlcm5hbENvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuaW50ZXJuYWxDb25maWdba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgICB0aGlzW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBjb250cm9sbGVyIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIE5ldyBzdGF0ZVxuICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIHN0YXRlIGluc3RlYWQgb2YgbWVyZ2luZ1xuICAgKi9cbiAgdXBkYXRlKHN0YXRlKSB7XG4gICAgbGV0IG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gb3ZlcndyaXRlID8gX29iamVjdFNwcmVhZCQzKHt9LCBzdGF0ZSkgOiBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCB0aGlzLmludGVybmFsU3RhdGUpLCBzdGF0ZSk7XG4gICAgdGhpcy5lbWl0KFwic3RvcmVcIiwgdGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29udHJvbGxlci4gVGhpcyBzZXRzIGVhY2ggY29uZmlnIG9wdGlvbiBhcyBhIG1lbWJlclxuICAgKiB2YXJpYWJsZSBvbiB0aGlzIGluc3RhbmNlIGFuZCB0cmlnZ2VycyBhbnkgZGVmaW5lZCBzZXR0ZXJzLiBUaGlzXG4gICAqIGFsc28gc2V0cyBpbml0aWFsIHN0YXRlIGFuZCB0cmlnZ2VycyBhbnkgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyAtIFRoaXMgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLmludGVybmFsQ29uZmlnID0gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgIHRoaXMuY29uZmlndXJlKHRoaXMuaW5pdGlhbENvbmZpZyk7XG4gICAgdGhpcy51cGRhdGUodGhpcy5pbml0aWFsU3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmNvbnN0IHNlYyA9IDEwMDA7XG5jb25zdCBjYWxjdWxhdGVTdW0gPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWU7XG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbXCJzeW5jXCIsIFwibGF0ZXN0XCJdO1xuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjb25maWcgPSB7fSxcbiAgICAgIHN0YXRlID0ge31cbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIC8vIGNvbmZpZ1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgXCJCYXNlQmxvY2tUcmFja2VyXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ibG9ja1Jlc2V0VGltZW91dFwiLCB2b2lkIDApO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgX2N1cnJlbnRCbG9jazoge1xuICAgICAgICBpZGVtcG90ZW5jeUtleTogXCJcIlxuICAgICAgfSxcbiAgICAgIF9pc1J1bm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBibG9ja1Jlc2V0RHVyYXRpb246IDIwICogc2VjXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAvLyBiaW5kIGZ1bmN0aW9ucyBmb3IgaW50ZXJuYWwgdXNlXG4gICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IHRoaXMuX29uTmV3TGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrID0gdGhpcy5fcmVzZXRDdXJyZW50QmxvY2suYmluZCh0aGlzKTtcbiAgICAvLyBsaXN0ZW4gZm9yIGhhbmRsZXIgY2hhbmdlc1xuICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgfVxuICBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuX2lzUnVubmluZztcbiAgfVxuICBnZXRDdXJyZW50QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcbiAgfVxuICBhc3luYyBnZXRMYXRlc3RCbG9jaygpIHtcbiAgICAvLyByZXR1cm4gaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcbiAgICB9XG4gICAgLy8gd2FpdCBmb3IgYSBuZXcgbGF0ZXN0IGJsb2NrXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMub25jZShcImxhdGVzdFwiLCBuZXdTdGF0ZSA9PiB7XG4gICAgICAgIGlmIChuZXdTdGF0ZS5fY3VycmVudEJsb2NrKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXdTdGF0ZS5fY3VycmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gcmV0dXJuIG5ld2x5IHNldCBjdXJyZW50IGJsb2NrXG4gICAgcmV0dXJuIGxhdGVzdEJsb2NrO1xuICB9XG4gIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgLy8gdHJpZ2dlciBzdG9wIGNoZWNrIGp1c3QgaW4gY2FzZVxuICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXG4gICAqL1xuICBfc3RhcnQoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cbiAgLyoqXG4gICAqIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgKi9cbiAgX2VuZCgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuICBfbmV3UG90ZW50aWFsTGF0ZXN0KG5ld0Jsb2NrKSB7XG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrO1xuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgIGlmIChjdXJyZW50QmxvY2sgJiYgbmV3QmxvY2suaWRlbXBvdGVuY3lLZXkgPT09IGN1cnJlbnRCbG9jay5pZGVtcG90ZW5jeUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXRDdXJyZW50QmxvY2sobmV3QmxvY2spO1xuICB9XG4gIF9zZXR1cEludGVybmFsRXZlbnRzKCkge1xuICAgIC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGlkZW1wb3RlbmN5XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcIm5ld0xpc3RlbmVyXCIsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJyZW1vdmVMaXN0ZW5lclwiLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICAvLyB0aGVuIGFkZCB0aGVtXG4gICAgdGhpcy5vbihcInJlbW92ZUxpc3RlbmVyXCIsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgIHRoaXMub24oXCJuZXdMaXN0ZW5lclwiLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgfVxuICBfb25OZXdMaXN0ZW5lcigpIHtcbiAgICB0aGlzLl9tYXliZVN0YXJ0KCk7XG4gIH1cbiAgX29uUmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgLy8gYHJlbW92ZUxpc3RlbmVyYCBpcyBjYWxsZWQgKmFmdGVyKiB0aGUgbGlzdGVuZXIgaXMgcmVtb3ZlZFxuICAgIGlmICh0aGlzLl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkgPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21heWJlRW5kKCk7XG4gIH1cbiAgX21heWJlU3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgIC8vIGNhbmNlbCBzZXR0aW5nIGxhdGVzdCBibG9jayB0byBzdGFsZVxuICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgdGhpcy5fc3RhcnQoKTtcbiAgfVxuICBfbWF5YmVFbmQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpO1xuICAgIHRoaXMuX2VuZCgpO1xuICB9XG4gIF9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkge1xuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHMubWFwKGV2ZW50TmFtZSA9PiB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSkucmVkdWNlKGNhbGN1bGF0ZVN1bSk7XG4gIH1cbiAgX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jaykge1xuICAgIGNvbnN0IG9sZEJsb2NrID0gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIF9jdXJyZW50QmxvY2s6IG5ld0Jsb2NrXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwibGF0ZXN0XCIsIG5ld0Jsb2NrKTtcbiAgICB0aGlzLmVtaXQoXCJzeW5jXCIsIHtcbiAgICAgIG9sZEJsb2NrLFxuICAgICAgbmV3QmxvY2tcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpIHtcbiAgICAvLyBjbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dFxuICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgLy8gY2xlYXIgbGF0ZXN0IGJsb2NrIHdoZW4gc3RhbGVcbiAgICB0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fcmVzZXRDdXJyZW50QmxvY2ssIHRoaXMuY29uZmlnLmJsb2NrUmVzZXREdXJhdGlvbik7XG4gICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKTtcbiAgICB9XG4gIH1cbiAgX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgX3Jlc2V0Q3VycmVudEJsb2NrKCkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIF9jdXJyZW50QmxvY2s6IHtcbiAgICAgICAgaWRlbXBvdGVuY3lLZXk6IFwiXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBmaWx0ZXJOb29wID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IGludGVybmFsRXZlbnRzID0gW1wibmV3TGlzdGVuZXJcIiwgXCJyZW1vdmVMaXN0ZW5lclwiXTtcbmNvbnN0IGV4dGVybmFsRXZlbnRGaWx0ZXIgPSBuYW1lID0+ICFpbnRlcm5hbEV2ZW50cy5pbmNsdWRlcyhuYW1lKTtcbmZ1bmN0aW9uIGdldFJhd0xpc3RlbmVycyhldmVudEVtaXR0ZXIsIG5hbWUpIHtcbiAgLy8gcHJlZmVyIG5hdGl2ZVxuICByZXR1cm4gdHlwZW9mIGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMgIT09IFwidW5kZWZpbmVkXCIgPyBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzKG5hbWUpIDogZXZlbnRFbWl0dGVyLmxpc3RlbmVycyhuYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5KGluaXRpYWxUYXJnZXQsIG9wdHMpIHtcbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBjb25zdCBmaW5hbE9wdHMgPSBvcHRzIHx8IHt9O1xuICBsZXQgZXZlbnRGaWx0ZXIgPSBmaW5hbE9wdHMuZXZlbnRGaWx0ZXIgfHwgZmlsdGVyTm9vcDtcbiAgaWYgKHR5cGVvZiBldmVudEZpbHRlciA9PT0gXCJzdHJpbmdcIiAmJiBldmVudEZpbHRlciA9PT0gXCJza2lwSW50ZXJuYWxcIikgZXZlbnRGaWx0ZXIgPSBleHRlcm5hbEV2ZW50RmlsdGVyO1xuICBpZiAodHlwZW9mIGV2ZW50RmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUV2ZW50RW1pdHRlclByb3h5IC0gSW52YWxpZCBldmVudEZpbHRlclwiKTtcbiAgbGV0IHRhcmdldCA9IGluaXRpYWxUYXJnZXQ7XG4gIGxldCBzZXRUYXJnZXQgPSBuZXdUYXJnZXQgPT4ge1xuICAgIGNvbnN0IG9sZFRhcmdldCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSBuZXdUYXJnZXQ7XG4gICAgb2xkVGFyZ2V0LmV2ZW50TmFtZXMoKS5maWx0ZXIoZXZlbnRGaWx0ZXIpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBnZXRSYXdMaXN0ZW5lcnMob2xkVGFyZ2V0LCBuYW1lKS5mb3JFYWNoKGhhbmRsZXIgPT4gbmV3VGFyZ2V0Lm9uKG5hbWUsIGhhbmRsZXIpKTtcbiAgICB9KTtcbiAgICAvLyByZW1vdmUgb2xkIGxpc3RlbmVyc1xuICAgIG9sZFRhcmdldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQ6IChfLCBuYW1lKSA9PiB7XG4gICAgICAvLyBvdmVycmlkZSBgc2V0VGFyZ2V0YCBhY2Nlc3NcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSByZXR1cm4gc2V0VGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSB7XG4gICAgICAgIHNldFRhcmdldCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTd2FwcGFibGVQcm94eShpbml0aWFsVGFyZ2V0KSB7XG4gIGxldCB0YXJnZXQgPSBpbml0aWFsVGFyZ2V0O1xuICBsZXQgc2V0VGFyZ2V0ID0gbmV3VGFyZ2V0ID0+IHtcbiAgICB0YXJnZXQgPSBuZXdUYXJnZXQ7XG4gIH07XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikgcmV0dXJuIHNldFRhcmdldDtcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6IChfLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgLy8gYWxsb3cgYHNldFRhcmdldGAgb3ZlcnJpZGVzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuLy8gZXZlcnkgdGVuIG1pbnV0ZXNcbmNvbnN0IFBPTExJTkdfSU5URVJWQUwgPSA2MDAwMDA7XG5jbGFzcyBCYXNlQ3VycmVuY3lDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGNvbmZpZyA9IHt9LFxuICAgICAgc3RhdGVcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgY3VycmVudEN1cnJlbmN5OiBcInVzZFwiLFxuICAgICAgY29udmVyc2lvblJhdGU6IDAsXG4gICAgICBjb252ZXJzaW9uRGF0ZTogXCJOL0FcIixcbiAgICAgIG5hdGl2ZUN1cnJlbmN5OiBcIkVUSFwiXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBwb2xsSW50ZXJ2YWw6IFBPTExJTkdfSU5URVJWQUxcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIC8vXG4gIC8vIFBVQkxJQyBNRVRIT0RTXG4gIC8vXG4gIGdldE5hdGl2ZUN1cnJlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm5hdGl2ZUN1cnJlbmN5O1xuICB9XG4gIHNldE5hdGl2ZUN1cnJlbmN5KG5hdGl2ZUN1cnJlbmN5KSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgbmF0aXZlQ3VycmVuY3ksXG4gICAgICB0aWNrZXI6IG5hdGl2ZUN1cnJlbmN5XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q3VycmVudEN1cnJlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRDdXJyZW5jeTtcbiAgfVxuICBzZXRDdXJyZW50Q3VycmVuY3koY3VycmVudEN1cnJlbmN5KSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgY3VycmVudEN1cnJlbmN5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgY29udmVyc2lvblJhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNvbnZlcnNpb24gcmF0ZSBmcm9tIEVUSCB0byB0aGUgc2VsZWN0ZWQgY3VycmVuY3kuXG4gICAqXG4gICAqL1xuICBnZXRDb252ZXJzaW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb252ZXJzaW9uUmF0ZTtcbiAgfVxuICBzZXRDb252ZXJzaW9uUmF0ZShjb252ZXJzaW9uUmF0ZSkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIGNvbnZlcnNpb25SYXRlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgY29udmVyc2lvbkRhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGRhdGUgYXQgd2hpY2ggdGhlIGNvbnZlcnNpb24gcmF0ZSB3YXMgc2V0LiBFeHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIG1pZG5pZ2h0IG9mXG4gICAqIEphbnVhcnkgMSwgMTk3MFxuICAgKlxuICAgKi9cbiAgZ2V0Q29udmVyc2lvbkRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udmVyc2lvbkRhdGU7XG4gIH1cbiAgc2V0Q29udmVyc2lvbkRhdGUoY29udmVyc2lvbkRhdGUpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBjb252ZXJzaW9uRGF0ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jb25zdCBjcmVhdGVSYW5kb21JZCA9IGdldENyZWF0ZVJhbmRvbUlkKCk7XG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IFNhZmVFdmVudEVtaXR0ZXIoKTtcbiAgLy8gaGFuZGxlIGJvdGggcnBjIHNlbmQgbWV0aG9kc1xuICBwcm92aWRlci5zZW5kQXN5bmMgPSBhc3luYyByZXEgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGVuZ2luZS5oYW5kbGUocmVxKTtcbiAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICB2YXIgX3JlcyRlcnJvciwgX3JlcyRlcnJvcjI7XG4gICAgICBjb25zdCBlcnIgPSBzZXJpYWxpemVFcnJvcihyZXMuZXJyb3IsIHtcbiAgICAgICAgZmFsbGJhY2tFcnJvcjoge1xuICAgICAgICAgIG1lc3NhZ2U6ICgoX3JlcyRlcnJvciA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvci5tZXNzYWdlKSB8fCByZXMuZXJyb3IudG9TdHJpbmcoKSxcbiAgICAgICAgICBjb2RlOiAoKF9yZXMkZXJyb3IyID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjIuY29kZSkgfHwgLTMyNjAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgcHJvdmlkZXIuc2VuZCA9IChyZXEsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBjYWxsYmFjayB0byBcInNlbmRcIiBtZXRob2QuJyk7XG4gICAgfVxuICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gIH07XG4gIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICBpZiAoZW5naW5lLm9uKSB7XG4gICAgZW5naW5lLm9uKFwibm90aWZpY2F0aW9uXCIsIG1lc3NhZ2UgPT4ge1xuICAgICAgcHJvdmlkZXIuZW1pdChcImRhdGFcIiwgbnVsbCwgbWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgcHJvdmlkZXIucmVxdWVzdCA9IGFzeW5jIGFyZ3MgPT4ge1xuICAgIGNvbnN0IHJlcSA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIGFyZ3MpLCB7fSwge1xuICAgICAgaWQ6IGNyZWF0ZVJhbmRvbUlkKCksXG4gICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gIGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpO1xuICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICByZXR1cm4gcHJvdmlkZXI7XG59XG5mdW5jdGlvbiBwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyUmVzID0gYXdhaXQgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSk7XG4gICAgICByZXMucmVzdWx0ID0gcHJvdmlkZXJSZXM7XG4gICAgICByZXR1cm4gZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlbmQoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XID0ge1xuICBoZWlnaHQ6IDY2MCxcbiAgd2lkdGg6IDM3NVxufTtcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA3NDAsXG4gIHdpZHRoOiAxMzE1XG59O1xuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzAwLFxuICB3aWR0aDogMTIwMFxufTtcbmNvbnN0IEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XID0ge1xuICBoZWlnaHQ6IDcwMCxcbiAgd2lkdGg6IDQ1MFxufTtcbmNvbnN0IFBPUFVQX0xPQURFRCA9IFwicG9wdXBfbG9hZGVkXCI7XG5jb25zdCBQT1BVUF9SRVNVTFQgPSBcInBvcHVwX3Jlc3VsdFwiO1xuY29uc3QgU0VUVVBfQ09NUExFVEUgPSBcInNldHVwX2NvbXBsZXRlXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQUxMID0gXCJ3YWxsZXRBY3Rpdml0eS5hbGxUcmFuc2FjdGlvbnNcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9TRU5EID0gXCJ3YWxsZXRBY3Rpdml0eS5zZW5kXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQlVSTiA9IFwid2FsbGV0QWN0aXZpdHkuYnVyblwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX1JFQ0VJVkUgPSBcIndhbGxldEFjdGl2aXR5LnJlY2VpdmVcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9UT1BVUCA9IFwid2FsbGV0QWN0aXZpdHkudG9wdXBcIjtcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9BTEwgPSBcIndhbGxldEFjdGl2aXR5LmFsbFwiO1xuY29uc3QgQUNUSVZJVFlfUEVSSU9EX1dFRUtfT05FID0gXCJ3YWxsZXRBY3Rpdml0eS5sYXN0T25lV2Vla1wiO1xuY29uc3QgQUNUSVZJVFlfUEVSSU9EX01PTlRIX09ORSA9IFwid2FsbGV0QWN0aXZpdHkubGFzdE9uZU1vbnRoXCI7XG5jb25zdCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfU0lYID0gXCJ3YWxsZXRBY3Rpdml0eS5sYXN0U2l4TW9udHNcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19TVUNDRVNTRlVMID0gXCJ3YWxsZXRBY3Rpdml0eS5zdWNjZXNzZnVsXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMID0gXCJ3YWxsZXRBY3Rpdml0eS51bnN1Y2Nlc3NmdWxcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19QRU5ESU5HID0gXCJ3YWxsZXRBY3Rpdml0eS5wZW5kaW5nXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTEVEID0gXCJ3YWxsZXRBY3Rpdml0eS5jYW5jZWxsZWRcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HID0gXCJ3YWxsZXRBY3Rpdml0eS5jYW5jZWxsaW5nXCI7XG5jb25zdCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMgPSB7XG4gIElGUkFNRV9TVEFUVVM6IFwiaWZyYW1lX3N0YXR1c1wiLFxuICAvLyBUZWxsIGVtYmVkIHRvIGNyZWF0ZSB0aGUgd2luZG93XG4gIENSRUFURV9XSU5ET1c6IFwiY3JlYXRlX3dpbmRvd1wiLFxuICAvLyBUZWxsIGVtYmVkIHRvIGNsb3NlIHRoZSB3aW5kb3dcbiAgQ0xPU0VfV0lORE9XOiBcImNsb3NlX3dpbmRvd1wiLFxuICBVU0VSX0xPR0dFRF9JTjogXCJ1c2VyX2xvZ2dlZF9pblwiLFxuICBVU0VSX0xPR0dFRF9PVVQ6IFwidXNlcl9sb2dnZWRfb3V0XCJcbn07XG5jb25zdCBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUyA9IHtcbiAgTE9HT1VUOiBcImxvZ291dFwiLFxuICBXQUxMRVRfSU5TVEFOQ0VfSUQ6IFwid2FsbGV0X2luc3RhbmNlX2lkXCIsXG4gIFVTRVJfSU5GTzogXCJ1c2VyX2luZm9cIixcbiAgU0VUX1BST1ZJREVSOiBcInNldF9wcm92aWRlclwiLFxuICBUT1BVUDogXCJ0b3B1cFwiLFxuICBJRlJBTUVfU1RBVFVTOiBcImlmcmFtZV9zdGF0dXNcIixcbiAgLy8gZW1iZWQgaGFzIG9wZW5lZCB0aGUgd2luZG93IGFzIHJlcXVlc3RlZFxuICBPUEVORURfV0lORE9XOiBcIm9wZW5lZF93aW5kb3dcIixcbiAgLy8gdXNlciBoYXMgY2xvc2VkIHRoZSB3aW5kb3cgZnJvbSBlbWJlZCdzIHNpZGVcbiAgQ0xPU0VEX1dJTkRPVzogXCJjbG9zZWRfd2luZG93XCIsXG4gIEdFVF9QUk9WSURFUl9TVEFURTogXCJnZXRfcHJvdmlkZXJfc3RhdGVcIixcbiAgTE9HSU5fV0lUSF9QUklWQVRFX0tFWTogXCJsb2dpbl93aXRoX3ByaXZhdGVfa2V5XCJcbn07XG5jb25zdCBQUk9WSURFUl9KUlBDX01FVEhPRFMgPSB7XG4gIEdFVF9QUk9WSURFUl9TVEFURTogXCJ3YWxsZXRfZ2V0X3Byb3ZpZGVyX3N0YXRlXCJcbn07XG5jb25zdCBQUk9WSURFUl9OT1RJRklDQVRJT05TID0ge1xuICBBQ0NPVU5UU19DSEFOR0VEOiBcIndhbGxldF9hY2NvdW50c19jaGFuZ2VkXCIsXG4gIENIQUlOX0NIQU5HRUQ6IFwid2FsbGV0X2NoYWluX2NoYW5nZWRcIixcbiAgVU5MT0NLX1NUQVRFX0NIQU5HRUQ6IFwid2FsbGV0X3VubG9ja19zdGF0ZV9jaGFuZ2VkXCJcbn07XG5jb25zdCBCUk9BRENBU1RfQ0hBTk5FTFMgPSB7XG4gIFJFRElSRUNUX0NIQU5ORUw6IFwicmVkaXJlY3RfY2hhbm5lbFwiLFxuICBQUk9WSURFUl9DSEFOR0VfQ0hBTk5FTDogXCJ0b3J1c19wcm92aWRlcl9jaGFuZ2VfY2hhbm5lbFwiLFxuICBUUkFOU0FDVElPTl9DSEFOTkVMOiBcInRvcnVzX2NoYW5uZWxcIixcbiAgTUVTU0FHRV9DSEFOTkVMOiBcInRvcnVzX21lc3NhZ2VfY2hhbm5lbFwiLFxuICBXQUxMRVRfTE9HT1VUX0NIQU5ORUw6IFwid2FsbGV0X2xvZ291dF9jaGFubmVsXCIsXG4gIFdBTExFVF9TRUxFQ1RFRF9BRERSRVNTX0NIQU5ORUw6IFwid2FsbGV0X3NlbGVjdGVkX2FkZHJlc3NfY2hhbm5lbFwiLFxuICBXQUxMRVRfTkVUV09SS19DSEFOR0VfQ0hBTk5FTDogXCJ3YWxsZXRfbmV0d29ya19jaGFuZ2VfY2hhbm5lbFwiLFxuICBXQUxMRVRfQUNDT1VOVF9JTVBPUlRfQ0hBTk5FTDogXCJ3YWxsZXRfYWNjb3VudF9pbXBvcnRfY2hhbm5lbFwiLFxuICBUSEVNRV9DSEFOR0U6IFwidGhlbWVfY2hhbmdlX2NoYW5uZWxcIlxufTtcbmNvbnN0IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTID0ge1xuICBMT0dPVVQ6IFwibG9nb3V0XCIsXG4gIEFDQ09VTlRfSU1QT1JURUQ6IFwiYWNjb3VudF9pbXBvcnRlZFwiLFxuICBTRUxFQ1RFRF9BRERSRVNTX0NIQU5HRTogXCJzZWxlY3RlZF9hZGRyZXNzX2NoYW5nZVwiLFxuICBORVRXT1JLX0NIQU5HRTogXCJuZXR3b3JrX2NoYW5nZVwiLFxuICBTRVRfVEhFTUU6IFwic2V0X3RoZW1lXCJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYW5nZVByb3ZpZGVyTWlkZGxld2FyZU1pZGRsZXdhcmUoX3JlZikge1xuICBsZXQge1xuICAgIGNoYW5nZVByb3ZpZGVyXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZFxuICAgIH0gPSByZXF1ZXN0O1xuICAgIGlmIChtZXRob2QgIT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNFVF9QUk9WSURFUikgcmV0dXJuIG5leHQoKTtcbiAgICBpZiAoIWNoYW5nZVByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDb21tdW5pY2F0aW9uTWlkZGxld2FyZSAtIG9wdHMuY2hhbmdlUHJvdmlkZXIgbm90IHByb3ZpZGVkXCIpO1xuICAgIHJlc3BvbnNlLnJlc3VsdCA9IGF3YWl0IGNoYW5nZVByb3ZpZGVyKHJlcXVlc3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvcHVwTWlkZGxld2FyZShfcmVmMikge1xuICBsZXQge1xuICAgIHRvcHVwXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2RcbiAgICB9ID0gcmVxdWVzdDtcbiAgICBpZiAobWV0aG9kICE9PSBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5UT1BVUCkgcmV0dXJuIG5leHQoKTtcbiAgICBpZiAoIXRvcHVwKSB0aHJvdyBuZXcgRXJyb3IoXCJDb21tdW5pY2F0aW9uTWlkZGxld2FyZSAtIG9wdHMudG9wdXAgbm90IHByb3ZpZGVkXCIpO1xuICAgIHJlc3BvbnNlLnJlc3VsdCA9IGF3YWl0IHRvcHVwKHJlcXVlc3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZSh0YXJnZXRNZXRob2QsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2RcbiAgICB9ID0gcmVxdWVzdDtcbiAgICBpZiAobWV0aG9kICE9PSB0YXJnZXRNZXRob2QpIHJldHVybiBuZXh0KCk7XG4gICAgaWYgKCFoYW5kbGVyKSB0aHJvdyBuZXcgRXJyb3IoYENvbW11bmljYXRpb25NaWRkbGV3YXJlIC0gJHt0YXJnZXRNZXRob2R9IG5vdCBwcm92aWRlZGApO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIocmVxdWVzdCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICAgIHJlc3BvbnNlLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW11bmljYXRpb25NaWRkbGV3YXJlKHByb3ZpZGVySGFuZGxlcnMpIHtcbiAgY29uc3Qge1xuICAgIGdldFVzZXJJbmZvLFxuICAgIGdldFdhbGxldEluc3RhbmNlSWQsXG4gICAgdG9wdXAsXG4gICAgbG9nb3V0LFxuICAgIGNoYW5nZVByb3ZpZGVyLFxuICAgIHNldElGcmFtZVN0YXR1cyxcbiAgICBoYW5kbGVXaW5kb3dScGMsXG4gICAgZ2V0UHJvdmlkZXJTdGF0ZSxcbiAgICBsb2dpbldpdGhQcml2YXRlS2V5XG4gIH0gPSBwcm92aWRlckhhbmRsZXJzO1xuICByZXR1cm4gbWVyZ2VNaWRkbGV3YXJlKFtjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlKHtcbiAgICBjaGFuZ2VQcm92aWRlclxuICB9KSwgY3JlYXRlVG9wdXBNaWRkbGV3YXJlKHtcbiAgICB0b3B1cFxuICB9KSwgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKHtcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HT1VUXTogbG9nb3V0LFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5XQUxMRVRfSU5TVEFOQ0VfSURdOiBnZXRXYWxsZXRJbnN0YW5jZUlkLFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5VU0VSX0lORk9dOiBnZXRVc2VySW5mbyxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuSUZSQU1FX1NUQVRVU106IHNldElGcmFtZVN0YXR1cyxcbiAgICAvLyBEbyB0aGlzIGluIHRoZSBvcmNoZXN0cmF0b3IgYmVjYXVzZSBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlciBuZWVkcyB0byBiZSBwYXNzZWQgaW50byBQb3B1cEhhbmRsZXJzXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLk9QRU5FRF9XSU5ET1ddOiBoYW5kbGVXaW5kb3dScGMsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1ddOiBoYW5kbGVXaW5kb3dScGMsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkdFVF9QUk9WSURFUl9TVEFURV06IGdldFByb3ZpZGVyU3RhdGVcbiAgfSksIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZShDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dJTl9XSVRIX1BSSVZBVEVfS0VZLCBsb2dpbldpdGhQcml2YXRlS2V5KV0pO1xufVxuXG5jbGFzcyBCYXNlRW1iZWRDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGNvbmZpZyA9IHt9LFxuICAgICAgc3RhdGVcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgYnV0dG9uUG9zaXRpb246IFwiYm90dG9tLXJpZ2h0XCIsXG4gICAgICBpc0lGcmFtZUZ1bGxTY3JlZW46IHRydWUsXG4gICAgICBhcGlLZXk6IFwidG9ydXMtZGVmYXVsdFwiLFxuICAgICAgb2F1dGhNb2RhbFZpc2liaWxpdHk6IGZhbHNlLFxuICAgICAgbG9naW5JblByb2dyZXNzOiBmYWxzZSxcbiAgICAgIGRhcHBNZXRhZGF0YToge1xuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICBpY29uOiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIGJ5IG9yY2hlc3RyYXRvciBvbmNlIHdoaWxlIGluaXRpYWxpemluZyB0aGUgY2xhc3NcbiAgICogQHBhcmFtIGhhbmRsZXJzIC0gSlJQQyBoYW5kbGVycyBmb3IgcHJvdmlkZXJcbiAgICogQHJldHVybnMgLSBwcm92aWRlciAtIFJldHVybnMgdGhlIHByb3ZpZGVyUHJveHlcbiAgICovXG4gIGluaXRpYWxpemVQcm92aWRlcihoYW5kbGVycykge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gICAgY29uc3QgY29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgPSBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZShoYW5kbGVycyk7XG4gICAgZW5naW5lLnB1c2goY29tbXVuaWNhdGlvbk1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IGNvbW11bmljYXRpb25Qcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuc2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyKGNvbW11bmljYXRpb25Qcm92aWRlcik7XG4gIH1cbiAgc2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyKGNvbW11bmljYXRpb25Qcm92aWRlcikge1xuICAgIGlmICh0aGlzLl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkuc2V0VGFyZ2V0KGNvbW11bmljYXRpb25Qcm92aWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5ID0gY3JlYXRlU3dhcHBhYmxlUHJveHkoY29tbXVuaWNhdGlvblByb3ZpZGVyKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQ29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVXaW5kb3dScGNcIiwgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSByZXF1ZXN0O1xuICAgICAgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuT1BFTkVEX1dJTkRPVykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSA9IHBhcmFtcztcbiAgICAgICAgLy8gSSd2ZSBiZWVuIGluZm9ybWVkIHRoYXQgYSB3aW5kb3cgaGFzIGJlZW4gb3BlbmVkXG4gICAgICAgIHRoaXMuZW1pdChgJHt3aW5kb3dJZH06b3BlbmVkYCk7XG4gICAgICAgIHJlc3BvbnNlLnJlc3VsdCA9IHRydWU7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1cpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0gPSBwYXJhbXM7XG4gICAgICAgIC8vIEkndmUgYmVlbiBpbmZvcm1lZCB0aGF0IGEgd2luZG93IGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICB0aGlzLmVtaXQoYCR7d2luZG93SWR9OmNsb3NlZGApO1xuICAgICAgICByZXNwb25zZS5yZXN1bHQgPSB0cnVlO1xuICAgICAgICBlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcbiAgR09PR0xFOiBcImdvb2dsZVwiLFxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXG4gIEFQUExFOiBcImFwcGxlXCIsXG4gIExJTkU6IFwibGluZVwiLFxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXG4gIEtBS0FPOiBcImtha2FvXCIsXG4gIExJTktFRElOOiBcImxpbmtlZGluXCIsXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxuICBXRUlCTzogXCJ3ZWlib1wiLFxuICBXRUNIQVQ6IFwid2VjaGF0XCIsXG4gIEVNQUlMX1BBU1NXT1JETEVTUzogXCJlbWFpbF9wYXNzd29yZGxlc3NcIlxufTtcbmNvbnN0IFBBWU1FTlRfUFJPVklERVIgPSB7XG4gIE1PT05QQVk6IFwibW9vbnBheVwiLFxuICBXWVJFOiBcInd5cmVcIixcbiAgUkFNUE5FVFdPUks6IFwicmFtcG5ldHdvcmtcIixcbiAgWEFOUE9PTDogXCJ4YW5wb29sXCIsXG4gIE1FUkNVUllPOiBcIm1lcmN1cnlvXCIsXG4gIFRSQU5TQUs6IFwidHJhbnNha1wiXG59O1xuXG5jb25zdCBnZXRUeFN0YXR1c1RleHQgPSB0eFN0YXR1cyA9PiB7XG4gIHN3aXRjaCAodHhTdGF0dXMpIHtcbiAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICBjYXNlIFwidW5hcHByb3ZlZFwiOlxuICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgIHJldHVybiBBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMO1xuICAgIGNhc2UgXCJjb25maXJtZWRcIjpcbiAgICAgIHJldHVybiBBQ1RJVklUWV9TVEFUVVNfU1VDQ0VTU0ZVTDtcbiAgICBjYXNlIFwic3VibWl0dGVkXCI6XG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkc7XG4gICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgcmV0dXJuIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICBjb25zdCBoZXggPSBpLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGAweCR7aGV4fWA7XG59XG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyLiBEb24ndCB1c2UgZm9yIGNyeXB0b2dyYXBoaWMgcHVycG9zZXMuXG4gKiBAcmV0dXJucyBhIHJhbmRvbSBudW1iZXJcbiAqL1xuY29uc3QgcmFuZG9tSWQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbi8qKlxuICogUGFkcyB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIGhleCBzdHJpbmcgd2l0aCB6ZXJvZXMgdW50aWwgaXQgcmVhY2hlcyB0aGVcbiAqIHRhcmdldCBsZW5ndGguIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgYWxyZWFkeSBsb25nZXIgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAqIHRhcmdldCBsZW5ndGgsIGl0IGlzIHJldHVybmVkIHVubW9kaWZpZWQuXG4gKlxuICogSWYgdGhlIGlucHV0IHN0cmluZyBpcyBcIjB4XCItcHJlZml4ZWQgb3Igbm90IGEgaGV4IHN0cmluZywgYW4gZXJyb3Igd2lsbCBiZVxuICogdGhyb3duLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHBhZCB3aXRoIHplcm9lcy5cbiAqIEBwYXJhbSB0YXJnZXRMZW5ndGggLSBUaGUgdGFyZ2V0IGxlbmd0aCBvZiB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGlucHV0IHN0cmluZyBmcm9udC1wYWRkZWQgd2l0aCB6ZXJvZXMsIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIGlmIGl0IHdhcyBhbHJlYWR5IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0byB0aGUgdGFyZ2V0IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyhoZXhTdHJpbmcsIHRhcmdldExlbmd0aCkge1xuICBpZiAoaGV4U3RyaW5nICE9PSBcIlwiICYmICEvXlthLWYwLTldKyQvaXUudGVzdChoZXhTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiB1bnByZWZpeGVkIGhleCBzdHJpbmcuIFJlY2VpdmVkOiAke2hleFN0cmluZ31gKTtcbiAgfVxuICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBub24tbmVnYXRpdmUgaW50ZWdlciB0YXJnZXQgbGVuZ3RoLiBSZWNlaXZlZDogJHt0YXJnZXRMZW5ndGh9YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQuY2FsbChoZXhTdHJpbmcsIHRhcmdldExlbmd0aCwgXCIwXCIpO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBleHRlbmRlZCBFQ0RTQSBzaWduYXR1cmUgaW50byBhIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgJ3YnIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSByIC0gVGhlICdyJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gcyAtIFRoZSAncycgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBFQ0RTQSBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFNpZyh2LCByLCBzKSB7XG4gIGNvbnN0IHJTaWcgPSBmcm9tU2lnbmVkKHIpO1xuICBjb25zdCBzU2lnID0gZnJvbVNpZ25lZChzKTtcbiAgY29uc3QgdlNpZyA9IGJ1ZmZlclRvQmlnSW50KHYpO1xuICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyh0b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKFwiaGV4XCIpLCA2NCk7XG4gIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKHRvVW5zaWduZWQoc1NpZykudG9TdHJpbmcoXCJoZXhcIiksIDY0KTtcbiAgY29uc3QgdlN0ciA9IHN0cmlwSGV4UHJlZml4KGJpZ0ludFRvSGV4KHZTaWcpKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0JDEoZHVyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXRSZWYgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYpO1xuICAgIH0sIGR1cmF0aW9uKTtcbiAgfSk7XG59XG5jb25zdCBnZXRIZWFkZXJzID0gand0ID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7and0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIFRleHQvbnVtYmVyIGZvcm1hdHRpbmcgdXRpbGl0aWVzXG4gKi9cbmNvbnN0IGZvcm1hdFNtYWxsTnVtYmVycyA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgbGV0IGN1cnJlbmN5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcInVzZFwiO1xuICBsZXQgbm9UaWxkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGNvbnN0IGZpbmFsTnVtYmVyID0gQmlnTnVtYmVyLmlzQmlnTnVtYmVyKG51bWJlcikgPyBudW1iZXIudG9OdW1iZXIoKSA6IG51bWJlcjtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmluYWxOdW1iZXIpKSByZXR1cm4gXCJcIjtcbiAgY29uc3QgdmFsdWUgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSgpID09PSBcInVzZFwiID8gcGFyc2VGbG9hdChOdW1iZXIoZmluYWxOdW1iZXIpLnRvRml4ZWQoMikpIDogcGFyc2VGbG9hdChOdW1iZXIoZmluYWxOdW1iZXIpLnRvRml4ZWQoNSkpO1xuICBjb25zdCB0aWxkZSA9IHZhbHVlID4gMCA/IFwifiBcIiA6IFwiXCI7XG4gIHJldHVybiBgJHtjdXJyZW5jeS50b0xvd2VyQ2FzZSgpID09PSBcInVzZFwiIHx8IG5vVGlsZGUgPyBcIlwiIDogdGlsZGV9JHtOdW1iZXIodmFsdWUpfSAke2N1cnJlbmN5LnRvVXBwZXJDYXNlKCl9YDtcbn07XG5jb25zdCBhZGRyZXNzU2xpY2VyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgbGV0IHNsaWNlTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xuICBpZiAoYWRkcmVzcy5sZW5ndGggPCAxMSkge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG4gIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIFwiXCI7XG4gIHJldHVybiBgJHthZGRyZXNzLnNsaWNlKDAsIHNsaWNlTGVuZ3RoKX0uLi4ke2FkZHJlc3Muc2xpY2UoLXNsaWNlTGVuZ3RoKX1gO1xufTtcbmNvbnN0IHNpZ25pZmljYW50RGlnaXRzID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBsZXQgcGVyYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIGxldCBsZW5ndGhfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAyO1xuICBsZXQgaW5wdXQgPSAhQmlnTnVtYmVyLmlzQmlnTnVtYmVyKG51bWJlcikgPyBuZXcgQmlnTnVtYmVyKG51bWJlcikgOiBudW1iZXI7XG4gIGlmIChpbnB1dC5pc1plcm8oKSkgcmV0dXJuIGlucHV0O1xuICBpZiAocGVyYykge1xuICAgIGlucHV0ID0gaW5wdXQudGltZXMobmV3IEJpZ051bWJlcigxMDApKTtcbiAgfVxuICBsZXQgZGVwdGg7XG4gIGlmIChpbnB1dC5ndGUobmV3IEJpZ051bWJlcigxKSkpIHtcbiAgICBkZXB0aCA9IGxlbmd0aF87XG4gIH0gZWxzZSB7XG4gICAgZGVwdGggPSBsZW5ndGhfIC0gMSArIE1hdGguY2VpbChNYXRoLmxvZzEwKG5ldyBCaWdOdW1iZXIoXCIxXCIpLmRpdihpbnB1dCkudG9OdW1iZXIoKSkpO1xuICB9XG4gIGNvbnN0IHNoaWZ0ID0gbmV3IEJpZ051bWJlcigxMCkucG93KG5ldyBCaWdOdW1iZXIoZGVwdGgpKTtcbiAgY29uc3Qgcm91bmRlZE51bWJlciA9IE1hdGgucm91bmQoc2hpZnQudGltZXMoaW5wdXQpLnRvTnVtYmVyKCkpIC8gc2hpZnQudG9OdW1iZXIoKTtcbiAgcmV0dXJuIHJvdW5kZWROdW1iZXI7XG59O1xuY29uc3QgZm9ybWF0RGF0ZSA9IGlucHV0RGF0ZSA9PiB7XG4gIGNvbnN0IG1vbnRoTGlzdCA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGlucHV0RGF0ZSk7XG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCBtb250aCA9IG1vbnRoTGlzdFtkYXRlLmdldE1vbnRoKCldO1xuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICByZXR1cm4gYCR7ZGF5fSAke21vbnRofSAke3llYXJ9YDtcbn07XG5jb25zdCBmb3JtYXRUaW1lID0gdGltZSA9PiB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lKS50b1RpbWVTdHJpbmcoKS5zbGljZSgwLCA4KTtcbn07XG4vKipcbiAqIE5ldHdvcmsgdXRpbGl0aWVzXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsgPSAodHJhbnNhY3Rpb24sIGNoYWluSWQpID0+IHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5jaGFpbklkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmNoYWluSWQgPT09IGNoYWluSWQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogU2lnbmluZyB1dGlsc1xuICovXG5jb25zdCBoYXNoTWVzc2FnZSA9IG1lc3NhZ2UgPT4ge1xuICBjb25zdCBidWZmZXJlZE1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCBcInV0ZjhcIik7XG4gIGNvbnN0IGVsID0gaGFzaFBlcnNvbmFsTWVzc2FnZShidWZmZXJlZE1lc3NhZ2UpO1xuICByZXR1cm4gZWw7XG59O1xuY29uc3Qgc2lnbk1lc3NhZ2UgPSAocHJpdmF0ZUtleSwgZGF0YSkgPT4ge1xuICBjb25zdCBwcml2S2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgXCJoZXhcIik7XG4gIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgY29uc3QgbXNnU2lnID0gZWNzaWduKEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwiaGV4XCIpLCBwcml2S2V5KTtcbiAgY29uc3QgcmF3TXNnU2lnID0gY29uY2F0U2lnKGJpZ0ludFRvQnVmZmVyKG1zZ1NpZy52KSwgbXNnU2lnLnIsIG1zZ1NpZy5zKTtcbiAgcmV0dXJuIHJhd01zZ1NpZztcbn07XG4vKipcbiAqIHBvcHVwIGhhbmRsZXIgdXRpbHNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wdXBGZWF0dXJlcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoXG4gIH0gPSBfcmVmO1xuICAvLyBGaXhlcyBkdWFsLXNjcmVlbiBwb3NpdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9zdCBicm93c2VycyAgICAgIEZpcmVmb3hcbiAgY29uc3QgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlbkxlZnQgOiB3aW5kb3cuc2NyZWVuWDtcbiAgY29uc3QgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiB3aW5kb3cuc2NyZWVuWTtcbiAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDogd2luZG93LnNjcmVlbi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgY29uc3Qgc3lzdGVtWm9vbSA9IDE7IC8vIE5vIHJlbGlhYmxlIGVzdGltYXRlXG4gIGNvbnN0IGxlZnQgPSBNYXRoLmFicygod2lkdGggLSB3KSAvIDIgLyBzeXN0ZW1ab29tICsgZHVhbFNjcmVlbkxlZnQpO1xuICBjb25zdCB0b3AgPSBNYXRoLmFicygoaGVpZ2h0IC0gaCkgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5Ub3ApO1xuICBjb25zdCBmZWF0dXJlcyA9IGB0aXRsZWJhcj0wLHRvb2xiYXI9MCxzdGF0dXM9MCxsb2NhdGlvbj0wLG1lbnViYXI9MCxoZWlnaHQ9JHtoIC8gc3lzdGVtWm9vbX0sd2lkdGg9JHt3IC8gc3lzdGVtWm9vbX0sdG9wPSR7dG9wfSxsZWZ0PSR7bGVmdH1gO1xuICByZXR1cm4gZmVhdHVyZXM7XG59XG5jb25zdCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyA9IHtcbiAgLy8gdHlwZTogJ2xvY2Fsc3RvcmFnZScsIC8vIChvcHRpb25hbCkgZW5mb3JjZSBhIHR5cGUsIG9uZU9mWyduYXRpdmUnLCAnaWRiJywgJ2xvY2Fsc3RvcmFnZScsICdub2RlJ11cbiAgd2ViV29ya2VyU3VwcG9ydDogZmFsc2UgLy8gKG9wdGlvbmFsKSBzZXQgdGhpcyB0byBmYWxzZSBpZiB5b3Uga25vdyB0aGF0IHlvdXIgY2hhbm5lbCB3aWxsIG5ldmVyIGJlIHVzZWQgaW4gYSBXZWJXb3JrZXIgKGluY3JlYXNlcyBwZXJmb3JtYW5jZSlcbn07XG5cbmZ1bmN0aW9uIGdldEN1c3RvbURldmljZUluZm8oKSB7XG4gIHZhciBfbmF2aWdhdG9yO1xuICBpZiAoKF9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3IpICE9PSBudWxsICYmIF9uYXZpZ2F0b3IgIT09IHZvaWQgMCAmJiBfbmF2aWdhdG9yLmJyYXZlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXI6IFwiQnJhdmVcIlxuICAgIH07XG4gIH1cbn1cbmNsYXNzIFVzZXJFcnJvciBleHRlbmRzIEVycm9yIHt9XG5jb25zdCBoYW5kbGVSZWRpcmVjdFBhcmFtZXRlcnMgPSAoaGFzaCwgcXVlcnlQYXJhbWV0ZXJzKSA9PiB7XG4gIGNvbnN0IGhhc2hQYXJhbWV0ZXJzID0ge307XG4gIGNvbnN0IGhhc2hVcmwgPSBuZXcgVVJMKGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59Lz8ke2hhc2guc2xpY2UoMSl9YCk7XG4gIGhhc2hVcmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoYXNoUGFyYW1ldGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICBsZXQgaW5zdGFuY2VQYXJhbWV0ZXJzID0ge307XG4gIGxldCBlcnJvciA9IFwiXCI7XG4gIGlmICghcXVlcnlQYXJhbWV0ZXJzLndpbmRvd0lkKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGhhc2hQYXJhbWV0ZXJzKS5sZW5ndGggPiAwICYmIGhhc2hQYXJhbWV0ZXJzLnN0YXRlKSB7XG4gICAgICBpbnN0YW5jZVBhcmFtZXRlcnMgPSBKU09OLnBhcnNlKHdpbmRvdy5hdG9iKGRlY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQoaGFzaFBhcmFtZXRlcnMuc3RhdGUpKSkpIHx8IHt9O1xuICAgICAgZXJyb3IgPSBoYXNoUGFyYW1ldGVycy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBoYXNoUGFyYW1ldGVycy5lcnJvciB8fCBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1ldGVycykubGVuZ3RoID4gMCAmJiBxdWVyeVBhcmFtZXRlcnMuc3RhdGUpIHtcbiAgICAgIGluc3RhbmNlUGFyYW1ldGVycyA9IEpTT04ucGFyc2Uod2luZG93LmF0b2IoZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChxdWVyeVBhcmFtZXRlcnMuc3RhdGUpKSkpIHx8IHt9O1xuICAgICAgaWYgKHF1ZXJ5UGFyYW1ldGVycy5lcnJvcikgZXJyb3IgPSBxdWVyeVBhcmFtZXRlcnMuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3IsXG4gICAgaW5zdGFuY2VQYXJhbWV0ZXJzLFxuICAgIGhhc2hQYXJhbWV0ZXJzXG4gIH07XG59O1xuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICB9KTtcbn1cblxuY2xhc3MgQmFzZUtleXJpbmdDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgdmFyIF9zdGF0ZSR3YWxsZXRzO1xuICAgIGxldCB7XG4gICAgICBjb25maWcgPSB7fSxcbiAgICAgIHN0YXRlXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIHdhbGxldHM6IChfc3RhdGUkd2FsbGV0cyA9IHN0YXRlLndhbGxldHMpICE9PSBudWxsICYmIF9zdGF0ZSR3YWxsZXRzICE9PSB2b2lkIDAgPyBfc3RhdGUkd2FsbGV0cyA6IFtdXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICAvLyBmb3Igc2lnbmluZyBhdXRoIG1lc3NhZ2VcbiAgc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gdGhpcy5zdGF0ZS53YWxsZXRzLmZpbmQoeCA9PiB4LmFkZHJlc3MgPT09IGFkZHJlc3MpO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWRNZXNzYWdlID0gaGFzaE1lc3NhZ2UobWVzc2FnZSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgcmF3TWVzc2FnZVNpZyA9IHNpZ25NZXNzYWdlKGtleXJpbmcucHJpdmF0ZUtleSwgaGFzaGVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHJhd01lc3NhZ2VTaWc7XG4gIH1cbn1cblxuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbi8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG5cIkdhdGV3YXkgdGltZW91dFwiLCBcIkVUSU1FRE9VVFwiLFxuLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbi8vIG9yIHRydW5jYXRlZCBqc29uIHJlc3BvbnNlc1xuXCJmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keVwiLFxuLy8gaWdub3JlIGVycm9ycyB3aGVyZSBodHRwIHJlcSBmYWlsZWQgdG8gZXN0YWJsaXNoXG5cIkZhaWxlZCB0byBmZXRjaFwiXTtcbmZ1bmN0aW9uIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcykge1xuICAvLyBjaGVjayBmb3IgZXJyb3JzXG4gIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDU6XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgY2FzZSA0MTg6XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgbWVzc2FnZTogYFJlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLmBcbiAgICAgIH0pO1xuICAgIGNhc2UgNTAzOlxuICAgIGNhc2UgNTA0OlxuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgIG1lc3NhZ2U6IGBHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy5gICsgYFRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgYm9keSkge1xuICAvLyBjaGVjayBmb3IgZXJyb3IgY29kZVxuICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICBkYXRhOiBib2R5XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICBpZiAoYm9keS5lcnJvcikge1xuICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgZGF0YTogYm9keS5lcnJvclxuICAgIH0pO1xuICB9XG4gIC8vIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdFxuICByZXR1cm4gYm9keS5yZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoX3JlZikge1xuICBsZXQge1xuICAgIHJlcSxcbiAgICBycGNUYXJnZXQsXG4gICAgb3JpZ2luSHR0cEhlYWRlcktleVxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChycGNUYXJnZXQpO1xuICAvLyBwcmVwYXJlIHBheWxvYWRcbiAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgaWQ6IHJlcS5pZCxcbiAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgcGFyYW1zOiByZXEucGFyYW1zXG4gIH07XG4gIC8vIGV4dHJhY3QgJ29yaWdpbicgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICBjb25zdCBvcmlnaW5Eb21haW4gPSByZXEub3JpZ2luO1xuICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIC8vIGNvbmZpZ3VyZSBmZXRjaCBwYXJhbXNcbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkXG4gIH07XG4gIC8vIG9wdGlvbmFsOiBhZGQgcmVxdWVzdCBvcmlnaW4gYXMgaGVhZGVyXG4gIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgIGZldGNoUGFyYW1zLmhlYWRlcnNbb3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmZXRjaFVybDogcGFyc2VkVXJsLmhyZWYsXG4gICAgZmV0Y2hQYXJhbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoTWlkZGxld2FyZShfcmVmMikge1xuICBsZXQge1xuICAgIHJwY1RhcmdldCxcbiAgICBvcmlnaW5IdHRwSGVhZGVyS2V5XG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIF9uZXh0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZmV0Y2hVcmwsXG4gICAgICBmZXRjaFBhcmFtc1xuICAgIH0gPSBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoe1xuICAgICAgcmVxLFxuICAgICAgcnBjVGFyZ2V0LFxuICAgICAgb3JpZ2luSHR0cEhlYWRlcktleVxuICAgIH0pO1xuICAgIC8vIGF0dGVtcHQgcmVxdWVzdCBtdWx0aXBsZSB0aW1lc1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGh0dHAgZXJycm9yc1xuICAgICAgICBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpO1xuICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgIGNvbnN0IGZldGNoQm9keSA9IGF3YWl0IGZldGNoUmVzLmpzb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgZmV0Y2hCb2R5KTtcbiAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUocGhyYXNlID0+IGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpKTtcbiAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyTWlkZGxld2FyZShvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsb2dnZXJNaWRkbGV3YXJlKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSB7XG4gICAgbmV4dChjYWxsYmFjayA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgbG9nLndhcm4oXCJFcnJvciBpbiBSUEMgcmVzcG9uc2U6XFxuXCIsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LmlzVG9ydXNJbnRlcm5hbCkgcmV0dXJuO1xuICAgICAgbG9nLmluZm8oYFJQQyAoJHtvcHRpb25zLm9yaWdpbn0pOmAsIHJlcXVlc3QsIFwiLT5cIiwgcmVzcG9uc2UpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JpZ2luTWlkZGxld2FyZShvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmlnaW5NaWRkbGV3YXJlKHJlcXVlc3QsIF8sIG5leHQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJlcXVlc3Qub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG4gICAgbmV4dCgpO1xuICB9O1xufVxuXG5jbGFzcyBCcm9hZGNhc3RDaGFubmVsSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxQcmVmaXgpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJiY1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxcIiwgdm9pZCAwKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBxdWVyeVBhcmFtZXRlcnMuZ2V0KFwiaW5zdGFuY2VJZFwiKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBgJHtjaGFubmVsUHJlZml4fV8ke2luc3RhbmNlSWR9YDtcbiAgICB0aGlzLmJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGhpcy5jaGFubmVsLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gIH1cbiAgZ2V0TWVzc2FnZUZyb21DaGFubmVsKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xuICAgICAgICBpZiAoZXYuZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXYuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0eXBlOiBQT1BVUF9MT0FERURcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgU3RyZWFtV2luZG93IGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlID0ge31cbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIC8vIGlmIHdpbmRvdyBoYXMgYmVlbiBjbG9zZWQgYnkgdXNlcnNcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbG9zZWRcIiwgZmFsc2UpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcbiAgICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXJcbiAgICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgIGxldCBwb3B1cFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLm9uY2UoYCR7dGhpcy5zdGF0ZS53aW5kb3dJZH06Y2xvc2VkYCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIC8vIFdpbmRvdyBpcyBub3Qgb3BlbiB5ZXRcbiAgICAgIGlmICghdGhpcy5zdGF0ZS53aW5kb3dJZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgd2luZG93SWQ6IHJhbmRvbUlkKClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLm9uY2UoYCR7dGhpcy5zdGF0ZS53aW5kb3dJZH06b3BlbmVkYCwgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUZWxsIHRoZSBvdGhlciBwYXJ0eSB0byBjcmVhdGUgYSB3aW5kb3cgYnkgcHJvbXB0aW5nIHRoZSB1c2VyIHRvIGNsaWNrIG9uIHNvbWV0aGluZ1xuICAgICAgICBjb21tdW5pY2F0aW9uRW5naW5lLmVtaXQoXCJub3RpZmljYXRpb25cIiwge1xuICAgICAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLkNSRUFURV9XSU5ET1csXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy5zdGF0ZS53aW5kb3dJZCxcbiAgICAgICAgICAgIHVybDogdGhpcy5zdGF0ZS51cmwuaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZW5kIHRoaXMgd2luZG93IHdpdGggYHdpbmRvd0lkYCB0aGUgdXJsIHRvIG9wZW4gdmlhIGJjXG4gICAgICAgIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGhpcy5zdGF0ZS53aW5kb3dJZCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGV2LCBgcmVjZWl2aW5nIGRhdGEgb24gY2hhbm5lbDogJHtiYy5uYW1lfWApO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSA9IGV2O1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFBvcHVwIHNheXMgc29tZSBlcnJvci4gc28sIHdlIHNheSBpdCdzIG5vdCByZWFsbHkgb3BlbmVkXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9ID0gZXYuZGF0YTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBQT1BVUF9MT0FERUQpIHtcbiAgICAgICAgICAgICAgcG9wdXBTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5zdGF0ZS51cmwuaHJlZixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiXCIgLy8gTm8gbmVlZCBvZiBhIG1zZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZy4gc28sIHdlIGNsb3NlIHRoYXQgd2luZG93XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyBpZiB0aGUgb3RoZXIgZW5kIGlzIHJlYWR5IHRvIHJlY2VpdmUgdGhpcyBtc2cuIFNvLCB3ZSBrZWVwIHdyaXRpbmcgdW50aWwgaXQgcmVjZWl2ZXMgYW5kIHNlbmRzIGJhY2sgc29tZXRoaW5nXG4gICAgICAgIC8vIHdlIG5lZWQgYmFja29mZiBzdHJhdGVneVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIGZpcnN0IGF0dGVtcHQgdG8gc3VjY2VlZC9mYWlsIHVudGlsIHRoZSBzZWNvbmQgYXR0ZW1wdFxuICAgICAgICAvLyBJZiB3ZSBnZXQgNDI5LCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGEgd2hpbGUgYW5kIHRoZW4gdHJ5IGFnYWluXG4gICAgICAgIGNvbnN0IHBvc3RNc2cgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gdGhpcyBuZXZlciB0aHJvd3NcbiAgICAgICAgICBjb25zdCBsb2NhbFJlc3BvbnNlID0gYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBTRVRVUF9DT01QTEVURVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBsb2NhbFJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY3VycmVudERlbGF5ID0gYmMudHlwZSA9PT0gXCJzZXJ2ZXJcIiA/IDEwMDAgOiAyMDA7XG4gICAgICAgIGNvbnN0IHJlY3Vyc2l2ZUZuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmICghcG9wdXBTdWNjZXNzICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxSZXNwb25zZSA9IGF3YWl0IHBvc3RNc2coKTtcbiAgICAgICAgICAgIGlmIChiYy50eXBlID09PSBcInNlcnZlclwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gbG9jYWxSZXNwb25zZTtcbiAgICAgICAgICAgICAgaWYgKHNlcnZlclJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIGEgd2hpbGUgYW5kIHRoZW4gdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgY3VycmVudERlbGF5ID0gTWF0aC5yb3VuZChjdXJyZW50RGVsYXkgKiAxLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXkpO1xuICAgICAgICAgICAgYXdhaXQgcmVjdXJzaXZlRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlY3Vyc2l2ZUZuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZVxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb21tdW5pY2F0aW9uRW5naW5lLmVtaXQoXCJub3RpZmljYXRpb25cIiwge1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuQ0xPU0VfV0lORE9XLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHdpbmRvd0lkOiB0aGlzLnN0YXRlLndpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLypcblNjZW5hcmlvczpcbjEuIE9wZW4gYSBub3JtYWwgcG9wdXAgd2luZG93IGFuZCBubyBjb21tdW5pY2F0aW9uIHdpdGggaXQgLSBVc2UgUG9wdXBIYW5kbGVyXG4yLiBPcGVuIGEgcG9wdXAgd2luZG93IGFuZCBjb21tdW5pY2F0ZSB3aXRoIGl0IC0gVXNlIFBvcHVwV2l0aEJjSGFuZGxlciAoY2FuIGluaXRpYXRlIGNvbW11bmljYXRpb24gYnkgd2FpdGluZyBmb3Igd2luZG93IHRvIG9wZW4gb3Igbm90KVxuXG4zLiBJZiB3aW5kb3cgaXMgYWxyZWFkeSBvcGVuZWQsIHBhc3MgaW4gd2luZG93SWQgdG8gdGhlIHBvcHVwIGhhbmRsZXIuXG4gICBUaGlzIHdpbGwgZXN0YWJsaXNoIGNvbW11bmljYXRpb24gd2l0aCB0aGUgcG9wdXAgd2luZG93IGFuZCBzZW5kcyBpdCBhIG5ldyB1cmwgdG8gcmVkaXJlY3QgdG9cblxuXG5JZiB5b3UncmUgdHJ5aW5nIHRvIG9wZW4gYSB3aW5kb3cgYW5kIGl0IGdldHMgYmxvY2tlZCAoaGFwcGVucyBpZiB5b3UncmUgaW4gaWZyYW1lIG9yIGRlbGF5IGIvdyBjbGljayBhbmQgb3BlbmluZyB3aW5kb3cpLFxuU3RyZWFtV2luZG93IGlzIGludm9rZWQgYW5kIGl0IHdyaXRlcyBpbiBhIGNoYW5uZWwgdG8gZGlzcGxheSBhIG1lc3NhZ2UgdG8gdGhlIHVzZXJcblxuT25jZSB1c2VyIGNsaWNrcyBvbiB0aGF0IG1vZGFsL2RpYWxvZywgd2UgcHJlLW9wZW4gdGhlIHdpbmRvdyBhbmQgcGFzcyBpbiB0aGUgd2luZG93SWQgKGdvZXMgdG8gMylcbiovXG4vKipcbiAqIEhhbmRsZXMgcG9wdXAgd2luZG93IG1hbmFnZW1lbnQuXG4gKiBGb3IgYnJvYWRjYXN0IGNoYW5uZWwgY29tbXVuaWNhdGlvbiwgdXNlIHVybCB3aXRoIGBpbnN0YW5jZUlkYCBjb2RlZCBpbnRvIHN0YXRlIHBhcmFtZXRlci5cbiAqIFRoaXMgc3RhdGUgcGFyYW1ldGVyIHdpbGwgYmUgcGFzc2VkIGFjcm9zcyByZWRpcmVjdHMgYWNjb3JkaW5nIHRvIE9BdXRoIHNwZWMuXG4gKi9cbmNsYXNzIFBvcHVwSGFuZGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgLy8gdGhpcy5pZCA9IHJhbmRvbUlkKClcbiAgICAvLyBBZGQgaW4gZGFwcCBzdG9yYWdlIGtleSB0byBhbGwgcG9wdXBzIGFzIGEgaGFzaCBwYXJhbWV0ZXJcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBkYXBwU3RvcmFnZUtleTogXCJcIixcbiAgICAgIGZlYXR1cmVzOiBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XKSxcbiAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgIGNvbW11bmljYXRpb25FbmdpbmU6IG51bGwsXG4gICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlcjogbnVsbFxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICB3aW5kb3dUaW1lcjogbnVsbCxcbiAgICAgIHdpbmRvdzogbnVsbCxcbiAgICAgIGlDbG9zZWRXaW5kb3c6IGZhbHNlLFxuICAgICAgd2luZG93SWQ6IFwiXCIsXG4gICAgICB1cmw6IHN0YXRlLnVybFxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5fc2V0dXBUaW1lcigpO1xuICB9XG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgLy8gaWYgd2luZG93IGlzIGFscmVhZHkgb3BlblxuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGFwcFN0b3JhZ2VLZXksXG4gICAgICBjb21tdW5pY2F0aW9uRW5naW5lLFxuICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXJcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qge1xuICAgICAgd2luZG93SWQsXG4gICAgICB1cmxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoZGFwcFN0b3JhZ2VLZXkpIHtcbiAgICAgIGNvbnN0IHVybEhhc2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnNsaWNlKDEpKTtcbiAgICAgIHVybEhhc2hQYXJhbXMuYXBwZW5kKFwiZGFwcFN0b3JhZ2VLZXlcIiwgZGFwcFN0b3JhZ2VLZXkpO1xuICAgICAgdXJsLmhhc2ggPSB1cmxIYXNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE5vIHdpbmRvdyBoYXMgYmVlbiBwcmUtb3BlbmVkXG4gICAgaWYgKCF3aW5kb3dJZCkge1xuICAgICAgLy8gdHJ5IHRvIG9wZW4gYSB3aW5kb3cgZmlyc3RcbiAgICAgIGxldCBsb2NhbFdpbmRvdyA9IHdpbmRvdy5vcGVuKHVybC5ocmVmLCB0YXJnZXQsIGZlYXR1cmVzKTtcbiAgICAgIGlmICghbG9jYWxXaW5kb3cpIHtcbiAgICAgICAgLy8gaWYgaXQncyBibG9ja2VkLCBvcGVuIFN0cmVhbVdpbmRvd1xuICAgICAgICBsb2NhbFdpbmRvdyA9IG5ldyBTdHJlYW1XaW5kb3coe1xuICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcbiAgICAgICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgdXJsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbG9jYWxXaW5kb3cub3BlbigpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICB3aW5kb3c6IGxvY2FsV2luZG93XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQSB3aW5kb3cgaGFzIGJlZW4gcHJlLW9wZW5lZCB3aXRoIGEgcXVlcnkgcGFyYW1ldGVyIGB3aW5kb3dJZGBcbiAgICBjb25zdCBsb2NhbFdpbmRvdyA9IG5ldyBTdHJlYW1XaW5kb3coe1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGNvbW11bmljYXRpb25FbmdpbmUsXG4gICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyXG4gICAgICB9LFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgdXJsLFxuICAgICAgICB3aW5kb3dJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHdpbmRvdzogbG9jYWxXaW5kb3dcbiAgICB9KTtcbiAgICBhd2FpdCBsb2NhbFdpbmRvdy5vcGVuKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgaUNsb3NlZFdpbmRvdzogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpbmRvd1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh3aW5kb3cpIHdpbmRvdy5jbG9zZSgpO1xuICB9XG4gIF9zZXR1cFRpbWVyKCkge1xuICAgIGNvbnN0IHRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2luZG93LFxuICAgICAgICB3aW5kb3dUaW1lcixcbiAgICAgICAgaUNsb3NlZFdpbmRvd1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgaWYgKHdpbmRvd1RpbWVyKSBjbGVhckludGVydmFsKHdpbmRvd1RpbWVyKTtcbiAgICAgICAgaWYgKCFpQ2xvc2VkV2luZG93KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgIGlDbG9zZWRXaW5kb3c6IGZhbHNlLFxuICAgICAgICAgIHdpbmRvdzogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cgPT09IG51bGwgJiYgd2luZG93VGltZXIpIGNsZWFySW50ZXJ2YWwod2luZG93VGltZXIpO1xuICAgIH0sIDUwMCk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgd2luZG93VGltZXI6IHRpbWVyXG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUG9wdXBTdG9yZUNoYW5uZWwge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGluc3RhbmNlSWQsXG4gICAgICBoYW5kbGVMb2dvdXQsXG4gICAgICBoYW5kbGVBY2NvdW50SW1wb3J0LFxuICAgICAgaGFuZGxlTmV0d29ya0NoYW5nZSxcbiAgICAgIGhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSxcbiAgICAgIGhhbmRsZVRoZW1lQ2hhbmdlXG4gICAgfSA9IF9yZWY7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlTG9nb3V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlQWNjb3VudEltcG9ydFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU5ldHdvcmtDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVUaGVtZUNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluc3RhbmNlSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuICAgIHRoaXMuaGFuZGxlTG9nb3V0ID0gaGFuZGxlTG9nb3V0O1xuICAgIHRoaXMuaGFuZGxlQWNjb3VudEltcG9ydCA9IGhhbmRsZUFjY291bnRJbXBvcnQ7XG4gICAgdGhpcy5oYW5kbGVOZXR3b3JrQ2hhbmdlID0gaGFuZGxlTmV0d29ya0NoYW5nZTtcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSA9IGhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZTtcbiAgICB0aGlzLmhhbmRsZVRoZW1lQ2hhbmdlID0gaGFuZGxlVGhlbWVDaGFuZ2U7XG4gIH1cbiAgc2V0dXBTdG9yZUNoYW5uZWxzKCkge1xuICAgIHRoaXMubG9nb3V0Q2hhbm5lbCgpO1xuICAgIHRoaXMuaW1wb3J0QWNjb3VudENoYW5uZWwoKTtcbiAgICB0aGlzLm5ldHdvcmtDaGFuZ2VDaGFubmVsKCk7XG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3NDaGFuZ2VDaGFubmVsKCk7XG4gICAgdGhpcy50aGVtZUNoYW5nZWRDaGFubmVsKCk7XG4gIH1cbiAgbG9nb3V0Q2hhbm5lbCgpIHtcbiAgICBjb25zdCBsb2dvdXRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9MT0dPVVRfQ0hBTk5FTH1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIGxvZ291dENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhO1xuICAgICAgbG9nLmluZm8oXCJyZWNlaXZlZCBsb2dvdXQgbWVzc2FnZVwiLCBldik7XG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGEgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGEudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLkxPR09VVCkge1xuICAgICAgICBsb2cuaW5mbyhcIkxvZ2dpbmcgT3V0XCIpO1xuICAgICAgICB0aGlzLmhhbmRsZUxvZ291dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGltcG9ydEFjY291bnRDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9BQ0NPVU5UX0lNUE9SVF9DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhMjtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTIgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhMi50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuQUNDT1VOVF9JTVBPUlRFRCkge1xuICAgICAgICB2YXIgX2V2JGRhdGEzO1xuICAgICAgICB0aGlzLmhhbmRsZUFjY291bnRJbXBvcnQoKF9ldiRkYXRhMyA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGEzLnByaXZLZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5ldHdvcmtDaGFuZ2VDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9ORVRXT1JLX0NIQU5HRV9DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhNDtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTQgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNC50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuTkVUV09SS19DSEFOR0UpIHtcbiAgICAgICAgdmFyIF9ldiRkYXRhNTtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrQ2hhbmdlKChfZXYkZGF0YTUgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNS5uZXR3b3JrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aGVtZUNoYW5nZWRDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLlRIRU1FX0NIQU5HRX1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ID0+IHtcbiAgICAgIHZhciBfZXYkZGF0YTY7XG4gICAgICBsb2cuaW5mbyh7XG4gICAgICAgIGV2XG4gICAgICB9KTtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTYgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNi50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuU0VUX1RIRU1FKSB7XG4gICAgICAgIHZhciBfZXYkZGF0YTc7XG4gICAgICAgIHRoaXMuaGFuZGxlVGhlbWVDaGFuZ2UoKF9ldiRkYXRhNyA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE3LnRoZW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZWxlY3RlZEFkZHJlc3NDaGFuZ2VDaGFubmVsKCkge1xuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7QlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9TRUxFQ1RFRF9BRERSRVNTX0NIQU5ORUx9XyR7dGhpcy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XG4gICAgICB2YXIgX2V2JGRhdGE4O1xuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhOCA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE4LnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5TRUxFQ1RFRF9BRERSRVNTX0NIQU5HRSkge1xuICAgICAgICB2YXIgX2V2JGRhdGE5O1xuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSgoX2V2JGRhdGE5ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTkuc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVwV2l0aEJjSGFuZGxlciBpcyBhIFBvcHVwSGFuZGxlciB3aGljaCB1c2VzIGJyb2FkY2FzdCBjaGFubmVsIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIHBvcHVwIHdpbmRvdy5cbiAqL1xuY2xhc3MgUG9wdXBXaXRoQmNIYW5kbGVyIGV4dGVuZHMgUG9wdXBIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZSxcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJjXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5iYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGluc3RhbmNlSWQsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVjZWl2ZXMgdGhlIGRhdGEgZnJvbSBwb3B1cCB3aW5kb3cgYW5kIGNsb3NlcyB0aGUgd2luZG93XG4gICAqIEBwYXJhbSBzdWNjZXNzRXh0cmFGbiAtIEV4dHJhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgZGF0YSBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBUaGUgZGF0YSB0byBiZSByZWNlaXZlZFxuICAgKi9cbiAgaGFuZGxlKHN1Y2Nlc3NFeHRyYUZuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNsb3NlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYmMuY2xvc2UoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBVc2VyRXJyb3IoXCJ1c2VyIGNsb3NlZCBwb3B1cFwiKSk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICB0aGlzLmJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgbG9nLmluZm8oZXYsIGByZWNlaXZpbmcgZGF0YSBvbiBjaGFubmVsOiAke3RoaXMuYmMubmFtZX1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9ID0gZXY7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWNjZXNzRXh0cmFGbikgYXdhaXQgc3VjY2Vzc0V4dHJhRm4uY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9wZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nLmluZm8oYG9wZW5lZCB3aW5kb3cgJHt0aGlzLmJjLm5hbWV9YCk7XG4gICAgICAgIC8vIE9wZW5lZCB3aW5kb3cuIHlheS4gIGxldCB0aGUgYmMgZXZlbnRzIGRvIHRoZWlyIGpvYlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgbG9nLmVycm9yKGVyciwgXCJzb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBvcGVuaW5nIHdpbmRvd1wiKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXNlIHRoaXMgaWYgd2UgaGF2ZSB0byBzZW5kIGxhcmdlIHBheWxvYWRzIHdoaWNoIGRvbid0IGZpdCBpbiBxdWVyeS9oYXNoIHBhcmFtcy5cbiAgICogV2FpdHMgZm9yIGFjayB0aGF0IHBvcHVwIHdpbmRvdyBpcyByZWFkeSB0byByZWNlaXZlIGRhdGEuXG4gICAqIFJlY2VpdmVzIHRoZSBkYXRhIGZyb20gcG9wdXAgd2luZG93IGFuZCBjbG9zZXMgdGhlIHdpbmRvd1xuICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBkYXRhIHRvIGJlIHNlbnQgdG8gdGhlIHBvcHVwIHdpbmRvdyBvbmNlIHdlIGhhdmUgYWNrIHRoYXQgd2luZG93IGlzIHJlYWR5IHRvIHJlY2VpdmUgZGF0YVxuICAgKiBAcGFyYW0gc3VjY2Vzc0V4dHJhRm4gLSBFeHRyYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGRhdGEgaXMgcmVjZWl2ZWRcbiAgICogQHJldHVybnMgVGhlIGRhdGEgdG8gYmUgcmVjZWl2ZWRcbiAgICovXG4gIGhhbmRsZVdpdGhIYW5kc2hha2UocGF5bG9hZCwgc3VjY2Vzc0V4dHJhRm4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xuICAgICAgICByZWplY3QobmV3IFVzZXJFcnJvcihcInVzZXIgY2xvc2VkIHBvcHVwXCIpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgIHRoaXMuYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvZy5pbmZvKGV2LCBgcmVjZWl2aW5nIGRhdGEgb24gY2hhbm5lbDogJHt0aGlzLmJjLm5hbWV9YCk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSA9IGV2O1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEbyBoYW5kc2hha2VcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0eXBlID0gXCJcIlxuICAgICAgICAgIH0gPSBkYXRhO1xuICAgICAgICAgIGlmICh0eXBlID09PSBQT1BVUF9MT0FERUQpIHtcbiAgICAgICAgICAgIC8vIEhhY2sgd2l0aCBnZW5lcmljIHRvIHVzZSB0aGUgc2FtZSB0eXBlIGZvciBib3RoIHNlbmQgYW5kIHJlY2VpdmVcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFBPUFVQX1JFU1VMVCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NFeHRyYUZuKSBhd2FpdCBzdWNjZXNzRXh0cmFGbi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIC8vIE11c3Qgb25seSBjbG9zZSB0aGUgYmMgYWZ0ZXIgcmVzdWx0IGlzIGRvbmVcbiAgICAgICAgICAgIHRoaXMuYmMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB0aGlzLmJjLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3BlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2cuaW5mbyhgb3BlbmVkIHdpbmRvdyAke3RoaXMuYmMubmFtZX1gKTtcbiAgICAgICAgLy8gT3BlbmVkIHdpbmRvdy4geWF5LiAgbGV0IHRoZSBiYyBldmVudHMgZG8gdGhlaXIgam9iXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoZXJyLCBcInNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIG9wZW5pbmcgd2luZG93XCIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlZGlyZWN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluYWxRdWVyeVBhcmFtc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5zdGFuY2VQYXJhbWV0ZXJzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzaFBhcmFtZXRlcnNcIiwgdm9pZCAwKTtcbiAgICBjb25zdCB7XG4gICAgICBoYXNoXG4gICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIHF1ZXJ5UGFyYW1ldGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzLmZpbmFsUXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGVycm9yLFxuICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzLFxuICAgICAgaGFzaFBhcmFtZXRlcnNcbiAgICB9ID0gaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzKGhhc2gsIHRoaXMuZmluYWxRdWVyeVBhcmFtcyk7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuaW5zdGFuY2VQYXJhbWV0ZXJzID0gaW5zdGFuY2VQYXJhbWV0ZXJzO1xuICAgIHRoaXMuaGFzaFBhcmFtZXRlcnMgPSBoYXNoUGFyYW1ldGVycztcbiAgfVxuICBhc3luYyBoYW5kbGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmluYWxRdWVyeVBhcmFtcyxcbiAgICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzLFxuICAgICAgICBoYXNoUGFyYW1ldGVycyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgbGV0IGJjO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmaW5hbFF1ZXJ5UGFyYW1zLndpbmRvd0lkKSB7XG4gICAgICAgICAgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuUkVESVJFQ1RfQ0hBTk5FTH1fJHtpbnN0YW5jZVBhcmFtZXRlcnMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LmVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChldi5lcnJvcik7XG4gICAgICAgICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgICAgICBsb2cuaW5mbyhcInBvc3RlZFwiLCB7XG4gICAgICAgICAgICAgICAgZmluYWxRdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBoYXNoUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbnN0YW5jZVBhcmFtczogaW5zdGFuY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICBoYXNoUGFyYW1zOiBoYXNoUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IGZpbmFsUXVlcnlQYXJhbXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoYCR7ZmluYWxRdWVyeVBhcmFtcy53aW5kb3dJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgIH0gPSBldi5kYXRhO1xuICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSBTRVRVUF9DT01QTEVURSkge1xuICAgICAgICAgICAgICBhd2FpdCBiYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IGZpbmFsUXVlcnlQYXJhbXMud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBQT1BVUF9MT0FERURcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2LmVycm9yICYmIGV2LmVycm9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGxvZy5lcnJvcihldi5lcnJvcik7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5pbmZvKGVyciwgXCJzb21ldGhpbmcgd2VudCB3cm9uZ1wiKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGlmIChiYykgYmMuY2xvc2UoKTtcbiAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgQUNUSVZJVFlfQUNUSU9OID0ge1xuICBBQ1RJVklUWV9BQ1RJT05fQUxMOiBcIndhbGxldEFjdGl2aXR5LmFsbFRyYW5zYWN0aW9uc1wiLFxuICBBQ1RJVklUWV9BQ1RJT05fU0VORDogXCJ3YWxsZXRBY3Rpdml0eS5zZW5kXCIsXG4gIEFDVElWSVRZX0FDVElPTl9SRUNFSVZFOiBcIndhbGxldEFjdGl2aXR5LnJlY2VpdmVcIixcbiAgQUNUSVZJVFlfQUNUSU9OX1RPUFVQOiBcIndhbGxldEFjdGl2aXR5LnRvcHVwXCJcbn07XG5jb25zdCBBQ0NPVU5UX0NBVEVHT1JZID0ge1xuICBOT1JNQUw6IFwibm9ybWFsXCIsXG4gIFRIUkVTSE9MRDogXCJ0aHJlc2hvbGRcIixcbiAgSU1QT1JURUQ6IFwiaW1wb3J0ZWRcIlxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbi8vIEJ5IGRlZmF1bHQsIHBvbGwgZXZlcnkgMyBtaW51dGVzXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMTgwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfUFJFRkVSRU5DRVMgPSB7XG4gIHNlbGVjdGVkQ3VycmVuY3k6IFwiVVNEXCIsXG4gIHRoZW1lOiBcImRhcmtcIixcbiAgbG9jYWxlOiBcImVuLVVTXCIsXG4gIGFjY291bnRUeXBlOiBBQ0NPVU5UX0NBVEVHT1JZLk5PUk1BTCxcbiAgY29udGFjdHM6IFtdLFxuICBqd3RUb2tlbjogXCJcIixcbiAgZmV0Y2hlZFBhc3RUeDogW10sXG4gIHBhc3RUcmFuc2FjdGlvbnM6IFtdLFxuICBwYXltZW50VHg6IFtdLFxuICBkZWZhdWx0UHVibGljQWRkcmVzczogXCJcIixcbiAgY3VzdG9tVG9rZW5zOiBbXSxcbiAgY3VzdG9tTmZ0czogW10sXG4gIGNyYXNoUmVwb3J0OiB0cnVlLFxuICB1c2VySW5mbzoge1xuICAgIGFnZ3JlZ2F0ZVZlcmlmaWVyOiBcIlwiLFxuICAgIGVtYWlsOiBcIlwiLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgcHJvZmlsZUltYWdlOiBcIlwiLFxuICAgIHR5cGVPZkxvZ2luOiBMT0dJTl9QUk9WSURFUi5HT09HTEUsXG4gICAgdmVyaWZpZXI6IFwiXCIsXG4gICAgdmVyaWZpZXJJZDogXCJcIlxuICB9XG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgc3RvcmVzIHNoYXJlZCBzZXR0aW5ncyBhbmQgZXhwb3NlcyBjb252ZW5pZW5jZSBtZXRob2RzXG4gKi9cbmNsYXNzIEJhc2VQcmVmZXJlbmNlc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJlZmVyZW5jZXNDb250cm9sbGVyIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgKi9cbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZSxcbiAgICAgIGRlZmF1bHRQcmVmZXJlbmNlcyxcbiAgICAgIHNpZ25BdXRoTWVzc2FnZVxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIFwiUHJlZmVyZW5jZXNDb250cm9sbGVyXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlmcmFtZU9yaWdpblwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpZ25BdXRoTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcmVmZXJlbmNlc1wiLCB2b2lkIDApO1xuICAgIGlmICghY29uZmlnLmFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJlZmVyZW5jZXNDb250cm9sbGVyIC0gbm8gYXBpIHNwZWNpZmllZCBpbiBjb25maWcuXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIGlkZW50aXRpZXM6IHt9LFxuICAgICAgc2VsZWN0ZWRBZGRyZXNzOiBcIlwiLFxuICAgICAgbGFzdEVycm9yTWVzc2FnZTogXCJcIixcbiAgICAgIGxhc3RTdWNjZXNzTWVzc2FnZTogXCJcIlxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgYXBpOiBjb25maWcuYXBpLFxuICAgICAgcG9sbEludGVydmFsOiBERUZBVUxUX0lOVEVSVkFMXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLmRlZmF1bHRQcmVmZXJlbmNlcyA9IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIERFRkFVTFRfUFJFRkVSRU5DRVMpLCBkZWZhdWx0UHJlZmVyZW5jZXMpO1xuICAgIHRoaXMuc2lnbkF1dGhNZXNzYWdlID0gc2lnbkF1dGhNZXNzYWdlO1xuICB9XG4gIHNldElmcmFtZU9yaWdpbihvcmlnaW4pIHtcbiAgICB0aGlzLmlmcmFtZU9yaWdpbiA9IG9yaWdpbjtcbiAgfVxuICBnZXRBZGRyZXNzU3RhdGUoYWRkcmVzcykge1xuICAgIGNvbnN0IHNlbGVjdGVkQWRkcmVzcyA9IGFkZHJlc3MgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWRlbnRpdGllc1tzZWxlY3RlZEFkZHJlc3NdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHNlbGVjdGVkIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIGNhc3BlciBhY2NvdW50IGhhc2hcbiAgICovXG4gIHNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBzZWxlY3RlZEFkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRVc2VyKGFkZHJlc3MpIHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0KGAke3RoaXMuY29uZmlnLmFwaX0vdXNlcj9mZXRjaFR4PWZhbHNlYCwgdGhpcy5oZWFkZXJzKGFkZHJlc3MpLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdXNlci5kYXRhO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVVzZXIocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VsZWN0ZWRDdXJyZW5jeSxcbiAgICAgIHRoZW1lLFxuICAgICAgdmVyaWZpZXIsXG4gICAgICB2ZXJpZmllcklkLFxuICAgICAgbG9jYWxlLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGlkVG9rZW5cbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHVzZXJQYXlsb2FkID0ge1xuICAgICAgZGVmYXVsdF9jdXJyZW5jeTogc2VsZWN0ZWRDdXJyZW5jeSxcbiAgICAgIHRoZW1lLFxuICAgICAgdmVyaWZpZXIsXG4gICAgICB2ZXJpZmllcl9pZDogdmVyaWZpZXJJZCxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGlkVG9rZW5cbiAgICB9O1xuICAgIGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS91c2VyYCwgdXNlclBheWxvYWQsIHRoaXMuaGVhZGVycyhhZGRyZXNzKSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICB0aGVtZSxcbiAgICAgIGRlZmF1bHRQdWJsaWNBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgc2VsZWN0ZWRDdXJyZW5jeSxcbiAgICAgIGxvY2FsZVxuICAgIH0sIGFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIHN0b3JlVXNlckxvZ2luKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZlcmlmaWVySWQsXG4gICAgICB2ZXJpZmllcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgaWRUb2tlblxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFvcHRpb25zLnJlaHlkcmF0ZSkge1xuICAgICAgY29uc3QgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgY29uc3Qgc3BlY2lhbEJyb3dzZXIgPSBnZXRDdXN0b21EZXZpY2VJbmZvKCk7XG4gICAgICBjb25zdCByZWNvcmRMb2dpblBheWxvYWQgPSB7XG4gICAgICAgIG9zOiBicm93c2VyLmdldE9TTmFtZSgpLFxuICAgICAgICBvc192ZXJzaW9uOiBicm93c2VyLmdldE9TVmVyc2lvbigpIHx8IFwidW5pZGVudGlmaWVkXCIsXG4gICAgICAgIGJyb3dzZXI6IChzcGVjaWFsQnJvd3NlciA9PT0gbnVsbCB8fCBzcGVjaWFsQnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BlY2lhbEJyb3dzZXIuYnJvd3NlcikgfHwgYnJvd3Nlci5nZXRCcm93c2VyTmFtZSgpIHx8IFwidW5pZGVudGlmaWVkXCIsXG4gICAgICAgIGJyb3dzZXJfdmVyc2lvbjogYnJvd3Nlci5nZXRCcm93c2VyVmVyc2lvbigpIHx8IFwidW5pZGVudGlmaWVkXCIsXG4gICAgICAgIHBsYXRmb3JtOiBicm93c2VyLmdldFBsYXRmb3JtKCkudHlwZSB8fCBcImRlc2t0b3BcIixcbiAgICAgICAgaG9zdG5hbWU6IHRoaXMuaWZyYW1lT3JpZ2luLFxuICAgICAgICB2ZXJpZmllcixcbiAgICAgICAgdmVyaWZpZXJfaWQ6IHZlcmlmaWVySWQsXG4gICAgICAgIGlkVG9rZW5cbiAgICAgIH07XG4gICAgICBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vdXNlci9yZWNvcmRMb2dpbmAsIHJlY29yZExvZ2luUGF5bG9hZCwgdGhpcy5oZWFkZXJzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldENyYXNoUmVwb3J0KGlzRW5hYmxlZCkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU7XG4gICAgaWYgKGlzRW5hYmxlZCA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZS5jcmFzaFJlcG9ydCkpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwYXRjaChgJHt0aGlzLmNvbmZpZy5hcGl9L3VzZXJgLCB7XG4gICAgICAgIGVuYWJsZV9jcmFzaF9yZXBvcnRlcjogaXNFbmFibGVkXG4gICAgICB9LCB0aGlzLmhlYWRlcnMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGNyYXNoUmVwb3J0OiBpc0VuYWJsZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldFVzZXJUaGVtZSh0aGVtZSkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGUyO1xuICAgIGlmICh0aGVtZSA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGUyID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMi50aGVtZSkpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwYXRjaChgJHt0aGlzLmNvbmZpZy5hcGl9L3VzZXJgLCB7XG4gICAgICAgIHRoZW1lXG4gICAgICB9LCB0aGlzLmhlYWRlcnMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIHRoZW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRVc2VyTG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGUzO1xuICAgIGlmIChsb2NhbGUgPT09ICgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMyA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTMubG9jYWxlKSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwYXRjaChgJHt0aGlzLmNvbmZpZy5hcGl9L3VzZXJgLCB7XG4gICAgICAgIGxvY2FsZVxuICAgICAgfSwgdGhpcy5oZWFkZXJzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBsb2NhbGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBzZXQgbG9jYWxlXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0U2VsZWN0ZWRDdXJyZW5jeShwYXlsb2FkKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTQ7XG4gICAgaWYgKHBheWxvYWQuc2VsZWN0ZWRDdXJyZW5jeSA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU0ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNC5zZWxlY3RlZEN1cnJlbmN5KSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHBhdGNoKGAke3RoaXMuY29uZmlnLmFwaX0vdXNlcmAsIHtcbiAgICAgICAgZGVmYXVsdF9jdXJyZW5jeTogcGF5bG9hZC5zZWxlY3RlZEN1cnJlbmN5XG4gICAgICB9LCB0aGlzLmhlYWRlcnMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIHNlbGVjdGVkQ3VycmVuY3k6IHBheWxvYWQuc2VsZWN0ZWRDdXJyZW5jeVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWRkQ29udGFjdChjb250YWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU1O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vY29udGFjdGAsIGNvbnRhY3QsIHRoaXMuaGVhZGVycygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgY29udGFjdHM6IFsuLi4oKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU1ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNS5jb250YWN0cykgfHwgW10pLCByZXNwb25zZS5kYXRhXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGFkZCBjb250YWN0XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVsZXRlQ29udGFjdChjb250YWN0SWQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTY7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlbW92ZShgJHt0aGlzLmNvbmZpZy5hcGl9L2NvbnRhY3QvJHtjb250YWN0SWR9YCwge30sIHRoaXMuaGVhZGVycygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBmaW5hbENvbnRhY3RzID0gKF90aGlzJGdldEFkZHJlc3NTdGF0ZTYgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU2LmNvbnRhY3RzLmZpbHRlcihjb250YWN0ID0+IGNvbnRhY3QuaWQgIT09IHJlc3BvbnNlLmRhdGEuaWQpO1xuICAgICAgaWYgKGZpbmFsQ29udGFjdHMpIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBjb250YWN0czogWy4uLmZpbmFsQ29udGFjdHNdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZGVsZXRlIGNvbnRhY3RcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyByZXZva2VEaXNjb3JkKGlkVG9rZW4pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9yZXZva2UvZGlzY29yZGAsIHtcbiAgICAgICAgdG9rZW46IGlkVG9rZW5cbiAgICAgIH0sIHRoaXMuaGVhZGVycygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhyZXNwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcGF0Y2hQYXN0VHgoYm9keSwgYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBhdGNoKGAke3RoaXMuY29uZmlnLmFwaX0vdHJhbnNhY3Rpb25gLCBib2R5LCB0aGlzLmhlYWRlcnMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKFwic3VjY2Vzc2Z1bGx5IHBhdGNoZWRcIiwgcmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gcGF0Y2ggdHhcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwb3N0UGFzdFR4KHR4LCBhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L3RyYW5zYWN0aW9uYCwgdHgsIHRoaXMuaGVhZGVycyhhZGRyZXNzKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbG9nLmluZm8oXCJzdWNjZXNzZnVsbHkgcG9zdGVkIHR4XCIsIHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yLCBcInVuYWJsZSB0byBpbnNlcnQgdHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFdhbGxldE9yZGVycyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KGAke3RoaXMuY29uZmlnLmFwaX0vdHJhbnNhY3Rpb25gLCB0aGlzLmhlYWRlcnMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA/IHJlc3BvbnNlLmRhdGEgOiBbXSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZ2V0IHdhbGxldCBvcmRlcnMgdHhcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRUb3BVcE9yZGVycyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KGAke3RoaXMuY29uZmlnLmNvbW1vbkFwaUhvc3R9L3RyYW5zYWN0aW9uYCwgdGhpcy5oZWFkZXJzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YSB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGZldGNoIHBhc3QgVG9wIHVwIG9yZGVyc1wiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEJpbGxCb2FyZERhdGEoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KGAke3RoaXMuY29uZmlnLmFwaX0vYmlsbGJvYXJkYCwgdGhpcy5oZWFkZXJzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZ2V0IGJpbGxib2FyZCBkYXRhXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZUZvclNpZ25pbmcocHVibGljQWRkcmVzcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvbWVzc2FnZWAsIHtcbiAgICAgIHB1YmxpY19hZGRyZXNzOiBwdWJsaWNBZGRyZXNzXG4gICAgfSwge30sIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5tZXNzYWdlO1xuICB9XG4gIGFzeW5jIGdldFR3aXR0ZXJJZChwYXlsb2FkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KGAke3RoaXMuY29uZmlnLmFwaX0vdHdpdHRlcj9zY3JlZW5fbmFtZT0ke3BheWxvYWQubmlja31gLCB0aGlzLmhlYWRlcnMoKSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGAke3BheWxvYWQudHlwZU9mTG9naW4udG9Mb3dlckNhc2UoKX18JHtyZXMuZGF0YS50b1N0cmluZygpfWA7XG4gIH1cbiAgYXN5bmMgc2VuZEVtYWlsKHBheWxvYWQpIHtcbiAgICByZXR1cm4gcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L3RyYW5zYWN0aW9uL3NlbmRlbWFpbGAsIHBheWxvYWQuZW1haWxPYmplY3QsIHRoaXMuaGVhZGVycygpLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZWZyZXNoSnd0KCkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gYXdhaXQgdGhpcy5nZXRNZXNzYWdlRm9yU2lnbmluZyhhZGRyZXNzKTtcbiAgICBpZiAoIW1lc3NhZ2VUb1NpZ24uc3RhcnRzV2l0aCh0aGlzLmNvbmZpZy5zaWduSW5QcmVmaXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2lnbiBvbiBpbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IHRoaXMuc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2VUb1NpZ24pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvdmVyaWZ5YCwge1xuICAgICAgcHVibGljX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICBzaWduZWRfbWVzc2FnZTogc2lnbmVkTWVzc2FnZVxuICAgIH0sIHt9LCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGp3dFRva2VuOiByZXNwb25zZS50b2tlblxuICAgIH0sIGFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGdldERhcHBMaXN0KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldChgJHt0aGlzLmNvbmZpZy5hcGl9L2RhcHBzYCwgdGhpcy5oZWFkZXJzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZ2V0IGJpbGxib2FyZCBkYXRhXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5pdChhZGRyZXNzLCB1c2VySW5mbywgand0VG9rZW4pIHtcbiAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICB0b2tlbjogand0VG9rZW5cbiAgICB9O1xuICAgIGlmICh0aGlzLmdldEFkZHJlc3NTdGF0ZShhZGRyZXNzKSkgcmV0dXJuO1xuICAgIGlmICghand0VG9rZW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSBhd2FpdCB0aGlzLmdldE1lc3NhZ2VGb3JTaWduaW5nKGFkZHJlc3MpO1xuICAgICAgaWYgKCFtZXNzYWdlVG9TaWduLnN0YXJ0c1dpdGgodGhpcy5jb25maWcuc2lnbkluUHJlZml4KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNpZ24gb24gaW52YWxpZCBtZXNzYWdlXCIpO1xuICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IHRoaXMuc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2VUb1NpZ24pO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC92ZXJpZnlgLCB7XG4gICAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBzaWduZWRfbWVzc2FnZTogc2lnbmVkTWVzc2FnZVxuICAgICAgfSwge30sIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBqd3RUb2tlbjogcmVzcG9uc2UudG9rZW4sXG4gICAgICB1c2VySW5mb1xuICAgIH0sIGFkZHJlc3MpO1xuICB9XG4gIHVwZGF0ZVN0YXRlKHByZWZlcmVuY2VzLCBhZGRyZXNzKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gYWRkcmVzcyB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZShzZWxlY3RlZEFkZHJlc3MpIHx8IGNsb25lRGVlcCh0aGlzLmRlZmF1bHRQcmVmZXJlbmNlcyk7XG4gICAgY29uc3QgbWVyZ2VkU3RhdGUgPSBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBjdXJyZW50U3RhdGUpLCBwcmVmZXJlbmNlcyk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgaWRlbnRpdGllczogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgdGhpcy5zdGF0ZS5pZGVudGl0aWVzKSwge30sIHtcbiAgICAgICAgW3NlbGVjdGVkQWRkcmVzc106IG1lcmdlZFN0YXRlXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRTdGF0ZTtcbiAgfVxuICBoZWFkZXJzKGFkZHJlc3MpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNztcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIHJldHVybiBnZXRIZWFkZXJzKCgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNyA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKHNlbGVjdGVkQWRkcmVzcykpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTcuand0VG9rZW4pIHx8IFwiXCIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggc3RhdHVzIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbnRlcm5hbGx5XG4gKiBpbiB0aGUgd2FsbGV0LiBTb21lIG9mIHRoZXNlIGNvcnJlc3BvbmQgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBuZXR3b3JrLCBidXRcbiAqIHNvbWUgYXJlIHdhbGxldC1zcGVjaWZpYy5cbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImFwcHJvdmVkXCJdID0gXCJhcHByb3ZlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImNhbmNlbGxlZFwiXSA9IFwiY2FuY2VsbGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiY29uZmlybWVkXCJdID0gXCJjb25maXJtZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJmYWlsZWRcIl0gPSBcImZhaWxlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImZpbmFsaXplZFwiXSA9IFwiZmluYWxpemVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wicHJvY2Vzc2VkXCJdID0gXCJwcm9jZXNzZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzaWduZWRcIl0gPSBcInNpZ25lZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInN1Ym1pdHRlZFwiXSA9IFwic3VibWl0dGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1widW5hcHByb3ZlZFwiXSA9IFwidW5hcHByb3ZlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImRyb3BwZWRcIl0gPSBcImRyb3BwZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJleHBpcmVkXCJdID0gXCJleHBpcmVkXCI7XG59KShUcmFuc2FjdGlvblN0YXR1cyB8fCAoVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xuY29uc3QgVFJBTlNBQ1RJT05fVFlQRVMgPSB7XG4gIENPTlRSQUNUX0lOVEVSQUNUSU9OOiBcImNvbnRyYWN0SW50ZXJhY3Rpb25cIixcbiAgREVQTE9ZX0NPTlRSQUNUOiBcImNvbnRyYWN0RGVwbG95bWVudFwiLFxuICBXQVNNX0JBU0VEX0RFUExPWTogXCJ3YXNtQmFzZWREZXBsb3lcIixcbiAgU1RBTkRBUkRfVFJBTlNBQ1RJT046IFwidHJhbnNhY3Rpb25cIixcbiAgU1RBTkRBUkRfUEFZTUVOVF9UUkFOU0FDVElPTjogXCJwYXltZW50X3RyYW5zYWN0aW9uXCIgLy8gc3BlY2lmaWMgdG8gY2hhaW5zIGxpa2Ugc29sYW5hIGFuZCBjYXNwZXJcbn07XG5cbmNvbnN0IFRYX0VWRU5UUyA9IHtcbiAgVFhfV0FSTklORzogXCJ0eDp3YXJuaW5nXCIsXG4gIFRYX0VSUk9SOiBcInR4OmVycm9yXCIsXG4gIFRYX0ZBSUxFRDogXCJ0eDpmYWlsZWRcIixcbiAgVFhfQ09ORklSTUVEOiBcInR4OmNvbmZpcm1lZFwiLFxuICBUWF9EUk9QUEVEOiBcInR4OmRyb3BwZWRcIixcbiAgVFhfRVhQSVJFRDogXCJ0eDpleHBpcmVkXCIsXG4gIFRYX1NUQVRVU19VUERBVEU6IFwidHg6c3RhdHVzX3VwZGF0ZVwiLFxuICBUWF9VTkFQUFJPVkVEOiBcInR4OnVuYXBwcm92ZWRcIlxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jbGFzcyBCYXNlVHJhbnNhY3Rpb25TdGF0ZU1hbmFnZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGUsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZFxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Q3VycmVudENoYWluSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICB0eEhpc3RvcnlMaW1pdDogNDBcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgdHJhbnNhY3Rpb25zOiB7fSxcbiAgICAgIHVuYXBwcm92ZWRUeHM6IHt9LFxuICAgICAgY3VycmVudE5ldHdvcmtUeHNMaXN0OiBbXVxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICB9XG4gIGdldFVuYXBwcm92ZWRUeExpc3QoKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICByZXR1cm4gcGlja0J5KHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQgJiYgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayh0cmFuc2FjdGlvbiwgY2hhaW5JZCkpO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uKHR4SWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25zW3R4SWRdO1xuICB9XG4gIHVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSkge1xuICAgIC8vIGNvbW1pdCB0eE1ldGEgdG8gc3RhdGVcbiAgICBjb25zdCB0eElkID0gdHhNZXRhLmlkO1xuICAgIHR4TWV0YS51cGRhdGVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucyksIHt9LCB7XG4gICAgICAgIFt0eElkXTogdHhNZXRhXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNldFR4U3RhdHVzUmVqZWN0ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkKTtcbiAgICB0aGlzLl9kZWxldGVUcmFuc2FjdGlvbih0eElkKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGltcGxlbWVudGluZyBjb250cm9sbGVyIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uYWxpdHkgYW5kIGFkZCBjdXN0b20gbG9naWMgKyBjYWxsIHN1cGVyLigpXG4gICAqL1xuICBzZXRUeFN0YXR1c1VuYXBwcm92ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzQXBwcm92ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmFwcHJvdmVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c1NpZ25lZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuc2lnbmVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c1N1Ym1pdHRlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c0Ryb3BwZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmRyb3BwZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzRXhwaXJlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuZXhwaXJlZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNDb25maXJtZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNGYWlsZWQodHhJZCwgZXJyb3JfKSB7XG4gICAgY29uc3QgZXJyb3IgPSAhZXJyb3JfID8gbmV3IEVycm9yKFwiSW50ZXJuYWwgdG9ydXMgZmFpbHVyZVwiKSA6IGVycm9yXztcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHR4TWV0YS5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKTtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiBhIGZpbmFsIHN0YXRlXG4gICAqIEBwYXJhbSBzdGF0dXMgLSBUcmFuc2FjdGlvbiBzdGF0dXNcbiAgICogQHJldHVybnMgYm9vbGVhbiBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZVxuICAgKi9cbiAgaXNGaW5hbFN0YXRlKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZXhwaXJlZDtcbiAgfVxuICAvKipcbiAgICogRmlsdGVycyBvdXQgdGhlIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIGZyb20gc3RhdGVcbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZFR4cygpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IG9taXRCeSh0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB3aWxsIGFwcGVuZCBuZXcgdHJhbnNhY3Rpb25zIHRvIG9sZCB0eG5zLlxuICAgKi9cbiAgX2FkZFRyYW5zYWN0aW9uc1RvU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMucmVkdWNlKChyZXN1bHQsIG5ld1R4KSA9PiB7XG4gICAgICAgIHJlc3VsdFtuZXdUeC5pZF0gPSBuZXdUeDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB3aWxsIHNldCBuZXcgdHhucywgb3ZlcnJpZGUgZXhpc3RpbmcgaWYgYW55IGluIHN0YXRlLlxuICAgKi9cbiAgX3NldFRyYW5zYWN0aW9uc1RvU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMucmVkdWNlKChyZXN1bHQsIG5ld1R4KSA9PiB7XG4gICAgICAgIHJlc3VsdFtuZXdUeC5pZF0gPSBuZXdUeDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KVxuICAgIH0pO1xuICB9XG4gIF9kZWxldGVUcmFuc2FjdGlvbih0YXJnZXRUcmFuc2FjdGlvbklkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgZGVsZXRlIHRyYW5zYWN0aW9uc1t0YXJnZXRUcmFuc2FjdGlvbklkXTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBfZGVsZXRlVHJhbnNhY3Rpb25zKHRhcmdldFRyYW5zYWN0aW9uSWRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGFyZ2V0VHJhbnNhY3Rpb25JZHMuZm9yRWFjaCh0cmFuc2FjdGlvbklkID0+IHtcbiAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZF07XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIHN0YXR1cykge1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgaWYgKCF0eE1ldGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHhNZXRhLnN0YXR1cyA9IHN0YXR1cztcbiAgICAvLyBvbmx5IHVwZGF0aW5nIHN0YXR1cyBzbyBubyB2YWxpZGF0aW9uIHJlcXVpcmVkIG9uIHR4bi5cbiAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSk7XG4gICAgdGhpcy5lbWl0KFRYX0VWRU5UUy5UWF9TVEFUVVNfVVBEQVRFLCB7XG4gICAgICB0eElkLFxuICAgICAgc3RhdHVzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuaXNGaW5hbFN0YXRlKHN0YXR1cykpIHtcbiAgICAgIHRoaXMuZW1pdChgJHt0eE1ldGEuaWR9OmZpbmlzaGVkYCwgdHhNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KGAke3R4TWV0YS5pZH06JHtzdGF0dXN9YCwgdHhJZCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEFDQ09VTlRfQ0FURUdPUlksIEFDVElWSVRZX0FDVElPTiwgQUNUSVZJVFlfQUNUSU9OX0FMTCwgQUNUSVZJVFlfQUNUSU9OX0JVUk4sIEFDVElWSVRZX0FDVElPTl9SRUNFSVZFLCBBQ1RJVklUWV9BQ1RJT05fU0VORCwgQUNUSVZJVFlfQUNUSU9OX1RPUFVQLCBBQ1RJVklUWV9QRVJJT0RfQUxMLCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfT05FLCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfU0lYLCBBQ1RJVklUWV9QRVJJT0RfV0VFS19PTkUsIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQsIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HLCBBQ1RJVklUWV9TVEFUVVNfUEVORElORywgQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUwsIEFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUwsIEJST0FEQ0FTVF9DSEFOTkVMUywgQlJPQURDQVNUX0NIQU5ORUxTX01TR1MsIEJhc2VCbG9ja1RyYWNrZXIsIEJhc2VDb250cm9sbGVyLCBCYXNlQ3VycmVuY3lDb250cm9sbGVyLCBCYXNlRW1iZWRDb250cm9sbGVyLCBCYXNlS2V5cmluZ0NvbnRyb2xsZXIsIEJhc2VQcmVmZXJlbmNlc0NvbnRyb2xsZXIsIEJhc2VUcmFuc2FjdGlvblN0YXRlTWFuYWdlciwgQnJvYWRjYXN0Q2hhbm5lbEhhbmRsZXIsIENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMsIENvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLCBERUZBVUxUX1BSRUZFUkVOQ0VTLCBGRUFUVVJFU19DT05GSVJNX1dJTkRPVywgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1csIEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVywgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVywgTE9HSU5fUFJPVklERVIsIFBBWU1FTlRfUFJPVklERVIsIFBPUFVQX0xPQURFRCwgUE9QVVBfUkVTVUxULCBQUk9WSURFUl9KUlBDX01FVEhPRFMsIFBST1ZJREVSX05PVElGSUNBVElPTlMsIFBvcHVwSGFuZGxlciwgUG9wdXBTdG9yZUNoYW5uZWwsIFBvcHVwV2l0aEJjSGFuZGxlciwgUmVkaXJlY3RIYW5kbGVyLCBTRVRVUF9DT01QTEVURSwgU3RyZWFtV2luZG93LCBUUkFOU0FDVElPTl9UWVBFUywgVFhfRVZFTlRTLCBUcmFuc2FjdGlvblN0YXR1cywgVXNlckVycm9yLCBhZGRyZXNzU2xpY2VyLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucywgY29uY2F0U2lnLCBjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlLCBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZSwgY3JlYXRlRXZlbnRFbWl0dGVyUHJveHksIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSwgY3JlYXRlRmV0Y2hNaWRkbGV3YXJlLCBjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUsIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUsIGNyZWF0ZVJhbmRvbUlkLCBjcmVhdGVTd2FwcGFibGVQcm94eSwgY3JlYXRlVG9wdXBNaWRkbGV3YXJlLCBmb3JtYXREYXRlLCBmb3JtYXRTbWFsbE51bWJlcnMsIGZvcm1hdFRpbWUsIGdldEN1c3RvbURldmljZUluZm8sIGdldEhlYWRlcnMsIGdldFBvcHVwRmVhdHVyZXMsIGdldFR4U3RhdHVzVGV4dCwgaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzLCBoYXNoTWVzc2FnZSwgaW50VG9IZXgsIHBhZFdpdGhaZXJvZXMsIHByb3ZpZGVyQXNNaWRkbGV3YXJlLCBwcm92aWRlckZyb21FbmdpbmUsIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUsIHJhbmRvbUlkLCBzaWduTWVzc2FnZSwgc2lnbmlmaWNhbnREaWdpdHMsIHNsZWVwLCB0aW1lb3V0JDEgYXMgdGltZW91dCwgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZUNvbnRyb2xsZXJzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJTYWZlRXZlbnRFbWl0dGVyIiwiSlJQQ0VuZ2luZSIsImNyZWF0ZUFzeW5jTWlkZGxld2FyZSIsIm1lcmdlTWlkZGxld2FyZSIsImNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSIsInNlcmlhbGl6ZUVycm9yIiwiZXRoRXJyb3JzIiwiZ2V0Q3JlYXRlUmFuZG9tSWQiLCJmcm9tU2lnbmVkIiwiYnVmZmVyVG9CaWdJbnQiLCJ0b1Vuc2lnbmVkIiwic3RyaXBIZXhQcmVmaXgiLCJiaWdJbnRUb0hleCIsImFkZEhleFByZWZpeCIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJlY3NpZ24iLCJiaWdJbnRUb0J1ZmZlciIsIkJpZ051bWJlciIsImxvZyIsIkJyb2FkY2FzdENoYW5uZWwiLCJnZXQiLCJwb3N0IiwicGF0Y2giLCJyZW1vdmUiLCJib3dzZXIiLCJjbG9uZURlZXAiLCJwaWNrQnkiLCJvbWl0QnkiLCJvd25LZXlzJDMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQkMyIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIkJhc2VDb250cm9sbGVyIiwiY29uc3RydWN0b3IiLCJfcmVmIiwiY29uZmlnIiwic3RhdGUiLCJkZWZhdWx0Q29uZmlnIiwiZGVmYXVsdFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwiaW5pdGlhbENvbmZpZyIsImludGVybmFsQ29uZmlnIiwiaW50ZXJuYWxTdGF0ZSIsImNvbmZpZ3VyZSIsIm92ZXJ3cml0ZSIsInVuZGVmaW5lZCIsImZ1bGxVcGRhdGUiLCJhc3NpZ24iLCJ1cGRhdGUiLCJlbWl0IiwiaW5pdGlhbGl6ZSIsInNlYyIsImNhbGN1bGF0ZVN1bSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiYmxvY2tUcmFja2VyRXZlbnRzIiwiQmFzZUJsb2NrVHJhY2tlciIsIl9jdXJyZW50QmxvY2siLCJpZGVtcG90ZW5jeUtleSIsIl9pc1J1bm5pbmciLCJibG9ja1Jlc2V0RHVyYXRpb24iLCJfb25OZXdMaXN0ZW5lciIsImJpbmQiLCJfb25SZW1vdmVMaXN0ZW5lciIsIl9yZXNldEN1cnJlbnRCbG9jayIsIl9zZXR1cEludGVybmFsRXZlbnRzIiwiaXNSdW5uaW5nIiwiZ2V0Q3VycmVudEJsb2NrIiwiZ2V0TGF0ZXN0QmxvY2siLCJsYXRlc3RCbG9jayIsIlByb21pc2UiLCJyZXNvbHZlIiwib25jZSIsIm5ld1N0YXRlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZXZlbnROYW1lIiwiX3N0YXJ0IiwiX2VuZCIsIl9uZXdQb3RlbnRpYWxMYXRlc3QiLCJuZXdCbG9jayIsImN1cnJlbnRCbG9jayIsIl9zZXRDdXJyZW50QmxvY2siLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwiX21heWJlU3RhcnQiLCJfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCIsIl9tYXliZUVuZCIsIl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCIsIl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0IiwibWFwIiwibGlzdGVuZXJDb3VudCIsInJlZHVjZSIsIm9sZEJsb2NrIiwiX2Jsb2NrUmVzZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsInVucmVmIiwiY2xlYXJUaW1lb3V0IiwiZmlsdGVyTm9vcCIsImludGVybmFsRXZlbnRzIiwiZXh0ZXJuYWxFdmVudEZpbHRlciIsIm5hbWUiLCJpbmNsdWRlcyIsImdldFJhd0xpc3RlbmVycyIsImV2ZW50RW1pdHRlciIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVycyIsImNyZWF0ZUV2ZW50RW1pdHRlclByb3h5IiwiaW5pdGlhbFRhcmdldCIsIm9wdHMiLCJmaW5hbE9wdHMiLCJldmVudEZpbHRlciIsIkVycm9yIiwic2V0VGFyZ2V0IiwibmV3VGFyZ2V0Iiwib2xkVGFyZ2V0IiwiZXZlbnROYW1lcyIsImhhbmRsZXIiLCJwcm94eSIsIlByb3h5IiwiXyIsInNldCIsInZhbHVlIiwiY3JlYXRlU3dhcHBhYmxlUHJveHkiLCJQT0xMSU5HX0lOVEVSVkFMIiwiQmFzZUN1cnJlbmN5Q29udHJvbGxlciIsImN1cnJlbnRDdXJyZW5jeSIsImNvbnZlcnNpb25SYXRlIiwiY29udmVyc2lvbkRhdGUiLCJuYXRpdmVDdXJyZW5jeSIsInBvbGxJbnRlcnZhbCIsImdldE5hdGl2ZUN1cnJlbmN5Iiwic2V0TmF0aXZlQ3VycmVuY3kiLCJ0aWNrZXIiLCJnZXRDdXJyZW50Q3VycmVuY3kiLCJzZXRDdXJyZW50Q3VycmVuY3kiLCJnZXRDb252ZXJzaW9uUmF0ZSIsInNldENvbnZlcnNpb25SYXRlIiwiZ2V0Q29udmVyc2lvbkRhdGUiLCJzZXRDb252ZXJzaW9uRGF0ZSIsIm93bktleXMkMiIsIl9vYmplY3RTcHJlYWQkMiIsImNyZWF0ZVJhbmRvbUlkIiwicHJvdmlkZXJGcm9tRW5naW5lIiwiZW5naW5lIiwicHJvdmlkZXIiLCJzZW5kQXN5bmMiLCJyZXEiLCJyZXMiLCJoYW5kbGUiLCJlcnJvciIsIl9yZXMkZXJyb3IiLCJfcmVzJGVycm9yMiIsImVyciIsImZhbGxiYWNrRXJyb3IiLCJtZXNzYWdlIiwidG9TdHJpbmciLCJjb2RlIiwicnBjIiwiaW50ZXJuYWwiLCJyZXN1bHQiLCJzZW5kIiwiY2FsbGJhY2siLCJyZXF1ZXN0IiwiYXJncyIsImlkIiwianNvbnJwYyIsInByb3ZpZGVyRnJvbU1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlIiwicHJvdmlkZXJBc01pZGRsZXdhcmUiLCJfbmV4dCIsImVuZCIsInByb3ZpZGVyUmVzIiwiRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyIsImhlaWdodCIsIndpZHRoIiwiRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XIiwiRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1ciLCJGRUFUVVJFU19DT05GSVJNX1dJTkRPVyIsIlBPUFVQX0xPQURFRCIsIlBPUFVQX1JFU1VMVCIsIlNFVFVQX0NPTVBMRVRFIiwiQUNUSVZJVFlfQUNUSU9OX0FMTCIsIkFDVElWSVRZX0FDVElPTl9TRU5EIiwiQUNUSVZJVFlfQUNUSU9OX0JVUk4iLCJBQ1RJVklUWV9BQ1RJT05fUkVDRUlWRSIsIkFDVElWSVRZX0FDVElPTl9UT1BVUCIsIkFDVElWSVRZX1BFUklPRF9BTEwiLCJBQ1RJVklUWV9QRVJJT0RfV0VFS19PTkUiLCJBQ1RJVklUWV9QRVJJT0RfTU9OVEhfT05FIiwiQUNUSVZJVFlfUEVSSU9EX01PTlRIX1NJWCIsIkFDVElWSVRZX1NUQVRVU19TVUNDRVNTRlVMIiwiQUNUSVZJVFlfU1RBVFVTX1VOU1VDQ0VTU0ZVTCIsIkFDVElWSVRZX1NUQVRVU19QRU5ESU5HIiwiQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRCIsIkFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HIiwiQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TIiwiSUZSQU1FX1NUQVRVUyIsIkNSRUFURV9XSU5ET1ciLCJDTE9TRV9XSU5ET1ciLCJVU0VSX0xPR0dFRF9JTiIsIlVTRVJfTE9HR0VEX09VVCIsIkNPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTIiwiTE9HT1VUIiwiV0FMTEVUX0lOU1RBTkNFX0lEIiwiVVNFUl9JTkZPIiwiU0VUX1BST1ZJREVSIiwiVE9QVVAiLCJPUEVORURfV0lORE9XIiwiQ0xPU0VEX1dJTkRPVyIsIkdFVF9QUk9WSURFUl9TVEFURSIsIkxPR0lOX1dJVEhfUFJJVkFURV9LRVkiLCJQUk9WSURFUl9KUlBDX01FVEhPRFMiLCJQUk9WSURFUl9OT1RJRklDQVRJT05TIiwiQUNDT1VOVFNfQ0hBTkdFRCIsIkNIQUlOX0NIQU5HRUQiLCJVTkxPQ0tfU1RBVEVfQ0hBTkdFRCIsIkJST0FEQ0FTVF9DSEFOTkVMUyIsIlJFRElSRUNUX0NIQU5ORUwiLCJQUk9WSURFUl9DSEFOR0VfQ0hBTk5FTCIsIlRSQU5TQUNUSU9OX0NIQU5ORUwiLCJNRVNTQUdFX0NIQU5ORUwiLCJXQUxMRVRfTE9HT1VUX0NIQU5ORUwiLCJXQUxMRVRfU0VMRUNURURfQUREUkVTU19DSEFOTkVMIiwiV0FMTEVUX05FVFdPUktfQ0hBTkdFX0NIQU5ORUwiLCJXQUxMRVRfQUNDT1VOVF9JTVBPUlRfQ0hBTk5FTCIsIlRIRU1FX0NIQU5HRSIsIkJST0FEQ0FTVF9DSEFOTkVMU19NU0dTIiwiQUNDT1VOVF9JTVBPUlRFRCIsIlNFTEVDVEVEX0FERFJFU1NfQ0hBTkdFIiwiTkVUV09SS19DSEFOR0UiLCJTRVRfVEhFTUUiLCJjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlIiwiY2hhbmdlUHJvdmlkZXIiLCJyZXNwb25zZSIsIm5leHQiLCJtZXRob2QiLCJjcmVhdGVUb3B1cE1pZGRsZXdhcmUiLCJfcmVmMiIsInRvcHVwIiwiY3JlYXRlR2VuZXJpY0pSUENNaWRkbGV3YXJlIiwidGFyZ2V0TWV0aG9kIiwiY3JlYXRlQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUiLCJwcm92aWRlckhhbmRsZXJzIiwiZ2V0VXNlckluZm8iLCJnZXRXYWxsZXRJbnN0YW5jZUlkIiwibG9nb3V0Iiwic2V0SUZyYW1lU3RhdHVzIiwiaGFuZGxlV2luZG93UnBjIiwiZ2V0UHJvdmlkZXJTdGF0ZSIsImxvZ2luV2l0aFByaXZhdGVLZXkiLCJCYXNlRW1iZWRDb250cm9sbGVyIiwiYnV0dG9uUG9zaXRpb24iLCJpc0lGcmFtZUZ1bGxTY3JlZW4iLCJhcGlLZXkiLCJvYXV0aE1vZGFsVmlzaWJpbGl0eSIsImxvZ2luSW5Qcm9ncmVzcyIsImRhcHBNZXRhZGF0YSIsImljb24iLCJpbml0aWFsaXplUHJvdmlkZXIiLCJoYW5kbGVycyIsImNvbW11bmljYXRpb25NaWRkbGV3YXJlIiwiY29tbXVuaWNhdGlvblByb3ZpZGVyIiwic2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyIiwiX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5IiwiQ29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIiLCJwYXJhbXMiLCJ3aW5kb3dJZCIsIkxPR0lOX1BST1ZJREVSIiwiR09PR0xFIiwiRkFDRUJPT0siLCJSRURESVQiLCJESVNDT1JEIiwiVFdJVENIIiwiQVBQTEUiLCJMSU5FIiwiR0lUSFVCIiwiS0FLQU8iLCJMSU5LRURJTiIsIlRXSVRURVIiLCJXRUlCTyIsIldFQ0hBVCIsIkVNQUlMX1BBU1NXT1JETEVTUyIsIlBBWU1FTlRfUFJPVklERVIiLCJNT09OUEFZIiwiV1lSRSIsIlJBTVBORVRXT1JLIiwiWEFOUE9PTCIsIk1FUkNVUllPIiwiVFJBTlNBSyIsImdldFR4U3RhdHVzVGV4dCIsInR4U3RhdHVzIiwiaW50VG9IZXgiLCJoZXgiLCJyYW5kb21JZCIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsInBhZFdpdGhaZXJvZXMiLCJoZXhTdHJpbmciLCJ0YXJnZXRMZW5ndGgiLCJ0ZXN0IiwiU3RyaW5nIiwicHJvdG90eXBlIiwicGFkU3RhcnQiLCJjYWxsIiwiY29uY2F0U2lnIiwidiIsInIiLCJzIiwiclNpZyIsInNTaWciLCJ2U2lnIiwiclN0ciIsInNTdHIiLCJ2U3RyIiwiY29uY2F0IiwidGltZW91dCQxIiwiZHVyYXRpb24iLCJ0aW1lb3V0UmVmIiwid2luZG93IiwiZ2V0SGVhZGVycyIsImp3dCIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiZm9ybWF0U21hbGxOdW1iZXJzIiwibnVtYmVyIiwiY3VycmVuY3kiLCJub1RpbGRlIiwiZmluYWxOdW1iZXIiLCJpc0JpZ051bWJlciIsInRvTnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwidGlsZGUiLCJ0b1VwcGVyQ2FzZSIsImFkZHJlc3NTbGljZXIiLCJhZGRyZXNzIiwic2xpY2VMZW5ndGgiLCJzaWduaWZpY2FudERpZ2l0cyIsInBlcmMiLCJsZW5ndGhfIiwiaW5wdXQiLCJpc1plcm8iLCJ0aW1lcyIsImRlcHRoIiwiZ3RlIiwiY2VpbCIsImxvZzEwIiwiZGl2Iiwic2hpZnQiLCJwb3ciLCJyb3VuZGVkTnVtYmVyIiwicm91bmQiLCJmb3JtYXREYXRlIiwiaW5wdXREYXRlIiwibW9udGhMaXN0IiwiZGF0ZSIsIkRhdGUiLCJkYXkiLCJnZXREYXRlIiwibW9udGgiLCJnZXRNb250aCIsInllYXIiLCJnZXRGdWxsWWVhciIsImZvcm1hdFRpbWUiLCJ0aW1lIiwidG9UaW1lU3RyaW5nIiwidHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayIsInRyYW5zYWN0aW9uIiwiY2hhaW5JZCIsImhhc2hNZXNzYWdlIiwiYnVmZmVyZWRNZXNzYWdlIiwiQnVmZmVyIiwiZnJvbSIsImVsIiwic2lnbk1lc3NhZ2UiLCJwcml2YXRlS2V5IiwiZGF0YSIsInByaXZLZXkiLCJtc2dTaWciLCJyYXdNc2dTaWciLCJnZXRQb3B1cEZlYXR1cmVzIiwidyIsImgiLCJkdWFsU2NyZWVuTGVmdCIsInNjcmVlbkxlZnQiLCJzY3JlZW5YIiwiZHVhbFNjcmVlblRvcCIsInNjcmVlblRvcCIsInNjcmVlblkiLCJpbm5lcldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsInNjcmVlbiIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3lzdGVtWm9vbSIsImxlZnQiLCJhYnMiLCJ0b3AiLCJmZWF0dXJlcyIsImJyb2FkY2FzdENoYW5uZWxPcHRpb25zIiwid2ViV29ya2VyU3VwcG9ydCIsImdldEN1c3RvbURldmljZUluZm8iLCJfbmF2aWdhdG9yIiwibmF2aWdhdG9yIiwiYnJhdmUiLCJicm93c2VyIiwiVXNlckVycm9yIiwiaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzIiwiaGFzaCIsInF1ZXJ5UGFyYW1ldGVycyIsImhhc2hQYXJhbWV0ZXJzIiwiaGFzaFVybCIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwic2VhcmNoUGFyYW1zIiwiaW5zdGFuY2VQYXJhbWV0ZXJzIiwiSlNPTiIsInBhcnNlIiwiYXRvYiIsImRlY29kZVVSSUNvbXBvbmVudCIsImVycm9yX2Rlc2NyaXB0aW9uIiwic2xlZXAiLCJtcyIsIkJhc2VLZXlyaW5nQ29udHJvbGxlciIsIl9zdGF0ZSR3YWxsZXRzIiwid2FsbGV0cyIsInNpZ25BdXRoTWVzc2FnZSIsImtleXJpbmciLCJmaW5kIiwieCIsImhhc2hlZE1lc3NhZ2UiLCJyYXdNZXNzYWdlU2lnIiwiUkVUUklBQkxFX0VSUk9SUyIsImNoZWNrRm9ySHR0cEVycm9ycyIsImZldGNoUmVzIiwic3RhdHVzIiwibWV0aG9kTm90Rm91bmQiLCJ0aW1lb3V0IiwicGFyc2VSZXNwb25zZSIsImJvZHkiLCJjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEiLCJycGNUYXJnZXQiLCJvcmlnaW5IdHRwSGVhZGVyS2V5IiwicGFyc2VkVXJsIiwicGF5bG9hZCIsIm9yaWdpbkRvbWFpbiIsInNlcmlhbGl6ZWRQYXlsb2FkIiwic3RyaW5naWZ5IiwiZmV0Y2hQYXJhbXMiLCJBY2NlcHQiLCJmZXRjaFVybCIsImhyZWYiLCJjcmVhdGVGZXRjaE1pZGRsZXdhcmUiLCJtYXhBdHRlbXB0cyIsInJldHJ5SW50ZXJ2YWwiLCJhdHRlbXB0IiwiZmV0Y2giLCJmZXRjaEJvZHkiLCJqc29uIiwiZXJyTXNnIiwiaXNSZXRyaWFibGUiLCJzb21lIiwicGhyYXNlIiwiY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSIsIm9wdGlvbnMiLCJsb2dnZXJNaWRkbGV3YXJlIiwid2FybiIsImlzVG9ydXNJbnRlcm5hbCIsImluZm8iLCJjcmVhdGVPcmlnaW5NaWRkbGV3YXJlIiwib3JpZ2luTWlkZGxld2FyZSIsIkJyb2FkY2FzdENoYW5uZWxIYW5kbGVyIiwiY2hhbm5lbFByZWZpeCIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImluc3RhbmNlSWQiLCJjaGFubmVsIiwiYmMiLCJnZXRNZXNzYWdlRnJvbUNoYW5uZWwiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZXYiLCJjbG9zZSIsInBvc3RNZXNzYWdlIiwidHlwZSIsIlN0cmVhbVdpbmRvdyIsIm9wZW4iLCJjb21tdW5pY2F0aW9uRW5naW5lIiwiY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIiLCJwb3B1cFN1Y2Nlc3MiLCJjbG9zZWQiLCJ1cmwiLCJwb3N0TXNnIiwibG9jYWxSZXNwb25zZSIsImN1cnJlbnREZWxheSIsInJlY3Vyc2l2ZUZuIiwic2VydmVyUmVzcG9uc2UiLCJQb3B1cEhhbmRsZXIiLCJkYXBwU3RvcmFnZUtleSIsIndpbmRvd1RpbWVyIiwiaUNsb3NlZFdpbmRvdyIsIl9zZXR1cFRpbWVyIiwidXJsSGFzaFBhcmFtcyIsImFwcGVuZCIsImxvY2FsV2luZG93IiwidGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJQb3B1cFN0b3JlQ2hhbm5lbCIsImhhbmRsZUxvZ291dCIsImhhbmRsZUFjY291bnRJbXBvcnQiLCJoYW5kbGVOZXR3b3JrQ2hhbmdlIiwiaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlIiwiaGFuZGxlVGhlbWVDaGFuZ2UiLCJzZXR1cFN0b3JlQ2hhbm5lbHMiLCJsb2dvdXRDaGFubmVsIiwiaW1wb3J0QWNjb3VudENoYW5uZWwiLCJuZXR3b3JrQ2hhbmdlQ2hhbm5lbCIsInNlbGVjdGVkQWRkcmVzc0NoYW5nZUNoYW5uZWwiLCJ0aGVtZUNoYW5nZWRDaGFubmVsIiwiX2V2JGRhdGEiLCJ3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCIsIl9ldiRkYXRhMiIsIl9ldiRkYXRhMyIsIl9ldiRkYXRhNCIsIl9ldiRkYXRhNSIsIm5ldHdvcmsiLCJfZXYkZGF0YTYiLCJfZXYkZGF0YTciLCJ0aGVtZSIsIl9ldiRkYXRhOCIsIl9ldiRkYXRhOSIsInNlbGVjdGVkQWRkcmVzcyIsIlBvcHVwV2l0aEJjSGFuZGxlciIsInN1Y2Nlc3NFeHRyYUZuIiwiY2xvc2VMaXN0ZW5lciIsInRoZW4iLCJjYXRjaCIsImhhbmRsZVdpdGhIYW5kc2hha2UiLCJSZWRpcmVjdEhhbmRsZXIiLCJmaW5hbFF1ZXJ5UGFyYW1zIiwiaW5zdGFuY2VQYXJhbXMiLCJoYXNoUGFyYW1zIiwicXVlcnlQYXJhbXMiLCJBQ1RJVklUWV9BQ1RJT04iLCJBQ0NPVU5UX0NBVEVHT1JZIiwiTk9STUFMIiwiVEhSRVNIT0xEIiwiSU1QT1JURUQiLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJERUZBVUxUX0lOVEVSVkFMIiwiREVGQVVMVF9QUkVGRVJFTkNFUyIsInNlbGVjdGVkQ3VycmVuY3kiLCJsb2NhbGUiLCJhY2NvdW50VHlwZSIsImNvbnRhY3RzIiwiand0VG9rZW4iLCJmZXRjaGVkUGFzdFR4IiwicGFzdFRyYW5zYWN0aW9ucyIsInBheW1lbnRUeCIsImRlZmF1bHRQdWJsaWNBZGRyZXNzIiwiY3VzdG9tVG9rZW5zIiwiY3VzdG9tTmZ0cyIsImNyYXNoUmVwb3J0IiwidXNlckluZm8iLCJhZ2dyZWdhdGVWZXJpZmllciIsImVtYWlsIiwicHJvZmlsZUltYWdlIiwidHlwZU9mTG9naW4iLCJ2ZXJpZmllciIsInZlcmlmaWVySWQiLCJCYXNlUHJlZmVyZW5jZXNDb250cm9sbGVyIiwiZGVmYXVsdFByZWZlcmVuY2VzIiwiYXBpIiwiaWRlbnRpdGllcyIsImxhc3RFcnJvck1lc3NhZ2UiLCJsYXN0U3VjY2Vzc01lc3NhZ2UiLCJzZXRJZnJhbWVPcmlnaW4iLCJpZnJhbWVPcmlnaW4iLCJnZXRBZGRyZXNzU3RhdGUiLCJzZXRTZWxlY3RlZEFkZHJlc3MiLCJnZXRVc2VyIiwidXNlciIsInVzZUFQSUtleSIsImNyZWF0ZVVzZXIiLCJpZFRva2VuIiwidXNlclBheWxvYWQiLCJkZWZhdWx0X2N1cnJlbmN5IiwidmVyaWZpZXJfaWQiLCJ1cGRhdGVTdGF0ZSIsInN0b3JlVXNlckxvZ2luIiwicmVoeWRyYXRlIiwiZ2V0UGFyc2VyIiwidXNlckFnZW50Iiwic3BlY2lhbEJyb3dzZXIiLCJyZWNvcmRMb2dpblBheWxvYWQiLCJvcyIsImdldE9TTmFtZSIsIm9zX3ZlcnNpb24iLCJnZXRPU1ZlcnNpb24iLCJnZXRCcm93c2VyTmFtZSIsImJyb3dzZXJfdmVyc2lvbiIsImdldEJyb3dzZXJWZXJzaW9uIiwicGxhdGZvcm0iLCJnZXRQbGF0Zm9ybSIsImhvc3RuYW1lIiwic2V0Q3Jhc2hSZXBvcnQiLCJpc0VuYWJsZWQiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGUiLCJlbmFibGVfY3Jhc2hfcmVwb3J0ZXIiLCJzZXRVc2VyVGhlbWUiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGUyIiwic2V0VXNlckxvY2FsZSIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTMiLCJzZXRTZWxlY3RlZEN1cnJlbmN5IiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNCIsImFkZENvbnRhY3QiLCJjb250YWN0IiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNSIsImRlbGV0ZUNvbnRhY3QiLCJjb250YWN0SWQiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGU2IiwiZmluYWxDb250YWN0cyIsInJldm9rZURpc2NvcmQiLCJyZXNwIiwidG9rZW4iLCJwYXRjaFBhc3RUeCIsInBvc3RQYXN0VHgiLCJ0eCIsImdldFdhbGxldE9yZGVycyIsInN1Y2Nlc3MiLCJnZXRUb3BVcE9yZGVycyIsImNvbW1vbkFwaUhvc3QiLCJnZXRCaWxsQm9hcmREYXRhIiwiZ2V0TWVzc2FnZUZvclNpZ25pbmciLCJwdWJsaWNBZGRyZXNzIiwicHVibGljX2FkZHJlc3MiLCJnZXRUd2l0dGVySWQiLCJuaWNrIiwic2VuZEVtYWlsIiwiZW1haWxPYmplY3QiLCJyZWZyZXNoSnd0IiwibWVzc2FnZVRvU2lnbiIsInN0YXJ0c1dpdGgiLCJzaWduSW5QcmVmaXgiLCJzaWduZWRNZXNzYWdlIiwic2lnbmVkX21lc3NhZ2UiLCJnZXREYXBwTGlzdCIsImluaXQiLCJwcmVmZXJlbmNlcyIsImN1cnJlbnRTdGF0ZSIsIm1lcmdlZFN0YXRlIiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNyIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVFJBTlNBQ1RJT05fVFlQRVMiLCJDT05UUkFDVF9JTlRFUkFDVElPTiIsIkRFUExPWV9DT05UUkFDVCIsIldBU01fQkFTRURfREVQTE9ZIiwiU1RBTkRBUkRfVFJBTlNBQ1RJT04iLCJTVEFOREFSRF9QQVlNRU5UX1RSQU5TQUNUSU9OIiwiVFhfRVZFTlRTIiwiVFhfV0FSTklORyIsIlRYX0VSUk9SIiwiVFhfRkFJTEVEIiwiVFhfQ09ORklSTUVEIiwiVFhfRFJPUFBFRCIsIlRYX0VYUElSRUQiLCJUWF9TVEFUVVNfVVBEQVRFIiwiVFhfVU5BUFBST1ZFRCIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwiQmFzZVRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyIiwiZ2V0Q3VycmVudENoYWluSWQiLCJ0eEhpc3RvcnlMaW1pdCIsInRyYW5zYWN0aW9ucyIsInVuYXBwcm92ZWRUeHMiLCJjdXJyZW50TmV0d29ya1R4c0xpc3QiLCJnZXRVbmFwcHJvdmVkVHhMaXN0IiwidW5hcHByb3ZlZCIsImdldFRyYW5zYWN0aW9uIiwidHhJZCIsInVwZGF0ZVRyYW5zYWN0aW9uIiwidHhNZXRhIiwidXBkYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwic2V0VHhTdGF0dXNSZWplY3RlZCIsIl9zZXRUcmFuc2FjdGlvblN0YXR1cyIsInJlamVjdGVkIiwiX2RlbGV0ZVRyYW5zYWN0aW9uIiwic2V0VHhTdGF0dXNVbmFwcHJvdmVkIiwic2V0VHhTdGF0dXNBcHByb3ZlZCIsImFwcHJvdmVkIiwic2V0VHhTdGF0dXNTaWduZWQiLCJzaWduZWQiLCJzZXRUeFN0YXR1c1N1Ym1pdHRlZCIsInN1Ym1pdHRlZCIsInNldFR4U3RhdHVzRHJvcHBlZCIsImRyb3BwZWQiLCJzZXRUeFN0YXR1c0V4cGlyZWQiLCJleHBpcmVkIiwic2V0VHhTdGF0dXNDb25maXJtZWQiLCJjb25maXJtZWQiLCJzZXRUeFN0YXR1c0ZhaWxlZCIsImVycm9yXyIsImZhaWxlZCIsImlzRmluYWxTdGF0ZSIsImNhbmNlbGxlZCIsImNsZWFyVW5hcHByb3ZlZFR4cyIsIl9hZGRUcmFuc2FjdGlvbnNUb1N0YXRlIiwibmV3VHgiLCJfc2V0VHJhbnNhY3Rpb25zVG9TdGF0ZSIsInRhcmdldFRyYW5zYWN0aW9uSWQiLCJfZGVsZXRlVHJhbnNhY3Rpb25zIiwidGFyZ2V0VHJhbnNhY3Rpb25JZHMiLCJ0cmFuc2FjdGlvbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/broadcast-channel.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/broadcast-channel.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadcastChannel: () => (/* binding */ BroadcastChannel),\n/* harmony export */   OPEN_BROADCAST_CHANNELS: () => (/* binding */ OPEN_BROADCAST_CHANNELS),\n/* harmony export */   enforceOptions: () => (/* binding */ enforceOptions)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n/* harmony import */ var _method_chooser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./method-chooser.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/method-chooser.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js\");\n\n\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */ var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n    // identifier of the channel to debug stuff\n    this.id = lastId++;\n    OPEN_BROADCAST_CHANNELS.add(this);\n    this.name = name;\n    if (ENFORCED_OPTIONS) {\n        options = ENFORCED_OPTIONS;\n    }\n    this.options = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.fillOptionsWithDefaults)(options);\n    this.method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(this.options);\n    // isListening\n    this._iL = false;\n    /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */ this._onML = null;\n    /**\n   * _addEventListeners\n   */ this._addEL = {\n        message: [],\n        internal: []\n    };\n    /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */ this._uMP = new Set();\n    /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */ this._befC = [];\n    /**\n   * _preparePromise\n   */ this._prepP = null;\n    _prepareChannel(this);\n};\n// STATICS\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */ BroadcastChannel._pubkey = true;\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */ var ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n    ENFORCED_OPTIONS = options;\n}\n// PROTOTYPE\nBroadcastChannel.prototype = {\n    postMessage: function postMessage(msg) {\n        if (this.closed) {\n            throw new Error(\"BroadcastChannel.postMessage(): \" + \"Cannot post message after channel has closed \" + /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */ JSON.stringify(msg));\n        }\n        return _post(this, \"message\", msg);\n    },\n    postInternal: function postInternal(msg) {\n        return _post(this, \"internal\", msg);\n    },\n    set onmessage (fn){\n        var time = this.method.microSeconds();\n        var listenObj = {\n            time: time,\n            fn: fn\n        };\n        _removeListenerObject(this, \"message\", this._onML);\n        if (fn && typeof fn === \"function\") {\n            this._onML = listenObj;\n            _addListenerObject(this, \"message\", listenObj);\n        } else {\n            this._onML = null;\n        }\n    },\n    addEventListener: function addEventListener(type, fn1) {\n        var time = this.method.microSeconds();\n        var listenObj = {\n            time: time,\n            fn: fn1\n        };\n        _addListenerObject(this, type, listenObj);\n    },\n    removeEventListener: function removeEventListener(type, fn1) {\n        var obj = this._addEL[type].find(function(obj) {\n            return obj.fn === fn1;\n        });\n        _removeListenerObject(this, type, obj);\n    },\n    close: function close() {\n        var _this = this;\n        if (this.closed) {\n            return;\n        }\n        OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n        this.closed = true;\n        var awaitPrepare = this._prepP ? this._prepP : _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_VOID;\n        this._onML = null;\n        this._addEL.message = [];\n        return awaitPrepare// wait until all current sending are processed\n        .then(function() {\n            return Promise.all(Array.from(_this._uMP));\n        })// run before-close hooks\n        .then(function() {\n            return Promise.all(_this._befC.map(function(fn1) {\n                return fn1();\n            }));\n        })// close the channel\n        .then(function() {\n            return _this.method.close(_this._state);\n        });\n    },\n    get type () {\n        return this.method.type;\n    },\n    get isClosed () {\n        return this.closed;\n    }\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */ function _post(broadcastChannel, type, msg) {\n    var time = broadcastChannel.method.microSeconds();\n    var msgObj = {\n        time: time,\n        type: type,\n        data: msg\n    };\n    var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_VOID;\n    return awaitPrepare.then(function() {\n        var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n        // add/remove to unsend messages list\n        broadcastChannel._uMP.add(sendPromise);\n        sendPromise[\"catch\"]().then(function() {\n            return broadcastChannel._uMP[\"delete\"](sendPromise);\n        });\n        return sendPromise;\n    });\n}\nfunction _prepareChannel(channel) {\n    var maybePromise = channel.method.create(channel.name, channel.options);\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isPromise)(maybePromise)) {\n        channel._prepP = maybePromise;\n        maybePromise.then(function(s) {\n            // used in tests to simulate slow runtime\n            /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/ channel._state = s;\n        });\n    } else {\n        channel._state = maybePromise;\n    }\n}\nfunction _hasMessageListeners(channel) {\n    if (channel._addEL.message.length > 0) return true;\n    if (channel._addEL.internal.length > 0) return true;\n    return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n    channel._addEL[type].push(obj);\n    _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n    channel._addEL[type] = channel._addEL[type].filter(function(o) {\n        return o !== obj;\n    });\n    _stopListening(channel);\n}\nfunction _startListening(channel) {\n    if (!channel._iL && _hasMessageListeners(channel)) {\n        // someone is listening, start subscribing\n        var listenerFn = function listenerFn(msgObj) {\n            channel._addEL[msgObj.type].forEach(function(listenerObject) {\n                /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */ var hundredMsInMicro = 100 * 1000;\n                var minMessageTime = listenerObject.time - hundredMsInMicro;\n                if (msgObj.time >= minMessageTime) {\n                    listenerObject.fn(msgObj.data);\n                } else if (channel.method.type === \"server\") {\n                    // server msg might lag based on connection.\n                    listenerObject.fn(msgObj.data);\n                }\n            });\n        };\n        var time = channel.method.microSeconds();\n        if (channel._prepP) {\n            channel._prepP.then(function() {\n                channel._iL = true;\n                channel.method.onMessage(channel._state, listenerFn, time);\n            });\n        } else {\n            channel._iL = true;\n            channel.method.onMessage(channel._state, listenerFn, time);\n        }\n    }\n}\nfunction _stopListening(channel) {\n    if (channel._iL && !_hasMessageListeners(channel)) {\n        // noone is listening, stop subscribing\n        channel._iL = false;\n        var time = channel.method.microSeconds();\n        channel.method.onMessage(channel._state, null, time);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvYnJvYWRjYXN0LWNoYW5uZWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTZEO0FBQ1Y7QUFDSTtBQUV2RDs7O0NBR0MsR0FDTSxJQUFJSSwwQkFBMEIsSUFBSUMsTUFBTTtBQUMvQyxJQUFJQyxTQUFTO0FBQ04sSUFBSUMsbUJBQW1CLFNBQVNBLGlCQUFpQkMsSUFBSSxFQUFFQyxPQUFPO0lBQ25FLDJDQUEyQztJQUMzQyxJQUFJLENBQUNDLEVBQUUsR0FBR0o7SUFDVkYsd0JBQXdCTyxHQUFHLENBQUMsSUFBSTtJQUNoQyxJQUFJLENBQUNILElBQUksR0FBR0E7SUFDWixJQUFJSSxrQkFBa0I7UUFDcEJILFVBQVVHO0lBQ1o7SUFDQSxJQUFJLENBQUNILE9BQU8sR0FBR04sb0VBQXVCQSxDQUFDTTtJQUN2QyxJQUFJLENBQUNJLE1BQU0sR0FBR1gsZ0VBQVlBLENBQUMsSUFBSSxDQUFDTyxPQUFPO0lBRXZDLGNBQWM7SUFDZCxJQUFJLENBQUNLLEdBQUcsR0FBRztJQUVYOzs7O0dBSUMsR0FDRCxJQUFJLENBQUNDLEtBQUssR0FBRztJQUViOztHQUVDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDWkMsU0FBUyxFQUFFO1FBQ1hDLFVBQVUsRUFBRTtJQUNkO0lBRUE7Ozs7R0FJQyxHQUNELElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlkO0lBRWhCOzs7O0dBSUMsR0FDRCxJQUFJLENBQUNlLEtBQUssR0FBRyxFQUFFO0lBRWY7O0dBRUMsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNkQyxnQkFBZ0IsSUFBSTtBQUN0QixFQUFFO0FBRUYsVUFBVTtBQUVWOzs7O0NBSUMsR0FDRGYsaUJBQWlCZ0IsT0FBTyxHQUFHO0FBRTNCOzs7Q0FHQyxHQUNELElBQUlYO0FBQ0csU0FBU1ksZUFBZWYsT0FBTztJQUNwQ0csbUJBQW1CSDtBQUNy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UUFBUS9DLEdBQUcsR0FBRztZQUNkK0MsUUFBUWhELE1BQU0sQ0FBQ2dFLFNBQVMsQ0FBQ2hCLFFBQVFOLE1BQU0sRUFBRWlCLFlBQVlwQztRQUN2RDtJQUNGO0FBQ0Y7QUFDQSxTQUFTbUMsZUFBZVYsT0FBTztJQUM3QixJQUFJQSxRQUFRL0MsR0FBRyxJQUFJLENBQUNtRCxxQkFBcUJKLFVBQVU7UUFDakQsdUNBQXVDO1FBQ3ZDQSxRQUFRL0MsR0FBRyxHQUFHO1FBQ2QsSUFBSXNCLE9BQU95QixRQUFRaEQsTUFBTSxDQUFDd0IsWUFBWTtRQUN0Q3dCLFFBQVFoRCxNQUFNLENBQUNnRSxTQUFTLENBQUNoQixRQUFRTixNQUFNLEVBQUUsTUFBTW5CO0lBQ2pEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvYnJvYWRjYXN0LWNoYW5uZWwuanM/Yjk0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1Byb21pc2UsIFBST01JU0VfUkVTT0xWRURfVk9JRCB9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgeyBjaG9vc2VNZXRob2QgfSBmcm9tICcuL21ldGhvZC1jaG9vc2VyLmpzJztcbmltcG9ydCB7IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzIH0gZnJvbSAnLi9vcHRpb25zLmpzJztcblxuLyoqXG4gKiBDb250YWlucyBhbGwgb3BlbiBjaGFubmVscyxcbiAqIHVzZWQgaW4gdGVzdHMgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgaXMgY2xvc2VkLlxuICovXG5leHBvcnQgdmFyIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTID0gbmV3IFNldCgpO1xudmFyIGxhc3RJZCA9IDA7XG5leHBvcnQgdmFyIEJyb2FkY2FzdENoYW5uZWwgPSBmdW5jdGlvbiBCcm9hZGNhc3RDaGFubmVsKG5hbWUsIG9wdGlvbnMpIHtcbiAgLy8gaWRlbnRpZmllciBvZiB0aGUgY2hhbm5lbCB0byBkZWJ1ZyBzdHVmZlxuICB0aGlzLmlkID0gbGFzdElkKys7XG4gIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTLmFkZCh0aGlzKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgaWYgKEVORk9SQ0VEX09QVElPTlMpIHtcbiAgICBvcHRpb25zID0gRU5GT1JDRURfT1BUSU9OUztcbiAgfVxuICB0aGlzLm9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgdGhpcy5tZXRob2QgPSBjaG9vc2VNZXRob2QodGhpcy5vcHRpb25zKTtcblxuICAvLyBpc0xpc3RlbmluZ1xuICB0aGlzLl9pTCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBfb25NZXNzYWdlTGlzdGVuZXJcbiAgICogc2V0dGluZyBvbm1lc3NhZ2UgdHdpY2UsXG4gICAqIHdpbGwgb3ZlcndyaXRlIHRoZSBmaXJzdCBsaXN0ZW5lclxuICAgKi9cbiAgdGhpcy5fb25NTCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIF9hZGRFdmVudExpc3RlbmVyc1xuICAgKi9cbiAgdGhpcy5fYWRkRUwgPSB7XG4gICAgbWVzc2FnZTogW10sXG4gICAgaW50ZXJuYWw6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2VuZCBtZXNzYWdlIHByb21pc2VzXG4gICAqIHdoZXJlIHRoZSBzZW5kaW5nIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIEB0eXBlIHtTZXQ8UHJvbWlzZT59XG4gICAqL1xuICB0aGlzLl91TVAgPSBuZXcgU2V0KCk7XG5cbiAgLyoqXG4gICAqIF9iZWZvcmVDbG9zZVxuICAgKiBhcnJheSBvZiBwcm9taXNlcyB0aGF0IHdpbGwgYmUgYXdhaXRlZFxuICAgKiBiZWZvcmUgdGhlIGNoYW5uZWwgaXMgY2xvc2VkXG4gICAqL1xuICB0aGlzLl9iZWZDID0gW107XG5cbiAgLyoqXG4gICAqIF9wcmVwYXJlUHJvbWlzZVxuICAgKi9cbiAgdGhpcy5fcHJlcFAgPSBudWxsO1xuICBfcHJlcGFyZUNoYW5uZWwodGhpcyk7XG59O1xuXG4vLyBTVEFUSUNTXG5cbi8qKlxuICogdXNlZCB0byBpZGVudGlmeSBpZiBzb21lb25lIG92ZXJ3cml0ZXNcbiAqIHdpbmRvdy5Ccm9hZGNhc3RDaGFubmVsIHdpdGggdGhpc1xuICogU2VlIG1ldGhvZHMvbmF0aXZlLmpzXG4gKi9cbkJyb2FkY2FzdENoYW5uZWwuX3B1YmtleSA9IHRydWU7XG5cbi8qKlxuICogaWYgc2V0LCB0aGlzIG1ldGhvZCBpcyBlbmZvcmNlZCxcbiAqIG5vIG1hdGhlciB3aGF0IHRoZSBvcHRpb25zIGFyZVxuICovXG52YXIgRU5GT1JDRURfT1BUSU9OUztcbmV4cG9ydCBmdW5jdGlvbiBlbmZvcmNlT3B0aW9ucyhvcHRpb25zKSB7XG4gIEVORk9SQ0VEX09QVElPTlMgPSBvcHRpb25zO1xufVxuXG4vLyBQUk9UT1RZUEVcbkJyb2FkY2FzdENoYW5uZWwucHJvdG90eXBlID0ge1xuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2UoKTogJyArICdDYW5ub3QgcG9zdCBtZXNzYWdlIGFmdGVyIGNoYW5uZWwgaGFzIGNsb3NlZCAnICtcbiAgICAgIC8qKlxuICAgICAgICogSW4gdGhlIHBhc3Qgd2hlbiB0aGlzIGVycm9yIGFwcGVhcmVkLCBpdCB3YXMgcmVhbHkgaGFyZCB0byBkZWJ1Zy5cbiAgICAgICAqIFNvIG5vdyB3ZSBsb2cgdGhlIG1zZyB0b2dldGhlciB3aXRoIHRoZSBlcnJvciBzbyBpdCBhdCBsZWFzdFxuICAgICAgICogZ2l2ZXMgc29tZSBjbHVlIGFib3V0IHdoZXJlIGluIHlvdXIgYXBwbGljYXRpb24gdGhpcyBoYXBwZW5zLlxuICAgICAgICovXG4gICAgICBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfSxcbiAgcG9zdEludGVybmFsOiBmdW5jdGlvbiBwb3N0SW50ZXJuYWwobXNnKSB7XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdpbnRlcm5hbCcsIG1zZyk7XG4gIH0sXG4gIHNldCBvbm1lc3NhZ2UoZm4pIHtcbiAgICB2YXIgdGltZSA9IHRoaXMubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIHZhciBsaXN0ZW5PYmogPSB7XG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgZm46IGZuXG4gICAgfTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgJ21lc3NhZ2UnLCB0aGlzLl9vbk1MKTtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9vbk1MID0gbGlzdGVuT2JqO1xuICAgICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgbGlzdGVuT2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25NTCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICB2YXIgbGlzdGVuT2JqID0ge1xuICAgICAgdGltZTogdGltZSxcbiAgICAgIGZuOiBmblxuICAgIH07XG4gICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIGxpc3Rlbk9iaik7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcbiAgICB2YXIgb2JqID0gdGhpcy5fYWRkRUxbdHlwZV0uZmluZChmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmZuID09PSBmbjtcbiAgICB9KTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgdHlwZSwgb2JqKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTW1wiZGVsZXRlXCJdKHRoaXMpO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB2YXIgYXdhaXRQcmVwYXJlID0gdGhpcy5fcHJlcFAgPyB0aGlzLl9wcmVwUCA6IFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgICB0aGlzLl9vbk1MID0gbnVsbDtcbiAgICB0aGlzLl9hZGRFTC5tZXNzYWdlID0gW107XG4gICAgcmV0dXJuIGF3YWl0UHJlcGFyZVxuICAgIC8vIHdhaXQgdW50aWwgYWxsIGN1cnJlbnQgc2VuZGluZyBhcmUgcHJvY2Vzc2VkXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKEFycmF5LmZyb20oX3RoaXMuX3VNUCkpO1xuICAgIH0pXG4gICAgLy8gcnVuIGJlZm9yZS1jbG9zZSBob29rc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5fYmVmQy5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSkpO1xuICAgIH0pXG4gICAgLy8gY2xvc2UgdGhlIGNoYW5uZWxcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMubWV0aG9kLmNsb3NlKF90aGlzLl9zdGF0ZSk7XG4gICAgfSk7XG4gIH0sXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZC50eXBlO1xuICB9LFxuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICB9XG59O1xuXG4vKipcbiAqIFBvc3QgYSBtZXNzYWdlIG92ZXIgdGhlIGNoYW5uZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVkIHdoZW4gdGhlIG1lc3NhZ2Ugc2VuZGluZyBpcyBkb25lXG4gKi9cbmZ1bmN0aW9uIF9wb3N0KGJyb2FkY2FzdENoYW5uZWwsIHR5cGUsIG1zZykge1xuICB2YXIgdGltZSA9IGJyb2FkY2FzdENoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICB2YXIgbXNnT2JqID0ge1xuICAgIHRpbWU6IHRpbWUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBtc2dcbiAgfTtcbiAgdmFyIGF3YWl0UHJlcGFyZSA9IGJyb2FkY2FzdENoYW5uZWwuX3ByZXBQID8gYnJvYWRjYXN0Q2hhbm5lbC5fcHJlcFAgOiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIHJldHVybiBhd2FpdFByZXBhcmUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbmRQcm9taXNlID0gYnJvYWRjYXN0Q2hhbm5lbC5tZXRob2QucG9zdE1lc3NhZ2UoYnJvYWRjYXN0Q2hhbm5lbC5fc3RhdGUsIG1zZ09iaik7XG5cbiAgICAvLyBhZGQvcmVtb3ZlIHRvIHVuc2VuZCBtZXNzYWdlcyBsaXN0XG4gICAgYnJvYWRjYXN0Q2hhbm5lbC5fdU1QLmFkZChzZW5kUHJvbWlzZSk7XG4gICAgc2VuZFByb21pc2VbXCJjYXRjaFwiXSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWwuX3VNUFtcImRlbGV0ZVwiXShzZW5kUHJvbWlzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbmRQcm9taXNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9wcmVwYXJlQ2hhbm5lbChjaGFubmVsKSB7XG4gIHZhciBtYXliZVByb21pc2UgPSBjaGFubmVsLm1ldGhvZC5jcmVhdGUoY2hhbm5lbC5uYW1lLCBjaGFubmVsLm9wdGlvbnMpO1xuICBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZSkpIHtcbiAgICBjaGFubmVsLl9wcmVwUCA9IG1heWJlUHJvbWlzZTtcbiAgICBtYXliZVByb21pc2UudGhlbihmdW5jdGlvbiAocykge1xuICAgICAgLy8gdXNlZCBpbiB0ZXN0cyB0byBzaW11bGF0ZSBzbG93IHJ1bnRpbWVcbiAgICAgIC8qaWYgKGNoYW5uZWwub3B0aW9ucy5wcmVwYXJlRGVsYXkpIHtcbiAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aGlzLm9wdGlvbnMucHJlcGFyZURlbGF5KSk7XG4gICAgICB9Ki9cbiAgICAgIGNoYW5uZWwuX3N0YXRlID0gcztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFubmVsLl9zdGF0ZSA9IG1heWJlUHJvbWlzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5fYWRkRUwubWVzc2FnZS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLmludGVybmFsLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfYWRkTGlzdGVuZXJPYmplY3QoY2hhbm5lbCwgdHlwZSwgb2JqKSB7XG4gIGNoYW5uZWwuX2FkZEVMW3R5cGVdLnB1c2gob2JqKTtcbiAgX3N0YXJ0TGlzdGVuaW5nKGNoYW5uZWwpO1xufVxuZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyT2JqZWN0KGNoYW5uZWwsIHR5cGUsIG9iaikge1xuICBjaGFubmVsLl9hZGRFTFt0eXBlXSA9IGNoYW5uZWwuX2FkZEVMW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICE9PSBvYmo7XG4gIH0pO1xuICBfc3RvcExpc3RlbmluZyhjaGFubmVsKTtcbn1cbmZ1bmN0aW9uIF9zdGFydExpc3RlbmluZyhjaGFubmVsKSB7XG4gIGlmICghY2hhbm5lbC5faUwgJiYgX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcbiAgICAvLyBzb21lb25lIGlzIGxpc3RlbmluZywgc3RhcnQgc3Vic2NyaWJpbmdcblxuICAgIHZhciBsaXN0ZW5lckZuID0gZnVuY3Rpb24gbGlzdGVuZXJGbihtc2dPYmopIHtcbiAgICAgIGNoYW5uZWwuX2FkZEVMW21zZ09iai50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lck9iamVjdCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0dGluZyB0aGUgY3VycmVudCB0aW1lIGluIEphdmFTY3JpcHQgaGFzIG5vIGdvb2QgcHJlY2lzaW9uLlxuICAgICAgICAgKiBTbyBpbnN0ZWFkIG9mIG9ubHkgbGlzdGVuaW5nIHRvIGV2ZW50cyB0aGF0IGhhcHBlbmQgJ2FmdGVyJyB0aGUgbGlzdGVuZXJcbiAgICAgICAgICogd2FzIGFkZGVkLCB3ZSBhbHNvIGxpc3RlbiB0byBldmVudHMgdGhhdCBoYXBwZW5kZWQgMTAwbXMgYmVmb3JlIGl0LlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIGFub3RoZXIgcHJvY2VzcywgbGlrZSBhIFdlYldvcmtlciwgc2VuZHMgZXZlbnRzXG4gICAgICAgICAqIHdlIGRvIG5vdCBtaXNzIHRoZW0gb3V0IGJlY2F1c2UgdGhlaXIgdGltZXN0YW1wIGlzIGEgYml0IG9mZiBjb21wYXJlZCB0byB0aGUgbWFpbiBwcm9jZXNzLlxuICAgICAgICAgKiBOb3QgZG9pbmcgdGhpcyB3b3VsZCBtYWtlIG1lc3NhZ2VzIG1pc3Npbmcgd2hlbiB3ZSBzZW5kIGRhdGEgZGlyZWN0bHkgYWZ0ZXIgc3Vic2NyaWJpbmcgYW5kIGF3YWl0aW5nIGEgcmVzcG9uc2UuXG4gICAgICAgICAqIEBsaW5rIGh0dHBzOi8vam9obnJlc2lnLmNvbS9ibG9nL2FjY3VyYWN5LW9mLWphdmFzY3JpcHQtdGltZS9cbiAgICAgICAgICovXG4gICAgICAgIHZhciBodW5kcmVkTXNJbk1pY3JvID0gMTAwICogMTAwMDtcbiAgICAgICAgdmFyIG1pbk1lc3NhZ2VUaW1lID0gbGlzdGVuZXJPYmplY3QudGltZSAtIGh1bmRyZWRNc0luTWljcm87XG4gICAgICAgIGlmIChtc2dPYmoudGltZSA+PSBtaW5NZXNzYWdlVGltZSkge1xuICAgICAgICAgIGxpc3RlbmVyT2JqZWN0LmZuKG1zZ09iai5kYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsLm1ldGhvZC50eXBlID09PSAnc2VydmVyJykge1xuICAgICAgICAgIC8vIHNlcnZlciBtc2cgbWlnaHQgbGFnIGJhc2VkIG9uIGNvbm5lY3Rpb24uXG4gICAgICAgICAgbGlzdGVuZXJPYmplY3QuZm4obXNnT2JqLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciB0aW1lID0gY2hhbm5lbC5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gICAgaWYgKGNoYW5uZWwuX3ByZXBQKSB7XG4gICAgICBjaGFubmVsLl9wcmVwUC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5faUwgPSB0cnVlO1xuICAgICAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIGxpc3RlbmVyRm4sIHRpbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwuX2lMID0gdHJ1ZTtcbiAgICAgIGNoYW5uZWwubWV0aG9kLm9uTWVzc2FnZShjaGFubmVsLl9zdGF0ZSwgbGlzdGVuZXJGbiwgdGltZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfc3RvcExpc3RlbmluZyhjaGFubmVsKSB7XG4gIGlmIChjaGFubmVsLl9pTCAmJiAhX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcbiAgICAvLyBub29uZSBpcyBsaXN0ZW5pbmcsIHN0b3Agc3Vic2NyaWJpbmdcbiAgICBjaGFubmVsLl9pTCA9IGZhbHNlO1xuICAgIHZhciB0aW1lID0gY2hhbm5lbC5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gICAgY2hhbm5lbC5tZXRob2Qub25NZXNzYWdlKGNoYW5uZWwuX3N0YXRlLCBudWxsLCB0aW1lKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJpc1Byb21pc2UiLCJQUk9NSVNFX1JFU09MVkVEX1ZPSUQiLCJjaG9vc2VNZXRob2QiLCJmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyIsIk9QRU5fQlJPQURDQVNUX0NIQU5ORUxTIiwiU2V0IiwibGFzdElkIiwiQnJvYWRjYXN0Q2hhbm5lbCIsIm5hbWUiLCJvcHRpb25zIiwiaWQiLCJhZGQiLCJFTkZPUkNFRF9PUFRJT05TIiwibWV0aG9kIiwiX2lMIiwiX29uTUwiLCJfYWRkRUwiLCJtZXNzYWdlIiwiaW50ZXJuYWwiLCJfdU1QIiwiX2JlZkMiLCJfcHJlcFAiLCJfcHJlcGFyZUNoYW5uZWwiLCJfcHVia2V5IiwiZW5mb3JjZU9wdGlvbnMiLCJwcm90b3R5cGUiLCJwb3N0TWVzc2FnZSIsIm1zZyIsImNsb3NlZCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9wb3N0IiwicG9zdEludGVybmFsIiwib25tZXNzYWdlIiwiZm4iLCJ0aW1lIiwibWljcm9TZWNvbmRzIiwibGlzdGVuT2JqIiwiX3JlbW92ZUxpc3RlbmVyT2JqZWN0IiwiX2FkZExpc3RlbmVyT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInR5cGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2JqIiwiZmluZCIsImNsb3NlIiwiX3RoaXMiLCJhd2FpdFByZXBhcmUiLCJ0aGVuIiwiUHJvbWlzZSIsImFsbCIsIkFycmF5IiwiZnJvbSIsIm1hcCIsIl9zdGF0ZSIsImlzQ2xvc2VkIiwiYnJvYWRjYXN0Q2hhbm5lbCIsIm1zZ09iaiIsImRhdGEiLCJzZW5kUHJvbWlzZSIsImNoYW5uZWwiLCJtYXliZVByb21pc2UiLCJjcmVhdGUiLCJzIiwiX2hhc01lc3NhZ2VMaXN0ZW5lcnMiLCJsZW5ndGgiLCJwdXNoIiwiX3N0YXJ0TGlzdGVuaW5nIiwiZmlsdGVyIiwibyIsIl9zdG9wTGlzdGVuaW5nIiwibGlzdGVuZXJGbiIsImZvckVhY2giLCJsaXN0ZW5lck9iamVjdCIsImh1bmRyZWRNc0luTWljcm8iLCJtaW5NZXNzYWdlVGltZSIsIm9uTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/broadcast-channel.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/method-chooser.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/method-chooser.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chooseMethod: () => (/* binding */ chooseMethod)\n/* harmony export */ });\n/* harmony import */ var _methods_native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/native.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/native.js\");\n/* harmony import */ var _methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/indexed-db.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/indexed-db.js\");\n/* harmony import */ var _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/localstorage.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/localstorage.js\");\n/* harmony import */ var _methods_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/server.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/server.js\");\n/* harmony import */ var _methods_simulate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./methods/simulate.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/simulate.js\");\n\n\n\n\n\n// order is important\nvar METHODS = [\n    _methods_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    // fastest\n    _methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    _methods_server_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n];\nfunction chooseMethod(options) {\n    var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n    // directly chosen\n    if (options.type) {\n        if (options.type === \"simulate\") {\n            // only use simulate-method if directly chosen\n            return _methods_simulate_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n        }\n        var ret = chooseMethods.find(function(m) {\n            return m.type === options.type;\n        });\n        if (!ret) throw new Error(\"method-type \" + options.type + \" not found\");\n        else return ret;\n    }\n    /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */ if (!options.webWorkerSupport) {\n        chooseMethods = chooseMethods.filter(function(m) {\n            return m.type !== \"idb\";\n        });\n    }\n    var useMethod = chooseMethods.find(function(method) {\n        return method.canBeUsed(options);\n    });\n    if (!useMethod) throw new Error(\"No useable method found in \" + JSON.stringify(METHODS.map(function(m) {\n        return m.type;\n    })));\n    else return useMethod;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kLWNob29zZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStDO0FBQ007QUFDTTtBQUNaO0FBQ0k7QUFFbkQscUJBQXFCO0FBQ3JCLElBQUlLLFVBQVU7SUFBQ0wsMERBQVlBO0lBQzNCLFVBQVU7SUFDVkMsOERBQWNBO0lBQUVDLGdFQUFrQkE7SUFBRUMsMERBQVlBO0NBQUM7QUFDMUMsU0FBU0csYUFBYUMsT0FBTztJQUNsQyxJQUFJQyxnQkFBZ0IsRUFBRSxDQUFDQyxNQUFNLENBQUNGLFFBQVFHLE9BQU8sRUFBRUwsU0FBU00sTUFBTSxDQUFDQztJQUUvRCxrQkFBa0I7SUFDbEIsSUFBSUwsUUFBUU0sSUFBSSxFQUFFO1FBQ2hCLElBQUlOLFFBQVFNLElBQUksS0FBSyxZQUFZO1lBQy9CLDhDQUE4QztZQUM5QyxPQUFPVCw0REFBY0E7UUFDdkI7UUFDQSxJQUFJVSxNQUFNTixjQUFjTyxJQUFJLENBQUMsU0FBVUMsQ0FBQztZQUN0QyxPQUFPQSxFQUFFSCxJQUFJLEtBQUtOLFFBQVFNLElBQUk7UUFDaEM7UUFDQSxJQUFJLENBQUNDLEtBQUssTUFBTSxJQUFJRyxNQUFNLGlCQUFpQlYsUUFBUU0sSUFBSSxHQUFHO2FBQW1CLE9BQU9DO0lBQ3RGO0lBRUE7OztHQUdDLEdBQ0QsSUFBSSxDQUFDUCxRQUFRVyxnQkFBZ0IsRUFBRTtRQUM3QlYsZ0JBQWdCQSxjQUFjRyxNQUFNLENBQUMsU0FBVUssQ0FBQztZQUM5QyxPQUFPQSxFQUFFSCxJQUFJLEtBQUs7UUFDcEI7SUFDRjtJQUNBLElBQUlNLFlBQVlYLGNBQWNPLElBQUksQ0FBQyxTQUFVSyxNQUFNO1FBQ2pELE9BQU9BLE9BQU9DLFNBQVMsQ0FBQ2Q7SUFDMUI7SUFDQSxJQUFJLENBQUNZLFdBQVcsTUFBTSxJQUFJRixNQUFNLGdDQUFnQ0ssS0FBS0MsU0FBUyxDQUFDbEIsUUFBUW1CLEdBQUcsQ0FBQyxTQUFVUixDQUFDO1FBQ3BHLE9BQU9BLEVBQUVILElBQUk7SUFDZjtTQUFVLE9BQU9NO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNub2RlL21ldGhvZC1jaG9vc2VyLmpzP2NiNmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5hdGl2ZU1ldGhvZCBmcm9tICcuL21ldGhvZHMvbmF0aXZlLmpzJztcbmltcG9ydCBJbmRleGVEYk1ldGhvZCBmcm9tICcuL21ldGhvZHMvaW5kZXhlZC1kYi5qcyc7XG5pbXBvcnQgTG9jYWxzdG9yYWdlTWV0aG9kIGZyb20gJy4vbWV0aG9kcy9sb2NhbHN0b3JhZ2UuanMnO1xuaW1wb3J0IFNlcnZlck1ldGhvZCBmcm9tICcuL21ldGhvZHMvc2VydmVyLmpzJztcbmltcG9ydCBTaW11bGF0ZU1ldGhvZCBmcm9tICcuL21ldGhvZHMvc2ltdWxhdGUuanMnO1xuXG4vLyBvcmRlciBpcyBpbXBvcnRhbnRcbnZhciBNRVRIT0RTID0gW05hdGl2ZU1ldGhvZCxcbi8vIGZhc3Rlc3RcbkluZGV4ZURiTWV0aG9kLCBMb2NhbHN0b3JhZ2VNZXRob2QsIFNlcnZlck1ldGhvZF07XG5leHBvcnQgZnVuY3Rpb24gY2hvb3NlTWV0aG9kKG9wdGlvbnMpIHtcbiAgdmFyIGNob29zZU1ldGhvZHMgPSBbXS5jb25jYXQob3B0aW9ucy5tZXRob2RzLCBNRVRIT0RTKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgLy8gZGlyZWN0bHkgY2hvc2VuXG4gIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnc2ltdWxhdGUnKSB7XG4gICAgICAvLyBvbmx5IHVzZSBzaW11bGF0ZS1tZXRob2QgaWYgZGlyZWN0bHkgY2hvc2VuXG4gICAgICByZXR1cm4gU2ltdWxhdGVNZXRob2Q7XG4gICAgfVxuICAgIHZhciByZXQgPSBjaG9vc2VNZXRob2RzLmZpbmQoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IG9wdGlvbnMudHlwZTtcbiAgICB9KTtcbiAgICBpZiAoIXJldCkgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QtdHlwZSAnICsgb3B0aW9ucy50eXBlICsgJyBub3QgZm91bmQnKTtlbHNlIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogaWYgbm8gd2Vid29ya2VyIHN1cHBvcnQgaXMgbmVlZGVkLFxuICAgKiByZW1vdmUgaWRiIGZyb20gdGhlIGxpc3Qgc28gdGhhdCBsb2NhbHN0b3JhZ2UgaXMgYmVlbiBjaG9zZW5cbiAgICovXG4gIGlmICghb3B0aW9ucy53ZWJXb3JrZXJTdXBwb3J0KSB7XG4gICAgY2hvb3NlTWV0aG9kcyA9IGNob29zZU1ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICByZXR1cm4gbS50eXBlICE9PSAnaWRiJztcbiAgICB9KTtcbiAgfVxuICB2YXIgdXNlTWV0aG9kID0gY2hvb3NlTWV0aG9kcy5maW5kKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kLmNhbkJlVXNlZChvcHRpb25zKTtcbiAgfSk7XG4gIGlmICghdXNlTWV0aG9kKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB1c2VhYmxlIG1ldGhvZCBmb3VuZCBpbiBcIiArIEpTT04uc3RyaW5naWZ5KE1FVEhPRFMubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIG0udHlwZTtcbiAgfSkpKTtlbHNlIHJldHVybiB1c2VNZXRob2Q7XG59Il0sIm5hbWVzIjpbIk5hdGl2ZU1ldGhvZCIsIkluZGV4ZURiTWV0aG9kIiwiTG9jYWxzdG9yYWdlTWV0aG9kIiwiU2VydmVyTWV0aG9kIiwiU2ltdWxhdGVNZXRob2QiLCJNRVRIT0RTIiwiY2hvb3NlTWV0aG9kIiwib3B0aW9ucyIsImNob29zZU1ldGhvZHMiLCJjb25jYXQiLCJtZXRob2RzIiwiZmlsdGVyIiwiQm9vbGVhbiIsInR5cGUiLCJyZXQiLCJmaW5kIiwibSIsIkVycm9yIiwid2ViV29ya2VyU3VwcG9ydCIsInVzZU1ldGhvZCIsIm1ldGhvZCIsImNhbkJlVXNlZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/method-chooser.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/indexed-db.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/indexed-db.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRANSACTION_SETTINGS: () => (/* binding */ TRANSACTION_SETTINGS),\n/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),\n/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),\n/* harmony export */   cleanOldMessages: () => (/* binding */ cleanOldMessages),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   commitIndexedDBTransaction: () => (/* binding */ commitIndexedDBTransaction),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createDatabase: () => (/* binding */ createDatabase),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getAllMessages: () => (/* binding */ getAllMessages),\n/* harmony export */   getIdb: () => (/* binding */ getIdb),\n/* harmony export */   getMessagesHigherThan: () => (/* binding */ getMessagesHigherThan),\n/* harmony export */   getOldMessages: () => (/* binding */ getOldMessages),\n/* harmony export */   microSeconds: () => (/* binding */ microSeconds),\n/* harmony export */   onMessage: () => (/* binding */ onMessage),\n/* harmony export */   postMessage: () => (/* binding */ postMessage),\n/* harmony export */   removeMessagesById: () => (/* binding */ removeMessagesById),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   writeMessage: () => (/* binding */ writeMessage)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ \"(ssr)/../node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js\");\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */ \nvar microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\n\n\nvar DB_PREFIX = \"pubkey.broadcast-channel-0-\";\nvar OBJECT_STORE_ID = \"messages\";\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ var TRANSACTION_SETTINGS = {\n    durability: \"relaxed\"\n};\nvar type = \"idb\";\nfunction getIdb() {\n    if (typeof indexedDB !== \"undefined\") return indexedDB;\n    if (false) {}\n    return false;\n}\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ function commitIndexedDBTransaction(tx) {\n    if (tx.commit) {\n        tx.commit();\n    }\n}\nfunction createDatabase(channelName) {\n    var IndexedDB = getIdb();\n    // create table\n    var dbName = DB_PREFIX + channelName;\n    /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */ var openRequest = IndexedDB.open(dbName);\n    openRequest.onupgradeneeded = function(ev) {\n        var db = ev.target.result;\n        db.createObjectStore(OBJECT_STORE_ID, {\n            keyPath: \"id\",\n            autoIncrement: true\n        });\n    };\n    var dbPromise = new Promise(function(res, rej) {\n        openRequest.onerror = function(ev) {\n            return rej(ev);\n        };\n        openRequest.onsuccess = function() {\n            res(openRequest.result);\n        };\n    });\n    return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */ function writeMessage(db, readerUuid, messageJson) {\n    var time = new Date().getTime();\n    var writeObject = {\n        uuid: readerUuid,\n        time: time,\n        data: messageJson\n    };\n    var tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    return new Promise(function(res, rej) {\n        tx.oncomplete = function() {\n            return res();\n        };\n        tx.onerror = function(ev) {\n            return rej(ev);\n        };\n        var objectStore = tx.objectStore(OBJECT_STORE_ID);\n        objectStore.add(writeObject);\n        commitIndexedDBTransaction(tx);\n    });\n}\nfunction getAllMessages(db) {\n    var tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    var ret = [];\n    return new Promise(function(res) {\n        objectStore.openCursor().onsuccess = function(ev) {\n            var cursor = ev.target.result;\n            if (cursor) {\n                ret.push(cursor.value);\n                //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                cursor[\"continue\"]();\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n    var tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    var ret = [];\n    var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n    /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */ if (objectStore.getAll) {\n        var getAllRequest = objectStore.getAll(keyRangeValue);\n        return new Promise(function(res, rej) {\n            getAllRequest.onerror = function(err) {\n                return rej(err);\n            };\n            getAllRequest.onsuccess = function(e) {\n                res(e.target.result);\n            };\n        });\n    }\n    function openCursor() {\n        // Occasionally Safari will fail on IDBKeyRange.bound, this\n        // catches that error, having it open the cursor to the first\n        // item. When it gets data it will advance to the desired key.\n        try {\n            keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n            return objectStore.openCursor(keyRangeValue);\n        } catch (e) {\n            return objectStore.openCursor();\n        }\n    }\n    return new Promise(function(res, rej) {\n        var openCursorRequest = openCursor();\n        openCursorRequest.onerror = function(err) {\n            return rej(err);\n        };\n        openCursorRequest.onsuccess = function(ev) {\n            var cursor = ev.target.result;\n            if (cursor) {\n                if (cursor.value.id < lastCursorId + 1) {\n                    cursor[\"continue\"](lastCursorId + 1);\n                } else {\n                    ret.push(cursor.value);\n                    cursor[\"continue\"]();\n                }\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction removeMessagesById(db, ids) {\n    var tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    return Promise.all(ids.map(function(id) {\n        var deleteRequest = objectStore[\"delete\"](id);\n        return new Promise(function(res) {\n            deleteRequest.onsuccess = function() {\n                return res();\n            };\n        });\n    }));\n}\nfunction getOldMessages(db, ttl) {\n    var olderThen = new Date().getTime() - ttl;\n    var tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    var ret = [];\n    return new Promise(function(res) {\n        objectStore.openCursor().onsuccess = function(ev) {\n            var cursor = ev.target.result;\n            if (cursor) {\n                var msgObk = cursor.value;\n                if (msgObk.time < olderThen) {\n                    ret.push(msgObk);\n                    //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                    cursor[\"continue\"]();\n                } else {\n                    // no more old messages,\n                    commitIndexedDBTransaction(tx);\n                    res(ret);\n                    return;\n                }\n            } else {\n                res(ret);\n            }\n        };\n    });\n}\nfunction cleanOldMessages(db, ttl) {\n    return getOldMessages(db, ttl).then(function(tooOld) {\n        return removeMessagesById(db, tooOld.map(function(msg) {\n            return msg.id;\n        }));\n    });\n}\nfunction create(channelName, options) {\n    options = (0,_options__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);\n    return createDatabase(channelName).then(function(db) {\n        var state = {\n            closed: false,\n            lastCursorId: 0,\n            channelName: channelName,\n            options: options,\n            uuid: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),\n            /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */ eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.idb.ttl * 2),\n            // ensures we do not read messages in parrallel\n            writeBlockPromise: _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID,\n            messagesCallback: null,\n            readQueuePromises: [],\n            db: db\n        };\n        /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */ db.onclose = function() {\n            state.closed = true;\n            if (options.idb.onclose) options.idb.onclose();\n        };\n        /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */ _readLoop(state);\n        return state;\n    });\n}\nfunction _readLoop(state) {\n    if (state.closed) return;\n    readNewMessages(state).then(function() {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(state.options.idb.fallbackInterval);\n    }).then(function() {\n        return _readLoop(state);\n    });\n}\nfunction _filterMessage(msgObj, state) {\n    if (msgObj.uuid === state.uuid) return false; // send by own\n    if (state.eMIs.has(msgObj.id)) return false; // already emitted\n    if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n    return true;\n}\n/**\n * reads all new messages from the database and emits them\n */ function readNewMessages(state) {\n    // channel already closed\n    if (state.closed) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n    // if no one is listening, we do not need to scan for new messages\n    if (!state.messagesCallback) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n    return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {\n        var useMessages = newerMessages/**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */ .filter(function(msgObj) {\n            return !!msgObj;\n        }).map(function(msgObj) {\n            if (msgObj.id > state.lastCursorId) {\n                state.lastCursorId = msgObj.id;\n            }\n            return msgObj;\n        }).filter(function(msgObj) {\n            return _filterMessage(msgObj, state);\n        }).sort(function(msgObjA, msgObjB) {\n            return msgObjA.time - msgObjB.time;\n        }); // sort by time\n        useMessages.forEach(function(msgObj) {\n            if (state.messagesCallback) {\n                state.eMIs.add(msgObj.id);\n                state.messagesCallback(msgObj.data);\n            }\n        });\n        return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n    });\n}\nfunction close(channelState) {\n    channelState.closed = true;\n    channelState.db.close();\n}\nfunction postMessage(channelState, messageJson) {\n    channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {\n        return writeMessage(channelState.db, channelState.uuid, messageJson);\n    }).then(function() {\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomInt)(0, 10) === 0) {\n            /* await (do not await) */ cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n        }\n    });\n    return channelState.writeBlockPromise;\n}\nfunction onMessage(channelState, fn, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn;\n    readNewMessages(channelState);\n}\nfunction canBeUsed(options) {\n    if (!options.support3PC) return false;\n    var idb = getIdb();\n    if (!idb) return false;\n    return true;\n}\nfunction averageResponseTime(options) {\n    return options.idb.fallbackInterval * 2;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    create: create,\n    close: close,\n    onMessage: onMessage,\n    postMessage: postMessage,\n    canBeUsed: canBeUsed,\n    type: type,\n    averageResponseTime: averageResponseTime,\n    microSeconds: microSeconds\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9pbmRleGVkLWRiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBRXdHO0FBQ2xHLElBQUlHLGVBQWVDLGtEQUFLQSxDQUFDO0FBQ2E7QUFDUTtBQUNyRCxJQUFJSSxZQUFZO0FBQ2hCLElBQUlDLGtCQUFrQjtBQUV0Qjs7O0NBR0MsR0FDTSxJQUFJQyx1QkFBdUI7SUFDaENDLFlBQVk7QUFDZCxFQUFFO0FBQ0ssSUFBSUMsT0FBTyxNQUFNO0FBQ2pCLFNBQVNDO0lBQ2QsSUFBSSxPQUFPQyxjQUFjLGFBQWEsT0FBT0E7SUFDN0MsSUFBSSxLQUFrQixFQUFhLEVBSWxDO0lBQ0QsT0FBTztBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNLLDJCQUEyQkMsRUFBRTtJQUMzQyxJQUFJQSxHQUFHQyxNQUFNLEVBQUU7UUFDYkQsR0FBR0MsTUFBTTtJQUNYO0FBQ0Y7QUFDTyxTQUFTQyxlQUFlQyxXQUFXO0lBQ3hDLElBQUlDLFlBQVlYO0lBRWhCLGVBQWU7SUFDZixJQUFJWSxTQUFTakIsWUFBWWU7SUFFekI7Ozs7R0FJQyxHQUNELElBQUlHLGNBQWNGLFVBQVVHLElBQUksQ0FBQ0Y7SUFDakNDLFlBQVlFLGVBQWUsR0FBRyxTQUFVQyxFQUFFO1FBQ3hDLElBQUlDLEtBQUtELEdBQUdFLE1BQU0sQ0FBQ0MsTUFBTTtRQUN6QkYsR0FBR0csaUJBQWlCLENBQUN4QixpQkFBaUI7WUFDcEN5QixTQUFTO1lBQ1RDLGVBQWU7UUFDakI7SUFDRjtJQUNBLElBQUlDLFlBQVksSUFBSUMsUUFBUSxTQUFVQyxHQUFHLEVBQUVDLEdBQUc7UUFDNUNiLFlBQVljLE9BQU8sR0FBRyxTQUFVWCxFQUFFO1lBQ2hDLE9BQU9VLElBQUlWO1FBQ2I7UUFDQUgsWUFBWWUsU0FBUyxHQUFHO1lBQ3RCSCxJQUFJ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Q3BDa0UsYUFBYWxCLGdCQUFnQixHQUFHcUI7SUFDaENqQixnQkFBZ0JjO0FBQ2xCO0FBQ08sU0FBU0ksVUFBVTVCLE9BQU87SUFDL0IsSUFBSSxDQUFDQSxRQUFRNkIsVUFBVSxFQUFFLE9BQU87SUFDaEMsSUFBSXpCLE1BQU05RTtJQUNWLElBQUksQ0FBQzhFLEtBQUssT0FBTztJQUNqQixPQUFPO0FBQ1Q7QUFDTyxTQUFTMEIsb0JBQW9COUIsT0FBTztJQUN6QyxPQUFPQSxRQUFRSSxHQUFHLENBQUNPLGdCQUFnQixHQUFHO0FBQ3hDO0FBQ0EsaUVBQWU7SUFDYlosUUFBUUE7SUFDUndCLE9BQU9BO0lBQ1BHLFdBQVdBO0lBQ1hELGFBQWFBO0lBQ2JHLFdBQVdBO0lBQ1h2RyxNQUFNQTtJQUNOeUcscUJBQXFCQTtJQUNyQmxILGNBQWNBO0FBQ2hCLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2Vzbm9kZS9tZXRob2RzL2luZGV4ZWQtZGIuanM/MTQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHRoaXMgbWV0aG9kIHVzZXMgaW5kZXhlZGRiIHRvIHN0b3JlIHRoZSBtZXNzYWdlc1xuICogVGhlcmUgaXMgY3VycmVudGx5IG5vIG9ic2VydmVyQVBJIGZvciBpZGJcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW5kZXhlZERCL2lzc3Vlcy81MVxuICpcbiAqIFdoZW4gd29ya2luZyBvbiB0aGlzLCBlbnN1cmUgdG8gdXNlIHRoZXNlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiBAbGluayBodHRwczovL3J4ZGIuaW5mby9zbG93LWluZGV4ZWRkYi5odG1sXG4gKi9cblxuaW1wb3J0IHsgc2xlZXAsIHJhbmRvbUludCwgcmFuZG9tVG9rZW4sIG1pY3JvU2Vjb25kcyBhcyBtaWNybywgUFJPTUlTRV9SRVNPTFZFRF9WT0lEIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xuaW1wb3J0IHsgT2JsaXZpb3VzU2V0IH0gZnJvbSAnb2JsaXZpb3VzLXNldCc7XG5pbXBvcnQgeyBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyB9IGZyb20gJy4uL29wdGlvbnMnO1xudmFyIERCX1BSRUZJWCA9ICdwdWJrZXkuYnJvYWRjYXN0LWNoYW5uZWwtMC0nO1xudmFyIE9CSkVDVF9TVE9SRV9JRCA9ICdtZXNzYWdlcyc7XG5cbi8qKlxuICogVXNlIHJlbGF4ZWQgZHVyYWJpbGl0eSBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlIG9uIGFsbCB0cmFuc2FjdGlvbnMuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5leHBvcnQgdmFyIFRSQU5TQUNUSU9OX1NFVFRJTkdTID0ge1xuICBkdXJhYmlsaXR5OiAncmVsYXhlZCdcbn07XG5leHBvcnQgdmFyIHR5cGUgPSAnaWRiJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRJZGIoKSB7XG4gIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4ZWREQjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy5tb3pJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cud2Via2l0SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy53ZWJraXRJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubXNJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1zSW5kZXhlZERCO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiBwb3NzaWJsZSwgd2Ugc2hvdWxkIGV4cGxpY2l0bHkgY29tbWl0IEluZGV4ZWREQiB0cmFuc2FjdGlvbnNcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpIHtcbiAgaWYgKHR4LmNvbW1pdCkge1xuICAgIHR4LmNvbW1pdCgpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0YWJhc2UoY2hhbm5lbE5hbWUpIHtcbiAgdmFyIEluZGV4ZWREQiA9IGdldElkYigpO1xuXG4gIC8vIGNyZWF0ZSB0YWJsZVxuICB2YXIgZGJOYW1lID0gREJfUFJFRklYICsgY2hhbm5lbE5hbWU7XG5cbiAgLyoqXG4gICAqIEFsbCBJbmRleGVkREIgZGF0YWJhc2VzIGFyZSBvcGVuZWQgd2l0aG91dCB2ZXJzaW9uXG4gICAqIGJlY2F1c2UgaXQgaXMgYSBiaXQgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIGZpcmVmb3hcbiAgICogQGxpbmsgaHR0cDovL25wYXJhc2h1cmFtLmNvbS9JbmRleGVkREIvcGVyZi8jT3BlbiUyMERhdGFiYXNlJTIwd2l0aCUyMHZlcnNpb25cbiAgICovXG4gIHZhciBvcGVuUmVxdWVzdCA9IEluZGV4ZWREQi5vcGVuKGRiTmFtZSk7XG4gIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYiA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lELCB7XG4gICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICB2YXIgZGJQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmV0dXJuIHJlaihldik7XG4gICAgfTtcbiAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXMob3BlblJlcXVlc3QucmVzdWx0KTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGRiUHJvbWlzZTtcbn1cblxuLyoqXG4gKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBkYXRhYmFzZVxuICogc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVNZXNzYWdlKGRiLCByZWFkZXJVdWlkLCBtZXNzYWdlSnNvbikge1xuICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB2YXIgd3JpdGVPYmplY3QgPSB7XG4gICAgdXVpZDogcmVhZGVyVXVpZCxcbiAgICB0aW1lOiB0aW1lLFxuICAgIGRhdGE6IG1lc3NhZ2VKc29uXG4gIH07XG4gIHZhciB0eCA9IGRiLnRyYW5zYWN0aW9uKFtPQkpFQ1RfU1RPUkVfSURdLCAncmVhZHdyaXRlJywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgdHgub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXMoKTtcbiAgICB9O1xuICAgIHR4Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJldHVybiByZWooZXYpO1xuICAgIH07XG4gICAgdmFyIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgICBvYmplY3RTdG9yZS5hZGQod3JpdGVPYmplY3QpO1xuICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWVzc2FnZXMoZGIpIHtcbiAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX0lELCAncmVhZG9ubHknLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHZhciBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIHZhciByZXQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgY3Vyc29yID0gZXYudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgcmV0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgLy9hbGVydChcIk5hbWUgZm9yIFNTTiBcIiArIGN1cnNvci5rZXkgKyBcIiBpcyBcIiArIGN1cnNvci52YWx1ZS5uYW1lKTtcbiAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmVzKHJldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZXNIaWdoZXJUaGFuKGRiLCBsYXN0Q3Vyc29ySWQpIHtcbiAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX0lELCAncmVhZG9ubHknLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHZhciBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGtleVJhbmdlVmFsdWUgPSBJREJLZXlSYW5nZS5ib3VuZChsYXN0Q3Vyc29ySWQgKyAxLCBJbmZpbml0eSk7XG5cbiAgLyoqXG4gICAqIE9wdGltaXphdGlvbiBzaG9ydGN1dCxcbiAgICogaWYgZ2V0QWxsKCkgY2FuIGJlIHVzZWQsIGRvIG5vdCB1c2UgYSBjdXJzb3IuXG4gICAqIEBsaW5rIGh0dHBzOi8vcnhkYi5pbmZvL3Nsb3ctaW5kZXhlZGRiLmh0bWxcbiAgICovXG4gIGlmIChvYmplY3RTdG9yZS5nZXRBbGwpIHtcbiAgICB2YXIgZ2V0QWxsUmVxdWVzdCA9IG9iamVjdFN0b3JlLmdldEFsbChrZXlSYW5nZVZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICBnZXRBbGxSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWooZXJyKTtcbiAgICAgIH07XG4gICAgICBnZXRBbGxSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJlcyhlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvcGVuQ3Vyc29yKCkge1xuICAgIC8vIE9jY2FzaW9uYWxseSBTYWZhcmkgd2lsbCBmYWlsIG9uIElEQktleVJhbmdlLmJvdW5kLCB0aGlzXG4gICAgLy8gY2F0Y2hlcyB0aGF0IGVycm9yLCBoYXZpbmcgaXQgb3BlbiB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdFxuICAgIC8vIGl0ZW0uIFdoZW4gaXQgZ2V0cyBkYXRhIGl0IHdpbGwgYWR2YW5jZSB0byB0aGUgZGVzaXJlZCBrZXkuXG4gICAgdHJ5IHtcbiAgICAgIGtleVJhbmdlVmFsdWUgPSBJREJLZXlSYW5nZS5ib3VuZChsYXN0Q3Vyc29ySWQgKyAxLCBJbmZpbml0eSk7XG4gICAgICByZXR1cm4gb2JqZWN0U3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZVZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgdmFyIG9wZW5DdXJzb3JSZXF1ZXN0ID0gb3BlbkN1cnNvcigpO1xuICAgIG9wZW5DdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqKGVycik7XG4gICAgfTtcbiAgICBvcGVuQ3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICBpZiAoY3Vyc29yLnZhbHVlLmlkIDwgbGFzdEN1cnNvcklkICsgMSkge1xuICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKGxhc3RDdXJzb3JJZCArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXMocmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVNZXNzYWdlc0J5SWQoZGIsIGlkcykge1xuICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihbT0JKRUNUX1NUT1JFX0lEXSwgJ3JlYWR3cml0ZScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgdmFyIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGRlbGV0ZVJlcXVlc3QgPSBvYmplY3RTdG9yZVtcImRlbGV0ZVwiXShpZCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzKCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T2xkTWVzc2FnZXMoZGIsIHR0bCkge1xuICB2YXIgb2xkZXJUaGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0dGw7XG4gIHZhciB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCwgJ3JlYWRvbmx5JywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICB2YXIgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICB2YXIgcmV0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIHZhciBtc2dPYmsgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIGlmIChtc2dPYmsudGltZSA8IG9sZGVyVGhlbikge1xuICAgICAgICAgIHJldC5wdXNoKG1zZ09iayk7XG4gICAgICAgICAgLy9hbGVydChcIk5hbWUgZm9yIFNTTiBcIiArIGN1cnNvci5rZXkgKyBcIiBpcyBcIiArIGN1cnNvci52YWx1ZS5uYW1lKTtcbiAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIG1vcmUgb2xkIG1lc3NhZ2VzLFxuICAgICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICByZXMocmV0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyhyZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuT2xkTWVzc2FnZXMoZGIsIHR0bCkge1xuICByZXR1cm4gZ2V0T2xkTWVzc2FnZXMoZGIsIHR0bCkudGhlbihmdW5jdGlvbiAodG9vT2xkKSB7XG4gICAgcmV0dXJuIHJlbW92ZU1lc3NhZ2VzQnlJZChkYiwgdG9vT2xkLm1hcChmdW5jdGlvbiAobXNnKSB7XG4gICAgICByZXR1cm4gbXNnLmlkO1xuICAgIH0pKTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgcmV0dXJuIGNyZWF0ZURhdGFiYXNlKGNoYW5uZWxOYW1lKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGNsb3NlZDogZmFsc2UsXG4gICAgICBsYXN0Q3Vyc29ySWQ6IDAsXG4gICAgICBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgdXVpZDogcmFuZG9tVG9rZW4oKSxcbiAgICAgIC8qKlxuICAgICAgICogZW1pdHRlZE1lc3NhZ2VzSWRzXG4gICAgICAgKiBjb250YWlucyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBiZWZvcmVcbiAgICAgICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAgICAgKi9cbiAgICAgIGVNSXM6IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5pZGIudHRsICogMiksXG4gICAgICAvLyBlbnN1cmVzIHdlIGRvIG5vdCByZWFkIG1lc3NhZ2VzIGluIHBhcnJhbGxlbFxuICAgICAgd3JpdGVCbG9ja1Byb21pc2U6IFBST01JU0VfUkVTT0xWRURfVk9JRCxcbiAgICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgICByZWFkUXVldWVQcm9taXNlczogW10sXG4gICAgICBkYjogZGJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFicnVwdCBjbG9zZXMgdGhhdCBkbyBub3Qgb3JpZ2luYXRlIGZyb20gZGIuY2xvc2UoKS5cbiAgICAgKiBUaGlzIGNvdWxkIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgaXNcbiAgICAgKiByZW1vdmVkIG9yIGlmIHRoZSB1c2VyIGNsZWFycyB0aGUgZGF0YWJhc2UgaW4gdGhlIGJyb3dzZXInc1xuICAgICAqIGhpc3RvcnkgcHJlZmVyZW5jZXMuXG4gICAgICovXG4gICAgZGIub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0YXRlLmNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5pZGIub25jbG9zZSkgb3B0aW9ucy5pZGIub25jbG9zZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXJ2aWNlLXdvcmtlcnMgYXJlIHVzZWQsXG4gICAgICogd2UgaGF2ZSBubyAnc3RvcmFnZSctZXZlbnQgaWYgdGhleSBwb3N0IGEgbWVzc2FnZSxcbiAgICAgKiB0aGVyZWZvcmUgd2UgYWxzbyBoYXZlIHRvIHNldCBhbiBpbnRlcnZhbFxuICAgICAqL1xuICAgIF9yZWFkTG9vcChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9yZWFkTG9vcChzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2xvc2VkKSByZXR1cm47XG4gIHJlYWROZXdNZXNzYWdlcyhzdGF0ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNsZWVwKHN0YXRlLm9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpO1xuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlYWRMb29wKHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKSB7XG4gIGlmIChtc2dPYmoudXVpZCA9PT0gc3RhdGUudXVpZCkgcmV0dXJuIGZhbHNlOyAvLyBzZW5kIGJ5IG93blxuICBpZiAoc3RhdGUuZU1Jcy5oYXMobXNnT2JqLmlkKSkgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGVtaXR0ZWRcbiAgaWYgKG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuIGZhbHNlOyAvLyBvbGRlciB0aGVuIG9uTWVzc2FnZUNhbGxiYWNrXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIHJlYWRzIGFsbCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgZGF0YWJhc2UgYW5kIGVtaXRzIHRoZW1cbiAqL1xuZnVuY3Rpb24gcmVhZE5ld01lc3NhZ2VzKHN0YXRlKSB7XG4gIC8vIGNoYW5uZWwgYWxyZWFkeSBjbG9zZWRcbiAgaWYgKHN0YXRlLmNsb3NlZCkgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcblxuICAvLyBpZiBubyBvbmUgaXMgbGlzdGVuaW5nLCB3ZSBkbyBub3QgbmVlZCB0byBzY2FuIGZvciBuZXcgbWVzc2FnZXNcbiAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICByZXR1cm4gZ2V0TWVzc2FnZXNIaWdoZXJUaGFuKHN0YXRlLmRiLCBzdGF0ZS5sYXN0Q3Vyc29ySWQpLnRoZW4oZnVuY3Rpb24gKG5ld2VyTWVzc2FnZXMpIHtcbiAgICB2YXIgdXNlTWVzc2FnZXMgPSBuZXdlck1lc3NhZ2VzXG4gICAgLyoqXG4gICAgICogdGhlcmUgaXMgYSBidWcgaW4gaU9TIHdoZXJlIHRoZSBtc2dPYmogY2FuIGJlIHVuZGVmaW5lZCBzb21lIHRpbWVzXG4gICAgICogc28gd2UgZmlsdGVyIHRoZW0gb3V0XG4gICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3B1YmtleS9icm9hZGNhc3QtY2hhbm5lbC9pc3N1ZXMvMTlcbiAgICAgKi8uZmlsdGVyKGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICAgIHJldHVybiAhIW1zZ09iajtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKG1zZ09iaikge1xuICAgICAgaWYgKG1zZ09iai5pZCA+IHN0YXRlLmxhc3RDdXJzb3JJZCkge1xuICAgICAgICBzdGF0ZS5sYXN0Q3Vyc29ySWQgPSBtc2dPYmouaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXNnT2JqO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAobXNnT2JqKSB7XG4gICAgICByZXR1cm4gX2ZpbHRlck1lc3NhZ2UobXNnT2JqLCBzdGF0ZSk7XG4gICAgfSkuc29ydChmdW5jdGlvbiAobXNnT2JqQSwgbXNnT2JqQikge1xuICAgICAgcmV0dXJuIG1zZ09iakEudGltZSAtIG1zZ09iakIudGltZTtcbiAgICB9KTsgLy8gc29ydCBieSB0aW1lXG4gICAgdXNlTWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobXNnT2JqKSB7XG4gICAgICBpZiAoc3RhdGUubWVzc2FnZXNDYWxsYmFjaykge1xuICAgICAgICBzdGF0ZS5lTUlzLmFkZChtc2dPYmouaWQpO1xuICAgICAgICBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKG1zZ09iai5kYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgY2hhbm5lbFN0YXRlLmNsb3NlZCA9IHRydWU7XG4gIGNoYW5uZWxTdGF0ZS5kYi5jbG9zZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgY2hhbm5lbFN0YXRlLndyaXRlQmxvY2tQcm9taXNlID0gY2hhbm5lbFN0YXRlLndyaXRlQmxvY2tQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3cml0ZU1lc3NhZ2UoY2hhbm5lbFN0YXRlLmRiLCBjaGFubmVsU3RhdGUudXVpZCwgbWVzc2FnZUpzb24pO1xuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmFuZG9tSW50KDAsIDEwKSA9PT0gMCkge1xuICAgICAgLyogYXdhaXQgKGRvIG5vdCBhd2FpdCkgKi9cbiAgICAgIGNsZWFuT2xkTWVzc2FnZXMoY2hhbm5lbFN0YXRlLmRiLCBjaGFubmVsU3RhdGUub3B0aW9ucy5pZGIudHRsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2hhbm5lbFN0YXRlLndyaXRlQmxvY2tQcm9taXNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG4gIHJlYWROZXdNZXNzYWdlcyhjaGFubmVsU3RhdGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbkJlVXNlZChvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5zdXBwb3J0M1BDKSByZXR1cm4gZmFsc2U7XG4gIHZhciBpZGIgPSBnZXRJZGIoKTtcbiAgaWYgKCFpZGIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsICogMjtcbn1cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNsb3NlOiBjbG9zZSxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXG4gIHR5cGU6IHR5cGUsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXG59OyJdLCJuYW1lcyI6WyJzbGVlcCIsInJhbmRvbUludCIsInJhbmRvbVRva2VuIiwibWljcm9TZWNvbmRzIiwibWljcm8iLCJQUk9NSVNFX1JFU09MVkVEX1ZPSUQiLCJPYmxpdmlvdXNTZXQiLCJmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyIsIkRCX1BSRUZJWCIsIk9CSkVDVF9TVE9SRV9JRCIsIlRSQU5TQUNUSU9OX1NFVFRJTkdTIiwiZHVyYWJpbGl0eSIsInR5cGUiLCJnZXRJZGIiLCJpbmRleGVkREIiLCJ3aW5kb3ciLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsImNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uIiwidHgiLCJjb21taXQiLCJjcmVhdGVEYXRhYmFzZSIsImNoYW5uZWxOYW1lIiwiSW5kZXhlZERCIiwiZGJOYW1lIiwib3BlblJlcXVlc3QiLCJvcGVuIiwib251cGdyYWRlbmVlZGVkIiwiZXYiLCJkYiIsInRhcmdldCIsInJlc3VsdCIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImF1dG9JbmNyZW1lbnQiLCJkYlByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwib25lcnJvciIsIm9uc3VjY2VzcyIsIndyaXRlTWVzc2FnZSIsInJlYWRlclV1aWQiLCJtZXNzYWdlSnNvbiIsInRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIndyaXRlT2JqZWN0IiwidXVpZCIsImRhdGEiLCJ0cmFuc2FjdGlvbiIsIm9uY29tcGxldGUiLCJvYmplY3RTdG9yZSIsImFkZCIsImdldEFsbE1lc3NhZ2VzIiwicmV0Iiwib3BlbkN1cnNvciIsImN1cnNvciIsInB1c2giLCJ2YWx1ZSIsImdldE1lc3NhZ2VzSGlnaGVyVGhhbiIsImxhc3RDdXJzb3JJZCIsImtleVJhbmdlVmFsdWUiLCJJREJLZXlSYW5nZSIsImJvdW5kIiwiSW5maW5pdHkiLCJnZXRBbGwiLCJnZXRBbGxSZXF1ZXN0IiwiZXJyIiwiZSIsIm9wZW5DdXJzb3JSZXF1ZXN0IiwiaWQiLCJyZW1vdmVNZXNzYWdlc0J5SWQiLCJpZHMiLCJhbGwiLCJtYXAiLCJkZWxldGVSZXF1ZXN0IiwiZ2V0T2xkTWVzc2FnZXMiLCJ0dGwiLCJvbGRlclRoZW4iLCJtc2dPYmsiLCJjbGVhbk9sZE1lc3NhZ2VzIiwidGhlbiIsInRvb09sZCIsIm1zZyIsImNyZWF0ZSIsIm9wdGlvbnMiLCJzdGF0ZSIsImNsb3NlZCIsImVNSXMiLCJpZGIiLCJ3cml0ZUJsb2NrUHJvbWlzZSIsIm1lc3NhZ2VzQ2FsbGJhY2siLCJyZWFkUXVldWVQcm9taXNlcyIsIm9uY2xvc2UiLCJfcmVhZExvb3AiLCJyZWFkTmV3TWVzc2FnZXMiLCJmYWxsYmFja0ludGVydmFsIiwiX2ZpbHRlck1lc3NhZ2UiLCJtc2dPYmoiLCJoYXMiLCJtZXNzYWdlc0NhbGxiYWNrVGltZSIsIm5ld2VyTWVzc2FnZXMiLCJ1c2VNZXNzYWdlcyIsImZpbHRlciIsInNvcnQiLCJtc2dPYmpBIiwibXNnT2JqQiIsImZvckVhY2giLCJjbG9zZSIsImNoYW5uZWxTdGF0ZSIsInBvc3RNZXNzYWdlIiwib25NZXNzYWdlIiwiZm4iLCJjYW5CZVVzZWQiLCJzdXBwb3J0M1BDIiwiYXZlcmFnZVJlc3BvbnNlVGltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/indexed-db.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/localstorage.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/localstorage.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addStorageEventListener: () => (/* binding */ addStorageEventListener),\n/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),\n/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getLocalStorage: () => (/* binding */ getLocalStorage),\n/* harmony export */   microSeconds: () => (/* binding */ microSeconds),\n/* harmony export */   onMessage: () => (/* binding */ onMessage),\n/* harmony export */   postMessage: () => (/* binding */ postMessage),\n/* harmony export */   removeStorageEventListener: () => (/* binding */ removeStorageEventListener),\n/* harmony export */   storageKey: () => (/* binding */ storageKey),\n/* harmony export */   type: () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ \"(ssr)/../node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ \n\n\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\nvar KEY_PREFIX = \"pubkey.broadcastChannel-\";\nvar type = \"localstorage\";\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */ function getLocalStorage() {\n    var localStorage;\n    if (true) return null;\n    try {\n        localStorage = window.localStorage;\n        localStorage = window[\"ie8-eventlistener/storage\"] || window.localStorage;\n    } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n    }\n    return localStorage;\n}\nfunction storageKey(channelName) {\n    return KEY_PREFIX + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage(channelState, messageJson) {\n    return new Promise(function(res) {\n        (0,_util__WEBPACK_IMPORTED_MODULE_0__.sleep)().then(function() {\n            var key = storageKey(channelState.channelName);\n            var writeObj = {\n                token: (0,_util__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),\n                time: new Date().getTime(),\n                data: messageJson,\n                uuid: channelState.uuid\n            };\n            var value = JSON.stringify(writeObj);\n            getLocalStorage().setItem(key, value);\n            /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */ var ev = document.createEvent(\"Event\");\n            ev.initEvent(\"storage\", true, true);\n            ev.key = key;\n            ev.newValue = value;\n            window.dispatchEvent(ev);\n            res();\n        });\n    });\n}\nfunction addStorageEventListener(channelName, fn) {\n    var key = storageKey(channelName);\n    var listener = function listener(ev) {\n        if (ev.key === key) {\n            fn(JSON.parse(ev.newValue));\n        }\n    };\n    window.addEventListener(\"storage\", listener);\n    return listener;\n}\nfunction removeStorageEventListener(listener) {\n    window.removeEventListener(\"storage\", listener);\n}\nfunction create(channelName, options) {\n    options = (0,_options__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);\n    if (!canBeUsed(options)) {\n        throw new Error(\"BroadcastChannel: localstorage cannot be used\");\n    }\n    var uuid = (0,_util__WEBPACK_IMPORTED_MODULE_0__.randomToken)();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ var eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.localstorage.removeTimeout);\n    var state = {\n        channelName: channelName,\n        uuid: uuid,\n        eMIs: eMIs // emittedMessagesIds\n    };\n    state.listener = addStorageEventListener(channelName, function(msgObj) {\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === uuid) return; // own message\n        if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n        if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    return state;\n}\nfunction close(channelState) {\n    removeStorageEventListener(channelState.listener);\n}\nfunction onMessage(channelState, fn, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn;\n}\nfunction canBeUsed(options) {\n    if (!options.support3PC) return false;\n    var ls = getLocalStorage();\n    if (!ls) return false;\n    try {\n        var key = \"__broadcastchannel_check\";\n        ls.setItem(key, \"works\");\n        ls.removeItem(key);\n    } catch (e) {\n        // Safari 10 in private mode will not allow write access to local\n        // storage and fail with a QuotaExceededError. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n        return false;\n    }\n    return true;\n}\nfunction averageResponseTime() {\n    var defaultTime = 120;\n    var userAgent = navigator.userAgent.toLowerCase();\n    if (userAgent.includes(\"safari\") && !userAgent.includes(\"chrome\")) {\n        // safari is much slower so this time is higher\n        return defaultTime * 2;\n    }\n    return defaultTime;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    create: create,\n    close: close,\n    onMessage: onMessage,\n    postMessage: postMessage,\n    canBeUsed: canBeUsed,\n    type: type,\n    averageResponseTime: averageResponseTime,\n    microSeconds: microSeconds\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9sb2NhbHN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUU0QztBQUNRO0FBQ2U7QUFDN0QsSUFBSUksZUFBZUMsK0NBQUtBLENBQUM7QUFDaEMsSUFBSUMsYUFBYTtBQUNWLElBQUlDLE9BQU8sZUFBZTtBQUVqQzs7O0NBR0MsR0FDTSxTQUFTQztJQUNkLElBQUlDO0lBQ0osSUFBSSxJQUFrQixFQUFhLE9BQU87SUFDMUMsSUFBSTtRQUNGQSxlQUFlQyxPQUFPRCxZQUFZO1FBQ2xDQSxlQUFlQyxNQUFNLENBQUMsNEJBQTRCLElBQUlBLE9BQU9ELFlBQVk7SUFDM0UsRUFBRSxPQUFPRSxHQUFHO0lBQ1YscURBQXFEO0lBQ3JELCtCQUErQjtJQUMvQix1REFBdUQ7SUFDekQ7SUFDQSxPQUFPRjtBQUNUO0FBQ08sU0FBU0csV0FBV0MsV0FBVztJQUNwQyxPQUFPUCxhQUFhTztBQUN0QjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDLFlBQVlDLFlBQVksRUFBRUMsV0FBVztJQUNuRCxPQUFPLElBQUlDLFFBQVEsU0FBVUMsR0FBRztRQUM5QmhCLDRDQUFLQSxHQUFHaUIsSUFBSSxDQUFDO1lBQ1gsSUFBSUMsTUFBTVIsV0FBV0csYUFBYUYsV0FBVztZQUM3QyxJQUFJUSxXQUFXO2dCQUNiQyxPQUFPbkIsa0RBQVdBO2dCQUNsQm9CLE1BQU0sSUFBSUMsT0FBT0MsT0FBTztnQkFDeEJDLE1BQU1WO2dCQUNOVyxNQUFNWixhQUFhWSxJQUFJO1lBQ3pCO1lBQ0EsSUFBSUMsUUFBUUMsS0FBS0MsU0FBUyxDQUFDVDtZQUMzQmIsa0JBQWtCdUIsT0FBTyxDQUFDWCxLQUFLUTtZQUUvQjs7OztPQUlDLEdBQ0QsSUFBSUksS0FBS0MsU0FBU0MsV0FBVyxDQUFDO1lBQzlCRixHQUFHRyxTQUFTLENB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LGFBQWFBO0lBQ2JpQyxXQUFXQTtJQUNYeEMsTUFBTUE7SUFDTndELHFCQUFxQkE7SUFDckIzRCxjQUFjQTtBQUNoQixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9sb2NhbHN0b3JhZ2UuanM/YjhjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XG4gKiBUaGlzIGRvZXMgbm90IHdvcmsgaW5zaWRlIG9mIHdlYndvcmtlcnMgYmVjYXVzZSB0aGV5IGhhdmUgbm8gYWNjZXNzIHRvIGxvY2FzdG9yYWdlXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBpbXBsZW1lbnRlZCB0byBzdXBwb3J0IElFOSBvciB5b3VyIGdyYW5kbW90aGVycyB0b2FzdGVyLlxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1uYW1ldmFsdWUtc3RvcmFnZVxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1pbmRleGVkZGJcbiAqL1xuXG5pbXBvcnQgeyBPYmxpdmlvdXNTZXQgfSBmcm9tICdvYmxpdmlvdXMtc2V0JztcbmltcG9ydCB7IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzIH0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQgeyBzbGVlcCwgcmFuZG9tVG9rZW4sIG1pY3JvU2Vjb25kcyBhcyBtaWNybyB9IGZyb20gJy4uL3V0aWwnO1xuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcbnZhciBLRVlfUFJFRklYID0gJ3B1YmtleS5icm9hZGNhc3RDaGFubmVsLSc7XG5leHBvcnQgdmFyIHR5cGUgPSAnbG9jYWxzdG9yYWdlJztcblxuLyoqXG4gKiBjb3BpZWQgZnJvbSBjcm9zc3RhYlxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RlamFjcXVlcy9jcm9zc3RhYi9ibG9iL21hc3Rlci9zcmMvY3Jvc3N0YWIuanMjTDMyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gIHZhciBsb2NhbFN0b3JhZ2U7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3dbJ2llOC1ldmVudGxpc3RlbmVyL3N0b3JhZ2UnXSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmV3IHZlcnNpb25zIG9mIEZpcmVmb3ggdGhyb3cgYSBTZWN1cml0eSBleGNlcHRpb25cbiAgICAvLyBpZiBjb29raWVzIGFyZSBkaXNhYmxlZC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyODE1M1xuICB9XG4gIHJldHVybiBsb2NhbFN0b3JhZ2U7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RvcmFnZUtleShjaGFubmVsTmFtZSkge1xuICByZXR1cm4gS0VZX1BSRUZJWCArIGNoYW5uZWxOYW1lO1xufVxuXG4vKipcbiAqIHdyaXRlcyB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIHN0b3JhZ2VcbiAqIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgc2xlZXAoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrZXkgPSBzdG9yYWdlS2V5KGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSk7XG4gICAgICB2YXIgd3JpdGVPYmogPSB7XG4gICAgICAgIHRva2VuOiByYW5kb21Ub2tlbigpLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgZGF0YTogbWVzc2FnZUpzb24sXG4gICAgICAgIHV1aWQ6IGNoYW5uZWxTdGF0ZS51dWlkXG4gICAgICB9O1xuICAgICAgdmFyIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkod3JpdGVPYmopO1xuICAgICAgZ2V0TG9jYWxTdG9yYWdlKCkuc2V0SXRlbShrZXksIHZhbHVlKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTdG9yYWdlRXZlbnQgZG9lcyBub3QgZmlyZSB0aGUgJ3N0b3JhZ2UnIGV2ZW50XG4gICAgICAgKiBpbiB0aGUgd2luZG93IHRoYXQgY2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhlIGxvY2FsIHN0b3JhZ2UuXG4gICAgICAgKiBTbyB3ZSBmaXJlIGl0IG1hbnVhbGx5XG4gICAgICAgKi9cbiAgICAgIHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXYuaW5pdEV2ZW50KCdzdG9yYWdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBldi5rZXkgPSBrZXk7XG4gICAgICBldi5uZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgcmVzKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFN0b3JhZ2VFdmVudExpc3RlbmVyKGNoYW5uZWxOYW1lLCBmbikge1xuICB2YXIga2V5ID0gc3RvcmFnZUtleShjaGFubmVsTmFtZSk7XG4gIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKGV2KSB7XG4gICAgaWYgKGV2LmtleSA9PT0ga2V5KSB7XG4gICAgICBmbihKU09OLnBhcnNlKGV2Lm5ld1ZhbHVlKSk7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgbGlzdGVuZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIGlmICghY2FuQmVVc2VkKG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsOiBsb2NhbHN0b3JhZ2UgY2Fubm90IGJlIHVzZWQnKTtcbiAgfVxuICB2YXIgdXVpZCA9IHJhbmRvbVRva2VuKCk7XG5cbiAgLyoqXG4gICAqIGVNSXNcbiAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAqL1xuICB2YXIgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWUsXG4gICAgdXVpZDogdXVpZCxcbiAgICBlTUlzOiBlTUlzIC8vIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICB9O1xuXG4gIHN0YXRlLmxpc3RlbmVyID0gYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbE5hbWUsIGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybjsgLy8gbm8gbGlzdGVuZXJcbiAgICBpZiAobXNnT2JqLnV1aWQgPT09IHV1aWQpIHJldHVybjsgLy8gb3duIG1lc3NhZ2VcbiAgICBpZiAoIW1zZ09iai50b2tlbiB8fCBlTUlzLmhhcyhtc2dPYmoudG9rZW4pKSByZXR1cm47IC8vIGFscmVhZHkgZW1pdHRlZFxuICAgIGlmIChtc2dPYmouZGF0YS50aW1lICYmIG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuOyAvLyB0b28gb2xkXG5cbiAgICBlTUlzLmFkZChtc2dPYmoudG9rZW4pO1xuICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xuICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsU3RhdGUubGlzdGVuZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLnN1cHBvcnQzUEMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGxzID0gZ2V0TG9jYWxTdG9yYWdlKCk7XG4gIGlmICghbHMpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIga2V5ID0gJ19fYnJvYWRjYXN0Y2hhbm5lbF9jaGVjayc7XG4gICAgbHMuc2V0SXRlbShrZXksICd3b3JrcycpO1xuICAgIGxzLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFNhZmFyaSAxMCBpbiBwcml2YXRlIG1vZGUgd2lsbCBub3QgYWxsb3cgd3JpdGUgYWNjZXNzIHRvIGxvY2FsXG4gICAgLy8gc3RvcmFnZSBhbmQgZmFpbCB3aXRoIGEgUXVvdGFFeGNlZWRlZEVycm9yLiBTZWVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1N0b3JhZ2VfQVBJI1ByaXZhdGVfQnJvd3NpbmdfSW5jb2duaXRvX21vZGVzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUoKSB7XG4gIHZhciBkZWZhdWx0VGltZSA9IDEyMDtcbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcygnc2FmYXJpJykgJiYgIXVzZXJBZ2VudC5pbmNsdWRlcygnY2hyb21lJykpIHtcbiAgICAvLyBzYWZhcmkgaXMgbXVjaCBzbG93ZXIgc28gdGhpcyB0aW1lIGlzIGhpZ2hlclxuICAgIHJldHVybiBkZWZhdWx0VGltZSAqIDI7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRUaW1lO1xufVxuZXhwb3J0IGRlZmF1bHQge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY2xvc2U6IGNsb3NlLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCxcbiAgdHlwZTogdHlwZSxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHNcbn07Il0sIm5hbWVzIjpbIk9ibGl2aW91c1NldCIsImZpbGxPcHRpb25zV2l0aERlZmF1bHRzIiwic2xlZXAiLCJyYW5kb21Ub2tlbiIsIm1pY3JvU2Vjb25kcyIsIm1pY3JvIiwiS0VZX1BSRUZJWCIsInR5cGUiLCJnZXRMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJ3aW5kb3ciLCJlIiwic3RvcmFnZUtleSIsImNoYW5uZWxOYW1lIiwicG9zdE1lc3NhZ2UiLCJjaGFubmVsU3RhdGUiLCJtZXNzYWdlSnNvbiIsIlByb21pc2UiLCJyZXMiLCJ0aGVuIiwia2V5Iiwid3JpdGVPYmoiLCJ0b2tlbiIsInRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsImRhdGEiLCJ1dWlkIiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0SXRlbSIsImV2IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsIm5ld1ZhbHVlIiwiZGlzcGF0Y2hFdmVudCIsImFkZFN0b3JhZ2VFdmVudExpc3RlbmVyIiwiZm4iLCJsaXN0ZW5lciIsInBhcnNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZSIsIm9wdGlvbnMiLCJjYW5CZVVzZWQiLCJFcnJvciIsImVNSXMiLCJsb2NhbHN0b3JhZ2UiLCJyZW1vdmVUaW1lb3V0Iiwic3RhdGUiLCJtc2dPYmoiLCJtZXNzYWdlc0NhbGxiYWNrIiwiaGFzIiwibWVzc2FnZXNDYWxsYmFja1RpbWUiLCJhZGQiLCJjbG9zZSIsIm9uTWVzc2FnZSIsInN1cHBvcnQzUEMiLCJscyIsInJlbW92ZUl0ZW0iLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwiZGVmYXVsdFRpbWUiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/localstorage.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/native.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/native.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),\n/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   microSeconds: () => (/* binding */ microSeconds),\n/* harmony export */   onMessage: () => (/* binding */ onMessage),\n/* harmony export */   postMessage: () => (/* binding */ postMessage),\n/* harmony export */   type: () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\nvar type = \"native\";\nfunction create(channelName) {\n    var state = {\n        messagesCallback: null,\n        bc: new BroadcastChannel(channelName),\n        subFns: [] // subscriberFunctions\n    };\n    state.bc.onmessage = function(msg) {\n        if (state.messagesCallback) {\n            state.messagesCallback(msg.data);\n        }\n    };\n    return state;\n}\nfunction close(channelState) {\n    channelState.bc.close();\n    channelState.subFns = [];\n}\nfunction postMessage(channelState, messageJson) {\n    try {\n        channelState.bc.postMessage(messageJson, false);\n        return _util__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n    } catch (err) {\n        return Promise.reject(err);\n    }\n}\nfunction onMessage(channelState, fn) {\n    channelState.messagesCallback = fn;\n}\nfunction canBeUsed(options) {\n    /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */ if (true) return false;\n    if (!options.support3PC) return false;\n    if (typeof BroadcastChannel === \"function\") {\n        if (BroadcastChannel._pubkey) {\n            throw new Error(\"BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill\");\n        }\n        return true;\n    } else return false;\n}\nfunction averageResponseTime() {\n    return 150;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    create: create,\n    close: close,\n    onMessage: onMessage,\n    postMessage: postMessage,\n    canBeUsed: canBeUsed,\n    type: type,\n    averageResponseTime: averageResponseTime,\n    microSeconds: microSeconds\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9uYXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNoRSxJQUFJQSxlQUFlQywrQ0FBS0EsQ0FBQztBQUN6QixJQUFJRSxPQUFPLFNBQVM7QUFDcEIsU0FBU0MsT0FBT0MsV0FBVztJQUNoQyxJQUFJQyxRQUFRO1FBQ1ZDLGtCQUFrQjtRQUNsQkMsSUFBSSxJQUFJQyxpQkFBaUJKO1FBQ3pCSyxRQUFRLEVBQUUsQ0FBQyxzQkFBc0I7SUFDbkM7SUFFQUosTUFBTUUsRUFBRSxDQUFDRyxTQUFTLEdBQUcsU0FBVUMsR0FBRztRQUNoQyxJQUFJTixNQUFNQyxnQkFBZ0IsRUFBRTtZQUMxQkQsTUFBTUMsZ0JBQWdCLENBQUNLLElBQUlDLElBQUk7UUFDakM7SUFDRjtJQUNBLE9BQU9QO0FBQ1Q7QUFDTyxTQUFTUSxNQUFNQyxZQUFZO0lBQ2hDQSxhQUFhUCxFQUFFLENBQUNNLEtBQUs7SUFDckJDLGFBQWFMLE1BQU0sR0FBRyxFQUFFO0FBQzFCO0FBQ08sU0FBU00sWUFBWUQsWUFBWSxFQUFFRSxXQUFXO0lBQ25ELElBQUk7UUFDRkYsYUFBYVAsRUFBRSxDQUFDUSxXQUFXLENBQUNDLGFBQWE7UUFDekMsT0FBT2Ysd0RBQXFCQTtJQUM5QixFQUFFLE9BQU9nQixLQUFLO1FBQ1osT0FBT0MsUUFBUUMsTUFBTSxDQUFDRjtJQUN4QjtBQUNGO0FBQ08sU0FBU0csVUFBVU4sWUFBWSxFQUFFTyxFQUFFO0lBQ3hDUCxhQUFhUixnQkFBZ0IsR0FBR2U7QUFDbEM7QUFDTyxTQUFTQyxVQUFVQyxPQUFPO0lBQy9COzs7R0FHQyxHQUNELElBQUksSUFBa0IsRUFBYSxPQUFPO0lBQzFDLElBQUksQ0FBQ0EsUUFBUUMsVUFBVSxFQUFFLE9BQU87SUFDaEMsSUFBSSxPQUFPaEIscUJBQXFCLFlBQVk7UUFDMUMsSUFBSUEsaUJBQWlCaUIsT0FBTyxFQUFFO1lBQzVCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87SUFDVCxPQUFPLE9BQU87QUFDaEI7QUFDTyxTQUFTQztJQUNkLE9BQU87QUFDVDtBQUNBLGlFQUFlO0lBQ2J4QixRQUFRQTtJQUNSVSxPQUFPQTtJQUNQTyxXQUFXQTtJQUNYTCxhQUFhQTtJQUNiTyxXQUFXQTtJQUNYcEIsTUFBTUE7SUFDTnlCLHFCQUFxQkE7SUFDckI1QixjQUFjQTtBQUNoQixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9uYXRpdmUuanM/N2RlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtaWNyb1NlY29uZHMgYXMgbWljcm8sIFBST01JU0VfUkVTT0xWRURfVk9JRCB9IGZyb20gJy4uL3V0aWwnO1xuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcbmV4cG9ydCB2YXIgdHlwZSA9ICduYXRpdmUnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSkge1xuICB2YXIgc3RhdGUgPSB7XG4gICAgbWVzc2FnZXNDYWxsYmFjazogbnVsbCxcbiAgICBiYzogbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUpLFxuICAgIHN1YkZuczogW10gLy8gc3Vic2NyaWJlckZ1bmN0aW9uc1xuICB9O1xuXG4gIHN0YXRlLmJjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAoc3RhdGUubWVzc2FnZXNDYWxsYmFjaykge1xuICAgICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2cuZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3RhdGU7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xvc2UoY2hhbm5lbFN0YXRlKSB7XG4gIGNoYW5uZWxTdGF0ZS5iYy5jbG9zZSgpO1xuICBjaGFubmVsU3RhdGUuc3ViRm5zID0gW107XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICB0cnkge1xuICAgIGNoYW5uZWxTdGF0ZS5iYy5wb3N0TWVzc2FnZShtZXNzYWdlSnNvbiwgZmFsc2UpO1xuICAgIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gb25NZXNzYWdlKGNoYW5uZWxTdGF0ZSwgZm4pIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYW5CZVVzZWQob3B0aW9ucykge1xuICAvKipcbiAgICogaW4gdGhlIGVsZWN0cm9uLXJlbmRlcmVyLCBpc05vZGUgd2lsbCBiZSB0cnVlIGV2ZW4gaWYgd2UgYXJlIGluIGJyb3dzZXItY29udGV4dFxuICAgKiBzbyB3ZSBhbHNvIGNoZWNrIGlmIHdpbmRvdyBpcyB1bmRlZmluZWRcbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoIW9wdGlvbnMuc3VwcG9ydDNQQykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQnJvYWRjYXN0Q2hhbm5lbC5fcHVia2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWw6IERvIG5vdCBvdmVyd3JpdGUgd2luZG93LkJyb2FkY2FzdENoYW5uZWwgd2l0aCB0aGlzIG1vZHVsZSwgdGhpcyBpcyBub3QgYSBwb2x5ZmlsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKCkge1xuICByZXR1cm4gMTUwO1xufVxuZXhwb3J0IGRlZmF1bHQge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY2xvc2U6IGNsb3NlLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCxcbiAgdHlwZTogdHlwZSxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHNcbn07Il0sIm5hbWVzIjpbIm1pY3JvU2Vjb25kcyIsIm1pY3JvIiwiUFJPTUlTRV9SRVNPTFZFRF9WT0lEIiwidHlwZSIsImNyZWF0ZSIsImNoYW5uZWxOYW1lIiwic3RhdGUiLCJtZXNzYWdlc0NhbGxiYWNrIiwiYmMiLCJCcm9hZGNhc3RDaGFubmVsIiwic3ViRm5zIiwib25tZXNzYWdlIiwibXNnIiwiZGF0YSIsImNsb3NlIiwiY2hhbm5lbFN0YXRlIiwicG9zdE1lc3NhZ2UiLCJtZXNzYWdlSnNvbiIsImVyciIsIlByb21pc2UiLCJyZWplY3QiLCJvbk1lc3NhZ2UiLCJmbiIsImNhbkJlVXNlZCIsIm9wdGlvbnMiLCJzdXBwb3J0M1BDIiwiX3B1YmtleSIsIkVycm9yIiwiYXZlcmFnZVJlc3BvbnNlVGltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/native.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/server.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/server.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),\n/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getSocketInstance: () => (/* binding */ getSocketInstance),\n/* harmony export */   microSeconds: () => (/* binding */ microSeconds),\n/* harmony export */   onMessage: () => (/* binding */ onMessage),\n/* harmony export */   postMessage: () => (/* binding */ postMessage),\n/* harmony export */   removeStorageEventListener: () => (/* binding */ removeStorageEventListener),\n/* harmony export */   setupSocketConnection: () => (/* binding */ setupSocketConnection),\n/* harmony export */   storageKey: () => (/* binding */ storageKey),\n/* harmony export */   type: () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/../node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"(ssr)/../node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! oblivious-set */ \"(ssr)/../node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(ssr)/../node_modules/socket.io-client/build/esm-debug/index.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/../node_modules/@toruslabs/eccrypto/dist/browser.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/../node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../options */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js\");\n\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ \n\n\n\n\n\n\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_5__.microSeconds;\nvar KEY_PREFIX = \"pubkey.broadcastChannel-\";\nvar type = \"server\";\nvar SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nvar runningChannels = new Set();\nfunction storageKey(channelName) {\n    return KEY_PREFIX + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage(channelState, messageJson) {\n    return new Promise(function(res, rej) {\n        (0,_util__WEBPACK_IMPORTED_MODULE_5__.sleep)().then(/*#__PURE__*/ _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()(/*#__PURE__*/ _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee() {\n            var key, channelEncPrivKey, encData, body;\n            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {\n                while(1)switch(_context.prev = _context.next){\n                    case 0:\n                        key = storageKey(channelState.channelName);\n                        channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_4__.keccak256)(Buffer.from(key, \"utf8\"));\n                        _context.next = 4;\n                        return (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_4__.encryptData)(channelEncPrivKey.toString(\"hex\"), {\n                            token: (0,_util__WEBPACK_IMPORTED_MODULE_5__.randomToken)(),\n                            time: new Date().getTime(),\n                            data: messageJson,\n                            uuid: channelState.uuid\n                        });\n                    case 4:\n                        encData = _context.sent;\n                        _context.t0 = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_3__.getPublic)(channelEncPrivKey).toString(\"hex\");\n                        _context.t1 = encData;\n                        _context.next = 9;\n                        return (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_3__.sign)(channelEncPrivKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_4__.keccak256)(Buffer.from(encData, \"utf8\")));\n                    case 9:\n                        _context.t2 = _context.sent.toString(\"hex\");\n                        body = {\n                            key: _context.t0,\n                            data: _context.t1,\n                            signature: _context.t2\n                        };\n                        if (channelState.timeout) body.timeout = channelState.timeout;\n                        return _context.abrupt(\"return\", fetch(channelState.serverUrl + \"/channel/set\", {\n                            method: \"POST\",\n                            body: JSON.stringify(body),\n                            headers: {\n                                \"Content-Type\": \"application/json; charset=utf-8\"\n                            }\n                        }).then(res)[\"catch\"](rej));\n                    case 13:\n                    case \"end\":\n                        return _context.stop();\n                }\n            }, _callee);\n        })));\n    });\n}\nfunction getSocketInstance(serverUrl) {\n    if (SOCKET_CONN_INSTANCE) {\n        return SOCKET_CONN_INSTANCE;\n    }\n    var SOCKET_CONN = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(serverUrl, {\n        transports: [\n            \"websocket\",\n            \"polling\"\n        ],\n        // use WebSocket first, if available\n        withCredentials: true,\n        reconnectionDelayMax: 10000,\n        reconnectionAttempts: 10\n    });\n    SOCKET_CONN.on(\"connect_error\", function(err) {\n        // revert to classic upgrade\n        SOCKET_CONN.io.opts.transports = [\n            \"polling\",\n            \"websocket\"\n        ];\n        _util__WEBPACK_IMPORTED_MODULE_5__.log.error(\"connect error\", err);\n    });\n    SOCKET_CONN.on(\"connect\", /*#__PURE__*/ _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()(/*#__PURE__*/ _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2() {\n        var engine;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {\n            while(1)switch(_context2.prev = _context2.next){\n                case 0:\n                    engine = SOCKET_CONN.io.engine;\n                    _util__WEBPACK_IMPORTED_MODULE_5__.log.debug(\"initially connected to\", engine.transport.name); // in most cases, prints \"polling\"\n                    engine.once(\"upgrade\", function() {\n                        // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n                        _util__WEBPACK_IMPORTED_MODULE_5__.log.debug(\"upgraded\", engine.transport.name); // in most cases, prints \"websocket\"\n                    });\n                    engine.once(\"close\", function(reason) {\n                        // called when the underlying connection is closed\n                        _util__WEBPACK_IMPORTED_MODULE_5__.log.debug(\"connection closed\", reason);\n                    });\n                case 4:\n                case \"end\":\n                    return _context2.stop();\n            }\n        }, _callee2);\n    })));\n    SOCKET_CONN.on(\"error\", function(err) {\n        _util__WEBPACK_IMPORTED_MODULE_5__.log.error(\"socket errored\", err);\n        SOCKET_CONN.disconnect();\n    });\n    SOCKET_CONN_INSTANCE = SOCKET_CONN;\n    return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelName, fn) {\n    var socketConn = getSocketInstance(serverUrl);\n    var key = storageKey(channelName);\n    var channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_4__.keccak256)(Buffer.from(key, \"utf8\"));\n    var channelPubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_3__.getPublic)(channelEncPrivKey).toString(\"hex\");\n    if (socketConn.connected) {\n        socketConn.emit(\"check_auth_status\", channelPubKey);\n    } else {\n        socketConn.once(\"connect\", function() {\n            _util__WEBPACK_IMPORTED_MODULE_5__.log.debug(\"connected with socket\");\n            socketConn.emit(\"check_auth_status\", channelPubKey);\n        });\n    }\n    var reconnect = function reconnect() {\n        socketConn.once(\"connect\", /*#__PURE__*/ _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()(/*#__PURE__*/ _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3() {\n            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee3$(_context3) {\n                while(1)switch(_context3.prev = _context3.next){\n                    case 0:\n                        socketConn.emit(\"check_auth_status\", channelPubKey);\n                    case 1:\n                    case \"end\":\n                        return _context3.stop();\n                }\n            }, _callee3);\n        })));\n    };\n    var visibilityListener = function visibilityListener() {\n        // if channel is closed, then remove the listener.\n        if (!socketConn) {\n            document.removeEventListener(\"visibilitychange\", visibilityListener);\n            return;\n        }\n        // if not connected, then wait for connection and ping server for latest msg.\n        if (!socketConn.connected && document.visibilityState === \"visible\") {\n            reconnect();\n        }\n    };\n    var listener = /*#__PURE__*/ function() {\n        var _ref4 = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()(/*#__PURE__*/ _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee4(ev) {\n            var decData;\n            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee4$(_context4) {\n                while(1)switch(_context4.prev = _context4.next){\n                    case 0:\n                        _context4.prev = 0;\n                        _context4.next = 3;\n                        return (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_4__.decryptData)(channelEncPrivKey.toString(\"hex\"), ev);\n                    case 3:\n                        decData = _context4.sent;\n                        _util__WEBPACK_IMPORTED_MODULE_5__.log.info(decData);\n                        fn(decData);\n                        _context4.next = 11;\n                        break;\n                    case 8:\n                        _context4.prev = 8;\n                        _context4.t0 = _context4[\"catch\"](0);\n                        _util__WEBPACK_IMPORTED_MODULE_5__.log.error(_context4.t0);\n                    case 11:\n                    case \"end\":\n                        return _context4.stop();\n                }\n            }, _callee4, null, [\n                [\n                    0,\n                    8\n                ]\n            ]);\n        }));\n        return function listener(_x) {\n            return _ref4.apply(this, arguments);\n        };\n    }();\n    socketConn.on(\"disconnect\", function() {\n        _util__WEBPACK_IMPORTED_MODULE_5__.log.debug(\"socket disconnected\");\n        if (runningChannels.has(channelName)) {\n            _util__WEBPACK_IMPORTED_MODULE_5__.log.error(\"socket disconnected unexpectedly, reconnecting socket\");\n            reconnect();\n        }\n    });\n    socketConn.on(channelPubKey + \"_success\", listener);\n    if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", visibilityListener);\n    return socketConn;\n}\nfunction removeStorageEventListener() {\n    if (SOCKET_CONN_INSTANCE) {\n        SOCKET_CONN_INSTANCE.disconnect();\n    }\n}\nfunction create(channelName, options) {\n    options = (0,_options__WEBPACK_IMPORTED_MODULE_6__.fillOptionsWithDefaults)(options);\n    if (!canBeUsed(options)) {\n        throw new Error(\"BroadcastChannel: server cannot be used\");\n    }\n    var uuid = (0,_util__WEBPACK_IMPORTED_MODULE_5__.randomToken)();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ var eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_7__.ObliviousSet(options.server.removeTimeout);\n    var state = {\n        channelName: channelName,\n        uuid: uuid,\n        eMIs: eMIs,\n        // emittedMessagesIds\n        serverUrl: options.server.url\n    };\n    if (options.server.timeout) state.timeout = options.server.timeout;\n    setupSocketConnection(options.server.url, channelName, function(msgObj) {\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === state.uuid) return; // own message\n        if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n        // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        state.eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    runningChannels.add(channelName);\n    return state;\n}\nfunction close(channelState) {\n    runningChannels[\"delete\"](channelState.channelName);\n// give 2 sec for all msgs which are in transit to be consumed\n// by receiver.\n// window.setTimeout(() => {\n//     removeStorageEventListener(channelState);\n//     SOCKET_CONN_INSTANCE = null;\n// }, 1000);\n}\nfunction onMessage(channelState, fn, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n    return true;\n}\nfunction averageResponseTime() {\n    var defaultTime = 500;\n    // TODO: Maybe increase it based on operation\n    return defaultTime;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    create: create,\n    close: close,\n    onMessage: onMessage,\n    postMessage: postMessage,\n    canBeUsed: canBeUsed,\n    type: type,\n    averageResponseTime: averageResponseTime,\n    microSeconds: microSeconds\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0U7QUFDWDtBQUM3RDs7Ozs7O0NBTUMsR0FFNEM7QUFDUDtBQUNnQjtBQUM0QjtBQUNwRDtBQUN1QjtBQUNlO0FBQzdELElBQUlhLGVBQWVDLCtDQUFLQSxDQUFDO0FBQ2hDLElBQUlDLGFBQWE7QUFDVixJQUFJQyxPQUFPLFNBQVM7QUFDM0IsSUFBSUMsdUJBQXVCO0FBQzNCLDhGQUE4RjtBQUM5RixJQUFJQyxrQkFBa0IsSUFBSUM7QUFDbkIsU0FBU0MsV0FBV0MsV0FBVztJQUNwQyxPQUFPTixhQUFhTTtBQUN0QjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDLFlBQVlDLFlBQVksRUFBRUMsV0FBVztJQUNuRCxPQUFPLElBQUlDLFFBQVEsU0FBVUMsR0FBRyxFQUFFQyxHQUFHO1FBQ25DaEIsNENBQUtBLEdBQUdpQixJQUFJLENBQUUsV0FBVyxHQUFFNUIsOEVBQWlCQSxDQUFFLFdBQVcsR0FBRUMsc0VBQXdCLENBQUMsU0FBUzZCO1lBQzNGLElBQUlDLEtBQUtDLG1CQUFtQkMsU0FBU0M7WUFDckMsT0FBT2pDLHNFQUF3QixDQUFDLFNBQVNtQyxTQUFTQyxRQUFRO2dCQUN4RCxNQUFPLEVBQUcsT0FBUUEsU0FBU0MsSUFBSSxHQUFHRCxTQUFTRSxJQUFJO29CQUM3QyxLQUFLO3dCQUNIUixNQUFNWCxXQUFXRyxhQUFhRixXQUFXO3dCQUN6Q1csb0JBQW9CeEIsc0VBQVNBLENBQUNnQyxPQUFPQyxJQUFJLENBQUNWLEtBQUs7d0JBQy9DTSxTQUFTRSxJQUFJLEdBQUc7d0JBQ2hCLE9BQU9qQyx3RUFBV0EsQ0FBQzBCLGtCQUFrQlUsUUFBUSxDQUFDLFFBQVE7NEJBQ3BEQyxPQUFPL0Isa0RBQVdBOzRCQUNsQmdDLE1BQU0sSUFBSUMsT0FBT0Ms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O1FBQzdFLDRGQUE0RjtRQUU1RjJFLE1BQU1ILElBQUksQ0FBQ08sR0FBRyxDQUFDRixPQUFPN0UsS0FBSztRQUMzQjJFLE1BQU1HLGdCQUFnQixDQUFDRCxPQUFPekUsSUFBSTtJQUNwQztJQUNBN0IsZ0JBQWdCd0csR0FBRyxDQUFDckc7SUFDcEIsT0FBT2lHO0FBQ1Q7QUFDTyxTQUFTSyxNQUFNcEcsWUFBWTtJQUNoQ0wsZUFBZSxDQUFDLFNBQVMsQ0FBQ0ssYUFBYUYsV0FBVztBQUNsRCw4REFBOEQ7QUFDOUQsZUFBZTtBQUNmLDRCQUE0QjtBQUM1QixnREFBZ0Q7QUFDaEQsbUNBQW1DO0FBQ25DLFlBQVk7QUFDZDtBQUVPLFNBQVN1RyxVQUFVckcsWUFBWSxFQUFFNkQsRUFBRSxFQUFFeEMsSUFBSTtJQUM5Q3JCLGFBQWFzRyxvQkFBb0IsR0FBR2pGO0lBQ3BDckIsYUFBYWtHLGdCQUFnQixHQUFHckM7QUFDbEM7QUFDTyxTQUFTNkI7SUFDZCxPQUFPO0FBQ1Q7QUFDTyxTQUFTYTtJQUNkLElBQUlDLGNBQWM7SUFDbEIsNkNBQTZDO0lBQzdDLE9BQU9BO0FBQ1Q7QUFDQSxpRUFBZTtJQUNiaEIsUUFBUUE7SUFDUlksT0FBT0E7SUFDUEMsV0FBV0E7SUFDWHRHLGFBQWFBO0lBQ2IyRixXQUFXQTtJQUNYakcsTUFBTUE7SUFDTjhHLHFCQUFxQkE7SUFDckJqSCxjQUFjQTtBQUNoQixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9zZXJ2ZXIuanM/YzM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSBcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCI7XG4vKipcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XG4gKiBUaGlzIGRvZXMgbm90IHdvcmsgaW5zaWRlIG9mIHdlYndvcmtlcnMgYmVjYXVzZSB0aGV5IGhhdmUgbm8gYWNjZXNzIHRvIGxvY2FzdG9yYWdlXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBpbXBsZW1lbnRlZCB0byBzdXBwb3J0IElFOSBvciB5b3VyIGdyYW5kbW90aGVycyB0b2FzdGVyLlxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1uYW1ldmFsdWUtc3RvcmFnZVxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1pbmRleGVkZGJcbiAqL1xuXG5pbXBvcnQgeyBPYmxpdmlvdXNTZXQgfSBmcm9tICdvYmxpdmlvdXMtc2V0JztcbmltcG9ydCB7IGlvIH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgeyBnZXRQdWJsaWMsIHNpZ24gfSBmcm9tICdAdG9ydXNsYWJzL2VjY3J5cHRvJztcbmltcG9ydCB7IGVuY3J5cHREYXRhLCBkZWNyeXB0RGF0YSwga2VjY2FrMjU2IH0gZnJvbSAnQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMgfSBmcm9tICcuLi9vcHRpb25zJztcbmltcG9ydCB7IHNsZWVwLCByYW5kb21Ub2tlbiwgbWljcm9TZWNvbmRzIGFzIG1pY3JvIH0gZnJvbSAnLi4vdXRpbCc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xudmFyIEtFWV9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdENoYW5uZWwtJztcbmV4cG9ydCB2YXIgdHlwZSA9ICdzZXJ2ZXInO1xudmFyIFNPQ0tFVF9DT05OX0lOU1RBTkNFID0gbnVsbDtcbi8vIHVzZWQgdG8gZGVjaWRlIHRvIHJlY29ubmVjdCBzb2NrZXQgZS5nLiB3aGVuIHNvY2tldCBjb25uZWN0aW9uIGlzIGRpc2Nvbm5lY3RlZCB1bmV4cGVjdGVkbHlcbnZhciBydW5uaW5nQ2hhbm5lbHMgPSBuZXcgU2V0KCk7XG5leHBvcnQgZnVuY3Rpb24gc3RvcmFnZUtleShjaGFubmVsTmFtZSkge1xuICByZXR1cm4gS0VZX1BSRUZJWCArIGNoYW5uZWxOYW1lO1xufVxuXG4vKipcbiAqIHdyaXRlcyB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIHN0b3JhZ2VcbiAqIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICBzbGVlcCgpLnRoZW4oIC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgdmFyIGtleSwgY2hhbm5lbEVuY1ByaXZLZXksIGVuY0RhdGEsIGJvZHk7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAga2V5ID0gc3RvcmFnZUtleShjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgY2hhbm5lbEVuY1ByaXZLZXkgPSBrZWNjYWsyNTYoQnVmZmVyLmZyb20oa2V5LCAndXRmOCcpKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGVuY3J5cHREYXRhKGNoYW5uZWxFbmNQcml2S2V5LnRvU3RyaW5nKCdoZXgnKSwge1xuICAgICAgICAgICAgICB0b2tlbjogcmFuZG9tVG9rZW4oKSxcbiAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VKc29uLFxuICAgICAgICAgICAgICB1dWlkOiBjaGFubmVsU3RhdGUudXVpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZW5jRGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IGdldFB1YmxpYyhjaGFubmVsRW5jUHJpdktleSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgX2NvbnRleHQudDEgPSBlbmNEYXRhO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbihjaGFubmVsRW5jUHJpdktleSwga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKGVuY0RhdGEsICd1dGY4JykpKTtcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dC50MiA9IF9jb250ZXh0LnNlbnQudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICAgICAga2V5OiBfY29udGV4dC50MCxcbiAgICAgICAgICAgICAgZGF0YTogX2NvbnRleHQudDEsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogX2NvbnRleHQudDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbFN0YXRlLnRpbWVvdXQpIGJvZHkudGltZW91dCA9IGNoYW5uZWxTdGF0ZS50aW1lb3V0O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmZXRjaChjaGFubmVsU3RhdGUuc2VydmVyVXJsICsgJy9jaGFubmVsL3NldCcsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS50aGVuKHJlcylbXCJjYXRjaFwiXShyZWopKTtcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvY2tldEluc3RhbmNlKHNlcnZlclVybCkge1xuICBpZiAoU09DS0VUX0NPTk5fSU5TVEFOQ0UpIHtcbiAgICByZXR1cm4gU09DS0VUX0NPTk5fSU5TVEFOQ0U7XG4gIH1cbiAgdmFyIFNPQ0tFVF9DT05OID0gaW8oc2VydmVyVXJsLCB7XG4gICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnLCAncG9sbGluZyddLFxuICAgIC8vIHVzZSBXZWJTb2NrZXQgZmlyc3QsIGlmIGF2YWlsYWJsZVxuICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICByZWNvbm5lY3Rpb25EZWxheU1heDogMTAwMDAsXG4gICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDEwXG4gIH0pO1xuICBTT0NLRVRfQ09OTi5vbignY29ubmVjdF9lcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAvLyByZXZlcnQgdG8gY2xhc3NpYyB1cGdyYWRlXG4gICAgU09DS0VUX0NPTk4uaW8ub3B0cy50cmFuc3BvcnRzID0gWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICAgIGxvZy5lcnJvcignY29ubmVjdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICBTT0NLRVRfQ09OTi5vbignY29ubmVjdCcsIC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICB2YXIgZW5naW5lO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZW5naW5lID0gU09DS0VUX0NPTk4uaW8uZW5naW5lO1xuICAgICAgICAgIGxvZy5kZWJ1ZygnaW5pdGlhbGx5IGNvbm5lY3RlZCB0bycsIGVuZ2luZS50cmFuc3BvcnQubmFtZSk7IC8vIGluIG1vc3QgY2FzZXMsIHByaW50cyBcInBvbGxpbmdcIlxuICAgICAgICAgIGVuZ2luZS5vbmNlKCd1cGdyYWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyB1cGdyYWRlZCAoaS5lLiBmcm9tIEhUVFAgbG9uZy1wb2xsaW5nIHRvIFdlYlNvY2tldClcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygndXBncmFkZWQnLCBlbmdpbmUudHJhbnNwb3J0Lm5hbWUpOyAvLyBpbiBtb3N0IGNhc2VzLCBwcmludHMgXCJ3ZWJzb2NrZXRcIlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZW5naW5lLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBpcyBjbG9zZWRcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnY29ubmVjdGlvbiBjbG9zZWQnLCByZWFzb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKSk7XG4gIFNPQ0tFVF9DT05OLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBsb2cuZXJyb3IoJ3NvY2tldCBlcnJvcmVkJywgZXJyKTtcbiAgICBTT0NLRVRfQ09OTi5kaXNjb25uZWN0KCk7XG4gIH0pO1xuICBTT0NLRVRfQ09OTl9JTlNUQU5DRSA9IFNPQ0tFVF9DT05OO1xuICByZXR1cm4gU09DS0VUX0NPTk47XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTb2NrZXRDb25uZWN0aW9uKHNlcnZlclVybCwgY2hhbm5lbE5hbWUsIGZuKSB7XG4gIHZhciBzb2NrZXRDb25uID0gZ2V0U29ja2V0SW5zdGFuY2Uoc2VydmVyVXJsKTtcbiAgdmFyIGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbE5hbWUpO1xuICB2YXIgY2hhbm5lbEVuY1ByaXZLZXkgPSBrZWNjYWsyNTYoQnVmZmVyLmZyb20oa2V5LCAndXRmOCcpKTtcbiAgdmFyIGNoYW5uZWxQdWJLZXkgPSBnZXRQdWJsaWMoY2hhbm5lbEVuY1ByaXZLZXkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgaWYgKHNvY2tldENvbm4uY29ubmVjdGVkKSB7XG4gICAgc29ja2V0Q29ubi5lbWl0KCdjaGVja19hdXRoX3N0YXR1cycsIGNoYW5uZWxQdWJLZXkpO1xuICB9IGVsc2Uge1xuICAgIHNvY2tldENvbm4ub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZy5kZWJ1ZygnY29ubmVjdGVkIHdpdGggc29ja2V0Jyk7XG4gICAgICBzb2NrZXRDb25uLmVtaXQoJ2NoZWNrX2F1dGhfc3RhdHVzJywgY2hhbm5lbFB1YktleSk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIHJlY29ubmVjdCA9IGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcbiAgICBzb2NrZXRDb25uLm9uY2UoJ2Nvbm5lY3QnLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHNvY2tldENvbm4uZW1pdCgnY2hlY2tfYXV0aF9zdGF0dXMnLCBjaGFubmVsUHViS2V5KTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICB9KSkpO1xuICB9O1xuICB2YXIgdmlzaWJpbGl0eUxpc3RlbmVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIC8vIGlmIGNoYW5uZWwgaXMgY2xvc2VkLCB0aGVuIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgaWYgKCFzb2NrZXRDb25uKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUxpc3RlbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgbm90IGNvbm5lY3RlZCwgdGhlbiB3YWl0IGZvciBjb25uZWN0aW9uIGFuZCBwaW5nIHNlcnZlciBmb3IgbGF0ZXN0IG1zZy5cbiAgICBpZiAoIXNvY2tldENvbm4uY29ubmVjdGVkICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICByZWNvbm5lY3QoKTtcbiAgICB9XG4gIH07XG4gIHZhciBsaXN0ZW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoZXYpIHtcbiAgICAgIHZhciBkZWNEYXRhO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gZGVjcnlwdERhdGEoY2hhbm5lbEVuY1ByaXZLZXkudG9TdHJpbmcoJ2hleCcpLCBldik7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGVjRGF0YSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgbG9nLmluZm8oZGVjRGF0YSk7XG4gICAgICAgICAgICBmbihkZWNEYXRhKTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGxvZy5lcnJvcihfY29udGV4dDQudDApO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU0LCBudWxsLCBbWzAsIDhdXSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBmdW5jdGlvbiBsaXN0ZW5lcihfeCkge1xuICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xuICBzb2NrZXRDb25uLm9uKCdkaXNjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIGxvZy5kZWJ1Zygnc29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgIGlmIChydW5uaW5nQ2hhbm5lbHMuaGFzKGNoYW5uZWxOYW1lKSkge1xuICAgICAgbG9nLmVycm9yKCdzb2NrZXQgZGlzY29ubmVjdGVkIHVuZXhwZWN0ZWRseSwgcmVjb25uZWN0aW5nIHNvY2tldCcpO1xuICAgICAgcmVjb25uZWN0KCk7XG4gICAgfVxuICB9KTtcbiAgc29ja2V0Q29ubi5vbihjaGFubmVsUHViS2V5ICsgXCJfc3VjY2Vzc1wiLCBsaXN0ZW5lcik7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUxpc3RlbmVyKTtcbiAgcmV0dXJuIHNvY2tldENvbm47XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXIoKSB7XG4gIGlmIChTT0NLRVRfQ09OTl9JTlNUQU5DRSkge1xuICAgIFNPQ0tFVF9DT05OX0lOU1RBTkNFLmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIGlmICghY2FuQmVVc2VkKG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsOiBzZXJ2ZXIgY2Fubm90IGJlIHVzZWQnKTtcbiAgfVxuICB2YXIgdXVpZCA9IHJhbmRvbVRva2VuKCk7XG5cbiAgLyoqXG4gICAqIGVNSXNcbiAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAqL1xuICB2YXIgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5zZXJ2ZXIucmVtb3ZlVGltZW91dCk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWUsXG4gICAgdXVpZDogdXVpZCxcbiAgICBlTUlzOiBlTUlzLFxuICAgIC8vIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICAgIHNlcnZlclVybDogb3B0aW9ucy5zZXJ2ZXIudXJsXG4gIH07XG4gIGlmIChvcHRpb25zLnNlcnZlci50aW1lb3V0KSBzdGF0ZS50aW1lb3V0ID0gb3B0aW9ucy5zZXJ2ZXIudGltZW91dDtcbiAgc2V0dXBTb2NrZXRDb25uZWN0aW9uKG9wdGlvbnMuc2VydmVyLnVybCwgY2hhbm5lbE5hbWUsIGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybjsgLy8gbm8gbGlzdGVuZXJcbiAgICBpZiAobXNnT2JqLnV1aWQgPT09IHN0YXRlLnV1aWQpIHJldHVybjsgLy8gb3duIG1lc3NhZ2VcbiAgICBpZiAoIW1zZ09iai50b2tlbiB8fCBzdGF0ZS5lTUlzLmhhcyhtc2dPYmoudG9rZW4pKSByZXR1cm47IC8vIGFscmVhZHkgZW1pdHRlZFxuICAgIC8vIGlmIChtc2dPYmouZGF0YS50aW1lICYmIG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuOyAvLyB0b28gb2xkXG5cbiAgICBzdGF0ZS5lTUlzLmFkZChtc2dPYmoudG9rZW4pO1xuICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICB9KTtcbiAgcnVubmluZ0NoYW5uZWxzLmFkZChjaGFubmVsTmFtZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgcnVubmluZ0NoYW5uZWxzW1wiZGVsZXRlXCJdKGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSk7XG4gIC8vIGdpdmUgMiBzZWMgZm9yIGFsbCBtc2dzIHdoaWNoIGFyZSBpbiB0cmFuc2l0IHRvIGJlIGNvbnN1bWVkXG4gIC8vIGJ5IHJlY2VpdmVyLlxuICAvLyB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gIC8vICAgICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsU3RhdGUpO1xuICAvLyAgICAgU09DS0VUX0NPTk5fSU5TVEFOQ0UgPSBudWxsO1xuICAvLyB9LCAxMDAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKCkge1xuICB2YXIgZGVmYXVsdFRpbWUgPSA1MDA7XG4gIC8vIFRPRE86IE1heWJlIGluY3JlYXNlIGl0IGJhc2VkIG9uIG9wZXJhdGlvblxuICByZXR1cm4gZGVmYXVsdFRpbWU7XG59XG5leHBvcnQgZGVmYXVsdCB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjbG9zZTogY2xvc2UsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkLFxuICB0eXBlOiB0eXBlLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kc1xufTsiXSwibmFtZXMiOlsiX2FzeW5jVG9HZW5lcmF0b3IiLCJfcmVnZW5lcmF0b3JSdW50aW1lIiwiT2JsaXZpb3VzU2V0IiwiaW8iLCJnZXRQdWJsaWMiLCJzaWduIiwiZW5jcnlwdERhdGEiLCJkZWNyeXB0RGF0YSIsImtlY2NhazI1NiIsImxvZyIsImZpbGxPcHRpb25zV2l0aERlZmF1bHRzIiwic2xlZXAiLCJyYW5kb21Ub2tlbiIsIm1pY3JvU2Vjb25kcyIsIm1pY3JvIiwiS0VZX1BSRUZJWCIsInR5cGUiLCJTT0NLRVRfQ09OTl9JTlNUQU5DRSIsInJ1bm5pbmdDaGFubmVscyIsIlNldCIsInN0b3JhZ2VLZXkiLCJjaGFubmVsTmFtZSIsInBvc3RNZXNzYWdlIiwiY2hhbm5lbFN0YXRlIiwibWVzc2FnZUpzb24iLCJQcm9taXNlIiwicmVzIiwicmVqIiwidGhlbiIsIm1hcmsiLCJfY2FsbGVlIiwia2V5IiwiY2hhbm5lbEVuY1ByaXZLZXkiLCJlbmNEYXRhIiwiYm9keSIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJ0b2tlbiIsInRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsImRhdGEiLCJ1dWlkIiwic2VudCIsInQwIiwidDEiLCJ0MiIsInNpZ25hdHVyZSIsInRpbWVvdXQiLCJhYnJ1cHQiLCJmZXRjaCIsInNlcnZlclVybCIsIm1ldGhvZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwic3RvcCIsImdldFNvY2tldEluc3RhbmNlIiwiU09DS0VUX0NPTk4iLCJ0cmFuc3BvcnRzIiwid2l0aENyZWRlbnRpYWxzIiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIm9uIiwiZXJyIiwib3B0cyIsImVycm9yIiwiX2NhbGxlZTIiLCJlbmdpbmUiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJkZWJ1ZyIsInRyYW5zcG9ydCIsIm5hbWUiLCJvbmNlIiwicmVhc29uIiwiZGlzY29ubmVjdCIsInNldHVwU29ja2V0Q29ubmVjdGlvbiIsImZuIiwic29ja2V0Q29ubiIsImNoYW5uZWxQdWJLZXkiLCJjb25uZWN0ZWQiLCJlbWl0IiwicmVjb25uZWN0IiwiX2NhbGxlZTMiLCJfY2FsbGVlMyQiLCJfY29udGV4dDMiLCJ2aXNpYmlsaXR5TGlzdGVuZXIiLCJkb2N1bWVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ2aXNpYmlsaXR5U3RhdGUiLCJsaXN0ZW5lciIsIl9yZWY0IiwiX2NhbGxlZTQiLCJldiIsImRlY0RhdGEiLCJfY2FsbGVlNCQiLCJfY29udGV4dDQiLCJpbmZvIiwiX3giLCJhcHBseSIsImFyZ3VtZW50cyIsImhhcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZSIsIm9wdGlvbnMiLCJjYW5CZVVzZWQiLCJFcnJvciIsImVNSXMiLCJzZXJ2ZXIiLCJyZW1vdmVUaW1lb3V0Iiwic3RhdGUiLCJ1cmwiLCJtc2dPYmoiLCJtZXNzYWdlc0NhbGxiYWNrIiwiYWRkIiwiY2xvc2UiLCJvbk1lc3NhZ2UiLCJtZXNzYWdlc0NhbGxiYWNrVGltZSIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJkZWZhdWx0VGltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/server.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/simulate.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/simulate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   averageResponseTime: () => (/* binding */ averageResponseTime),\n/* harmony export */   canBeUsed: () => (/* binding */ canBeUsed),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   microSeconds: () => (/* binding */ microSeconds),\n/* harmony export */   onMessage: () => (/* binding */ onMessage),\n/* harmony export */   postMessage: () => (/* binding */ postMessage),\n/* harmony export */   type: () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\nvar type = \"simulate\";\nvar SIMULATE_CHANNELS = new Set();\nfunction create(channelName) {\n    var state = {\n        name: channelName,\n        messagesCallback: null\n    };\n    SIMULATE_CHANNELS.add(state);\n    return state;\n}\nfunction close(channelState) {\n    SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nfunction postMessage(channelState, messageJson) {\n    return new Promise(function(res) {\n        return setTimeout(function() {\n            var channelArray = Array.from(SIMULATE_CHANNELS);\n            channelArray.filter(function(channel) {\n                return channel.name === channelState.name;\n            }).filter(function(channel) {\n                return channel !== channelState;\n            }).filter(function(channel) {\n                return !!channel.messagesCallback;\n            }).forEach(function(channel) {\n                return channel.messagesCallback(messageJson);\n            });\n            res();\n        }, 5);\n    });\n}\nfunction onMessage(channelState, fn) {\n    channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n    return true;\n}\nfunction averageResponseTime() {\n    return 5;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    create: create,\n    close: close,\n    onMessage: onMessage,\n    postMessage: postMessage,\n    canBeUsed: canBeUsed,\n    type: type,\n    averageResponseTime: averageResponseTime,\n    microSeconds: microSeconds\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9zaW11bGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ3pDLElBQUlBLGVBQWVDLCtDQUFLQSxDQUFDO0FBQ3pCLElBQUlDLE9BQU8sV0FBVztBQUM3QixJQUFJQyxvQkFBb0IsSUFBSUM7QUFDckIsU0FBU0MsT0FBT0MsV0FBVztJQUNoQyxJQUFJQyxRQUFRO1FBQ1ZDLE1BQU1GO1FBQ05HLGtCQUFrQjtJQUNwQjtJQUNBTixrQkFBa0JPLEdBQUcsQ0FBQ0g7SUFDdEIsT0FBT0E7QUFDVDtBQUNPLFNBQVNJLE1BQU1DLFlBQVk7SUFDaENULGlCQUFpQixDQUFDLFNBQVMsQ0FBQ1M7QUFDOUI7QUFDTyxTQUFTQyxZQUFZRCxZQUFZLEVBQUVFLFdBQVc7SUFDbkQsT0FBTyxJQUFJQyxRQUFRLFNBQVVDLEdBQUc7UUFDOUIsT0FBT0MsV0FBVztZQUNoQixJQUFJQyxlQUFlQyxNQUFNQyxJQUFJLENBQUNqQjtZQUM5QmUsYUFBYUcsTUFBTSxDQUFDLFNBQVVDLE9BQU87Z0JBQ25DLE9BQU9BLFFBQVFkLElBQUksS0FBS0ksYUFBYUosSUFBSTtZQUMzQyxHQUFHYSxNQUFNLENBQUMsU0FBVUMsT0FBTztnQkFDekIsT0FBT0EsWUFBWVY7WUFDckIsR0FBR1MsTUFBTSxDQUFDLFNBQVVDLE9BQU87Z0JBQ3pCLE9BQU8sQ0FBQyxDQUFDQSxRQUFRYixnQkFBZ0I7WUFDbkMsR0FBR2MsT0FBTyxDQUFDLFNBQVVELE9BQU87Z0JBQzFCLE9BQU9BLFFBQVFiLGdCQUFnQixDQUFDSztZQUNsQztZQUNBRTtRQUNGLEdBQUc7SUFDTDtBQUNGO0FBQ08sU0FBU1EsVUFBVVosWUFBWSxFQUFFYSxFQUFFO0lBQ3hDYixhQUFhSCxnQkFBZ0IsR0FBR2dCO0FBQ2xDO0FBQ08sU0FBU0M7SUFDZCxPQUFPO0FBQ1Q7QUFDTyxTQUFTQztJQUNkLE9BQU87QUFDVDtBQUNBLGlFQUFlO0lBQ2J0QixRQUFRQTtJQUNSTSxPQUFPQTtJQUNQYSxXQUFXQTtJQUNYWCxhQUFhQTtJQUNiYSxXQUFXQTtJQUNYeEIsTUFBTUE7SUFDTnlCLHFCQUFxQkE7SUFDckIzQixjQUFjQTtBQUNoQixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvbWV0aG9kcy9zaW11bGF0ZS5qcz81Yzk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1pY3JvU2Vjb25kcyBhcyBtaWNybyB9IGZyb20gJy4uL3V0aWwnO1xuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcbmV4cG9ydCB2YXIgdHlwZSA9ICdzaW11bGF0ZSc7XG52YXIgU0lNVUxBVEVfQ0hBTk5FTFMgPSBuZXcgU2V0KCk7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBuYW1lOiBjaGFubmVsTmFtZSxcbiAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsXG4gIH07XG4gIFNJTVVMQVRFX0NIQU5ORUxTLmFkZChzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgU0lNVUxBVEVfQ0hBTk5FTFNbXCJkZWxldGVcIl0oY2hhbm5lbFN0YXRlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoYW5uZWxBcnJheSA9IEFycmF5LmZyb20oU0lNVUxBVEVfQ0hBTk5FTFMpO1xuICAgICAgY2hhbm5lbEFycmF5LmZpbHRlcihmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbC5uYW1lID09PSBjaGFubmVsU3RhdGUubmFtZTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbCAhPT0gY2hhbm5lbFN0YXRlO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiAhIWNoYW5uZWwubWVzc2FnZXNDYWxsYmFjaztcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwubWVzc2FnZXNDYWxsYmFjayhtZXNzYWdlSnNvbik7XG4gICAgICB9KTtcbiAgICAgIHJlcygpO1xuICAgIH0sIDUpO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbkJlVXNlZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcbiAgcmV0dXJuIDU7XG59XG5leHBvcnQgZGVmYXVsdCB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjbG9zZTogY2xvc2UsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkLFxuICB0eXBlOiB0eXBlLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kc1xufTsiXSwibmFtZXMiOlsibWljcm9TZWNvbmRzIiwibWljcm8iLCJ0eXBlIiwiU0lNVUxBVEVfQ0hBTk5FTFMiLCJTZXQiLCJjcmVhdGUiLCJjaGFubmVsTmFtZSIsInN0YXRlIiwibmFtZSIsIm1lc3NhZ2VzQ2FsbGJhY2siLCJhZGQiLCJjbG9zZSIsImNoYW5uZWxTdGF0ZSIsInBvc3RNZXNzYWdlIiwibWVzc2FnZUpzb24iLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsImNoYW5uZWxBcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsImNoYW5uZWwiLCJmb3JFYWNoIiwib25NZXNzYWdlIiwiZm4iLCJjYW5CZVVzZWQiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/methods/simulate.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fillOptionsWithDefaults: () => (/* binding */ fillOptionsWithDefaults)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\");\n\nfunction fillOptionsWithDefaults() {\n    var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = JSON.parse(JSON.stringify(originalOptions));\n    if (typeof options.support3PC === \"undefined\") options.support3PC = (0,_util__WEBPACK_IMPORTED_MODULE_0__.are3PCSupported)();\n    // main\n    if (typeof options.webWorkerSupport === \"undefined\") options.webWorkerSupport = true;\n    // indexed-db\n    if (!options.idb) options.idb = {};\n    //  after this time the messages get deleted\n    if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n    //  handles abrupt db onclose events.\n    if (originalOptions.idb && typeof originalOptions.idb.onclose === \"function\") options.idb.onclose = originalOptions.idb.onclose;\n    // localstorage\n    if (!options.localstorage) options.localstorage = {};\n    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n    // server\n    if (!options.server) options.server = {};\n    if (!options.server.url) options.server.url = \"https://broadcast-server.tor.us\";\n    if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n    // custom methods\n    if (originalOptions.methods) options.methods = originalOptions.methods;\n    return options;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUNsQyxTQUFTQztJQUNkLElBQUlDLGtCQUFrQkMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUMzRixJQUFJRyxVQUFVQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ1A7SUFDeEMsSUFBSSxPQUFPSSxRQUFRSSxVQUFVLEtBQUssYUFBYUosUUFBUUksVUFBVSxHQUFHVixzREFBZUE7SUFFbkYsT0FBTztJQUNQLElBQUksT0FBT00sUUFBUUssZ0JBQWdCLEtBQUssYUFBYUwsUUFBUUssZ0JBQWdCLEdBQUc7SUFFaEYsYUFBYTtJQUNiLElBQUksQ0FBQ0wsUUFBUU0sR0FBRyxFQUFFTixRQUFRTSxHQUFHLEdBQUcsQ0FBQztJQUNqQyw0Q0FBNEM7SUFDNUMsSUFBSSxDQUFDTixRQUFRTSxHQUFHLENBQUNDLEdBQUcsRUFBRVAsUUFBUU0sR0FBRyxDQUFDQyxHQUFHLEdBQUcsT0FBTztJQUMvQyxJQUFJLENBQUNQLFFBQVFNLEdBQUcsQ0FBQ0UsZ0JBQWdCLEVBQUVSLFFBQVFNLEdBQUcsQ0FBQ0UsZ0JBQWdCLEdBQUc7SUFDbEUscUNBQXFDO0lBQ3JDLElBQUlaLGdCQUFnQlUsR0FBRyxJQUFJLE9BQU9WLGdCQUFnQlUsR0FBRyxDQUFDRyxPQUFPLEtBQUssWUFBWVQsUUFBUU0sR0FBRyxDQUFDRyxPQUFPLEdBQUdiLGdCQUFnQlUsR0FBRyxDQUFDRyxPQUFPO0lBRS9ILGVBQWU7SUFDZixJQUFJLENBQUNULFFBQVFVLFlBQVksRUFBRVYsUUFBUVUsWUFBWSxHQUFHLENBQUM7SUFDbkQsSUFBSSxDQUFDVixRQUFRVSxZQUFZLENBQUNDLGFBQWEsRUFBRVgsUUFBUVUsWUFBWSxDQUFDQyxhQUFhLEdBQUcsT0FBTztJQUVyRixTQUFTO0lBQ1QsSUFBSSxDQUFDWCxRQUFRWSxNQUFNLEVBQUVaLFFBQVFZLE1BQU0sR0FBRyxDQUFDO0lBQ3ZDLElBQUksQ0FBQ1osUUFBUVksTUFBTSxDQUFDQyxHQUFHLEVBQUViLFFBQVFZLE1BQU0sQ0FBQ0MsR0FBRyxHQUFHO0lBQzlDLElBQUksQ0FBQ2IsUUFBUVksTUFBTSxDQUFDRCxhQUFhLEVBQUVYLFFBQVFZLE1BQU0sQ0FBQ0QsYUFBYSxHQUFHLE9BQU8sS0FBSyxHQUFHLFlBQVk7SUFFN0YsaUJBQWlCO0lBQ2pCLElBQUlmLGdCQUFnQmtCLE9BQU8sRUFBRWQsUUFBUWMsT0FBTyxHQUFHbEIsZ0JBQWdCa0IsT0FBTztJQUN0RSxPQUFPZDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNub2RlL29wdGlvbnMuanM/YzZhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcmUzUENTdXBwb3J0ZWQgfSBmcm9tICcuL3V0aWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKCkge1xuICB2YXIgb3JpZ2luYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsT3B0aW9ucykpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuc3VwcG9ydDNQQyA9PT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuc3VwcG9ydDNQQyA9IGFyZTNQQ1N1cHBvcnRlZCgpO1xuXG4gIC8vIG1haW5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLndlYldvcmtlclN1cHBvcnQgPT09ICd1bmRlZmluZWQnKSBvcHRpb25zLndlYldvcmtlclN1cHBvcnQgPSB0cnVlO1xuXG4gIC8vIGluZGV4ZWQtZGJcbiAgaWYgKCFvcHRpb25zLmlkYikgb3B0aW9ucy5pZGIgPSB7fTtcbiAgLy8gIGFmdGVyIHRoaXMgdGltZSB0aGUgbWVzc2FnZXMgZ2V0IGRlbGV0ZWRcbiAgaWYgKCFvcHRpb25zLmlkYi50dGwpIG9wdGlvbnMuaWRiLnR0bCA9IDEwMDAgKiA0NTtcbiAgaWYgKCFvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsKSBvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsID0gMTUwO1xuICAvLyAgaGFuZGxlcyBhYnJ1cHQgZGIgb25jbG9zZSBldmVudHMuXG4gIGlmIChvcmlnaW5hbE9wdGlvbnMuaWRiICYmIHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuaWRiLm9uY2xvc2UgPT09ICdmdW5jdGlvbicpIG9wdGlvbnMuaWRiLm9uY2xvc2UgPSBvcmlnaW5hbE9wdGlvbnMuaWRiLm9uY2xvc2U7XG5cbiAgLy8gbG9jYWxzdG9yYWdlXG4gIGlmICghb3B0aW9ucy5sb2NhbHN0b3JhZ2UpIG9wdGlvbnMubG9jYWxzdG9yYWdlID0ge307XG4gIGlmICghb3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCkgb3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCA9IDEwMDAgKiA2MDtcblxuICAvLyBzZXJ2ZXJcbiAgaWYgKCFvcHRpb25zLnNlcnZlcikgb3B0aW9ucy5zZXJ2ZXIgPSB7fTtcbiAgaWYgKCFvcHRpb25zLnNlcnZlci51cmwpIG9wdGlvbnMuc2VydmVyLnVybCA9ICdodHRwczovL2Jyb2FkY2FzdC1zZXJ2ZXIudG9yLnVzJztcbiAgaWYgKCFvcHRpb25zLnNlcnZlci5yZW1vdmVUaW1lb3V0KSBvcHRpb25zLnNlcnZlci5yZW1vdmVUaW1lb3V0ID0gMTAwMCAqIDYwICogNTsgLy8gNSBtaW51dGVzXG5cbiAgLy8gY3VzdG9tIG1ldGhvZHNcbiAgaWYgKG9yaWdpbmFsT3B0aW9ucy5tZXRob2RzKSBvcHRpb25zLm1ldGhvZHMgPSBvcmlnaW5hbE9wdGlvbnMubWV0aG9kcztcbiAgcmV0dXJuIG9wdGlvbnM7XG59Il0sIm5hbWVzIjpbImFyZTNQQ1N1cHBvcnRlZCIsImZpbGxPcHRpb25zV2l0aERlZmF1bHRzIiwib3JpZ2luYWxPcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwib3B0aW9ucyIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInN1cHBvcnQzUEMiLCJ3ZWJXb3JrZXJTdXBwb3J0IiwiaWRiIiwidHRsIiwiZmFsbGJhY2tJbnRlcnZhbCIsIm9uY2xvc2UiLCJsb2NhbHN0b3JhZ2UiLCJyZW1vdmVUaW1lb3V0Iiwic2VydmVyIiwidXJsIiwibWV0aG9kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/options.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js":
/*!************************************************************************!*\
  !*** ../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROMISE_RESOLVED_FALSE: () => (/* binding */ PROMISE_RESOLVED_FALSE),\n/* harmony export */   PROMISE_RESOLVED_TRUE: () => (/* binding */ PROMISE_RESOLVED_TRUE),\n/* harmony export */   PROMISE_RESOLVED_VOID: () => (/* binding */ PROMISE_RESOLVED_VOID),\n/* harmony export */   are3PCSupported: () => (/* binding */ are3PCSupported),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   microSeconds: () => (/* binding */ microSeconds),\n/* harmony export */   randomInt: () => (/* binding */ randomInt),\n/* harmony export */   randomToken: () => (/* binding */ randomToken),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bowser */ \"(ssr)/../node_modules/bowser/src/bowser.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! loglevel */ \"(ssr)/../node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * returns true if the given object is a promise\n */ function isPromise(obj) {\n    if (obj && typeof obj.then === \"function\") {\n        return true;\n    } else {\n        return false;\n    }\n}\nvar PROMISE_RESOLVED_FALSE = Promise.resolve(false);\nvar PROMISE_RESOLVED_TRUE = Promise.resolve(true);\nvar PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n    if (!time) time = 0;\n    return new Promise(function(res) {\n        return setTimeout(function() {\n            return res(resolveWith);\n        }, time);\n    });\n}\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */ function randomToken() {\n    return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */ function microSeconds() {\n    var ms = new Date().getTime();\n    if (ms === lastMs) {\n        additional++;\n        return ms * 1000 + additional;\n    } else {\n        lastMs = ms;\n        additional = 0;\n        return ms * 1000;\n    }\n}\nfunction are3PCSupported() {\n    if (typeof navigator === \"undefined\") return false;\n    var browserInfo = bowser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(navigator.userAgent);\n    log.info(JSON.stringify(browserInfo), \"current browser info\");\n    var thirdPartyCookieSupport = true;\n    // brave\n    if (navigator.brave) {\n        thirdPartyCookieSupport = false;\n    }\n    // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n    // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n    if (browserInfo.engine.name === bowser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ENGINE_MAP.WebKit || browserInfo.engine.name === bowser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ENGINE_MAP.Gecko) {\n        thirdPartyCookieSupport = false;\n    }\n    return thirdPartyCookieSupport;\n}\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_1___default().getLogger(\"broadcast-channel\");\nlog.setLevel(\"error\");\nvar setLogLevel = function setLogLevel(level) {\n    log.setLevel(level);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNJO0FBRWhDOztDQUVDLEdBQ00sU0FBU0UsVUFBVUMsR0FBRztJQUMzQixJQUFJQSxPQUFPLE9BQU9BLElBQUlDLElBQUksS0FBSyxZQUFZO1FBQ3pDLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFDTyxJQUFJQyx5QkFBeUJDLFFBQVFDLE9BQU8sQ0FBQyxPQUFPO0FBQ3BELElBQUlDLHdCQUF3QkYsUUFBUUMsT0FBTyxDQUFDLE1BQU07QUFDbEQsSUFBSUUsd0JBQXdCSCxRQUFRQyxPQUFPLEdBQUc7QUFDOUMsU0FBU0csTUFBTUMsSUFBSSxFQUFFQyxXQUFXO0lBQ3JDLElBQUksQ0FBQ0QsTUFBTUEsT0FBTztJQUNsQixPQUFPLElBQUlMLFFBQVEsU0FBVU8sR0FBRztRQUM5QixPQUFPQyxXQUFXO1lBQ2hCLE9BQU9ELElBQUlEO1FBQ2IsR0FBR0Q7SUFDTDtBQUNGO0FBQ08sU0FBU0ksVUFBVUMsR0FBRyxFQUFFQyxHQUFHO0lBQ2hDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNSCxDQUFBQSxNQUFNRCxNQUFNLEtBQUtBO0FBQ3REO0FBRUE7O0NBRUMsR0FDTSxTQUFTSztJQUNkLE9BQU9ILEtBQUtFLE1BQU0sR0FBR0UsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQztBQUM5QztBQUNBLElBQUlDLFNBQVM7QUFDYixJQUFJQyxhQUFhO0FBRWpCOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSUMsS0FBSyxJQUFJQyxPQUFPQyxPQUFPO0lBQzNCLElBQUlGLE9BQU9ILFFBQVE7UUFDakJDO1FBQ0EsT0FBT0UsS0FBSyxPQUFPRjtJQUNyQixPQUFPO1FBQ0xELFNBQVNHO1FBQ1RGLGFBQWE7UUFDYixPQUFPRSxLQUFLO0lBQ2Q7QUFDRjtBQUNPLFNBQVNHO0lBQ2QsSUFBSSxPQUFPQyxjQUFjLGFBQWEsT0FBTztJQUM3QyxJQUFJQyxjQUFjaEMsOENBQU1BLENBQUNpQyxLQUFLLENBQUNGLFVBQVVHLFNBQVM7SUFDbERDLElBQUlDLElBQUksQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDTixjQUFjO0lBQ3RDLElBQUlPLDBCQUEwQjtJQUM5QixRQUFRO0lBQ1IsSUFBSVIsVUFBVVMsS0FBSyxFQUFFO1FBQ25CRCwwQkFBMEI7SUFDNUI7SUFDQSxpRkFBaUY7SUFDakYsK0VBQStFO0lBQy9FLElBQUlQLFlBQVlTLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLMUMsOENBQU1BLENBQUMyQyxVQUFVLENBQUNDLE1BQU0sSUFBSVosWUFBWVMsTUFBTSxDQUFDQyxJQUFJLEtBQUsxQyw4Q0FBTUEsQ0FBQzJDLFVBQVUsQ0FBQ0UsS0FBSyxFQUFFO1FBQy9HTiwwQkFBMEI7SUFDNUI7SUFDQSxPQUFPQTtBQUNUO0FBQ08sSUFBSUosTUFBTWxDLHlEQUFrQixDQUFDLHFCQUFxQjtBQUN6RGtDLElBQUlZLFFBQVEsQ0FBQztBQUNOLElBQUlDLGNBQWMsU0FBU0EsWUFBWUMsS0FBSztJQUNqRGQsSUFBSVksUUFBUSxDQUFDRTtBQUNmLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc25vZGUvdXRpbC5qcz82MThiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCb3dzZXIgZnJvbSAnYm93c2VyJztcbmltcG9ydCBsb2dsZXZlbCBmcm9tICdsb2dsZXZlbCc7XG5cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwcm9taXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfRkFMU0UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuZXhwb3J0IHZhciBQUk9NSVNFX1JFU09MVkVEX1RSVUUgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfVk9JRCA9IFByb21pc2UucmVzb2x2ZSgpO1xuZXhwb3J0IGZ1bmN0aW9uIHNsZWVwKHRpbWUsIHJlc29sdmVXaXRoKSB7XG4gIGlmICghdGltZSkgdGltZSA9IDA7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcyhyZXNvbHZlV2l0aCk7XG4gICAgfSwgdGltZSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA4NDI0OFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVG9rZW4oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG52YXIgbGFzdE1zID0gMDtcbnZhciBhZGRpdGlvbmFsID0gMDtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbWljcm8tc2Vjb25kcyxcbiAqIFdBUk5JTkc6IFRoaXMgaXMgYSBwc2V1ZG8tZnVuY3Rpb25cbiAqIFBlcmZvcm1hbmNlLm5vdyBpcyBub3QgcmVsaWFibGUgaW4gd2Vid29ya2Vycywgc28gd2UganVzdCBtYWtlIHN1cmUgdG8gbmV2ZXIgcmV0dXJuIHRoZSBzYW1lIHRpbWUuXG4gKiBUaGlzIGlzIGVub3VnaCBpbiBicm93c2VycywgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgYmUgdXNlZCBpbiBub2RlanMuXG4gKiBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXMgaGFjayBpcyB0byBlbnN1cmUgdGhhdCBCcm9hZGNhc3RDaGFubmVsIGJlaGF2ZXMgZXF1YWwgdG8gcHJvZHVjdGlvbiB3aGVuIGl0IGlzIHVzZWQgaW4gZmFzdC1ydW5uaW5nIHVuaXQgdGVzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaWNyb1NlY29uZHMoKSB7XG4gIHZhciBtcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAobXMgPT09IGxhc3RNcykge1xuICAgIGFkZGl0aW9uYWwrKztcbiAgICByZXR1cm4gbXMgKiAxMDAwICsgYWRkaXRpb25hbDtcbiAgfSBlbHNlIHtcbiAgICBsYXN0TXMgPSBtcztcbiAgICBhZGRpdGlvbmFsID0gMDtcbiAgICByZXR1cm4gbXMgKiAxMDAwO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXJlM1BDU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIGJyb3dzZXJJbmZvID0gQm93c2VyLnBhcnNlKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBsb2cuaW5mbyhKU09OLnN0cmluZ2lmeShicm93c2VySW5mbyksICdjdXJyZW50IGJyb3dzZXIgaW5mbycpO1xuICB2YXIgdGhpcmRQYXJ0eUNvb2tpZVN1cHBvcnQgPSB0cnVlO1xuICAvLyBicmF2ZVxuICBpZiAobmF2aWdhdG9yLmJyYXZlKSB7XG4gICAgdGhpcmRQYXJ0eUNvb2tpZVN1cHBvcnQgPSBmYWxzZTtcbiAgfVxuICAvLyBBbGwgd2Via2l0ICYgZ2Vja28gZW5naW5lIGluc3RhbmNlcyB1c2UgaXRwIChpbnRlbGxpZ2VudCB0cmFja2luZyBwcmV2ZW50aW9uIC1cbiAgLy8gaHR0cHM6Ly93ZWJraXQub3JnL3RyYWNraW5nLXByZXZlbnRpb24vI2ludGVsbGlnZW50LXRyYWNraW5nLXByZXZlbnRpb24taXRwKVxuICBpZiAoYnJvd3NlckluZm8uZW5naW5lLm5hbWUgPT09IEJvd3Nlci5FTkdJTkVfTUFQLldlYktpdCB8fCBicm93c2VySW5mby5lbmdpbmUubmFtZSA9PT0gQm93c2VyLkVOR0lORV9NQVAuR2Vja28pIHtcbiAgICB0aGlyZFBhcnR5Q29va2llU3VwcG9ydCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB0aGlyZFBhcnR5Q29va2llU3VwcG9ydDtcbn1cbmV4cG9ydCB2YXIgbG9nID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKCdicm9hZGNhc3QtY2hhbm5lbCcpO1xubG9nLnNldExldmVsKCdlcnJvcicpO1xuZXhwb3J0IHZhciBzZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIGxvZy5zZXRMZXZlbChsZXZlbCk7XG59OyJdLCJuYW1lcyI6WyJCb3dzZXIiLCJsb2dsZXZlbCIsImlzUHJvbWlzZSIsIm9iaiIsInRoZW4iLCJQUk9NSVNFX1JFU09MVkVEX0ZBTFNFIiwiUHJvbWlzZSIsInJlc29sdmUiLCJQUk9NSVNFX1JFU09MVkVEX1RSVUUiLCJQUk9NSVNFX1JFU09MVkVEX1ZPSUQiLCJzbGVlcCIsInRpbWUiLCJyZXNvbHZlV2l0aCIsInJlcyIsInNldFRpbWVvdXQiLCJyYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJyYW5kb21Ub2tlbiIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwibGFzdE1zIiwiYWRkaXRpb25hbCIsIm1pY3JvU2Vjb25kcyIsIm1zIiwiRGF0ZSIsImdldFRpbWUiLCJhcmUzUENTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJicm93c2VySW5mbyIsInBhcnNlIiwidXNlckFnZW50IiwibG9nIiwiaW5mbyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0aGlyZFBhcnR5Q29va2llU3VwcG9ydCIsImJyYXZlIiwiZW5naW5lIiwibmFtZSIsIkVOR0lORV9NQVAiLCJXZWJLaXQiLCJHZWNrbyIsImdldExvZ2dlciIsInNldExldmVsIiwic2V0TG9nTGV2ZWwiLCJsZXZlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/broadcast-channel/dist/esnode/util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/eccrypto/dist/browser.js":
/*!***********************************************************!*\
  !*** ../node_modules/@toruslabs/eccrypto/dist/browser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst EC = (__webpack_require__(/*! elliptic */ \"(ssr)/../node_modules/elliptic/lib/elliptic.js\").ec);\nconst ec = new EC(\"secp256k1\");\nconst browserCrypto = global.crypto || global.msCrypto || {};\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nfunction isScalar(x) {\n    return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n    if (!isScalar(privateKey)) {\n        return false;\n    }\n    return privateKey.compare(ZERO32) > 0 && // > 0\n    privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for(let i = 0; i < b1.length; i++){\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */ function randomBytes(size) {\n    const arr = new Uint8Array(size);\n    if (typeof browserCrypto.getRandomValues === \"undefined\") {\n        return Buffer.from(nodeCrypto.randomBytes(size));\n    } else {\n        browserCrypto.getRandomValues(arr);\n    }\n    return Buffer.from(arr);\n}\nasync function sha512(msg) {\n    if (subtle) {\n        const hash = await subtle.digest(\"SHA-512\", msg);\n        const result = new Uint8Array(hash);\n        return result;\n    }\n    const hash = nodeCrypto.createHash(\"sha512\");\n    const result = hash.update(msg).digest();\n    return new Uint8Array(result);\n}\nfunction getAes(op) {\n    return async function(iv, key, data) {\n        if (subtle) {\n            const importAlgorithm = {\n                name: \"AES-CBC\"\n            };\n            const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [\n                op\n            ]);\n            const encAlgorithm = {\n                name: \"AES-CBC\",\n                iv: iv\n            };\n            const result = await subtle[op](encAlgorithm, cryptoKey, data);\n            return Buffer.from(new Uint8Array(result));\n        } else if (op === \"encrypt\") {\n            const cipher = nodeCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n            let firstChunk = cipher.update(data);\n            let secondChunk = cipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        } else if (op === \"decrypt\") {\n            const decipher = nodeCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n            let firstChunk = decipher.update(data);\n            let secondChunk = decipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        }\n    };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n    if (subtle) {\n        const importAlgorithm = {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\n            \"sign\",\n            \"verify\"\n        ]);\n        const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n        const result = Buffer.from(new Uint8Array(sig));\n        return result;\n    }\n    const hmac = nodeCrypto.createHmac(\"sha256\", Buffer.from(key));\n    hmac.update(msg);\n    const result = hmac.digest();\n    return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n    const expectedSig = await hmacSha256Sign(key, msg);\n    return equalConstTime(expectedSig, sig);\n}\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n * @return {Buffer} A 32-byte private key.\n * @function\n */ exports.generatePrivate = function() {\n    let privateKey = randomBytes(32);\n    while(!isValidPrivateKey(privateKey)){\n        privateKey = randomBytes(32);\n    }\n    return privateKey;\n};\nconst getPublic = exports.getPublic = function(privateKey) {\n    // This function has sync API so we throw an error immediately.\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // XXX(Kagami): `elliptic.utils.encode` returns array for every\n    // encoding except `hex`.\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n/**\n * Get compressed version of public key.\n */ exports.getPublicCompressed = function(privateKey) {\n    // jshint ignore:line\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // See https://github.com/wanderer/secp256k1-node/issues/46\n    let compressed = true;\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = async function(privateKey, msg) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    return Buffer.from(ec.sign(msg, privateKey, {\n        canonical: true\n    }).toDER());\n};\nexports.verify = async function(publicKey, msg, sig) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65) {\n        assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33) {\n        assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n        return null;\n    } else {\n        throw new Error(\"Bad signature\");\n    }\n};\nconst deriveUnpadded = exports.derive = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toArray());\n};\nconst derivePadded = exports.derivePadded = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nexports.encrypt = async function(publicKeyTo, msg, opts) {\n    opts = opts || {};\n    // Tmp variables to save context from flat promises;\n    let iv, ephemPublicKey, ciphertext, macKey;\n    let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey)){\n        ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n    const hash = await sha512(Px);\n    iv = opts.iv || randomBytes(16);\n    const encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    const data = await aesCbcEncrypt(iv, encryptionKey, msg);\n    ciphertext = data;\n    const dataToMac = Buffer.concat([\n        iv,\n        ephemPublicKey,\n        ciphertext\n    ]);\n    const mac = await hmacSha256Sign(macKey, dataToMac);\n    return {\n        iv: iv,\n        ephemPublicKey: ephemPublicKey,\n        ciphertext: ciphertext,\n        mac: mac\n    };\n};\nconst decrypt = async function(privateKey, opts) {\n    let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // Tmp variable to save context from flat promises;\n    let encryptionKey;\n    const derive = padding ? derivePadded : deriveUnpadded;\n    const Px = await derive(privateKey, opts.ephemPublicKey);\n    const hash = await sha512(Px);\n    encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const dataToMac = Buffer.concat([\n        opts.iv,\n        opts.ephemPublicKey,\n        opts.ciphertext\n    ]);\n    const macGood = await hmacSha256Verify(macKey, dataToMac, opts.mac);\n    if (!macGood && padding === false) {\n        return decrypt(privateKey, opts, true);\n    } else if (!macGood && padding === true) {\n        throw new Error(\"bad MAC after trying padded\");\n    }\n    const msg = await aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n    return Buffer.from(new Uint8Array(msg));\n};\nexports.decrypt = decrypt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvZWNjcnlwdG8vZGlzdC9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsS0FBS0MsMEZBQXNCO0FBQ2pDLE1BQU1DLEtBQUssSUFBSUYsR0FBRztBQUNsQixNQUFNRyxnQkFBZ0JDLE9BQU9DLE1BQU0sSUFBSUQsT0FBT0UsUUFBUSxJQUFJLENBQUM7QUFDM0QsTUFBTUMsU0FBU0osY0FBY0ksTUFBTSxJQUFJSixjQUFjSyxZQUFZO0FBQ2pFLE1BQU1DLGFBQWFSLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ25DLE1BQU1TLGlCQUFpQkMsT0FBT0MsSUFBSSxDQUFDLG9FQUFvRTtBQUN2RyxNQUFNQyxTQUFTRixPQUFPRyxLQUFLLENBQUMsSUFBSTtBQUNoQyxTQUFTQyxPQUFPQyxTQUFTLEVBQUVDLE9BQU87SUFDaEMsSUFBSSxDQUFDRCxXQUFXO1FBQ2QsTUFBTSxJQUFJRSxNQUFNRCxXQUFXO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTRSxTQUFTQyxDQUFDO0lBQ2pCLE9BQU9ULE9BQU9VLFFBQVEsQ0FBQ0QsTUFBTUEsRUFBRUUsTUFBTSxLQUFLO0FBQzVDO0FBQ0EsU0FBU0Msa0JBQWtCQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0wsU0FBU0ssYUFBYTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxXQUFXQyxPQUFPLENBQUNaLFVBQVUsS0FDcEMsTUFBTTtJQUNOVyxXQUFXQyxPQUFPLENBQUNmLGtCQUFrQixHQUFHLE1BQU07QUFDaEQ7QUFFQSxrRUFBa0U7QUFDbEUsU0FBU2dCLGVBQWVDLEVBQUUsRUFBRUMsRUFBRTtJQUM1QixJQUFJRCxHQUFHTCxNQUFNLEtBQUtNLEdBQUdOLE1BQU0sRUFBRTtRQUMzQixPQUFPO0lBQ1Q7SUFDQSxJQUFJTyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEdBQUdMLE1BQU0sRUFBRVEsSUFBSztRQUNsQ0QsT0FBT0YsRUFBRSxD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O0lBQ3hDLE1BQU1PLEtBQUssTUFBTU4sT0FBT3pELFlBQVlxRSxLQUFLQyxjQUFjO0lBQ3ZELE1BQU14RCxPQUFPLE1BQU1GLE9BQU9tRDtJQUMxQlcsZ0JBQWdCNUQsS0FBSzZELEtBQUssQ0FBQyxHQUFHO0lBQzlCLE1BQU1ILFNBQVMxRCxLQUFLNkQsS0FBSyxDQUFDO0lBQzFCLE1BQU1DLFlBQVl6RixPQUFPK0MsTUFBTSxDQUFDO1FBQUNtQyxLQUFLaEQsRUFBRTtRQUFFZ0QsS0FBS0MsY0FBYztRQUFFRCxLQUFLRSxVQUFVO0tBQUM7SUFDL0UsTUFBTVcsVUFBVSxNQUFNdEMsaUJBQWlCNEIsUUFBUUksV0FBV1AsS0FBS1EsR0FBRztJQUNsRSxJQUFJLENBQUNLLFdBQVdILFlBQVksT0FBTztRQUNqQyxPQUFPRCxRQUFROUUsWUFBWXFFLE1BQU07SUFDbkMsT0FBTyxJQUFJLENBQUNhLFdBQVdILFlBQVksTUFBTTtRQUN2QyxNQUFNLElBQUlyRixNQUFNO0lBQ2xCO0lBQ0EsTUFBTW1CLE1BQU0sTUFBTXlCLGNBQWMrQixLQUFLaEQsRUFBRSxFQUFFcUQsZUFBZUwsS0FBS0UsVUFBVTtJQUN2RSxPQUFPcEYsT0FBT0MsSUFBSSxDQUFDLElBQUlzQixXQUFXRztBQUNwQztBQUNBaUMsZUFBZSxHQUFHZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvZWNjcnlwdG8vZGlzdC9icm93c2VyLmpzPzJlMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IEVDID0gcmVxdWlyZShcImVsbGlwdGljXCIpLmVjO1xuY29uc3QgZWMgPSBuZXcgRUMoXCJzZWNwMjU2azFcIik7XG5jb25zdCBicm93c2VyQ3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8gfHwge307XG5jb25zdCBzdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbmNvbnN0IG5vZGVDcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgRUNfR1JPVVBfT1JERVIgPSBCdWZmZXIuZnJvbShcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIiwgXCJoZXhcIik7XG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTY2FsYXIoeCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFpc1NjYWxhcihwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleS5jb21wYXJlKFpFUk8zMikgPiAwICYmXG4gIC8vID4gMFxuICBwcml2YXRlS2V5LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMDsgLy8gPCBHXG59XG5cbi8vIENvbXBhcmUgdHdvIGJ1ZmZlcnMgaW4gY29uc3RhbnQgdGltZSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzLlxuZnVuY3Rpb24gZXF1YWxDb25zdFRpbWUoYjEsIGIyKSB7XG4gIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIHJlcyB8PSBiMVtpXSBeIGIyW2ldOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfVxuXG4gIHJldHVybiByZXMgPT09IDA7XG59XG5cbi8qIFRoaXMgbXVzdCBjaGVjayBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlciBvclxubm90LCBzaW5jZSB0aGUgZnVuY3Rpb25zIGFyZSBkaWZmZXJlbnQgYW5kIGRvZXNcbm5vdCBjb252ZXJ0IHVzaW5nIGJyb3dzZXJpZnkgKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIGlmICh0eXBlb2YgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obm9kZUNyeXB0by5yYW5kb21CeXRlcyhzaXplKSk7XG4gIH0gZWxzZSB7XG4gICAgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNoYTUxMihtc2cpIHtcbiAgaWYgKHN1YnRsZSkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaGFzaCA9IG5vZGVDcnlwdG8uY3JlYXRlSGFzaChcInNoYTUxMlwiKTtcbiAgY29uc3QgcmVzdWx0ID0gaGFzaC51cGRhdGUobXNnKS5kaWdlc3QoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXRBZXMob3ApIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdiwga2V5LCBkYXRhKSB7XG4gICAgaWYgKHN1YnRsZSkge1xuICAgICAgY29uc3QgaW1wb3J0QWxnb3JpdGhtID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIlxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBpbXBvcnRBbGdvcml0aG0sIGZhbHNlLCBbb3BdKTtcbiAgICAgIGNvbnN0IGVuY0FsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICAgIGl2OiBpdlxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1YnRsZVtvcF0oZW5jQWxnb3JpdGhtLCBjcnlwdG9LZXksIGRhdGEpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZW5jcnlwdFwiKSB7XG4gICAgICBjb25zdCBjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBpdik7XG4gICAgICBsZXQgZmlyc3RDaHVuayA9IGNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBsZXQgc2Vjb25kQ2h1bmsgPSBjaXBoZXIuZmluYWwoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdENodW5rLCBzZWNvbmRDaHVua10pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZGVjcnlwdFwiKSB7XG4gICAgICBjb25zdCBkZWNpcGhlciA9IG5vZGVDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtY2JjXCIsIGtleSwgaXYpO1xuICAgICAgbGV0IGZpcnN0Q2h1bmsgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBsZXQgc2Vjb25kQ2h1bmsgPSBkZWNpcGhlci5maW5hbCgpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2ZpcnN0Q2h1bmssIHNlY29uZENodW5rXSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgYWVzQ2JjRW5jcnlwdCA9IGdldEFlcyhcImVuY3J5cHRcIik7XG5jb25zdCBhZXNDYmNEZWNyeXB0ID0gZ2V0QWVzKFwiZGVjcnlwdFwiKTtcbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTZTaWduKGtleSwgbXNnKSB7XG4gIGlmIChzdWJ0bGUpIHtcbiAgICBjb25zdCBpbXBvcnRBbGdvcml0aG0gPSB7XG4gICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogXCJTSEEtMjU2XCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgbmV3IFVpbnQ4QXJyYXkoa2V5KSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSk7XG4gICAgY29uc3Qgc2lnID0gYXdhaXQgc3VidGxlLnNpZ24oXCJITUFDXCIsIGNyeXB0b0tleSwgbXNnKTtcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzaWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGhtYWMgPSBub2RlQ3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgQnVmZmVyLmZyb20oa2V5KSk7XG4gIGhtYWMudXBkYXRlKG1zZyk7XG4gIGNvbnN0IHJlc3VsdCA9IGhtYWMuZGlnZXN0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBobWFjU2hhMjU2VmVyaWZ5KGtleSwgbXNnLCBzaWcpIHtcbiAgY29uc3QgZXhwZWN0ZWRTaWcgPSBhd2FpdCBobWFjU2hhMjU2U2lnbihrZXksIG1zZyk7XG4gIHJldHVybiBlcXVhbENvbnN0VGltZShleHBlY3RlZFNpZywgc2lnKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyB2YWxpZCBwcml2YXRlIGtleS4gV2lsbCB1c2UgdGhlIHdpbmRvdy5jcnlwdG8gb3Igd2luZG93Lm1zQ3J5cHRvIGFzIHNvdXJjZVxuICogZGVwZW5kaW5nIG9uIHlvdXIgYnJvd3Nlci5cbiAqIEByZXR1cm4ge0J1ZmZlcn0gQSAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVQcml2YXRlID0gZnVuY3Rpb24gKCkge1xuICBsZXQgcHJpdmF0ZUtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgd2hpbGUgKCFpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSkge1xuICAgIHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gIH1cbiAgcmV0dXJuIHByaXZhdGVLZXk7XG59O1xuY29uc3QgZ2V0UHVibGljID0gZXhwb3J0cy5nZXRQdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBzeW5jIEFQSSBzbyB3ZSB0aHJvdyBhbiBlcnJvciBpbW1lZGlhdGVseS5cbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIC8vIFhYWChLYWdhbWkpOiBgZWxsaXB0aWMudXRpbHMuZW5jb2RlYCByZXR1cm5zIGFycmF5IGZvciBldmVyeVxuICAvLyBlbmNvZGluZyBleGNlcHQgYGhleGAuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoXCJhcnJcIikpO1xufTtcblxuLyoqXG4gKiBHZXQgY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydHMuZ2V0UHVibGljQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93YW5kZXJlci9zZWNwMjU2azEtbm9kZS9pc3N1ZXMvNDZcbiAgbGV0IGNvbXByZXNzZWQgPSB0cnVlO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKGNvbXByZXNzZWQsIFwiYXJyXCIpKTtcbn07XG5cbi8vIE5PVEUoS2FnYW1pKTogV2UgZG9uJ3QgdXNlIHByb21pc2Ugc2hpbSBpbiBCcm93c2VyIGltcGxlbWVudGF0aW9uXG4vLyBiZWNhdXNlIGl0J3Mgc3VwcG9ydGVkIG5hdGl2ZWx5IGluIG5ldyBicm93c2VycyAoc2VlXG4vLyA8aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PXByb21pc2VzPikgYW5kIHdlIGNhbiB1c2Ugb25seSBuZXcgYnJvd3NlcnNcbi8vIGJlY2F1c2Ugb2YgdGhlIFdlYkNyeXB0b0FQSSAoc2VlXG4vLyA8aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWNyeXB0b2dyYXBoeT4pLlxuZXhwb3J0cy5zaWduID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZykge1xuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPiAwLCBcIk1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPD0gMzIsIFwiTWVzc2FnZSBpcyB0b28gbG9uZ1wiKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLnNpZ24obXNnLCBwcml2YXRlS2V5LCB7XG4gICAgY2Fub25pY2FsOiB0cnVlXG4gIH0pLnRvREVSKCkpO1xufTtcbmV4cG9ydHMudmVyaWZ5ID0gYXN5bmMgZnVuY3Rpb24gKHB1YmxpY0tleSwgbXNnLCBzaWcpIHtcbiAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleS5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5WzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlbMF0gPT09IDIgfHwgcHVibGljS2V5WzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGFzc2VydChtc2cubGVuZ3RoID4gMCwgXCJNZXNzYWdlIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoIDw9IDMyLCBcIk1lc3NhZ2UgaXMgdG9vIGxvbmdcIik7XG4gIGlmIChlYy52ZXJpZnkobXNnLCBzaWcsIHB1YmxpY0tleSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc2lnbmF0dXJlXCIpO1xuICB9XG59O1xuY29uc3QgZGVyaXZlVW5wYWRkZWQgPSBleHBvcnRzLmRlcml2ZSA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSAyIHx8IHB1YmxpY0tleUJbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5QSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlBKTtcbiAgY29uc3Qga2V5QiA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5Qik7XG4gIGNvbnN0IFB4ID0ga2V5QS5kZXJpdmUoa2V5Qi5nZXRQdWJsaWMoKSk7IC8vIEJOIGluc3RhbmNlXG4gIHJldHVybiBCdWZmZXIuZnJvbShQeC50b0FycmF5KCkpO1xufTtcbmNvbnN0IGRlcml2ZVBhZGRlZCA9IGV4cG9ydHMuZGVyaXZlUGFkZGVkID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXlBLCBwdWJsaWNLZXlCKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCKSwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgYXNzZXJ0KHByaXZhdGVLZXlBLmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDIgfHwgcHVibGljS2V5QlswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlBID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUEpO1xuICBjb25zdCBrZXlCID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlCKTtcbiAgY29uc3QgUHggPSBrZXlBLmRlcml2ZShrZXlCLmdldFB1YmxpYygpKTsgLy8gQk4gaW5zdGFuY2VcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFB4LnRvU3RyaW5nKDE2LCA2NCksIFwiaGV4XCIpO1xufTtcbmV4cG9ydHMuZW5jcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwdWJsaWNLZXlUbywgbXNnLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvLyBUbXAgdmFyaWFibGVzIHRvIHNhdmUgY29udGV4dCBmcm9tIGZsYXQgcHJvbWlzZXM7XG4gIGxldCBpdiwgZXBoZW1QdWJsaWNLZXksIGNpcGhlcnRleHQsIG1hY0tleTtcbiAgbGV0IGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgLy8gVGhlcmUgaXMgYSB2ZXJ5IHVubGlrZWx5IHBvc3NpYmlsaXR5IHRoYXQgaXQgaXMgbm90IGEgdmFsaWQga2V5XG4gIHdoaWxlICghaXNWYWxpZFByaXZhdGVLZXkoZXBoZW1Qcml2YXRlS2V5KSkge1xuICAgIGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICBlcGhlbVB1YmxpY0tleSA9IGdldFB1YmxpYyhlcGhlbVByaXZhdGVLZXkpO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZVVucGFkZGVkKGVwaGVtUHJpdmF0ZUtleSwgcHVibGljS2V5VG8pO1xuICBjb25zdCBoYXNoID0gYXdhaXQgc2hhNTEyKFB4KTtcbiAgaXYgPSBvcHRzLml2IHx8IHJhbmRvbUJ5dGVzKDE2KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IGhhc2guc2xpY2UoMCwgMzIpO1xuICBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGFlc0NiY0VuY3J5cHQoaXYsIGVuY3J5cHRpb25LZXksIG1zZyk7XG4gIGNpcGhlcnRleHQgPSBkYXRhO1xuICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtpdiwgZXBoZW1QdWJsaWNLZXksIGNpcGhlcnRleHRdKTtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24obWFjS2V5LCBkYXRhVG9NYWMpO1xuICByZXR1cm4ge1xuICAgIGl2OiBpdixcbiAgICBlcGhlbVB1YmxpY0tleTogZXBoZW1QdWJsaWNLZXksXG4gICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcbiAgICBtYWM6IG1hY1xuICB9O1xufTtcbmNvbnN0IGRlY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleSwgb3B0cykge1xuICBsZXQgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIC8vIFRtcCB2YXJpYWJsZSB0byBzYXZlIGNvbnRleHQgZnJvbSBmbGF0IHByb21pc2VzO1xuICBsZXQgZW5jcnlwdGlvbktleTtcbiAgY29uc3QgZGVyaXZlID0gcGFkZGluZyA/IGRlcml2ZVBhZGRlZCA6IGRlcml2ZVVucGFkZGVkO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZShwcml2YXRlS2V5LCBvcHRzLmVwaGVtUHVibGljS2V5KTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IHNoYTUxMihQeCk7XG4gIGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgY29uc3QgbWFjS2V5ID0gaGFzaC5zbGljZSgzMik7XG4gIGNvbnN0IGRhdGFUb01hYyA9IEJ1ZmZlci5jb25jYXQoW29wdHMuaXYsIG9wdHMuZXBoZW1QdWJsaWNLZXksIG9wdHMuY2lwaGVydGV4dF0pO1xuICBjb25zdCBtYWNHb29kID0gYXdhaXQgaG1hY1NoYTI1NlZlcmlmeShtYWNLZXksIGRhdGFUb01hYywgb3B0cy5tYWMpO1xuICBpZiAoIW1hY0dvb2QgJiYgcGFkZGluZyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZGVjcnlwdChwcml2YXRlS2V5LCBvcHRzLCB0cnVlKTtcbiAgfSBlbHNlIGlmICghbWFjR29vZCAmJiBwYWRkaW5nID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIE1BQyBhZnRlciB0cnlpbmcgcGFkZGVkXCIpO1xuICB9XG4gIGNvbnN0IG1zZyA9IGF3YWl0IGFlc0NiY0RlY3J5cHQob3B0cy5pdiwgZW5jcnlwdGlvbktleSwgb3B0cy5jaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KG1zZykpO1xufTtcbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7Il0sIm5hbWVzIjpbIkVDIiwicmVxdWlyZSIsImVjIiwiYnJvd3NlckNyeXB0byIsImdsb2JhbCIsImNyeXB0byIsIm1zQ3J5cHRvIiwic3VidGxlIiwid2Via2l0U3VidGxlIiwibm9kZUNyeXB0byIsIkVDX0dST1VQX09SREVSIiwiQnVmZmVyIiwiZnJvbSIsIlpFUk8zMiIsImFsbG9jIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaXNTY2FsYXIiLCJ4IiwiaXNCdWZmZXIiLCJsZW5ndGgiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJjb21wYXJlIiwiZXF1YWxDb25zdFRpbWUiLCJiMSIsImIyIiwicmVzIiwiaSIsInJhbmRvbUJ5dGVzIiwic2l6ZSIsImFyciIsIlVpbnQ4QXJyYXkiLCJnZXRSYW5kb21WYWx1ZXMiLCJzaGE1MTIiLCJtc2ciLCJoYXNoIiwiZGlnZXN0IiwicmVzdWx0IiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImdldEFlcyIsIm9wIiwiaXYiLCJrZXkiLCJkYXRhIiwiaW1wb3J0QWxnb3JpdGhtIiwibmFtZSIsImNyeXB0b0tleSIsImltcG9ydEtleSIsImVuY0FsZ29yaXRobSIsImNpcGhlciIsImNyZWF0ZUNpcGhlcml2IiwiZmlyc3RDaHVuayIsInNlY29uZENodW5rIiwiZmluYWwiLCJjb25jYXQiLCJkZWNpcGhlciIsImNyZWF0ZURlY2lwaGVyaXYiLCJhZXNDYmNFbmNyeXB0IiwiYWVzQ2JjRGVjcnlwdCIsImhtYWNTaGEyNTZTaWduIiwic2lnIiwic2lnbiIsImhtYWMiLCJjcmVhdGVIbWFjIiwiaG1hY1NoYTI1NlZlcmlmeSIsImV4cGVjdGVkU2lnIiwiZXhwb3J0cyIsImdlbmVyYXRlUHJpdmF0ZSIsImdldFB1YmxpYyIsImtleUZyb21Qcml2YXRlIiwiZ2V0UHVibGljQ29tcHJlc3NlZCIsImNvbXByZXNzZWQiLCJjYW5vbmljYWwiLCJ0b0RFUiIsInZlcmlmeSIsInB1YmxpY0tleSIsImRlcml2ZVVucGFkZGVkIiwiZGVyaXZlIiwicHJpdmF0ZUtleUEiLCJwdWJsaWNLZXlCIiwia2V5QSIsImtleUIiLCJrZXlGcm9tUHVibGljIiwiUHgiLCJ0b0FycmF5IiwiZGVyaXZlUGFkZGVkIiwidG9TdHJpbmciLCJlbmNyeXB0IiwicHVibGljS2V5VG8iLCJvcHRzIiwiZXBoZW1QdWJsaWNLZXkiLCJjaXBoZXJ0ZXh0IiwibWFjS2V5IiwiZXBoZW1Qcml2YXRlS2V5IiwiZW5jcnlwdGlvbktleSIsInNsaWNlIiwiZGF0YVRvTWFjIiwibWFjIiwiZGVjcnlwdCIsInBhZGRpbmciLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJtYWNHb29kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/eccrypto/dist/browser.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/../node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/../node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n    sentry = _sentry;\n    tracingOrigins.push(..._tracingOrigins);\n    tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n    embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n    embedHost = \"\";\n}\nfunction getEmbedHost() {\n    return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n    apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n    apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n    return apiKey;\n}\n// #endregion\nfunction setLogLevel(level) {\n    log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n    let _url = null;\n    try {\n        _url = new URL(url);\n    } catch (error) {}\n    if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n        const transaction = sentry.startTransaction({\n            name: url\n        });\n        const span = transaction.startChild({\n            op: \"http\"\n        }); // This function returns a Span\n        const response = await fetch(url, init);\n        span.finish(); // Remember that only finished spans will be sent with the transaction\n        transaction.finish(); // Finishing the transaction will send it to Sentry\n        return response;\n    }\n    return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n    const headers = {};\n    if (apiKey) headers[gatewayAuthHeader] = apiKey;\n    if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n    return headers;\n}\nfunction debugLogResponse(response) {\n    log.info(`Response: ${response.status} ${response.statusText}`);\n    log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n    log.info(`Request tracing with traceID=${response.headers.get(\"x-web3-correlation-id\")}`);\n}\nconst promiseTimeout = (ms, promise)=>{\n    const timeout = new Promise((resolve, reject)=>{\n        const id = setTimeout(()=>{\n            clearTimeout(id);\n            reject(new Error(`Timed out in ${ms}ms`));\n        }, ms);\n    });\n    return Promise.race([\n        promise,\n        timeout\n    ]);\n};\nconst get = async function(url) {\n    let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {}\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"GET\"\n    });\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        return response.json();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst post = function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"POST\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then((response)=>{\n        if (customOptions.logTracingHeader) {\n            logTracingHeader(response);\n        }\n        if (response.ok) {\n            return response.json();\n        }\n        debugLogResponse(response);\n        throw response;\n    }));\n};\nconst patch = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PATCH\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        return response.json();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst put = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PUT\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        return response.json();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst remove = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"DELETE\"\n    });\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        return response.json();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst generateJsonRPCObject = (method, parameters)=>({\n        jsonrpc: \"2.0\",\n        method,\n        id: 10,\n        params: parameters\n    });\nconst promiseRace = function(url, options) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n    return Promise.race([\n        get(url, options),\n        new Promise((resolve, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(\"timed out\"));\n            }, timeout);\n        })\n    ]);\n};\n //# sourceMappingURL=httpHelpers.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzL2Rpc3QvaHR0cEhlbHBlcnMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNuQztBQUNXO0FBRTVDLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0Y7SUFBUyxJQUFJRyxPQUFPQyxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVGLE9BQU9DLHFCQUFxQixDQUFDSjtRQUFTQyxrQkFBbUJJLENBQUFBLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO1lBQUksT0FBT0osT0FBT0ssd0JBQXdCLENBQUNSLFFBQVFPLEtBQUtFLFVBQVU7UUFBRSxFQUFDLEdBQUlQLEtBQUtRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNRztJQUFVO0lBQUUsT0FBT0g7QUFBTTtBQUNwVixTQUFTVSxjQUFjQyxNQUFNO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztRQUFFLElBQUlHLFNBQVMsUUFBUUYsU0FBUyxDQUFDRCxFQUFFLEdBQUdDLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJZixRQUFRSSxPQUFPYyxTQUFTLENBQUMsR0FBR0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFBSXhCLDRFQUFlQSxDQUFDa0IsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1FBQUcsS0FBS2hCLE9BQU9pQix5QkFBeUIsR0FBR2pCLE9BQU9rQixnQkFBZ0IsQ0FBQ1IsUUFBUVYsT0FBT2lCLHlCQUF5QixDQUFDSCxXQUFXbEIsUUFBUUksT0FBT2MsU0FBU0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFBSWhCLE9BQU9tQixjQUFjLENBQUNULFFBQVFNLEtBQUtoQixPQUFPSyx3QkFBd0IsQ0FBQ1MsUUFB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LENBQUNiLFFBQVFjLGFBQWdCO1FBQ3JEQyxTQUFTO1FBQ1RmO1FBQ0FaLElBQUk7UUFDSjRCLFFBQVFGO0lBQ1Y7QUFDQSxNQUFNRyxjQUFjLFNBQVU3RCxHQUFHLEVBQUUyQyxPQUFPO0lBQ3hDLElBQUlmLFVBQVU5RCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS3dFLFlBQVl4RSxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2xGLE9BQU8rRCxRQUFRTyxJQUFJLENBQUM7UUFBQ1osSUFBSXhCLEtBQUsyQztRQUFVLElBQUlkLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDNURFLFdBQVc7Z0JBQ1RGLE9BQU8sSUFBSUksTUFBTTtZQUNuQixHQUFHUDtRQUNMO0tBQUc7QUFDTDtBQUV5UCxDQUN6UCwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzL2Rpc3QvaHR0cEhlbHBlcnMuZXNtLmpzP2ZhNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gubWVyZ2UnO1xuaW1wb3J0IGxvZ0xldmVsLCB7IGxldmVscyB9IGZyb20gJ2xvZ2xldmVsJztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jb25zdCBsb2cgPSBsb2dMZXZlbC5nZXRMb2dnZXIoXCJodHRwLWhlbHBlcnNcIik7XG5sb2cuc2V0TGV2ZWwobGV2ZWxzLklORk8pO1xubGV0IGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xubGV0IGVtYmVkSG9zdCA9IFwiXCI7XG4vLyAjcmVnaW9uIEFQSSBLZXlzXG5jb25zdCBnYXRld2F5QXV0aEhlYWRlciA9IFwieC1hcGkta2V5XCI7XG5jb25zdCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyID0gXCJ4LWVtYmVkLWhvc3RcIjtcbmxldCBzZW50cnkgPSBudWxsO1xuY29uc3QgdHJhY2luZ09yaWdpbnMgPSBbXTtcbmNvbnN0IHRyYWNpbmdQYXRocyA9IFtdO1xuZnVuY3Rpb24gZW5hYmxlU2VudHJ5VHJhY2luZyhfc2VudHJ5LCBfdHJhY2luZ09yaWdpbnMsIF90cmFjaW5nUGF0aHMpIHtcbiAgc2VudHJ5ID0gX3NlbnRyeTtcbiAgdHJhY2luZ09yaWdpbnMucHVzaCguLi5fdHJhY2luZ09yaWdpbnMpO1xuICB0cmFjaW5nUGF0aHMucHVzaCguLi5fdHJhY2luZ1BhdGhzKTtcbn1cbmZ1bmN0aW9uIHNldEVtYmVkSG9zdChlbWJlZEhvc3RfKSB7XG4gIGVtYmVkSG9zdCA9IGVtYmVkSG9zdF87XG59XG5mdW5jdGlvbiBjbGVhckVtYmVkSG9zdCgpIHtcbiAgZW1iZWRIb3N0ID0gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldEVtYmVkSG9zdCgpIHtcbiAgcmV0dXJuIGVtYmVkSG9zdDtcbn1cbmZ1bmN0aW9uIHNldEFQSUtleShhcGlLZXlfKSB7XG4gIGFwaUtleSA9IGFwaUtleV87XG59XG5mdW5jdGlvbiBjbGVhckFQSUtleSgpIHtcbiAgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCI7XG59XG5mdW5jdGlvbiBnZXRBUElLZXkoKSB7XG4gIHJldHVybiBhcGlLZXk7XG59XG4vLyAjZW5kcmVnaW9uXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRUcmFjZSh1cmwsIGluaXQpIHtcbiAgbGV0IF91cmwgPSBudWxsO1xuICB0cnkge1xuICAgIF91cmwgPSBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICBpZiAoc2VudHJ5ICYmIF91cmwgJiYgKHRyYWNpbmdPcmlnaW5zLmluY2x1ZGVzKF91cmwub3JpZ2luKSB8fCB0cmFjaW5nUGF0aHMuaW5jbHVkZXMoX3VybC5wYXRobmFtZSkpKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzZW50cnkuc3RhcnRUcmFuc2FjdGlvbih7XG4gICAgICBuYW1lOiB1cmxcbiAgICB9KTtcbiAgICBjb25zdCBzcGFuID0gdHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICBvcDogXCJodHRwXCJcbiAgICB9KTsgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3BhblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBpbml0KTtcbiAgICBzcGFuLmZpbmlzaCgpOyAvLyBSZW1lbWJlciB0aGF0IG9ubHkgZmluaXNoZWQgc3BhbnMgd2lsbCBiZSBzZW50IHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gICAgdHJhbnNhY3Rpb24uZmluaXNoKCk7IC8vIEZpbmlzaGluZyB0aGUgdHJhbnNhY3Rpb24gd2lsbCBzZW5kIGl0IHRvIFNlbnRyeVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICByZXR1cm4gZmV0Y2godXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGdldEFwaUtleUhlYWRlcnMoKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGFwaUtleSkgaGVhZGVyc1tnYXRld2F5QXV0aEhlYWRlcl0gPSBhcGlLZXk7XG4gIGlmIChlbWJlZEhvc3QpIGhlYWRlcnNbZ2F0ZXdheUVtYmVkSG9zdEhlYWRlcl0gPSBlbWJlZEhvc3Q7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSkge1xuICBsb2cuaW5mbyhgUmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIGxvZy5pbmZvKGBVcmw6ICR7cmVzcG9uc2UudXJsfWApO1xufVxuZnVuY3Rpb24gbG9nVHJhY2luZ0hlYWRlcihyZXNwb25zZSkge1xuICBsb2cuaW5mbyhgUmVxdWVzdCB0cmFjaW5nIHdpdGggdHJhY2VJRD0ke3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC13ZWIzLWNvcnJlbGF0aW9uLWlkXCIpfWApO1xufVxuY29uc3QgcHJvbWlzZVRpbWVvdXQgPSAobXMsIHByb21pc2UpID0+IHtcbiAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVkIG91dCBpbiAke21zfW1zYCkpO1xuICAgIH0sIG1zKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRdKTtcbn07XG5jb25zdCBnZXQgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge31cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJHRVRcIlxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHBvc3QgPSBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZVRpbWVvdXQoY3VzdG9tT3B0aW9ucy50aW1lb3V0IHx8IDYwMDAwLCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgaWYgKGN1c3RvbU9wdGlvbnMubG9nVHJhY2luZ0hlYWRlcikge1xuICAgICAgbG9nVHJhY2luZ0hlYWRlcihyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gICAgdGhyb3cgcmVzcG9uc2U7XG4gIH0pKTtcbn07XG5jb25zdCBwYXRjaCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBBVENIXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcHV0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUFVUXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgfSk7XG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBnZW5lcmF0ZUpzb25SUENPYmplY3QgPSAobWV0aG9kLCBwYXJhbWV0ZXJzKSA9PiAoe1xuICBqc29ucnBjOiBcIjIuMFwiLFxuICBtZXRob2QsXG4gIGlkOiAxMCxcbiAgcGFyYW1zOiBwYXJhbWV0ZXJzXG59KTtcbmNvbnN0IHByb21pc2VSYWNlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNjAwMDA7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW2dldCh1cmwsIG9wdGlvbnMpLCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwidGltZWQgb3V0XCIpKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSldKTtcbn07XG5cbmV4cG9ydCB7IGNsZWFyQVBJS2V5LCBjbGVhckVtYmVkSG9zdCwgZW5hYmxlU2VudHJ5VHJhY2luZywgZ2F0ZXdheUF1dGhIZWFkZXIsIGdhdGV3YXlFbWJlZEhvc3RIZWFkZXIsIGdlbmVyYXRlSnNvblJQQ09iamVjdCwgZ2V0LCBnZXRBUElLZXksIGdldEVtYmVkSG9zdCwgcGF0Y2gsIHBvc3QsIHByb21pc2VSYWNlLCBwcm9taXNlVGltZW91dCwgcHV0LCByZW1vdmUsIHNldEFQSUtleSwgc2V0RW1iZWRIb3N0LCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cEhlbHBlcnMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm1lcmdlIiwibG9nTGV2ZWwiLCJsZXZlbHMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwibG9nIiwiZ2V0TG9nZ2VyIiwic2V0TGV2ZWwiLCJJTkZPIiwiYXBpS2V5IiwiZW1iZWRIb3N0IiwiZ2F0ZXdheUF1dGhIZWFkZXIiLCJnYXRld2F5RW1iZWRIb3N0SGVhZGVyIiwic2VudHJ5IiwidHJhY2luZ09yaWdpbnMiLCJ0cmFjaW5nUGF0aHMiLCJlbmFibGVTZW50cnlUcmFjaW5nIiwiX3NlbnRyeSIsIl90cmFjaW5nT3JpZ2lucyIsIl90cmFjaW5nUGF0aHMiLCJzZXRFbWJlZEhvc3QiLCJlbWJlZEhvc3RfIiwiY2xlYXJFbWJlZEhvc3QiLCJnZXRFbWJlZEhvc3QiLCJzZXRBUElLZXkiLCJhcGlLZXlfIiwiY2xlYXJBUElLZXkiLCJnZXRBUElLZXkiLCJzZXRMb2dMZXZlbCIsImxldmVsIiwiZmV0Y2hBbmRUcmFjZSIsInVybCIsImluaXQiLCJfdXJsIiwiVVJMIiwiZXJyb3IiLCJpbmNsdWRlcyIsIm9yaWdpbiIsInBhdGhuYW1lIiwidHJhbnNhY3Rpb24iLCJzdGFydFRyYW5zYWN0aW9uIiwibmFtZSIsInNwYW4iLCJzdGFydENoaWxkIiwib3AiLCJyZXNwb25zZSIsImZldGNoIiwiZmluaXNoIiwiZ2V0QXBpS2V5SGVhZGVycyIsImhlYWRlcnMiLCJkZWJ1Z0xvZ1Jlc3BvbnNlIiwiaW5mbyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJsb2dUcmFjaW5nSGVhZGVyIiwiZ2V0IiwicHJvbWlzZVRpbWVvdXQiLCJtcyIsInByb21pc2UiLCJ0aW1lb3V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJFcnJvciIsInJhY2UiLCJvcHRpb25zXyIsInVuZGVmaW5lZCIsImN1c3RvbU9wdGlvbnMiLCJkZWZhdWx0T3B0aW9ucyIsIm1vZGUiLCJ1c2VBUElLZXkiLCJvcHRpb25zIiwibWV0aG9kIiwib2siLCJqc29uIiwicG9zdCIsImRhdGEiLCJpc1VybEVuY29kZWREYXRhIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0aGVuIiwicGF0Y2giLCJwdXQiLCJyZW1vdmUiLCJnZW5lcmF0ZUpzb25SUENPYmplY3QiLCJwYXJhbWV0ZXJzIiwianNvbnJwYyIsInBhcmFtcyIsInByb21pc2VSYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptData: () => (/* binding */ decryptData),\n/* harmony export */   \"default\": () => (/* binding */ MetadataStorageLayer),\n/* harmony export */   ec: () => (/* binding */ ec),\n/* harmony export */   encParamsBufToHex: () => (/* binding */ encParamsBufToHex),\n/* harmony export */   encParamsHexToBuf: () => (/* binding */ encParamsHexToBuf),\n/* harmony export */   encryptAndSetData: () => (/* binding */ encryptAndSetData),\n/* harmony export */   encryptData: () => (/* binding */ encryptData),\n/* harmony export */   getAndDecryptData: () => (/* binding */ getAndDecryptData),\n/* harmony export */   getDeviceShare: () => (/* binding */ getDeviceShare),\n/* harmony export */   getTorusShare: () => (/* binding */ getTorusShare),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   setDeviceShare: () => (/* binding */ setDeviceShare),\n/* harmony export */   setTorusShare: () => (/* binding */ setTorusShare)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/../node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! json-stable-stringify */ \"(ssr)/../node_modules/json-stable-stringify/index.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! elliptic */ \"(ssr)/../node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/../node_modules/ethereum-cryptography/esm/keccak.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/../node_modules/@toruslabs/eccrypto/dist/browser.js\");\n\n\n\n\n\n\nfunction keccak256(a) {\n    return Buffer.from((0,ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_4__.keccak256)(a));\n}\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_3__.ec(\"secp256k1\");\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nclass MetadataStorageLayer {\n    // ms\n    constructor(){\n        let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n        let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"metadataHost\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"serverTimeOffset\", void 0);\n        this.metadataHost = metadataHost;\n        this.serverTimeOffset = serverTimeOffset;\n    }\n    static setAPIKey(apiKey) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.setAPIKey)(apiKey);\n    }\n    static setEmbedHost(embedHost) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.setEmbedHost)(embedHost);\n    }\n    generateMetadataParams(message, privateKeyHex) {\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        const setData = {\n            data: message,\n            timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n        };\n        const sig = key.sign(keccak256(Buffer.from(json_stable_stringify__WEBPACK_IMPORTED_MODULE_2___default()(setData), \"utf8\")));\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64),\n            set_data: setData,\n            signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + (sig.recoveryParam?.toString(16).padStart(2, \"0\").slice(-2) ?? \"00\"), \"hex\").toString(\"base64\")\n        };\n    }\n    generatePubKeyParams(privateKeyHex) {\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64)\n        };\n    }\n    async setMetadata(data, namespace, options) {\n        const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n            namespace\n        }) : data;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.post)(`${this.metadataHost}/set`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n    async getMetadata(pubKey, namespace, options) {\n        const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n            namespace\n        }) : pubKey;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.post)(`${this.metadataHost}/get`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n}\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n    return {\n        iv: Buffer.from(encParamsHex.iv, \"hex\"),\n        ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n        ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n        mac: Buffer.from(encParamsHex.mac, \"hex\")\n    };\n}\nfunction encParamsBufToHex(encParams) {\n    return {\n        iv: Buffer.from(encParams.iv).toString(\"hex\"),\n        ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n        ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n        mac: Buffer.from(encParams.mac).toString(\"hex\")\n    };\n}\nasync function encryptData(privKeyHex, d) {\n    const serializedDec = JSON.stringify(d);\n    const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n    const encParams = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_5__.encrypt)((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_5__.getPublic)(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n    const encParamsHex = encParamsBufToHex(encParams);\n    const sData = JSON.stringify(encParamsHex);\n    return sData;\n}\nasync function decryptData(privKeyHex, d) {\n    const encParamsHex = JSON.parse(d);\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(privKeyHex);\n    const serializedBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_5__.decrypt)(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedDec = serializedBuf.toString(\"utf-8\");\n    const data = JSON.parse(serializedDec);\n    return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n    const keyPair = ec.keyFromPrivate(privKeyHex);\n    const pubKey = keyPair.getPublic();\n    const serializedData = await m.getMetadata({\n        pub_key_X: pubKey.getX().toString(16),\n        pub_key_Y: pubKey.getY().toString(16)\n    }, namespace);\n    if (!serializedData) {\n        return null;\n    }\n    const data = await decryptData(privKeyHex, serializedData);\n    return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n    const sData = await encryptData(privKeyHex, d);\n    const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n    await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n    const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = refKeyPair.getPrivate();\n    const pubKey = ec.keyFromPublic({\n        x: webAuthnPubKey.pub_key_X,\n        y: webAuthnPubKey.pub_key_Y\n    });\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    let d = {};\n    if (data) d = data;\n    const serializedSubspaceData = JSON.stringify(subspaceData);\n    const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n    const encSubspaceData = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_5__.encrypt)(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n    const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n    d[subspace] = encSubspaceDataHex;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n    const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = keyPair.getPrivate();\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    let d = {};\n    if (data) d = data;\n    d[subspace] = subspaceData;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    if (!data) return null;\n    const encParamsHex = data[subspace];\n    if (!encParamsHex) return null;\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n    const privKey = keyPair.getPrivate();\n    const serializedSubspaceDataBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_5__.decrypt)(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n    const subspaceData = JSON.parse(serializedSubspaceData);\n    return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    if (data) return data[subspace];\n    return null;\n}\n //# sourceMappingURL=metadataHelpers.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvbWV0YWRhdGEtaGVscGVycy9kaXN0L21ldGFkYXRhSGVscGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNJO0FBQzFCO0FBQ1I7QUFDa0M7QUFDTjtBQUVsRSxTQUFTTyxVQUFVSyxDQUFDO0lBQ2xCLE9BQU9DLE9BQU9DLElBQUksQ0FBQ04sdUVBQVdBLENBQUNJO0FBQ2pDO0FBQ0EsTUFBTVAsS0FBSyxJQUFJQyx3Q0FBSUEsQ0FBQztBQUVwQixTQUFTUyxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBQVMsSUFBSUcsT0FBT0MscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFBU0Msa0JBQW1CSSxDQUFBQSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztZQUFJLE9BQU9KLE9BQU9LLHdCQUF3QixDQUFDUixRQUFRTyxLQUFLRSxVQUFVO1FBQUUsRUFBQyxHQUFJUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFBVTtJQUFFLE9BQU9IO0FBQU07QUFDcFYsU0FBU1UsY0FBY0MsTUFBTTtJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJRyxTQUFTLFFBQVFGLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHQyxTQUFTLENBQUNELEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSWYsUUFBUUksT0FBT2MsU0FBUyxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1lBQUluQyw0RUFBZUEsQ0FBQzZCLFFBQVFNLEtBQUtGLE1BQU0sQ0FBQ0UsSUFBSTtRQUFHLEtBQUtoQixPQUFPaUIseUJBQXlCLEdBQUdqQixPQUFPa0IsZ0JBQWdCLENBQUNSLFFBQVFW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TUFBTWtELGtCQUFrQkMsR0FBR00sZ0JBQWdCM0I7SUFDeEQsSUFBSVcsSUFBSSxDQUFDO0lBQ1QsSUFBSXpDLE1BQU15QyxJQUFJekM7SUFDZHlDLENBQUMsQ0FBQ2lCLFNBQVMsR0FBR0M7SUFDZCxNQUFNTixrQkFBa0JGLEdBQUdVLFFBQVF2RCxRQUFRLENBQUMsT0FBTyxLQUFLbUMsR0FBR1g7QUFDN0Q7QUFDQSxlQUFld0MsY0FBY25CLENBQUMsRUFBRW9CLGNBQWMsRUFBRWQsY0FBYyxFQUFFQyxRQUFRO0lBQ3RFLE1BQU0xRCxPQUFPLE1BQU1rRCxrQkFBa0JDLEdBQUdNLGdCQUFnQjVCO0lBQ3hELElBQUksQ0FBQzdCLE1BQU0sT0FBTztJQUNsQixNQUFNZ0MsZUFBZWhDLElBQUksQ0FBQzBELFNBQVM7SUFDbkMsSUFBSSxDQUFDMUIsY0FBYyxPQUFPO0lBQzFCLE1BQU1NLFlBQVlQLGtCQUFrQkM7SUFDcEMsTUFBTWdCLFVBQVU5RixHQUFHNEMsY0FBYyxDQUFDeUU7SUFDbEMsTUFBTVYsVUFBVWIsUUFBUUMsVUFBVTtJQUNsQyxNQUFNaUIsNEJBQTRCLE1BQU0xRyw0REFBT0EsQ0FBQ0UsT0FBT0MsSUFBSSxDQUFDa0csUUFBUXZELFFBQVEsQ0FBQyxPQUFPLEtBQUssUUFBUWdDO0lBQ2pHLE1BQU0yQix5QkFBeUJDLDBCQUEwQjVELFFBQVEsQ0FBQztJQUNsRSxNQUFNcUQsZUFBZWhCLEtBQUtJLEtBQUssQ0FBQ2tCO0lBQ2hDLE9BQU9OO0FBQ1Q7QUFDQSxlQUFlYSxlQUFlckIsQ0FBQyxFQUFFTSxjQUFjLEVBQUVDLFFBQVE7SUFDdkQsTUFBTTFELE9BQU8sTUFBTWtELGtCQUFrQkMsR0FBR00sZ0JBQWdCM0I7SUFDeEQsSUFBSTlCLE1BQU0sT0FBT0EsSUFBSSxDQUFDMEQsU0FBUztJQUMvQixPQUFPO0FBQ1Q7QUFFOE4sQ0FDOU4sK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL21ldGFkYXRhLWhlbHBlcnMvZGlzdC9tZXRhZGF0YUhlbHBlcnMuZXNtLmpzPzgwNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IHNldEFQSUtleSwgc2V0RW1iZWRIb3N0LCBwb3N0IH0gZnJvbSAnQHRvcnVzbGFicy9odHRwLWhlbHBlcnMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdqc29uLXN0YWJsZS1zdHJpbmdpZnknO1xuaW1wb3J0IHsgZWMgYXMgZWMkMSB9IGZyb20gJ2VsbGlwdGljJztcbmltcG9ydCB7IGtlY2NhazI1NiBhcyBrZWNjYWsyNTYkMSB9IGZyb20gJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnO1xuaW1wb3J0IHsgZW5jcnlwdCwgZ2V0UHVibGljLCBkZWNyeXB0IH0gZnJvbSAnQHRvcnVzbGFicy9lY2NyeXB0byc7XG5cbmZ1bmN0aW9uIGtlY2NhazI1NihhKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShrZWNjYWsyNTYkMShhKSk7XG59XG5jb25zdCBlYyA9IG5ldyBlYyQxKFwic2VjcDI1NmsxXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmNsYXNzIE1ldGFkYXRhU3RvcmFnZUxheWVyIHtcbiAgLy8gbXNcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG1ldGFkYXRhSG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJodHRwczovL21ldGFkYXRhLnRvci51c1wiO1xuICAgIGxldCBzZXJ2ZXJUaW1lT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhSG9zdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcnZlclRpbWVPZmZzZXRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLm1ldGFkYXRhSG9zdCA9IG1ldGFkYXRhSG9zdDtcbiAgICB0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBzZXJ2ZXJUaW1lT2Zmc2V0O1xuICB9XG4gIHN0YXRpYyBzZXRBUElLZXkoYXBpS2V5KSB7XG4gICAgc2V0QVBJS2V5KGFwaUtleSk7XG4gIH1cbiAgc3RhdGljIHNldEVtYmVkSG9zdChlbWJlZEhvc3QpIHtcbiAgICBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0KTtcbiAgfVxuICBnZW5lcmF0ZU1ldGFkYXRhUGFyYW1zKG1lc3NhZ2UsIHByaXZhdGVLZXlIZXgpIHtcbiAgICBjb25zdCBrZXkgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5SGV4LCBcImhleFwiKTtcbiAgICBjb25zdCBzZXREYXRhID0ge1xuICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih0aGlzLnNlcnZlclRpbWVPZmZzZXQgKyBEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoMTYpXG4gICAgfTtcbiAgICBjb25zdCBzaWcgPSBrZXkuc2lnbihrZWNjYWsyNTYoQnVmZmVyLmZyb20oc3RyaW5naWZ5KHNldERhdGEpLCBcInV0ZjhcIikpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViX2tleV9YOiBrZXkuZ2V0UHVibGljKCkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgICBwdWJfa2V5X1k6IGtleS5nZXRQdWJsaWMoKS5nZXRZKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHNldF9kYXRhOiBzZXREYXRhLFxuICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuci50b1N0cmluZygxNiwgNjQpICsgc2lnLnMudG9TdHJpbmcoMTYsIDY0KSArIChzaWcucmVjb3ZlcnlQYXJhbT8udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKS5zbGljZSgtMikgPz8gXCIwMFwiKSwgXCJoZXhcIikudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlUHViS2V5UGFyYW1zKHByaXZhdGVLZXlIZXgpIHtcbiAgICBjb25zdCBrZXkgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5SGV4LCBcImhleFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViX2tleV9YOiBrZXkuZ2V0UHVibGljKCkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgICBwdWJfa2V5X1k6IGtleS5nZXRQdWJsaWMoKS5nZXRZKCkudG9TdHJpbmcoMTYsIDY0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoZGF0YSwgbmFtZXNwYWNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmFtZXNwYWNlICE9PSBudWxsID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkYXRhKSwge30sIHtcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pIDogZGF0YTtcbiAgICBjb25zdCBtZXRhZGF0YVJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLm1ldGFkYXRhSG9zdH0vc2V0YCwgcGFyYW1zLCBvcHRpb25zLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0YWRhdGFSZXNwb25zZS5tZXNzYWdlO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhKHB1YktleSwgbmFtZXNwYWNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmFtZXNwYWNlICE9PSBudWxsID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwdWJLZXkpLCB7fSwge1xuICAgICAgbmFtZXNwYWNlXG4gICAgfSkgOiBwdWJLZXk7XG4gICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5tZXRhZGF0YUhvc3R9L2dldGAsIHBhcmFtcywgb3B0aW9ucywge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhUmVzcG9uc2UubWVzc2FnZTtcbiAgfVxufVxuXG5jb25zdCBXRUJBVVRITl9UT1JVU19TSEFSRSA9IFwid2ViYXV0aG5fdG9ydXNfc2hhcmVcIjtcbmNvbnN0IFdFQkFVVEhOX0RFVklDRV9TSEFSRSA9IFwid2ViYXV0aG5fZGV2aWNlX3NoYXJlXCI7XG5mdW5jdGlvbiBlbmNQYXJhbXNIZXhUb0J1ZihlbmNQYXJhbXNIZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpdjogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4Lml2LCBcImhleFwiKSxcbiAgICBlcGhlbVB1YmxpY0tleTogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4LmVwaGVtUHVibGljS2V5LCBcImhleFwiKSxcbiAgICBjaXBoZXJ0ZXh0OiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXguY2lwaGVydGV4dCwgXCJoZXhcIiksXG4gICAgbWFjOiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXgubWFjLCBcImhleFwiKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jUGFyYW1zQnVmVG9IZXgoZW5jUGFyYW1zKSB7XG4gIHJldHVybiB7XG4gICAgaXY6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5pdikudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgZXBoZW1QdWJsaWNLZXk6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5lcGhlbVB1YmxpY0tleSkudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgY2lwaGVydGV4dDogQnVmZmVyLmZyb20oZW5jUGFyYW1zLmNpcGhlcnRleHQpLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIG1hYzogQnVmZmVyLmZyb20oZW5jUGFyYW1zLm1hYykudG9TdHJpbmcoXCJoZXhcIilcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHREYXRhKHByaXZLZXlIZXgsIGQpIHtcbiAgY29uc3Qgc2VyaWFsaXplZERlYyA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICBjb25zdCBzZXJpYWxpemVkQnVmID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZERlYywgXCJ1dGYtOFwiKTtcbiAgY29uc3QgZW5jUGFyYW1zID0gYXdhaXQgZW5jcnlwdChnZXRQdWJsaWMoQnVmZmVyLmZyb20ocHJpdktleUhleCwgXCJoZXhcIikpLCBzZXJpYWxpemVkQnVmKTtcbiAgY29uc3QgZW5jUGFyYW1zSGV4ID0gZW5jUGFyYW1zQnVmVG9IZXgoZW5jUGFyYW1zKTtcbiAgY29uc3Qgc0RhdGEgPSBKU09OLnN0cmluZ2lmeShlbmNQYXJhbXNIZXgpO1xuICByZXR1cm4gc0RhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0RGF0YShwcml2S2V5SGV4LCBkKSB7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IEpTT04ucGFyc2UoZCk7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCk7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2S2V5SGV4KTtcbiAgY29uc3Qgc2VyaWFsaXplZEJ1ZiA9IGF3YWl0IGRlY3J5cHQoQnVmZmVyLmZyb20oa2V5UGFpci5nZXRQcml2YXRlKCkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBcImhleFwiKSwgZW5jUGFyYW1zKTtcbiAgY29uc3Qgc2VyaWFsaXplZERlYyA9IHNlcmlhbGl6ZWRCdWYudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZERlYyk7XG4gIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QW5kRGVjcnlwdERhdGEobSwgcHJpdktleUhleCwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2S2V5SGV4KTtcbiAgY29uc3QgcHViS2V5ID0ga2V5UGFpci5nZXRQdWJsaWMoKTtcbiAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBhd2FpdCBtLmdldE1ldGFkYXRhKHtcbiAgICBwdWJfa2V5X1g6IHB1YktleS5nZXRYKCkudG9TdHJpbmcoMTYpLFxuICAgIHB1Yl9rZXlfWTogcHViS2V5LmdldFkoKS50b1N0cmluZygxNilcbiAgfSwgbmFtZXNwYWNlKTtcbiAgaWYgKCFzZXJpYWxpemVkRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBkZWNyeXB0RGF0YShwcml2S2V5SGV4LCBzZXJpYWxpemVkRGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleUhleCwgZCwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IHNEYXRhID0gYXdhaXQgZW5jcnlwdERhdGEocHJpdktleUhleCwgZCk7XG4gIGNvbnN0IG1ldGFkYXRhUGFyYW1zID0gbS5nZW5lcmF0ZU1ldGFkYXRhUGFyYW1zKHNEYXRhLCBwcml2S2V5SGV4KTtcbiAgYXdhaXQgbS5zZXRNZXRhZGF0YShtZXRhZGF0YVBhcmFtcywgbmFtZXNwYWNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldFRvcnVzU2hhcmUobSwgd2ViQXV0aG5QdWJLZXksIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSwgc3Vic3BhY2VEYXRhKSB7XG4gIGNvbnN0IHJlZktleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRoblJlZkhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSByZWZLZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3QgcHViS2V5ID0gZWMua2V5RnJvbVB1YmxpYyh7XG4gICAgeDogd2ViQXV0aG5QdWJLZXkucHViX2tleV9YLFxuICAgIHk6IHdlYkF1dGhuUHViS2V5LnB1Yl9rZXlfWVxuICB9KTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG4gIGxldCBkID0ge307XG4gIGlmIChkYXRhKSBkID0gZGF0YTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YSA9IEpTT04uc3RyaW5naWZ5KHN1YnNwYWNlRGF0YSk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkU3Vic3BhY2VEYXRhLCBcInV0Zi04XCIpO1xuICBjb25zdCBlbmNTdWJzcGFjZURhdGEgPSBhd2FpdCBlbmNyeXB0KEJ1ZmZlci5mcm9tKHB1YktleS5nZXRQdWJsaWMoXCJoZXhcIiksIFwiaGV4XCIpLCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmKTtcbiAgY29uc3QgZW5jU3Vic3BhY2VEYXRhSGV4ID0gZW5jUGFyYW1zQnVmVG9IZXgoZW5jU3Vic3BhY2VEYXRhKTtcbiAgZFtzdWJzcGFjZV0gPSBlbmNTdWJzcGFjZURhdGFIZXg7XG4gIGF3YWl0IGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBkLCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZXREZXZpY2VTaGFyZShtLCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UsIHN1YnNwYWNlRGF0YSkge1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5SZWZIZXgpO1xuICBjb25zdCBwcml2S2V5ID0ga2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbiAgbGV0IGQgPSB7fTtcbiAgaWYgKGRhdGEpIGQgPSBkYXRhO1xuICBkW3N1YnNwYWNlXSA9IHN1YnNwYWNlRGF0YTtcbiAgYXdhaXQgZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIGQsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUb3J1c1NoYXJlKG0sIHdlYkF1dGhuS2V5SGV4LCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG4gIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IGRhdGFbc3Vic3BhY2VdO1xuICBpZiAoIWVuY1BhcmFtc0hleCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCk7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRobktleUhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSBrZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1ZiA9IGF3YWl0IGRlY3J5cHQoQnVmZmVyLmZyb20ocHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIFwiaGV4XCIpLCBlbmNQYXJhbXMpO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhID0gc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1Zi50b1N0cmluZyhcInV0Zi04XCIpO1xuICBjb25zdCBzdWJzcGFjZURhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEpO1xuICByZXR1cm4gc3Vic3BhY2VEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlU2hhcmUobSwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbiAgaWYgKGRhdGEpIHJldHVybiBkYXRhW3N1YnNwYWNlXTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGRlY3J5cHREYXRhLCBNZXRhZGF0YVN0b3JhZ2VMYXllciBhcyBkZWZhdWx0LCBlYywgZW5jUGFyYW1zQnVmVG9IZXgsIGVuY1BhcmFtc0hleFRvQnVmLCBlbmNyeXB0QW5kU2V0RGF0YSwgZW5jcnlwdERhdGEsIGdldEFuZERlY3J5cHREYXRhLCBnZXREZXZpY2VTaGFyZSwgZ2V0VG9ydXNTaGFyZSwga2VjY2FrMjU2LCBzZXREZXZpY2VTaGFyZSwgc2V0VG9ydXNTaGFyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGFIZWxwZXJzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJzZXRBUElLZXkiLCJzZXRFbWJlZEhvc3QiLCJwb3N0Iiwic3RyaW5naWZ5IiwiZWMiLCJlYyQxIiwia2VjY2FrMjU2Iiwia2VjY2FrMjU2JDEiLCJlbmNyeXB0IiwiZ2V0UHVibGljIiwiZGVjcnlwdCIsImEiLCJCdWZmZXIiLCJmcm9tIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIk1ldGFkYXRhU3RvcmFnZUxheWVyIiwiY29uc3RydWN0b3IiLCJtZXRhZGF0YUhvc3QiLCJ1bmRlZmluZWQiLCJzZXJ2ZXJUaW1lT2Zmc2V0IiwiYXBpS2V5IiwiZW1iZWRIb3N0IiwiZ2VuZXJhdGVNZXRhZGF0YVBhcmFtcyIsIm1lc3NhZ2UiLCJwcml2YXRlS2V5SGV4Iiwia2V5RnJvbVByaXZhdGUiLCJzZXREYXRhIiwiZGF0YSIsInRpbWVzdGFtcCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsInNpZyIsInNpZ24iLCJwdWJfa2V5X1giLCJnZXRYIiwicHViX2tleV9ZIiwiZ2V0WSIsInNldF9kYXRhIiwic2lnbmF0dXJlIiwiciIsInMiLCJyZWNvdmVyeVBhcmFtIiwicGFkU3RhcnQiLCJzbGljZSIsImdlbmVyYXRlUHViS2V5UGFyYW1zIiwic2V0TWV0YWRhdGEiLCJuYW1lc3BhY2UiLCJvcHRpb25zIiwicGFyYW1zIiwibWV0YWRhdGFSZXNwb25zZSIsInVzZUFQSUtleSIsImdldE1ldGFkYXRhIiwicHViS2V5IiwiV0VCQVVUSE5fVE9SVVNfU0hBUkUiLCJXRUJBVVRITl9ERVZJQ0VfU0hBUkUiLCJlbmNQYXJhbXNIZXhUb0J1ZiIsImVuY1BhcmFtc0hleCIsIml2IiwiZXBoZW1QdWJsaWNLZXkiLCJjaXBoZXJ0ZXh0IiwibWFjIiwiZW5jUGFyYW1zQnVmVG9IZXgiLCJlbmNQYXJhbXMiLCJlbmNyeXB0RGF0YSIsInByaXZLZXlIZXgiLCJkIiwic2VyaWFsaXplZERlYyIsIkpTT04iLCJzZXJpYWxpemVkQnVmIiwic0RhdGEiLCJkZWNyeXB0RGF0YSIsInBhcnNlIiwia2V5UGFpciIsImdldFByaXZhdGUiLCJnZXRBbmREZWNyeXB0RGF0YSIsIm0iLCJzZXJpYWxpemVkRGF0YSIsImVuY3J5cHRBbmRTZXREYXRhIiwibWV0YWRhdGFQYXJhbXMiLCJzZXRUb3J1c1NoYXJlIiwid2ViQXV0aG5QdWJLZXkiLCJ3ZWJBdXRoblJlZkhleCIsInN1YnNwYWNlIiwic3Vic3BhY2VEYXRhIiwicmVmS2V5UGFpciIsInByaXZLZXkiLCJrZXlGcm9tUHVibGljIiwieCIsInkiLCJzZXJpYWxpemVkU3Vic3BhY2VEYXRhIiwic2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1ZiIsImVuY1N1YnNwYWNlRGF0YSIsImVuY1N1YnNwYWNlRGF0YUhleCIsInNldERldmljZVNoYXJlIiwiZ2V0VG9ydXNTaGFyZSIsIndlYkF1dGhuS2V5SGV4IiwiZ2V0RGV2aWNlU2hhcmUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePostMessageStream: () => (/* binding */ BasePostMessageStream),\n/* harmony export */   IGNORE_SUBSTREAM: () => (/* binding */ IGNORE_SUBSTREAM),\n/* harmony export */   JRPCEngine: () => (/* binding */ JRPCEngine),\n/* harmony export */   ObjectMultiplex: () => (/* binding */ ObjectMultiplex),\n/* harmony export */   PostMessageStream: () => (/* binding */ PostMessageStream),\n/* harmony export */   SafeEventEmitter: () => (/* binding */ SafeEventEmitter),\n/* harmony export */   SerializableError: () => (/* binding */ SerializableError),\n/* harmony export */   Substream: () => (/* binding */ Substream),\n/* harmony export */   createAsyncMiddleware: () => (/* binding */ createAsyncMiddleware),\n/* harmony export */   createEngineStream: () => (/* binding */ createEngineStream),\n/* harmony export */   createErrorMiddleware: () => (/* binding */ createErrorMiddleware),\n/* harmony export */   createIdRemapMiddleware: () => (/* binding */ createIdRemapMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createScaffoldMiddleware: () => (/* binding */ createScaffoldMiddleware),\n/* harmony export */   createStreamMiddleware: () => (/* binding */ createStreamMiddleware),\n/* harmony export */   getRpcPromiseCallback: () => (/* binding */ getRpcPromiseCallback),\n/* harmony export */   mergeMiddleware: () => (/* binding */ mergeMiddleware),\n/* harmony export */   providerAsMiddleware: () => (/* binding */ providerAsMiddleware),\n/* harmony export */   providerFromEngine: () => (/* binding */ providerFromEngine),\n/* harmony export */   providerFromMiddleware: () => (/* binding */ providerFromMiddleware),\n/* harmony export */   setupMultiplex: () => (/* binding */ setupMultiplex)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/index.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/../node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @metamask/rpc-errors */ \"(ssr)/../node_modules/@metamask/rpc-errors/dist/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! end-of-stream */ \"(ssr)/../node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! once */ \"(ssr)/../node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/../node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\nfunction noop() {\n    return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { name, target, targetWindow = window, targetOrigin = \"*\" } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_init\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_haveSyn\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetOrigin\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_onMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_synIntervalId\", void 0);\n        if (!name || !target) {\n            throw new Error(\"Invalid input.\");\n        }\n        this._init = false;\n        this._haveSyn = false;\n        this._name = name;\n        this._target = target; // target origin\n        this._targetWindow = targetWindow;\n        this._targetOrigin = targetOrigin;\n        this._onMessage = this.onMessage.bind(this);\n        this._synIntervalId = null;\n        window.addEventListener(\"message\", this._onMessage, false);\n        this._handShake();\n    }\n    _break() {\n        this.cork();\n        this._write(BRK, null, noop);\n        this._haveSyn = false;\n        this._init = false;\n    }\n    _handShake() {\n        this._write(SYN, null, noop);\n        this.cork();\n    }\n    _onData(data) {\n        if (!this._init) {\n            // listen for handshake\n            if (data === SYN) {\n                this._haveSyn = true;\n                this._write(ACK, null, noop);\n            } else if (data === ACK) {\n                this._init = true;\n                if (!this._haveSyn) {\n                    this._write(ACK, null, noop);\n                }\n                this.uncork();\n            }\n        } else if (data === BRK) {\n            this._break();\n        } else {\n            // forward message\n            try {\n                this.push(data);\n            } catch (err) {\n                this.emit(\"error\", err);\n            }\n        }\n    }\n    _postMessage(data) {\n        const originConstraint = this._targetOrigin;\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n    onMessage(event) {\n        const message = event.data;\n        // validate message\n        if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n            return;\n        }\n        this._onData(message.data);\n    }\n    _read() {\n        return undefined;\n    }\n    _write(data, _, cb) {\n        this._postMessage(data);\n        cb();\n    }\n    _destroy() {\n        window.removeEventListener(\"message\", this._onMessage, false);\n    }\n}\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    } catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(()=>{\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for(let i = 0; i < n; i += 1){\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {\n    emit(type) {\n        let doError = type === \"error\";\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        } else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === \"function\") {\n            safeApply(handler, this, args);\n        } else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for(let i = 0; i < len; i += 1){\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nclass SerializableError extends Error {\n    constructor(_ref){\n        let { code, message, data } = _ref;\n        if (!Number.isInteger(code)) {\n            throw new Error(\"code must be an integer\");\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error(\"message must be string\");\n        }\n        super(message);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n    toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_3___default()({\n            code: this.code,\n            message: this.message,\n            data: this.data,\n            stack: this.stack\n        });\n    }\n}\nconst getRpcPromiseCallback = function(resolve, reject) {\n    let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return (error, response)=>{\n        if (error || response.error) {\n            reject(error || response.error);\n        } else if (!unwrapResult || Array.isArray(response)) {\n            resolve(response);\n        } else {\n            resolve(response.result);\n        }\n    };\n};\nfunction createErrorMiddleware(log) {\n    return (req, res, next, end)=>{\n        try {\n            // json-rpc-engine will terminate the request when it notices this error\n            if (typeof req.method !== \"string\" || !req.method) {\n                res.error = new SerializableError({\n                    code: -32603,\n                    message: \"invalid method\"\n                });\n                end();\n                return;\n            }\n            next((done)=>{\n                const { error } = res;\n                if (!error) {\n                    return done();\n                }\n                log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n                return done();\n            });\n        } catch (error) {\n            log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n            res.error = new SerializableError({\n                code: -32603,\n                message: error.message\n            });\n            end();\n        }\n    };\n}\nfunction createStreamMiddleware() {\n    const idMap = {};\n    function readNoop() {\n        return false;\n    }\n    const events = new SafeEventEmitter();\n    function processResponse(res) {\n        const context = idMap[res.id];\n        if (!context) {\n            throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n        }\n        delete idMap[res.id];\n        // copy whole res onto original res\n        Object.assign(context.res, res);\n        // run callback on empty stack,\n        // prevent internal stream-handler from catching errors\n        setTimeout(context.end);\n    }\n    function processNotification(res) {\n        events.emit(\"notification\", res);\n    }\n    function processMessage(res, _encoding, cb) {\n        let err;\n        try {\n            const isNotification = !res.id;\n            if (isNotification) {\n                processNotification(res);\n            } else {\n                processResponse(res);\n            }\n        } catch (_err) {\n            err = _err;\n        }\n        // continue processing stream\n        cb(err);\n    }\n    const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read: readNoop,\n        write: processMessage\n    });\n    const middleware = (req, res, next, end)=>{\n        // write req to stream\n        stream.push(req);\n        // register request on id map\n        idMap[req.id] = {\n            req,\n            res,\n            next,\n            end\n        };\n    };\n    return {\n        events,\n        middleware,\n        stream\n    };\n}\nfunction createScaffoldMiddleware(handlers) {\n    return (req, res, next, end)=>{\n        const handler = handlers[req.method];\n        // if no handler, return\n        if (handler === undefined) {\n            return next();\n        }\n        // if handler is fn, call as middleware\n        if (typeof handler === \"function\") {\n            return handler(req, res, next, end);\n        }\n        // if handler is some other value, use as result\n        res.result = handler;\n        return end();\n    };\n}\nfunction createIdRemapMiddleware() {\n    return (req, res, next, _end)=>{\n        const originalId = req.id;\n        const newId = Math.random().toString(36).slice(2);\n        req.id = newId;\n        res.id = newId;\n        next((done)=>{\n            req.id = originalId;\n            res.id = originalId;\n            done();\n        });\n    };\n}\nfunction createLoggerMiddleware(logger) {\n    return (req, res, next, _)=>{\n        logger.debug(\"REQ\", req, \"RES\", res);\n        next();\n    };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n    return async (req, res, next, end)=>{\n        // nextPromise is the key to the implementation\n        // it is resolved by the return handler passed to the\n        // \"next\" function\n        let resolveNextPromise;\n        const nextPromise = new Promise((resolve)=>{\n            resolveNextPromise = resolve;\n        });\n        let returnHandlerCallback = null;\n        let nextWasCalled = false;\n        // This will be called by the consumer's async middleware.\n        const asyncNext = async ()=>{\n            nextWasCalled = true;\n            // We pass a return handler to next(). When it is called by the engine,\n            // the consumer's async middleware will resume executing.\n            next((runReturnHandlersCallback)=>{\n                // This callback comes from JRPCEngine._runReturnHandlers\n                returnHandlerCallback = runReturnHandlersCallback;\n                resolveNextPromise();\n            });\n            await nextPromise;\n        };\n        try {\n            await asyncMiddleware(req, res, asyncNext);\n            if (nextWasCalled) {\n                await nextPromise; // we must wait until the return handler is called\n                returnHandlerCallback(null);\n            } else {\n                end(null);\n            }\n        } catch (error) {\n            if (returnHandlerCallback) {\n                returnHandlerCallback(error);\n            } else {\n                end(error);\n            }\n        }\n    };\n}\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */ class JRPCEngine extends SafeEventEmitter {\n    constructor(){\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_middleware\", void 0);\n        this._middleware = [];\n    }\n    /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */ static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack){\n            [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [\n            error,\n            isComplete,\n            returnHandlers.reverse()\n        ];\n    }\n    /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */ static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve)=>{\n            const end = (err)=>{\n                const error = err || res.error;\n                if (error) {\n                    res.error = (0,_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_4__.serializeError)(error);\n                }\n                // True indicates that the request should end\n                resolve([\n                    error,\n                    true\n                ]);\n            };\n            const next = (returnHandler)=>{\n                if (res.error) {\n                    end(res.error);\n                } else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== \"function\") {\n                            end(new SerializableError({\n                                code: -32603,\n                                message: \"JRPCEngine: 'next' return handlers must be functions\"\n                            }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([\n                        null,\n                        false\n                    ]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            } catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */ static async _runReturnHandlers(handlers) {\n        for (const handler of handlers){\n            await new Promise((resolve, reject)=>{\n                handler((err)=>err ? reject(err) : resolve());\n            });\n        }\n    }\n    /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */ static _checkForCompletion(req, res, isComplete) {\n        if (!(\"result\" in res) && !(\"error\" in res)) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Response has no error or result for request\"\n            });\n        }\n        if (!isComplete) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Nothing ended request\"\n            });\n        }\n    }\n    /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */ push(middleware) {\n        this._middleware.push(middleware);\n    }\n    handle(req, cb) {\n        if (cb && typeof cb !== \"function\") {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */ asMiddleware() {\n        return async (req, res, next, end)=>{\n            try {\n                const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JRPCEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback)=>{\n                    try {\n                        await JRPCEngine._runReturnHandlers(returnHandlers);\n                    } catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            } catch (error) {\n                return end(error);\n            }\n        };\n    }\n    async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(// 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        } catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n   * A promise-wrapped _handle.\n   */ _promiseHandle(req) {\n        return new Promise((resolve)=>{\n            this._handle(req, (_err, res)=>{\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                resolve(res);\n            });\n        });\n    }\n    /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */ async _handle(callerReq, cb) {\n        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"request must be plain object\"\n            });\n            return cb(error, {\n                id: undefined,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        if (typeof callerReq.method !== \"string\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"method must be string\"\n            });\n            return cb(error, {\n                id: callerReq.id,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        const req = _objectSpread$1({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        } catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                res.error = (0,_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_4__.serializeError)(error);\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */ async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JRPCEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JRPCEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n}\nfunction mergeMiddleware(middlewareStack) {\n    const engine = new JRPCEngine();\n    middlewareStack.forEach((middleware)=>engine.push(middleware));\n    return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n    if (!opts || !opts.engine) {\n        throw new Error(\"Missing engine parameter!\");\n    }\n    const { engine } = opts;\n    // eslint-disable-next-line prefer-const\n    let stream;\n    function read() {\n        return undefined;\n    }\n    function write(req, _encoding, cb) {\n        engine.handle(req, (_err, res)=>{\n            stream.push(res);\n        });\n        cb();\n    }\n    stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read,\n        write\n    });\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            stream.push(message);\n        });\n    }\n    return stream;\n}\nfunction providerFromEngine(engine) {\n    const provider = new SafeEventEmitter();\n    // handle both rpc send methods\n    provider.sendAsync = async (req)=>{\n        const res = await engine.handle(req);\n        if (res.error) {\n            var _res$error, _res$error2;\n            const err = (0,_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_4__.serializeError)(res.error, {\n                fallbackError: {\n                    message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n                    code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n                }\n            });\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_4__.rpcErrors.internal(err);\n        }\n        return res.result;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    provider.send = (req, callback)=>{\n        if (typeof callback !== \"function\") {\n            throw new Error('Must provide callback to \"send\" method.');\n        }\n        engine.handle(req, callback);\n    };\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            provider.emit(\"data\", null, message);\n        });\n    }\n    provider.request = async (args)=>{\n        const req = _objectSpread$1(_objectSpread$1({}, args), {}, {\n            id: Math.random().toString(36).slice(2),\n            jsonrpc: \"2.0\"\n        });\n        const res = await provider.sendAsync(req);\n        return res;\n    };\n    return provider;\n}\nfunction providerFromMiddleware(middleware) {\n    const engine = new JRPCEngine();\n    engine.push(middleware);\n    const provider = providerFromEngine(engine);\n    return provider;\n}\nfunction providerAsMiddleware(provider) {\n    return async (req, res, _next, end)=>{\n        // send request to provider\n        try {\n            const providerRes = await provider.sendAsync(req);\n            res.result = providerRes;\n            return end();\n        } catch (error) {\n            return end(error.message);\n        }\n    };\n}\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { parent, name } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_parent\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        this._parent = parent;\n        this._name = name;\n    }\n    /**\n   * Explicitly sets read operations to a no-op.\n   */ _read() {\n        return undefined;\n    }\n    /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */ _write(chunk, _encoding, callback) {\n        this._parent.push({\n            name: this._name,\n            data: chunk\n        });\n        callback();\n    }\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(){\n        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super(_objectSpread(_objectSpread({}, opts), {}, {\n            objectMode: true\n        }));\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_substreams\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getStream\", void 0);\n        this._substreams = {};\n    }\n    createStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // create substream\n        const substream = new Substream({\n            parent: this,\n            name\n        });\n        this._substreams[name] = substream;\n        // listen for parent stream to end\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        anyStreamEnd(this, (_error)=>substream.destroy(_error || undefined));\n        return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n    ignoreStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // set\n        this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n    _read() {\n        return undefined;\n    }\n    _write(chunk, _encoding, callback) {\n        const { name, data } = chunk;\n        if (!name) {\n            window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n            return callback();\n        }\n        // get corresponding substream\n        const substream = this._substreams[name];\n        if (!substream) {\n            window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n            return callback();\n        }\n        // push data into substream\n        if (substream !== IGNORE_SUBSTREAM) {\n            substream.push(data);\n        }\n        return callback();\n    }\n}\n// util\nfunction anyStreamEnd(stream, _cb) {\n    const cb = once__WEBPACK_IMPORTED_MODULE_6___default()(_cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        readable: false\n    }, cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        writable: false\n    }, cb);\n}\nfunction setupMultiplex(stream) {\n    const mux = new ObjectMultiplex();\n    mux.getStream = function streamHelper(name) {\n        if (this._substreams[name]) {\n            return this._substreams[name];\n        }\n        return this.createStream(name);\n    };\n    pump__WEBPACK_IMPORTED_MODULE_7___default()(stream, mux, stream, (err)=>{\n        if (err) window.console.error(err);\n    });\n    return mux;\n}\nclass PostMessageStream extends BasePostMessageStream {\n    _postMessage(data) {\n        let originConstraint = this._targetOrigin;\n        if (typeof data === \"object\") {\n            const dataObj = data;\n            if (typeof dataObj.data === \"object\") {\n                const dataObjData = dataObj.data;\n                if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n                    const dataObjDataParam = dataObjData.params[0];\n                    if (dataObjDataParam._origin) {\n                        originConstraint = dataObjDataParam._origin;\n                    }\n                    // add a constraint for the response\n                    dataObjDataParam._origin = window.location.origin;\n                }\n            }\n        }\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n}\n //# sourceMappingURL=openloginJrpc.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvZGlzdC9vcGVubG9naW5KcnBjLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDM0I7QUFDSDtBQUNNO0FBQ3FCO0FBQ2pDO0FBQ1I7QUFDQTtBQUV4QixTQUFTUztJQUNQLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNQyxNQUFNO0FBQ1osTUFBTUMsTUFBTTtBQUNaLE1BQU1DLE1BQU07QUFDWixNQUFNQyw4QkFBOEJiLG1EQUFNQTtJQUN4Q2MsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLGVBQWVDLE1BQU0sRUFDckJDLGVBQWUsR0FBRyxFQUNuQixHQUFHTDtRQUNKLEtBQUssQ0FBQztZQUNKTSxZQUFZO1FBQ2Q7UUFDQXRCLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxXQUFXLEtBQUs7UUFDdENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsS0FBSztRQUM1Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsY0FBYyxLQUFLO1FBQ3pDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLEtBQUs7UUFDN0MsSUFBSSxDQUFDaUIsUUFBUSxDQUFDQyxRQUFRO1lBQ3BCLE1BQU0sSUFBSUssTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdUO1FBQ2IsSUFBSSxDQUFD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QUFDa00sV0FBVyxDQUFDbE0sS0FBSyxFQUFFO1lBQzFCLE9BQU8sSUFBSSxDQUFDa00sV0FBVyxDQUFDbE0sS0FBSztRQUMvQjtRQUNBLE9BQU8sSUFBSSxDQUFDbU0sWUFBWSxDQUFDbk07SUFDM0I7SUFDQVQsMkNBQUlBLENBQUM0RyxRQUFRMkcsS0FBSzNHLFFBQVF6RSxDQUFBQTtRQUN4QixJQUFJQSxLQUFLdkIsT0FBT3FNLE9BQU8sQ0FBQzdJLEtBQUssQ0FBQ2pDO0lBQ2hDO0lBQ0EsT0FBT29MO0FBQ1Q7QUFFQSxNQUFNRywwQkFBMEJwTjtJQUM5QitCLGFBQWFMLElBQUksRUFBRTtRQUNqQixJQUFJTSxtQkFBbUIsSUFBSSxDQUFDakIsYUFBYTtRQUN6QyxJQUFJLE9BQU9XLFNBQVMsVUFBVTtZQUM1QixNQUFNMkwsVUFBVTNMO1lBQ2hCLElBQUksT0FBTzJMLFFBQVEzTCxJQUFJLEtBQUssVUFBVTtnQkFDcEMsTUFBTTRMLGNBQWNELFFBQVEzTCxJQUFJO2dCQUNoQyxJQUFJNkIsTUFBTXlCLE9BQU8sQ0FBQ3NJLFlBQVlDLE1BQU0sS0FBS0QsWUFBWUMsTUFBTSxDQUFDbEssTUFBTSxHQUFHLEdBQUc7b0JBQ3RFLE1BQU1tSyxtQkFBbUJGLFlBQVlDLE1BQU0sQ0FBQyxFQUFFO29CQUM5QyxJQUFJQyxpQkFBaUJDLE9BQU8sRUFBRTt3QkFDNUJ6TCxtQkFBbUJ3TCxpQkFBaUJDLE9BQU87b0JBQzdDO29CQUNBLG9DQUFvQztvQkFDcENELGlCQUFpQkMsT0FBTyxHQUFHbk4sT0FBT29OLFFBQVEsQ0FBQ3RMLE1BQU07Z0JBQ25EO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ3RCLGFBQWEsQ0FBQ21CLFdBQVcsQ0FBQztZQUM3QjdCLFFBQVEsSUFBSSxDQUFDUyxPQUFPO1lBQ3BCYTtRQUNGLEdBQUdNO0lBQ0w7QUFDRjtBQUVrYixDQUNsYiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvZGlzdC9vcGVubG9naW5KcnBjLmVzbS5qcz81Mzg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBEdXBsZXggfSBmcm9tICdyZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnZmFzdC1zYWZlLXN0cmluZ2lmeSc7XG5pbXBvcnQgeyBzZXJpYWxpemVFcnJvciwgcnBjRXJyb3JzIH0gZnJvbSAnQG1ldGFtYXNrL3JwYy1lcnJvcnMnO1xuaW1wb3J0IGVvcyBmcm9tICdlbmQtb2Ytc3RyZWFtJztcbmltcG9ydCBvbmNlIGZyb20gJ29uY2UnO1xuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBTWU4gPSBcIlNZTlwiO1xuY29uc3QgQUNLID0gXCJBQ0tcIjtcbmNvbnN0IEJSSyA9IFwiQlJLXCI7XG5jbGFzcyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0gZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0YXJnZXRXaW5kb3cgPSB3aW5kb3csXG4gICAgICB0YXJnZXRPcmlnaW4gPSBcIipcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW5pdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYXZlU3luXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFdpbmRvd1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRPcmlnaW5cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25NZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N5bkludGVydmFsSWRcIiwgdm9pZCAwKTtcbiAgICBpZiAoIW5hbWUgfHwgIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XG4gICAgfVxuICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0OyAvLyB0YXJnZXQgb3JpZ2luXG4gICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gdGFyZ2V0V2luZG93O1xuICAgIHRoaXMuX3RhcmdldE9yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICB0aGlzLl9vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N5bkludGVydmFsSWQgPSBudWxsO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICB0aGlzLl9oYW5kU2hha2UoKTtcbiAgfVxuICBfYnJlYWsoKSB7XG4gICAgdGhpcy5jb3JrKCk7XG4gICAgdGhpcy5fd3JpdGUoQlJLLCBudWxsLCBub29wKTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuICB9XG4gIF9oYW5kU2hha2UoKSB7XG4gICAgdGhpcy5fd3JpdGUoU1lOLCBudWxsLCBub29wKTtcbiAgICB0aGlzLmNvcmsoKTtcbiAgfVxuICBfb25EYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2luaXQpIHtcbiAgICAgIC8vIGxpc3RlbiBmb3IgaGFuZHNoYWtlXG4gICAgICBpZiAoZGF0YSA9PT0gU1lOKSB7XG4gICAgICAgIHRoaXMuX2hhdmVTeW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBBQ0spIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faGF2ZVN5bikge1xuICAgICAgICAgIHRoaXMuX3dyaXRlKEFDSywgbnVsbCwgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEJSSykge1xuICAgICAgdGhpcy5fYnJlYWsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yd2FyZCBtZXNzYWdlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBvcmlnaW5Db25zdHJhaW50ID0gdGhpcy5fdGFyZ2V0T3JpZ2luO1xuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGRhdGFcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcbiAgfVxuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgaWYgKHRoaXMuX3RhcmdldE9yaWdpbiAhPT0gXCIqXCIgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl90YXJnZXRPcmlnaW4gfHwgZXZlbnQuc291cmNlICE9PSB0aGlzLl90YXJnZXRXaW5kb3cgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZS50YXJnZXQgIT09IHRoaXMuX25hbWUgfHwgIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vbkRhdGEobWVzc2FnZS5kYXRhKTtcbiAgfVxuICBfcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIF93cml0ZShkYXRhLCBfLCBjYikge1xuICAgIHRoaXMuX3Bvc3RNZXNzYWdlKGRhdGEpO1xuICAgIGNiKCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uTWVzc2FnZSwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgY29uc3QgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuY2xhc3MgU2FmZUV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGVtaXQodHlwZSkge1xuICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gXCJlcnJvclwiO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgbGV0IGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBbZXJdID0gYXJncztcbiAgICAgIH1cbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5oYW5kbGVkIGVycm9yLiR7ZXIgPyBgICgke2VyLm1lc3NhZ2V9KWAgOiBcIlwifWApO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuY2xhc3MgU2VyaWFsaXphYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2RlIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXNzYWdlIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeSh7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGdldFJwY1Byb21pc2VDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgbGV0IHVud3JhcFJlc3VsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgcmV0dXJuIChlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICBpZiAoZXJyb3IgfHwgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvciB8fCByZXNwb25zZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmICghdW53cmFwUmVzdWx0IHx8IEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVFcnJvck1pZGRsZXdhcmUobG9nKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcbiAgICAgIGlmICh0eXBlb2YgcmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhcmVxLm1ldGhvZCkge1xuICAgICAgICByZXMuZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgICBtZXNzYWdlOiBcImludmFsaWQgbWV0aG9kXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXh0KGRvbmUgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IHJlcztcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLmVycm9yKGBPcGVuTG9naW4gLSBSUEMgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGBPcGVuTG9naW4gLSBSUEMgRXJyb3IgdGhyb3duOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgcmVzLmVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUoKSB7XG4gIGNvbnN0IGlkTWFwID0ge307XG4gIGZ1bmN0aW9uIHJlYWROb29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBldmVudHMgPSBuZXcgU2FmZUV2ZW50RW1pdHRlcigpO1xuICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF07XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmVhbU1pZGRsZXdhcmUgLSBVbmtub3duIHJlc3BvbnNlIGlkIFwiJHtyZXMuaWR9XCJgKTtcbiAgICB9XG4gICAgZGVsZXRlIGlkTWFwW3Jlcy5pZF07XG4gICAgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXNcbiAgICBPYmplY3QuYXNzaWduKGNvbnRleHQucmVzLCByZXMpO1xuICAgIC8vIHJ1biBjYWxsYmFjayBvbiBlbXB0eSBzdGFjayxcbiAgICAvLyBwcmV2ZW50IGludGVybmFsIHN0cmVhbS1oYW5kbGVyIGZyb20gY2F0Y2hpbmcgZXJyb3JzXG4gICAgc2V0VGltZW91dChjb250ZXh0LmVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpIHtcbiAgICBldmVudHMuZW1pdChcIm5vdGlmaWNhdGlvblwiLCByZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKHJlcywgX2VuY29kaW5nLCBjYikge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzTm90aWZpY2F0aW9uID0gIXJlcy5pZDtcbiAgICAgIGlmIChpc05vdGlmaWNhdGlvbikge1xuICAgICAgICBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzUmVzcG9uc2UocmVzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICBlcnIgPSBfZXJyO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nIHN0cmVhbVxuICAgIGNiKGVycik7XG4gIH1cbiAgY29uc3Qgc3RyZWFtID0gbmV3IER1cGxleCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICByZWFkOiByZWFkTm9vcCxcbiAgICB3cml0ZTogcHJvY2Vzc01lc3NhZ2VcbiAgfSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIC8vIHdyaXRlIHJlcSB0byBzdHJlYW1cbiAgICBzdHJlYW0ucHVzaChyZXEpO1xuICAgIC8vIHJlZ2lzdGVyIHJlcXVlc3Qgb24gaWQgbWFwXG4gICAgaWRNYXBbcmVxLmlkXSA9IHtcbiAgICAgIHJlcSxcbiAgICAgIHJlcyxcbiAgICAgIG5leHQsXG4gICAgICBlbmRcbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGV2ZW50cyxcbiAgICBtaWRkbGV3YXJlLFxuICAgIHN0cmVhbVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKGhhbmRsZXJzKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tyZXEubWV0aG9kXTtcbiAgICAvLyBpZiBubyBoYW5kbGVyLCByZXR1cm5cbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICAvLyBpZiBoYW5kbGVyIGlzIGZuLCBjYWxsIGFzIG1pZGRsZXdhcmVcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgfVxuICAgIC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxuICAgIHJlcy5yZXN1bHQgPSBoYW5kbGVyO1xuICAgIHJldHVybiBlbmQoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxJZCA9IHJlcS5pZDtcbiAgICBjb25zdCBuZXdJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuICAgIHJlcS5pZCA9IG5ld0lkO1xuICAgIHJlcy5pZCA9IG5ld0lkO1xuICAgIG5leHQoZG9uZSA9PiB7XG4gICAgICByZXEuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgcmVzLmlkID0gb3JpZ2luYWxJZDtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUobG9nZ2VyKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIF8pID0+IHtcbiAgICBsb2dnZXIuZGVidWcoXCJSRVFcIiwgcmVxLCBcIlJFU1wiLCByZXMpO1xuICAgIG5leHQoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luY01pZGRsZXdhcmUpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gbmV4dFByb21pc2UgaXMgdGhlIGtleSB0byB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAvLyBpdCBpcyByZXNvbHZlZCBieSB0aGUgcmV0dXJuIGhhbmRsZXIgcGFzc2VkIHRvIHRoZVxuICAgIC8vIFwibmV4dFwiIGZ1bmN0aW9uXG4gICAgbGV0IHJlc29sdmVOZXh0UHJvbWlzZTtcbiAgICBjb25zdCBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmVzb2x2ZU5leHRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBsZXQgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gbnVsbDtcbiAgICBsZXQgbmV4dFdhc0NhbGxlZCA9IGZhbHNlO1xuICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgdGhlIGNvbnN1bWVyJ3MgYXN5bmMgbWlkZGxld2FyZS5cbiAgICBjb25zdCBhc3luY05leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBuZXh0V2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIC8vIFdlIHBhc3MgYSByZXR1cm4gaGFuZGxlciB0byBuZXh0KCkuIFdoZW4gaXQgaXMgY2FsbGVkIGJ5IHRoZSBlbmdpbmUsXG4gICAgICAvLyB0aGUgY29uc3VtZXIncyBhc3luYyBtaWRkbGV3YXJlIHdpbGwgcmVzdW1lIGV4ZWN1dGluZy5cbiAgICAgIG5leHQocnVuUmV0dXJuSGFuZGxlcnNDYWxsYmFjayA9PiB7XG4gICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgY29tZXMgZnJvbSBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVyc1xuICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrO1xuICAgICAgICByZXNvbHZlTmV4dFByb21pc2UoKTtcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbmV4dFByb21pc2U7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXN5bmNNaWRkbGV3YXJlKHJlcSwgcmVzLCBhc3luY05leHQpO1xuICAgICAgaWYgKG5leHRXYXNDYWxsZWQpIHtcbiAgICAgICAgYXdhaXQgbmV4dFByb21pc2U7IC8vIHdlIG11c3Qgd2FpdCB1bnRpbCB0aGUgcmV0dXJuIGhhbmRsZXIgaXMgY2FsbGVkXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZChudWxsKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHJldHVybkhhbmRsZXJDYWxsYmFjaykge1xuICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcbiAqIEEgSlNPTi1SUEMgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcHJvY2Vzc29yLlxuICogR2l2ZSBpdCBhIHN0YWNrIG9mIG1pZGRsZXdhcmUsIHBhc3MgaXQgcmVxdWVzdHMsIGFuZCBnZXQgYmFjayByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEpSUENFbmdpbmUgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWlkZGxld2FyZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX21pZGRsZXdhcmUgPSBbXTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsbHkgZXhlY3V0ZXMgdGhlIGdpdmVuIHN0YWNrIG9mIG1pZGRsZXdhcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdXRpb24sXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZCwgYW5kIGFuIGFycmF5IG9mXG4gICAqIG1pZGRsZXdhcmUtZGVmaW5lZCByZXR1cm4gaGFuZGxlcnMuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmVTdGFjaykge1xuICAgIGNvbnN0IHJldHVybkhhbmRsZXJzID0gW107XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBsZXQgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIC8vIEdvIGRvd24gc3RhY2sgb2YgbWlkZGxld2FyZSwgY2FsbCBhbmQgY29sbGVjdCBvcHRpb25hbCByZXR1cm5IYW5kbGVyc1xuICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlU3RhY2spIHtcbiAgICAgIFtlcnJvciwgaXNDb21wbGV0ZV0gPSBhd2FpdCBKUlBDRW5naW5lLl9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycyk7XG4gICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtlcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnMucmV2ZXJzZSgpXTtcbiAgfVxuICAvKipcbiAgICogUnVucyBhbiBpbmRpdmlkdWFsIG1pZGRsZXdhcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdGlvbixcbiAgICogYW5kIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc2hvdWxkIGVuZC5cbiAgICovXG4gIHN0YXRpYyBfcnVuTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZSwgcmV0dXJuSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBlbmQgPSBlcnIgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IGVyciB8fCByZXMuZXJyb3I7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBlbmRcbiAgICAgICAgcmVzb2x2ZShbZXJyb3IsIHRydWVdKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXh0ID0gcmV0dXJuSGFuZGxlciA9PiB7XG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICBlbmQocmVzLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmV0dXJuSGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXR1cm5IYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZW5kKG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSlJQQ0VuZ2luZTogJ25leHQnIHJldHVybiBoYW5kbGVycyBtdXN0IGJlIGZ1bmN0aW9uc1wiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybkhhbmRsZXJzLnB1c2gocmV0dXJuSGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBub3QgZW5kXG4gICAgICAgICAgcmVzb2x2ZShbbnVsbCwgZmFsc2VdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxseSBleGVjdXRlcyBhcnJheSBvZiByZXR1cm4gaGFuZGxlcnMuIFRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBhcmVcbiAgICogYXNzdW1lZCB0byBiZSBpbiB0aGVpciBzY29wZS5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBfcnVuUmV0dXJuSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaGFuZGxlcihlcnIgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciwgb3IgaWZcbiAgICogdGhlIFwiaXNDb21wbGV0ZVwiIGZsYWcgaXMgZmFsc3kuXG4gICAqL1xuICBzdGF0aWMgX2NoZWNrRm9yQ29tcGxldGlvbihyZXEsIHJlcywgaXNDb21wbGV0ZSkge1xuICAgIGlmICghKFwicmVzdWx0XCIgaW4gcmVzKSAmJiAhKFwiZXJyb3JcIiBpbiByZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwiUmVzcG9uc2UgaGFzIG5vIGVycm9yIG9yIHJlc3VsdCBmb3IgcmVxdWVzdFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0NvbXBsZXRlKSB7XG4gICAgICB0aHJvdyBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwiTm90aGluZyBlbmRlZCByZXF1ZXN0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0byB0aGUgZW5naW5lJ3MgbWlkZGxld2FyZSBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIG1pZGRsZXdhcmUgLSBUaGUgbWlkZGxld2FyZSBmdW5jdGlvbiB0byBhZGQuXG4gICAqL1xuICBwdXNoKG1pZGRsZXdhcmUpIHtcbiAgICB0aGlzLl9taWRkbGV3YXJlLnB1c2gobWlkZGxld2FyZSk7XG4gIH1cbiAgaGFuZGxlKHJlcSwgY2IpIHtcbiAgICBpZiAoY2IgJiYgdHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjYWxsYmFja1wiIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVxKSkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVCYXRjaChyZXEsIGNiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVCYXRjaChyZXEpO1xuICAgIH1cbiAgICBpZiAoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGUocmVxLCBjYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlSGFuZGxlKHJlcSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHB1c2hlZCB0byBvdGhlclxuICAgKiBlbmdpbmVzLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGlzIGVuZ2luZSBhcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24uXG4gICAqL1xuICBhc01pZGRsZXdhcmUoKSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbbWlkZGxld2FyZUVycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVyc10gPSBhd2FpdCBKUlBDRW5naW5lLl9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCB0aGlzLl9taWRkbGV3YXJlKTtcbiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgcmV0dXJuIGVuZChtaWRkbGV3YXJlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGFzeW5jIGhhbmRsZXJDYWxsYmFjayA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJDYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIF9oYW5kbGVCYXRjaChyZXFzLCBjYikge1xuICAgIC8vIFRoZSBvcmRlciBoZXJlIGlzIGltcG9ydGFudFxuICAgIHRyeSB7XG4gICAgICAvLyAyLiBXYWl0IGZvciBhbGwgcmVxdWVzdHMgdG8gZmluaXNoLCBvciB0aHJvdyBvbiBzb21lIGtpbmQgb2YgZmF0YWxcbiAgICAgIC8vIGVycm9yXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIC8vIDEuIEJlZ2luIGV4ZWN1dGluZyBlYWNoIHJlcXVlc3QgaW4gdGhlIG9yZGVyIHJlY2VpdmVkXG4gICAgICByZXFzLm1hcCh0aGlzLl9wcm9taXNlSGFuZGxlLmJpbmQodGhpcykpKTtcbiAgICAgIC8vIDMuIFJldHVybiBiYXRjaCByZXNwb25zZVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihudWxsLCByZXNwb25zZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihlcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEEgcHJvbWlzZS13cmFwcGVkIF9oYW5kbGUuXG4gICAqL1xuICBfcHJvbWlzZUhhbmRsZShyZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICAgIC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGEgcmVzcG9uc2UsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXZlIGFueSBlcnJvclxuICAgICAgICAvLyB0aGF0IGlzIGNhdWdodCBhbmQgcHJvcGFnYXRlZC5cbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgcmVxdWVzdCBvYmplY3QgaXMgdmFsaWQsIHByb2Nlc3NlcyBpdCwgYW5kIHBhc3NlcyBhbnlcbiAgICogZXJyb3IgYW5kIHRoZSByZXNwb25zZSBvYmplY3QgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgKlxuICAgKiBEb2VzIG5vdCByZWplY3QuXG4gICAqL1xuICBhc3luYyBfaGFuZGxlKGNhbGxlclJlcSwgY2IpIHtcbiAgICBpZiAoIWNhbGxlclJlcSB8fCBBcnJheS5pc0FycmF5KGNhbGxlclJlcSkgfHwgdHlwZW9mIGNhbGxlclJlcSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwicmVxdWVzdCBtdXN0IGJlIHBsYWluIG9iamVjdFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYihlcnJvciwge1xuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGVyUmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWV0aG9kIG11c3QgYmUgc3RyaW5nXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKGVycm9yLCB7XG4gICAgICAgIGlkOiBjYWxsZXJSZXEuaWQsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVxID0gX29iamVjdFNwcmVhZCQxKHt9LCBjYWxsZXJSZXEpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGlkOiByZXEuaWQsXG4gICAgICBqc29ucnBjOiByZXEuanNvbnJwY1xuICAgIH07XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgLy8gQSByZXF1ZXN0IGhhbmRsZXIgZXJyb3IsIGEgcmUtdGhyb3duIG1pZGRsZXdhcmUgZXJyb3IsIG9yIHNvbWV0aGluZ1xuICAgICAgLy8gdW5leHBlY3RlZC5cbiAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIC8vIEVuc3VyZSBubyByZXN1bHQgaXMgcHJlc2VudCBvbiBhbiBlcnJvcmVkIHJlc3BvbnNlXG4gICAgICBkZWxldGUgcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzLmVycm9yKSB7XG4gICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNiKGVycm9yLCByZXMpO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIHJlcXVlc3QgYW5kIHJlc3BvbnNlLCBydW5zIGFsbCBtaWRkbGV3YXJlIGFuZCB0aGVpciByZXR1cm5cbiAgICogaGFuZGxlcnMsIGlmIGFueSwgYW5kIGVuc3VyZXMgdGhhdCBpbnRlcm5hbCByZXF1ZXN0IHByb2Nlc3Npbmcgc2VtYW50aWNzXG4gICAqIGFyZSBzYXRpc2ZpZWQuXG4gICAqL1xuICBhc3luYyBfcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpIHtcbiAgICBjb25zdCBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuICAgIC8vIFRocm93IGlmIFwiZW5kXCIgd2FzIG5vdCBjYWxsZWQsIG9yIGlmIHRoZSByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdFxuICAgIC8vIG5vciBhbiBlcnJvci5cbiAgICBKUlBDRW5naW5lLl9jaGVja0ZvckNvbXBsZXRpb24ocmVxLCByZXMsIGlzQ29tcGxldGUpO1xuICAgIC8vIFRoZSByZXR1cm4gaGFuZGxlcnMgc2hvdWxkIHJ1biBldmVuIGlmIGFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCBkdXJpbmdcbiAgICAvLyBtaWRkbGV3YXJlIHByb2Nlc3NpbmcuXG4gICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgIC8vIE5vdyB3ZSByZS10aHJvdyB0aGUgbWlkZGxld2FyZSBwcm9jZXNzaW5nIGVycm9yLCBpZiBhbnksIHRvIGNhdGNoIGl0XG4gICAgLy8gZnVydGhlciB1cCB0aGUgY2FsbCBjaGFpbi5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VNaWRkbGV3YXJlKG1pZGRsZXdhcmVTdGFjaykge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICBtaWRkbGV3YXJlU3RhY2suZm9yRWFjaChtaWRkbGV3YXJlID0+IGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpKTtcbiAgcmV0dXJuIGVuZ2luZS5hc01pZGRsZXdhcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZVN0cmVhbShvcHRzKSB7XG4gIGlmICghb3B0cyB8fCAhb3B0cy5lbmdpbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVuZ2luZSBwYXJhbWV0ZXIhXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBlbmdpbmVcbiAgfSA9IG9wdHM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHN0cmVhbTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlKHJlcSwgX2VuY29kaW5nLCBjYikge1xuICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICBzdHJlYW0ucHVzaChyZXMpO1xuICAgIH0pO1xuICAgIGNiKCk7XG4gIH1cbiAgc3RyZWFtID0gbmV3IER1cGxleCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICByZWFkLFxuICAgIHdyaXRlXG4gIH0pO1xuICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgaWYgKGVuZ2luZS5vbikge1xuICAgIGVuZ2luZS5vbihcIm5vdGlmaWNhdGlvblwiLCBtZXNzYWdlID0+IHtcbiAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdHJlYW07XG59XG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IFNhZmVFdmVudEVtaXR0ZXIoKTtcbiAgLy8gaGFuZGxlIGJvdGggcnBjIHNlbmQgbWV0aG9kc1xuICBwcm92aWRlci5zZW5kQXN5bmMgPSBhc3luYyByZXEgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGVuZ2luZS5oYW5kbGUocmVxKTtcbiAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICB2YXIgX3JlcyRlcnJvciwgX3JlcyRlcnJvcjI7XG4gICAgICBjb25zdCBlcnIgPSBzZXJpYWxpemVFcnJvcihyZXMuZXJyb3IsIHtcbiAgICAgICAgZmFsbGJhY2tFcnJvcjoge1xuICAgICAgICAgIG1lc3NhZ2U6ICgoX3JlcyRlcnJvciA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvci5tZXNzYWdlKSB8fCByZXMuZXJyb3IudG9TdHJpbmcoKSxcbiAgICAgICAgICBjb2RlOiAoKF9yZXMkZXJyb3IyID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjIuY29kZSkgfHwgLTMyNjAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKGVycik7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBwcm92aWRlci5zZW5kID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGNhbGxiYWNrIHRvIFwic2VuZFwiIG1ldGhvZC4nKTtcbiAgICB9XG4gICAgZW5naW5lLmhhbmRsZShyZXEsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gIGlmIChlbmdpbmUub24pIHtcbiAgICBlbmdpbmUub24oXCJub3RpZmljYXRpb25cIiwgbWVzc2FnZSA9PiB7XG4gICAgICBwcm92aWRlci5lbWl0KFwiZGF0YVwiLCBudWxsLCBtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBwcm92aWRlci5yZXF1ZXN0ID0gYXN5bmMgYXJncyA9PiB7XG4gICAgY29uc3QgcmVxID0gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgYXJncyksIHt9LCB7XG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXG4gICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gIGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpO1xuICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICByZXR1cm4gcHJvdmlkZXI7XG59XG5mdW5jdGlvbiBwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyUmVzID0gYXdhaXQgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSk7XG4gICAgICByZXMucmVzdWx0ID0gcHJvdmlkZXJSZXM7XG4gICAgICByZXR1cm4gZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlbmQoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG5jbGFzcyBTdWJzdHJlYW0gZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcmVudCxcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBFeHBsaWNpdGx5IHNldHMgcmVhZCBvcGVyYXRpb25zIHRvIGEgbm8tb3AuXG4gICAqL1xuICBfcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkYXRhIHNob3VsZCBiZSB3cml0dGVuIHRvIHRoaXMgd3JpdGFibGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0gY2h1bmsgLSBBcmJpdHJhcnkgb2JqZWN0IHRvIHdyaXRlXG4gICAqIEBwYXJhbSBlbmNvZGluZyAtIEVuY29kaW5nIHRvIHVzZSB3aGVuIHdyaXRpbmcgcGF5bG9hZFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsZWQgd2hlbiB3cml0aW5nIGlzIGNvbXBsZXRlIG9yIGFuIGVycm9yIG9jY3Vyc1xuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcGFyZW50LnB1c2goe1xuICAgICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICAgIGRhdGE6IGNodW5rXG4gICAgfSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmNvbnN0IElHTk9SRV9TVUJTVFJFQU0gPSBTeW1ib2woXCJJR05PUkVfU1VCU1RSRUFNXCIpO1xuY2xhc3MgT2JqZWN0TXVsdGlwbGV4IGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0cyksIHt9LCB7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdWJzdHJlYW1zXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0U3RyZWFtXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fc3Vic3RyZWFtcyA9IHt9O1xuICB9XG4gIGNyZWF0ZVN0cmVhbShuYW1lKSB7XG4gICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW1cbiAgICBjb25zdCBzdWJzdHJlYW0gPSBuZXcgU3Vic3RyZWFtKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gc3Vic3RyZWFtO1xuICAgIC8vIGxpc3RlbiBmb3IgcGFyZW50IHN0cmVhbSB0byBlbmRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgYW55U3RyZWFtRW5kKHRoaXMsIF9lcnJvciA9PiBzdWJzdHJlYW0uZGVzdHJveShfZXJyb3IgfHwgdW5kZWZpbmVkKSk7XG4gICAgcmV0dXJuIHN1YnN0cmVhbTtcbiAgfVxuICAvLyBpZ25vcmUgc3RyZWFtcyAoZG9udCBkaXNwbGF5IG9ycGhhbmVkIGRhdGEgd2FybmluZylcbiAgaWdub3JlU3RyZWFtKG5hbWUpIHtcbiAgICAvLyB2YWxpZGF0ZSBuYW1lXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3RNdWx0aXBsZXggLSBTdWJzdHJlYW0gZm9yIG5hbWUgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgLy8gc2V0XG4gICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IElHTk9SRV9TVUJTVFJFQU07XG4gIH1cbiAgX3JlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZGF0YVxuICAgIH0gPSBjaHVuaztcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG1hbGZvcm1lZCBjaHVuayB3aXRob3V0IG5hbWUgXCIke2NodW5rfVwiYCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gZ2V0IGNvcnJlc3BvbmRpbmcgc3Vic3RyZWFtXG4gICAgY29uc3Qgc3Vic3RyZWFtID0gdGhpcy5fc3Vic3RyZWFtc1tuYW1lXTtcbiAgICBpZiAoIXN1YnN0cmVhbSkge1xuICAgICAgd2luZG93LmNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gb3JwaGFuZWQgZGF0YSBmb3Igc3RyZWFtIFwiJHtuYW1lfVwiYCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gcHVzaCBkYXRhIGludG8gc3Vic3RyZWFtXG4gICAgaWYgKHN1YnN0cmVhbSAhPT0gSUdOT1JFX1NVQlNUUkVBTSkge1xuICAgICAgc3Vic3RyZWFtLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG59XG4vLyB1dGlsXG5mdW5jdGlvbiBhbnlTdHJlYW1FbmQoc3RyZWFtLCBfY2IpIHtcbiAgY29uc3QgY2IgPSBvbmNlKF9jYik7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogZmFsc2VcbiAgfSwgY2IpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sIGNiKTtcbn1cbmZ1bmN0aW9uIHNldHVwTXVsdGlwbGV4KHN0cmVhbSkge1xuICBjb25zdCBtdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7XG4gIG11eC5nZXRTdHJlYW0gPSBmdW5jdGlvbiBzdHJlYW1IZWxwZXIobmFtZSkge1xuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic3RyZWFtc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RyZWFtKG5hbWUpO1xuICB9O1xuICBwdW1wKHN0cmVhbSwgbXV4LCBzdHJlYW0sIGVyciA9PiB7XG4gICAgaWYgKGVycikgd2luZG93LmNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSk7XG4gIHJldHVybiBtdXg7XG59XG5cbmNsYXNzIFBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgQmFzZVBvc3RNZXNzYWdlU3RyZWFtIHtcbiAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICBsZXQgb3JpZ2luQ29uc3RyYWludCA9IHRoaXMuX3RhcmdldE9yaWdpbjtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGRhdGFPYmogPSBkYXRhO1xuICAgICAgaWYgKHR5cGVvZiBkYXRhT2JqLmRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgZGF0YU9iakRhdGEgPSBkYXRhT2JqLmRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFPYmpEYXRhLnBhcmFtcykgJiYgZGF0YU9iakRhdGEucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBkYXRhT2JqRGF0YVBhcmFtID0gZGF0YU9iakRhdGEucGFyYW1zWzBdO1xuICAgICAgICAgIGlmIChkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIG9yaWdpbkNvbnN0cmFpbnQgPSBkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFkZCBhIGNvbnN0cmFpbnQgZm9yIHRoZSByZXNwb25zZVxuICAgICAgICAgIGRhdGFPYmpEYXRhUGFyYW0uX29yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdGFyZ2V0V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgZGF0YVxuICAgIH0sIG9yaWdpbkNvbnN0cmFpbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSwgSUdOT1JFX1NVQlNUUkVBTSwgSlJQQ0VuZ2luZSwgT2JqZWN0TXVsdGlwbGV4LCBQb3N0TWVzc2FnZVN0cmVhbSwgU2FmZUV2ZW50RW1pdHRlciwgU2VyaWFsaXphYmxlRXJyb3IsIFN1YnN0cmVhbSwgY3JlYXRlQXN5bmNNaWRkbGV3YXJlLCBjcmVhdGVFbmdpbmVTdHJlYW0sIGNyZWF0ZUVycm9yTWlkZGxld2FyZSwgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUsIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSwgY3JlYXRlU3RyZWFtTWlkZGxld2FyZSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrLCBtZXJnZU1pZGRsZXdhcmUsIHByb3ZpZGVyQXNNaWRkbGV3YXJlLCBwcm92aWRlckZyb21FbmdpbmUsIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUsIHNldHVwTXVsdGlwbGV4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVubG9naW5KcnBjLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJEdXBsZXgiLCJFdmVudEVtaXR0ZXIiLCJzdHJpbmdpZnkiLCJzZXJpYWxpemVFcnJvciIsInJwY0Vycm9ycyIsImVvcyIsIm9uY2UiLCJwdW1wIiwibm9vcCIsInVuZGVmaW5lZCIsIlNZTiIsIkFDSyIsIkJSSyIsIkJhc2VQb3N0TWVzc2FnZVN0cmVhbSIsImNvbnN0cnVjdG9yIiwiX3JlZiIsIm5hbWUiLCJ0YXJnZXQiLCJ0YXJnZXRXaW5kb3ciLCJ3aW5kb3ciLCJ0YXJnZXRPcmlnaW4iLCJvYmplY3RNb2RlIiwiRXJyb3IiLCJfaW5pdCIsIl9oYXZlU3luIiwiX25hbWUiLCJfdGFyZ2V0IiwiX3RhcmdldFdpbmRvdyIsIl90YXJnZXRPcmlnaW4iLCJfb25NZXNzYWdlIiwib25NZXNzYWdlIiwiYmluZCIsIl9zeW5JbnRlcnZhbElkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9oYW5kU2hha2UiLCJfYnJlYWsiLCJjb3JrIiwiX3dyaXRlIiwiX29uRGF0YSIsImRhdGEiLCJ1bmNvcmsiLCJwdXNoIiwiZXJyIiwiZW1pdCIsIl9wb3N0TWVzc2FnZSIsIm9yaWdpbkNvbnN0cmFpbnQiLCJwb3N0TWVzc2FnZSIsImV2ZW50IiwibWVzc2FnZSIsIm9yaWdpbiIsInNvdXJjZSIsIl9yZWFkIiwiXyIsImNiIiwiX2Rlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2FmZUFwcGx5IiwiaGFuZGxlciIsImNvbnRleHQiLCJhcmdzIiwiUmVmbGVjdCIsImFwcGx5Iiwic2V0VGltZW91dCIsImFycmF5Q2xvbmUiLCJhcnIiLCJuIiwibGVuZ3RoIiwiY29weSIsIkFycmF5IiwiaSIsIlNhZmVFdmVudEVtaXR0ZXIiLCJ0eXBlIiwiZG9FcnJvciIsImV2ZW50cyIsIl9ldmVudHMiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJfa2V5IiwiZXIiLCJsZW4iLCJsaXN0ZW5lcnMiLCJTZXJpYWxpemFibGVFcnJvciIsImNvZGUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ0b1N0cmluZyIsInN0YWNrIiwiZ2V0UnBjUHJvbWlzZUNhbGxiYWNrIiwicmVzb2x2ZSIsInJlamVjdCIsInVud3JhcFJlc3VsdCIsInJlc3BvbnNlIiwiaXNBcnJheSIsInJlc3VsdCIsImNyZWF0ZUVycm9yTWlkZGxld2FyZSIsImxvZyIsInJlcSIsInJlcyIsIm5leHQiLCJlbmQiLCJtZXRob2QiLCJkb25lIiwiY3JlYXRlU3RyZWFtTWlkZGxld2FyZSIsImlkTWFwIiwicmVhZE5vb3AiLCJwcm9jZXNzUmVzcG9uc2UiLCJpZCIsIk9iamVjdCIsImFzc2lnbiIsInByb2Nlc3NOb3RpZmljYXRpb24iLCJwcm9jZXNzTWVzc2FnZSIsIl9lbmNvZGluZyIsImlzTm90aWZpY2F0aW9uIiwiX2VyciIsInN0cmVhbSIsInJlYWQiLCJ3cml0ZSIsIm1pZGRsZXdhcmUiLCJjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUiLCJoYW5kbGVycyIsImNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlIiwiX2VuZCIsIm9yaWdpbmFsSWQiLCJuZXdJZCIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUiLCJsb2dnZXIiLCJkZWJ1ZyIsImNyZWF0ZUFzeW5jTWlkZGxld2FyZSIsImFzeW5jTWlkZGxld2FyZSIsInJlc29sdmVOZXh0UHJvbWlzZSIsIm5leHRQcm9taXNlIiwiUHJvbWlzZSIsInJldHVybkhhbmRsZXJDYWxsYmFjayIsIm5leHRXYXNDYWxsZWQiLCJhc3luY05leHQiLCJydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrIiwib3duS2V5cyQxIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfb2JqZWN0U3ByZWFkJDEiLCJmb3JFYWNoIiwia2V5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIkpSUENFbmdpbmUiLCJfbWlkZGxld2FyZSIsIl9ydW5BbGxNaWRkbGV3YXJlIiwibWlkZGxld2FyZVN0YWNrIiwicmV0dXJuSGFuZGxlcnMiLCJpc0NvbXBsZXRlIiwiX3J1bk1pZGRsZXdhcmUiLCJyZXZlcnNlIiwicmV0dXJuSGFuZGxlciIsIl9ydW5SZXR1cm5IYW5kbGVycyIsIl9jaGVja0ZvckNvbXBsZXRpb24iLCJoYW5kbGUiLCJfaGFuZGxlQmF0Y2giLCJfaGFuZGxlIiwiX3Byb21pc2VIYW5kbGUiLCJhc01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlRXJyb3IiLCJoYW5kbGVyQ2FsbGJhY2siLCJyZXFzIiwicmVzcG9uc2VzIiwiYWxsIiwibWFwIiwiY2FsbGVyUmVxIiwianNvbnJwYyIsIl9wcm9jZXNzUmVxdWVzdCIsIl9lcnJvciIsIm1lcmdlTWlkZGxld2FyZSIsImVuZ2luZSIsImNyZWF0ZUVuZ2luZVN0cmVhbSIsIm9wdHMiLCJvbiIsInByb3ZpZGVyRnJvbUVuZ2luZSIsInByb3ZpZGVyIiwic2VuZEFzeW5jIiwiX3JlcyRlcnJvciIsIl9yZXMkZXJyb3IyIiwiZmFsbGJhY2tFcnJvciIsImludGVybmFsIiwic2VuZCIsImNhbGxiYWNrIiwicmVxdWVzdCIsInByb3ZpZGVyRnJvbU1pZGRsZXdhcmUiLCJwcm92aWRlckFzTWlkZGxld2FyZSIsIl9uZXh0IiwicHJvdmlkZXJSZXMiLCJTdWJzdHJlYW0iLCJwYXJlbnQiLCJfcGFyZW50IiwiY2h1bmsiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsIklHTk9SRV9TVUJTVFJFQU0iLCJTeW1ib2wiLCJPYmplY3RNdWx0aXBsZXgiLCJfc3Vic3RyZWFtcyIsImNyZWF0ZVN0cmVhbSIsInN1YnN0cmVhbSIsImFueVN0cmVhbUVuZCIsImRlc3Ryb3kiLCJpZ25vcmVTdHJlYW0iLCJjb25zb2xlIiwid2FybiIsIl9jYiIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJzZXR1cE11bHRpcGxleCIsIm11eCIsImdldFN0cmVhbSIsInN0cmVhbUhlbHBlciIsIlBvc3RNZXNzYWdlU3RyZWFtIiwiZGF0YU9iaiIsImRhdGFPYmpEYXRhIiwicGFyYW1zIiwiZGF0YU9iakRhdGFQYXJhbSIsIl9vcmlnaW4iLCJsb2NhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js":
/*!***********************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js ***!
  \***********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { isNodeStream, isWebStream, kControllerErrorFunction } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nconst { ERR_INVALID_ARG_TYPE } = codes;\nlet addAbortListener;\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal, name)=>{\n    if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n    }\n};\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n    validateAbortSignal(signal, \"signal\");\n    if (!isNodeStream(stream) && !isWebStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", [\n            \"ReadableStream\",\n            \"WritableStream\",\n            \"Stream\"\n        ], stream);\n    }\n    return module.exports.addAbortSignalNoValidate(signal, stream);\n};\nmodule.exports.addAbortSignalNoValidate = function(signal, stream) {\n    if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        return stream;\n    }\n    const onAbort = isNodeStream(stream) ? ()=>{\n        stream.destroy(new AbortError(undefined, {\n            cause: signal.reason\n        }));\n    } : ()=>{\n        stream[kControllerErrorFunction](new AbortError(undefined, {\n            cause: signal.reason\n        }));\n    };\n    if (signal.aborted) {\n        onAbort();\n    } else {\n        addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").addAbortListener);\n        const disposable = addAbortListener(signal, onAbort);\n        eos(stream, disposable[SymbolDispose]);\n    }\n    return stream;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hZGQtYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQUVHLFlBQVksRUFBRUMsV0FBVyxFQUFFQyx3QkFBd0IsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN4RSxNQUFNTSxNQUFNTixtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQUVPLG9CQUFvQixFQUFFLEdBQUdMO0FBQ2pDLElBQUlNO0FBRUosa0RBQWtEO0FBQ2xELCtEQUErRDtBQUMvRCxrRUFBa0U7QUFDbEUsTUFBTUMsc0JBQXNCLENBQUNDLFFBQVFDO0lBQ25DLElBQUksT0FBT0QsV0FBVyxZQUFZLENBQUUsY0FBYUEsTUFBSyxHQUFJO1FBQ3hELE1BQU0sSUFBSUgscUJBQXFCSSxNQUFNLGVBQWVEO0lBQ3REO0FBQ0Y7QUFDQUUsNkJBQTZCLEdBQUcsU0FBU0UsZUFBZUosTUFBTSxFQUFFSyxNQUFNO0lBQ3BFTixvQkFBb0JDLFFBQVE7SUFDNUIsSUFBSSxDQUFDUCxhQUFhWSxXQUFXLENBQUNYLFlBQVlXLFNBQVM7UUFDakQsTUFBTSxJQUFJUixxQkFBcUIsVUFBVTtZQUFDO1lBQWtCO1lBQWtCO1NBQVMsRUFBRVE7SUFDM0Y7SUFDQSxPQUFPSCxPQUFPQyxPQUFPLENBQUNHLHdCQUF3QixDQUFDTixRQUFRSztBQUN6RDtBQUNBSCx1Q0FBdUMsR0FBRyxTQUFVRixNQUFNLEVBQUVLLE1BQU07SUFDaEUsSUFBSSxPQUFPTCxXQUFXLFlBQVksQ0FBRSxjQUFhQSxNQUFLLEdBQUk7UUFDeEQsT0FBT0s7SUFDVDtJQUNBLE1BQU1FLFVBQVVkLGFBQWFZLFVBQ3pCO1FBQ0VBLE9BQU9HLE9BQU8sQ0FDWixJQUFJakIsV0FBV2tCLFdBQVc7WUFDeEJDLE9BQU9WLE9BQU9XLE1BQU07UUFDdEI7SUFFSixJQUNBO1FBQ0VOLE1BQU0sQ0FBQ1YseUJBQXlCLENBQzlCLElBQUlKLFdBQVdrQixXQUFXO1lBQ3hCQyxPQUFPVixPQUFPVyxNQUFNO1FBQ3RCO0lBRUo7SUFDSixJQUFJWCxPQUFPWSxPQUFPLEVBQUU7UUFDbEJMO0lBQ0YsT0FBTztRQUNMVCxtQkFBbUJBLG9CQUFvQlIsOEpBQTJDO1FBQ2xGLE1BQU11QixhQUFhZixpQkFBaUJFLFFBQVFPO1FBQzVDWCxJQUFJUyxRQUFRUSxVQUFVLENBQUN4QixjQUFjO0lBQ3ZDO0lBQ0EsT0FBT2dCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hZGQtYWJvcnQtc2lnbmFsLmpzP2YzM2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgU3ltYm9sRGlzcG9zZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IEFib3J0RXJyb3IsIGNvZGVzIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IGlzTm9kZVN0cmVhbSwgaXNXZWJTdHJlYW0sIGtDb250cm9sbGVyRXJyb3JGdW5jdGlvbiB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxuY29uc3QgeyBFUlJfSU5WQUxJRF9BUkdfVFlQRSB9ID0gY29kZXNcbmxldCBhZGRBYm9ydExpc3RlbmVyXG5cbi8vIFRoaXMgbWV0aG9kIGlzIGlubGluZWQgaGVyZSBmb3IgcmVhZGFibGUtc3RyZWFtXG4vLyBJdCBhbHNvIGRvZXMgbm90IGFsbG93IGZvciBzaWduYWwgdG8gbm90IGV4aXN0IG9uIHRoZSBzdHJlYW1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM2MDYxI2Rpc2N1c3Npb25fcjUzMzcxODAyOVxuY29uc3QgdmFsaWRhdGVBYm9ydFNpZ25hbCA9IChzaWduYWwsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Fib3J0U2lnbmFsJywgc2lnbmFsKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cy5hZGRBYm9ydFNpZ25hbCA9IGZ1bmN0aW9uIGFkZEFib3J0U2lnbmFsKHNpZ25hbCwgc3RyZWFtKSB7XG4gIHZhbGlkYXRlQWJvcnRTaWduYWwoc2lnbmFsLCAnc2lnbmFsJylcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSAmJiAhaXNXZWJTdHJlYW0oc3RyZWFtKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnc3RyZWFtJywgWydSZWFkYWJsZVN0cmVhbScsICdXcml0YWJsZVN0cmVhbScsICdTdHJlYW0nXSwgc3RyZWFtKVxuICB9XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5hZGRBYm9ydFNpZ25hbE5vVmFsaWRhdGUoc2lnbmFsLCBzdHJlYW0pXG59XG5tb2R1bGUuZXhwb3J0cy5hZGRBYm9ydFNpZ25hbE5vVmFsaWRhdGUgPSBmdW5jdGlvbiAoc2lnbmFsLCBzdHJlYW0pIHtcbiAgaWYgKHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpIHtcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cbiAgY29uc3Qgb25BYm9ydCA9IGlzTm9kZVN0cmVhbShzdHJlYW0pXG4gICAgPyAoKSA9PiB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KFxuICAgICAgICAgIG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgY2F1c2U6IHNpZ25hbC5yZWFzb25cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9XG4gICAgOiAoKSA9PiB7XG4gICAgICAgIHN0cmVhbVtrQ29udHJvbGxlckVycm9yRnVuY3Rpb25dKFxuICAgICAgICAgIG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgY2F1c2U6IHNpZ25hbC5yZWFzb25cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIG9uQWJvcnQoKVxuICB9IGVsc2Uge1xuICAgIGFkZEFib3J0TGlzdGVuZXIgPSBhZGRBYm9ydExpc3RlbmVyIHx8IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmFkZEFib3J0TGlzdGVuZXJcbiAgICBjb25zdCBkaXNwb3NhYmxlID0gYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIG9uQWJvcnQpXG4gICAgZW9zKHN0cmVhbSwgZGlzcG9zYWJsZVtTeW1ib2xEaXNwb3NlXSlcbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG4iXSwibmFtZXMiOlsiU3ltYm9sRGlzcG9zZSIsInJlcXVpcmUiLCJBYm9ydEVycm9yIiwiY29kZXMiLCJpc05vZGVTdHJlYW0iLCJpc1dlYlN0cmVhbSIsImtDb250cm9sbGVyRXJyb3JGdW5jdGlvbiIsImVvcyIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiYWRkQWJvcnRMaXN0ZW5lciIsInZhbGlkYXRlQWJvcnRTaWduYWwiLCJzaWduYWwiLCJuYW1lIiwibW9kdWxlIiwiZXhwb3J0cyIsImFkZEFib3J0U2lnbmFsIiwic3RyZWFtIiwiYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlIiwib25BYm9ydCIsImRlc3Ryb3kiLCJ1bmRlZmluZWQiLCJjYXVzZSIsInJlYXNvbiIsImFib3J0ZWQiLCJkaXNwb3NhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { inspect } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nmodule.exports = class BufferList {\n    constructor(){\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    push(v) {\n        const entry = {\n            data: v,\n            next: null\n        };\n        if (this.length > 0) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n        ++this.length;\n    }\n    unshift(v) {\n        const entry = {\n            data: v,\n            next: this.head\n        };\n        if (this.length === 0) this.tail = entry;\n        this.head = entry;\n        ++this.length;\n    }\n    shift() {\n        if (this.length === 0) return;\n        const ret = this.head.data;\n        if (this.length === 1) this.head = this.tail = null;\n        else this.head = this.head.next;\n        --this.length;\n        return ret;\n    }\n    clear() {\n        this.head = this.tail = null;\n        this.length = 0;\n    }\n    join(s) {\n        if (this.length === 0) return \"\";\n        let p = this.head;\n        let ret = \"\" + p.data;\n        while((p = p.next) !== null)ret += s + p.data;\n        return ret;\n    }\n    concat(n) {\n        if (this.length === 0) return Buffer.alloc(0);\n        const ret = Buffer.allocUnsafe(n >>> 0);\n        let p = this.head;\n        let i = 0;\n        while(p){\n            TypedArrayPrototypeSet(ret, p.data, i);\n            i += p.data.length;\n            p = p.next;\n        }\n        return ret;\n    }\n    // Consumes a specified amount of bytes or characters from the buffered data.\n    consume(n, hasStrings) {\n        const data = this.head.data;\n        if (n < data.length) {\n            // `slice` is the same for buffers and strings.\n            const slice = data.slice(0, n);\n            this.head.data = data.slice(n);\n            return slice;\n        }\n        if (n === data.length) {\n            // First chunk is a perfect match.\n            return this.shift();\n        }\n        // Result spans more than one buffer.\n        return hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n    first() {\n        return this.head.data;\n    }\n    *[SymbolIterator]() {\n        for(let p = this.head; p; p = p.next){\n            yield p.data;\n        }\n    }\n    // Consumes a specified amount of characters from the buffered data.\n    _getString(n) {\n        let ret = \"\";\n        let p = this.head;\n        let c = 0;\n        do {\n            const str = p.data;\n            if (n > str.length) {\n                ret += str;\n                n -= str.length;\n            } else {\n                if (n === str.length) {\n                    ret += str;\n                    ++c;\n                    if (p.next) this.head = p.next;\n                    else this.head = this.tail = null;\n                } else {\n                    ret += StringPrototypeSlice(str, 0, n);\n                    this.head = p;\n                    p.data = StringPrototypeSlice(str, n);\n                }\n                break;\n            }\n            ++c;\n        }while ((p = p.next) !== null);\n        this.length -= c;\n        return ret;\n    }\n    // Consumes a specified amount of bytes from the buffered data.\n    _getBuffer(n) {\n        const ret = Buffer.allocUnsafe(n);\n        const retLen = n;\n        let p = this.head;\n        let c = 0;\n        do {\n            const buf = p.data;\n            if (n > buf.length) {\n                TypedArrayPrototypeSet(ret, buf, retLen - n);\n                n -= buf.length;\n            } else {\n                if (n === buf.length) {\n                    TypedArrayPrototypeSet(ret, buf, retLen - n);\n                    ++c;\n                    if (p.next) this.head = p.next;\n                    else this.head = this.tail = null;\n                } else {\n                    TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);\n                    this.head = p;\n                    p.data = buf.slice(n);\n                }\n                break;\n            }\n            ++c;\n        }while ((p = p.next) !== null);\n        this.length -= c;\n        return ret;\n    }\n    // Make sure the linked list only shows the minimal necessary information.\n    [Symbol.for(\"nodejs.util.inspect.custom\")](_, options) {\n        return inspect(this, {\n            ...options,\n            // Only inspect one level.\n            depth: 0,\n            // It should not recurse.\n            customInspect: false\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsb0JBQW9CLEVBQUVDLGNBQWMsRUFBRUMsc0JBQXNCLEVBQUVDLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM3RixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVFLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUM1QkcsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2hCO0lBQ0FDLEtBQUtDLENBQUMsRUFBRTtRQUNOLE1BQU1DLFFBQVE7WUFDWkMsTUFBTUY7WUFDTkcsTUFBTTtRQUNSO1FBQ0EsSUFBSSxJQUFJLENBQUNMLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQ0QsSUFBSSxDQUFDTSxJQUFJLEdBQUdGO2FBQ2pDLElBQUksQ0FBQ0wsSUFBSSxHQUFHSztRQUNqQixJQUFJLENBQUNKLElBQUksR0FBR0k7UUFDWixFQUFFLElBQUksQ0FBQ0gsTUFBTTtJQUNmO0lBQ0FNLFFBQVFKLENBQUMsRUFBRTtRQUNULE1BQU1DLFFBQVE7WUFDWkMsTUFBTUY7WUFDTkcsTUFBTSxJQUFJLENBQUNQLElBQUk7UUFDakI7UUFDQSxJQUFJLElBQUksQ0FBQ0UsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDRCxJQUFJLEdBQUdJO1FBQ25DLElBQUksQ0FBQ0wsSUFBSSxHQUFHSztRQUNaLEVBQUUsSUFBSSxDQUFDSCxNQUFNO0lBQ2Y7SUFDQU8sUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDUCxNQUFNLEtBQUssR0FBRztRQUN2QixNQUFNUSxNQUFNLElBQUksQ0FBQ1YsSUFBSSxDQUFDTSxJQUFJO1FBQzFCLElBQUksSUFBSSxDQUFDSixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUNGLElBQUksR0FBRyxJQUFJLENBQUNDLElBQUksR0FBRzthQUMxQyxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQ08sSUFBSTtRQUMvQixFQUFFLElBQUksQ0FBQ0wsTUFBTTtRQUNiLE9BQU9RO0lBQ1Q7SUFDQUMsUUFBUTtRQUNOLElBQUksQ0FBQ1gsSUFBSSxHQUFHLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2hCO0lBQ0FVLEtBQUtDLENBQUMsRUFBRTtRQUNOLElBQUksSUFBSSxDQUFDWCxNQUFNLEtBQUssR0FBRyxPQUFPO1FBQzlCLElBQUlZLElBQUksSUFBSSxDQUFDZCxJQUFJO1FBQ2pCLElBQUlVLE1BQU0sS0FBS0ksRUFBRVIsSUFBSTtRQUNyQixNQUFPLENBQUNRLElBQUlBLEVBQUVQLElBQUksTUFBTSxLQUFNRyxPQUFPRyxJQUFJQyxFQUFFUixJQUFJO1FBQy9DLE9BQU9JO0lBQ1Q7SUFDQUssT0FBT0MsQ0FBQyxFQUFFO1FBQ1IsSUFBSSxJQUFJLENBQUNkLE1BQU0sS0FBSyxHQUFHLE9BQU9SLE9BQU91QixLQUFLLENBQUM7UUFDM0MsTUFBTVAsTUFBTWhCLE9BQU93QixXQUFXLENBQUNGLE1BQU07UUFDckMsSUFBSUYsSUFBSSxJQUFJLENBQUNkLElBQUk7UUFDakIsSUFBSW1CLElBQUk7UUFDUixNQUFPTCxFQUFHO1lBQ1J2Qix1QkFBdUJtQixLQUFLSSxFQUFFUixJQUFJLEVBQUVhO1lBQ3BDQSxLQUFLTCxFQUFFUixJQUFJLENBQUNKLE1BQU07WUFDbEJZLElBQUlBLEVBQUVQLElBQUk7UUFDWjtRQUNBLE9BQU9HO0lBQ1Q7SUFFQSw2RUFBNkU7SUFDN0VVLFFBQVFKLENBQUMsRUFBRUssVUFBVSxFQUFFO1FBQ3JCLE1BQU1mLE9BQU8sSUFBSSxDQUFDTixJQUFJLENBQUNNLElBQUk7UUFDM0IsSUFBSVUsSUFBSVYsS0FBS0osTUFBTSxFQUFFO1lBQ25CLCtDQUErQztZQUMvQyxNQUFNb0IsUUFBUWhCLEtBQUtnQixLQUFLLENBQUMsR0FBR047WUFDNUIsSUFBSSxDQUFDaEIsSUFBSSxDQUFDTSxJQUFJLEdBQUdBLEtBQUtnQixLQUFLLENBQUNOO1lBQzVCLE9BQU9NO1FBQ1Q7UUFDQSxJQUFJTixNQUFNVixLQUFLSixNQUFNLEVBQUU7WUFDckIsa0NBQWtDO1lBQ2xDLE9BQU8sSUFBSSxDQUFDTyxLQUFLO1FBQ25CO1FBQ0EscUNBQXFDO1FBQ3JDLE9BQU9ZLGFBQWEsSUFBSSxDQUFDRSxVQUFVLENBQUNQLEtBQUssSUFBSSxDQUFDUSxVQUFVLENBQUNSO0lBQzNEO0lBQ0FTLFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQ3pCLElBQUksQ0FBQ00sSUFBSTtJQUN2QjtJQUNBLENBQUMsQ0FBQ2hCLGVBQWUsR0FBRztRQUNsQixJQUFLLElBQUl3QixJQUFJLElBQUksQ0FBQ2QsSUFBSSxFQUFFYyxHQUFHQSxJQUFJQSxFQUFFUCxJQUFJLENBQUU7WUFDckMsTUFBTU8sRUFBRVIsSUFBSTtRQUNkO0lBQ0Y7SUFFQSxvRUFBb0U7SUFDcEVpQixXQUFXUCxDQUFDLEVBQUU7UUFDWixJQUFJTixNQUFNO1FBQ1YsSUFBSUksSUFBSSxJQUFJLENBQUNkLElBQUk7UUFDakIsSUFBSTBCLElBQUk7UUFDUixHQUFHO1lBQ0QsTUFBTUMsTUFBTWIsRUFBRVIsSUFBSTtZQUNsQixJQUFJVSxJQUFJVyxJQUFJekIsTUFBTSxFQUFFO2dCQUNsQlEsT0FBT2lCO2dCQUNQWCxLQUFLVyxJQUFJekIsTUFBTTtZQUNqQixPQUFPO2dCQUNMLElBQUljLE1BQU1XLElBQUl6QixNQUFNLEVBQUU7b0JBQ3BCUSxPQUFPaUI7b0JBQ1AsRUFBRUQ7b0JBQ0YsSUFBSVosRUFBRVAsSUFBSSxFQUFFLElBQUksQ0FBQ1AsSUFBSSxHQUFHYyxFQUFFUCxJQUFJO3lCQUN6QixJQUFJLENBQUNQLElBQUksR0FBRyxJQUFJLENBQUNDLElBQUksR0FBRztnQkFDL0IsT0FBTztvQkFDTFMsT0FBT3JCLHFCQUFxQnNDLEtBQUssR0FBR1g7b0JBQ3BDLElBQUksQ0FBQ2hCLElBQUksR0FBR2M7b0JBQ1pBLEVBQUVSLElBQUksR0FBR2pCLHFCQUFxQnNDLEtBQUtYO2dCQUNyQztnQkFDQTtZQUNGO1lBQ0EsRUFBRVU7UUFDSixRQUFTLENBQUNaLElBQUlBLEVBQUVQLElBQUksTUFBTSxNQUFLO1FBQy9CLElBQUksQ0FBQ0wsTUFBTSxJQUFJd0I7UUFDZixPQUFPaEI7SUFDVDtJQUVBLCtEQUErRDtJQUMvRGMsV0FBV1IsQ0FBQyxFQUFFO1FBQ1osTUFBTU4sTUFBTWhCLE9BQU93QixXQUFXLENBQUNGO1FBQy9CLE1BQU1ZLFNBQVNaO1FBQ2YsSUFBSUYsSUFBSSxJQUFJLENBQUNkLElBQUk7UUFDakIsSUFBSTBCLElBQUk7UUFDUixHQUFHO1lBQ0QsTUFBTUcsTUFBTWYsRUFBRVIsSUFBSTtZQUNsQixJQUFJVSxJQUFJYSxJQUFJM0IsTUFBTSxFQUFFO2dCQUNsQlgsdUJBQXVCbUIsS0FBS21CLEtBQUtELFNBQVNaO2dCQUMxQ0EsS0FBS2EsSUFBSTNCLE1BQU07WUFDakIsT0FBTztnQkFDTCxJQUFJYyxNQUFNYSxJQUFJM0IsTUFBTSxFQUFFO29CQUNwQlgsdUJBQXVCbUIsS0FBS21CLEtBQUtELFNBQVNaO29CQUMxQyxFQUFFVTtvQkFDRixJQUFJWixFQUFFUCxJQUFJLEVBQUUsSUFBSSxDQUFDUCxJQUFJLEdBQUdjLEVBQUVQLElBQUk7eUJBQ3pCLElBQUksQ0FBQ1AsSUFBSSxHQUFHLElBQUksQ0FBQ0MsSUFBSSxHQUFHO2dCQUMvQixPQUFPO29CQUNMVix1QkFBdUJtQixLQUFLLElBQUlsQixXQUFXcUMsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVmLElBQUlZLFNBQVNaO29CQUNwRixJQUFJLENBQUNoQixJQUFJLEdBQUdjO29CQUNaQSxFQUFFUixJQUFJLEdBQUd1QixJQUFJUCxLQUFLLENBQUNOO2dCQUNyQjtnQkFDQTtZQUNGO1lBQ0EsRUFBRVU7UUFDSixRQUFTLENBQUNaLElBQUlBLEVBQUVQLElBQUksTUFBTSxNQUFLO1FBQy9CLElBQUksQ0FBQ0wsTUFBTSxJQUFJd0I7UUFDZixPQUFPaEI7SUFDVDtJQUVBLDBFQUEwRTtJQUMxRSxDQUFDc0IsT0FBT0MsR0FBRyxDQUFDLDhCQUE4QixDQUFDQyxDQUFDLEVBQUVDLE9BQU8sRUFBRTtRQUNyRCxPQUFPeEMsUUFBUSxJQUFJLEVBQUU7WUFDbkIsR0FBR3dDLE9BQU87WUFDViwwQkFBMEI7WUFDMUJDLE9BQU87WUFDUCx5QkFBeUI7WUFDekJDLGVBQWU7UUFDakI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanM/NmRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBTdHJpbmdQcm90b3R5cGVTbGljZSwgU3ltYm9sSXRlcmF0b3IsIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQsIFVpbnQ4QXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IGluc3BlY3QgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEJ1ZmZlckxpc3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gICAgdGhpcy50YWlsID0gbnVsbFxuICAgIHRoaXMubGVuZ3RoID0gMFxuICB9XG4gIHB1c2godikge1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgZGF0YTogdixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeVxuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnlcbiAgICB0aGlzLnRhaWwgPSBlbnRyeVxuICAgICsrdGhpcy5sZW5ndGhcbiAgfVxuICB1bnNoaWZ0KHYpIHtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGRhdGE6IHYsXG4gICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeVxuICAgIHRoaXMuaGVhZCA9IGVudHJ5XG4gICAgKyt0aGlzLmxlbmd0aFxuICB9XG4gIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgY29uc3QgcmV0ID0gdGhpcy5oZWFkLmRhdGFcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgICBlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0XG4gICAgLS10aGlzLmxlbmd0aFxuICAgIHJldHVybiByZXRcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCByZXQgPSAnJyArIHAuZGF0YVxuICAgIHdoaWxlICgocCA9IHAubmV4dCkgIT09IG51bGwpIHJldCArPSBzICsgcC5kYXRhXG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gICAgY29uc3QgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApXG4gICAgbGV0IHAgPSB0aGlzLmhlYWRcbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZSAocCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZVNldChyZXQsIHAuZGF0YSwgaSlcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aFxuICAgICAgcCA9IHAubmV4dFxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5oZWFkLmRhdGFcbiAgICBpZiAobiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgY29uc3Qgc2xpY2UgPSBkYXRhLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzLmhlYWQuZGF0YSA9IGRhdGEuc2xpY2UobilcbiAgICAgIHJldHVybiBzbGljZVxuICAgIH1cbiAgICBpZiAobiA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgIHJldHVybiB0aGlzLnNoaWZ0KClcbiAgICB9XG4gICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgIHJldHVybiBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pXG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhXG4gIH1cbiAgKltTeW1ib2xJdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgcCA9IHRoaXMuaGVhZDsgcDsgcCA9IHAubmV4dCkge1xuICAgICAgeWllbGQgcC5kYXRhXG4gICAgfVxuICB9XG5cbiAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgX2dldFN0cmluZyhuKSB7XG4gICAgbGV0IHJldCA9ICcnXG4gICAgbGV0IHAgPSB0aGlzLmhlYWRcbiAgICBsZXQgYyA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBzdHIgPSBwLmRhdGFcbiAgICAgIGlmIChuID4gc3RyLmxlbmd0aCkge1xuICAgICAgICByZXQgKz0gc3RyXG4gICAgICAgIG4gLT0gc3RyLmxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgKz0gc3RyXG4gICAgICAgICAgKytjXG4gICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0XG4gICAgICAgICAgZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ICs9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKHN0ciwgMCwgbilcbiAgICAgICAgICB0aGlzLmhlYWQgPSBwXG4gICAgICAgICAgcC5kYXRhID0gU3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RyLCBuKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICArK2NcbiAgICB9IHdoaWxlICgocCA9IHAubmV4dCkgIT09IG51bGwpXG4gICAgdGhpcy5sZW5ndGggLT0gY1xuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICBfZ2V0QnVmZmVyKG4pIHtcbiAgICBjb25zdCByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobilcbiAgICBjb25zdCByZXRMZW4gPSBuXG4gICAgbGV0IHAgPSB0aGlzLmhlYWRcbiAgICBsZXQgYyA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSBwLmRhdGFcbiAgICAgIGlmIChuID4gYnVmLmxlbmd0aCkge1xuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHJldCwgYnVmLCByZXRMZW4gLSBuKVxuICAgICAgICBuIC09IGJ1Zi5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZVNldChyZXQsIGJ1ZiwgcmV0TGVuIC0gbilcbiAgICAgICAgICArK2NcbiAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHRcbiAgICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHJldCwgbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCByZXRMZW4gLSBuKVxuICAgICAgICAgIHRoaXMuaGVhZCA9IHBcbiAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobilcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgKytjXG4gICAgfSB3aGlsZSAoKHAgPSBwLm5leHQpICE9PSBudWxsKVxuICAgIHRoaXMubGVuZ3RoIC09IGNcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgZGVwdGg6IDAsXG4gICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgIH0pXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJTdHJpbmdQcm90b3R5cGVTbGljZSIsIlN5bWJvbEl0ZXJhdG9yIiwiVHlwZWRBcnJheVByb3RvdHlwZVNldCIsIlVpbnQ4QXJyYXkiLCJyZXF1aXJlIiwiQnVmZmVyIiwiaW5zcGVjdCIsIm1vZHVsZSIsImV4cG9ydHMiLCJCdWZmZXJMaXN0IiwiY29uc3RydWN0b3IiLCJoZWFkIiwidGFpbCIsImxlbmd0aCIsInB1c2giLCJ2IiwiZW50cnkiLCJkYXRhIiwibmV4dCIsInVuc2hpZnQiLCJzaGlmdCIsInJldCIsImNsZWFyIiwiam9pbiIsInMiLCJwIiwiY29uY2F0IiwibiIsImFsbG9jIiwiYWxsb2NVbnNhZmUiLCJpIiwiY29uc3VtZSIsImhhc1N0cmluZ3MiLCJzbGljZSIsIl9nZXRTdHJpbmciLCJfZ2V0QnVmZmVyIiwiZmlyc3QiLCJjIiwic3RyIiwicmV0TGVuIiwiYnVmIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIlN5bWJvbCIsImZvciIsIl8iLCJvcHRpb25zIiwiZGVwdGgiLCJjdXN0b21JbnNwZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/buffer_list.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/compose.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/compose.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { pipeline } = __webpack_require__(/*! ./pipeline */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\nconst { destroyer } = __webpack_require__(/*! ./destroy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nconst { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst { AbortError, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nmodule.exports = function compose(...streams) {\n    if (streams.length === 0) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n    }\n    if (streams.length === 1) {\n        return Duplex.from(streams[0]);\n    }\n    const orgStreams = [\n        ...streams\n    ];\n    if (typeof streams[0] === \"function\") {\n        streams[0] = Duplex.from(streams[0]);\n    }\n    if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n    }\n    for(let n = 0; n < streams.length; ++n){\n        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n            continue;\n        }\n        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {\n            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        }\n        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be writable\");\n        }\n    }\n    let ondrain;\n    let onfinish;\n    let onreadable;\n    let onclose;\n    let d;\n    function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n            cb(err);\n        } else if (err) {\n            d.destroy(err);\n        } else if (!readable && !writable) {\n            d.destroy();\n        }\n    }\n    const head = streams[0];\n    const tail = pipeline(streams, onfinished);\n    const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));\n    const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));\n    // TODO(ronag): Avoid double buffering.\n    // Implement Writable/Readable/Duplex traits.\n    // See, https://github.com/nodejs/node/pull/33515.\n    d = new Duplex({\n        // TODO (ronag): highWaterMark?\n        writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n        writable,\n        readable\n    });\n    if (writable) {\n        if (isNodeStream(head)) {\n            d._write = function(chunk, encoding, callback) {\n                if (head.write(chunk, encoding)) {\n                    callback();\n                } else {\n                    ondrain = callback;\n                }\n            };\n            d._final = function(callback) {\n                head.end();\n                onfinish = callback;\n            };\n            head.on(\"drain\", function() {\n                if (ondrain) {\n                    const cb = ondrain;\n                    ondrain = null;\n                    cb();\n                }\n            });\n        } else if (isWebStream(head)) {\n            const writable = isTransformStream(head) ? head.writable : head;\n            const writer = writable.getWriter();\n            d._write = async function(chunk, encoding, callback) {\n                try {\n                    await writer.ready;\n                    writer.write(chunk).catch(()=>{});\n                    callback();\n                } catch (err) {\n                    callback(err);\n                }\n            };\n            d._final = async function(callback) {\n                try {\n                    await writer.ready;\n                    writer.close().catch(()=>{});\n                    onfinish = callback;\n                } catch (err) {\n                    callback(err);\n                }\n            };\n        }\n        const toRead = isTransformStream(tail) ? tail.readable : tail;\n        eos(toRead, ()=>{\n            if (onfinish) {\n                const cb = onfinish;\n                onfinish = null;\n                cb();\n            }\n        });\n    }\n    if (readable) {\n        if (isNodeStream(tail)) {\n            tail.on(\"readable\", function() {\n                if (onreadable) {\n                    const cb = onreadable;\n                    onreadable = null;\n                    cb();\n                }\n            });\n            tail.on(\"end\", function() {\n                d.push(null);\n            });\n            d._read = function() {\n                while(true){\n                    const buf = tail.read();\n                    if (buf === null) {\n                        onreadable = d._read;\n                        return;\n                    }\n                    if (!d.push(buf)) {\n                        return;\n                    }\n                }\n            };\n        } else if (isWebStream(tail)) {\n            const readable = isTransformStream(tail) ? tail.readable : tail;\n            const reader = readable.getReader();\n            d._read = async function() {\n                while(true){\n                    try {\n                        const { value, done } = await reader.read();\n                        if (!d.push(value)) {\n                            return;\n                        }\n                        if (done) {\n                            d.push(null);\n                            return;\n                        }\n                    } catch  {\n                        return;\n                    }\n                }\n            };\n        }\n    }\n    d._destroy = function(err, callback) {\n        if (!err && onclose !== null) {\n            err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n            callback(err);\n        } else {\n            onclose = callback;\n            if (isNodeStream(tail)) {\n                destroyer(tail, err);\n            }\n        }\n    };\n    return d;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9jb21wb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFRSxTQUFTLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDOUIsTUFBTSxFQUNKRyxZQUFZLEVBQ1pDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGlCQUFpQixFQUNqQkMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDakIsR0FBR1QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pVLFVBQVUsRUFDVkMsT0FBTyxFQUFFQyxxQkFBcUIsRUFBRUMsZ0JBQWdCLEVBQUUsRUFDbkQsR0FBR2IsbUJBQU9BLENBQUM7QUFDWixNQUFNYyxNQUFNZCxtQkFBT0EsQ0FBQztBQUNwQmUsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLFFBQVEsR0FBR0MsT0FBTztJQUMxQyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssR0FBRztRQUN4QixNQUFNLElBQUlOLGlCQUFpQjtJQUM3QjtJQUNBLElBQUlLLFFBQVFDLE1BQU0sS0FBSyxHQUFHO1FBQ3hCLE9BQU9sQixPQUFPbUIsSUFBSSxDQUFDRixPQUFPLENBQUMsRUFBRTtJQUMvQjtJQUNBLE1BQU1HLGFBQWE7V0FBSUg7S0FBUTtJQUMvQixJQUFJLE9BQU9BLE9BQU8sQ0FBQyxFQUFFLEtBQUssWUFBWTtRQUNwQ0EsT0FBTyxDQUFDLEVBQUUsR0FBR2pCLE9BQU9tQixJQUFJLENBQUNGLE9BQU8sQ0FBQyxFQUFFO0lBQ3JDO0lBQ0EsSUFBSSxPQUFPQSxPQUFPLENBQUNBLFFBQVFDLE1BQU0sR0FBRyxFQUFFLEtBQUssWUFBWTtRQUNyRCxNQUFN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QUFJLENBQUNFLE1BQU07d0JBQ2hCO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRixPQUFPLElBQUlsRCxZQUFZOEIsT0FBTztZQUM1QixNQUFNSCxXQUFXMUIsa0JBQWtCNkIsUUFBUUEsS0FBS0gsUUFBUSxHQUFHRztZQUMzRCxNQUFNc0IsU0FBU3pCLFNBQVMwQixTQUFTO1lBQ2pDL0IsRUFBRTJCLEtBQUssR0FBRztnQkFDUixNQUFPLEtBQU07b0JBQ1gsSUFBSTt3QkFDRixNQUFNLEVBQUVLLEtBQUssRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTUgsT0FBT0QsSUFBSTt3QkFDekMsSUFBSSxDQUFDN0IsRUFBRTBCLElBQUksQ0FBQ00sUUFBUTs0QkFDbEI7d0JBQ0Y7d0JBQ0EsSUFBSUMsTUFBTTs0QkFDUmpDLEVBQUUwQixJQUFJLENBQUM7NEJBQ1A7d0JBQ0Y7b0JBQ0YsRUFBRSxPQUFNO3dCQUNOO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0ExQixFQUFFa0MsUUFBUSxHQUFHLFNBQVVoQyxHQUFHLEVBQUVhLFFBQVE7UUFDbEMsSUFBSSxDQUFDYixPQUFPSCxZQUFZLE1BQU07WUFDNUJHLE1BQU0sSUFBSXBCO1FBQ1o7UUFDQWdCLGFBQWE7UUFDYkYsVUFBVTtRQUNWQyxXQUFXO1FBQ1gsSUFBSUUsWUFBWSxNQUFNO1lBQ3BCZ0IsU0FBU2I7UUFDWCxPQUFPO1lBQ0xILFVBQVVnQjtZQUNWLElBQUl4QyxhQUFhaUMsT0FBTztnQkFDdEJsQyxVQUFVa0MsTUFBTU47WUFDbEI7UUFDRjtJQUNGO0lBQ0EsT0FBT0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UuanM/YTNmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnLi9waXBlbGluZScpXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleCcpXG5jb25zdCB7IGRlc3Ryb3llciB9ID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IHtcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlLFxuICBpc1dyaXRhYmxlLFxuICBpc1dlYlN0cmVhbSxcbiAgaXNUcmFuc2Zvcm1TdHJlYW0sXG4gIGlzV3JpdGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW1cbn0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHtcbiAgQWJvcnRFcnJvcixcbiAgY29kZXM6IHsgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBFUlJfTUlTU0lOR19BUkdTIH1cbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wb3NlKC4uLnN0cmVhbXMpIHtcbiAgaWYgKHN0cmVhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKVxuICB9XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBEdXBsZXguZnJvbShzdHJlYW1zWzBdKVxuICB9XG4gIGNvbnN0IG9yZ1N0cmVhbXMgPSBbLi4uc3RyZWFtc11cbiAgaWYgKHR5cGVvZiBzdHJlYW1zWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtc1swXSA9IER1cGxleC5mcm9tKHN0cmVhbXNbMF0pXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBpZHggPSBzdHJlYW1zLmxlbmd0aCAtIDFcbiAgICBzdHJlYW1zW2lkeF0gPSBEdXBsZXguZnJvbShzdHJlYW1zW2lkeF0pXG4gIH1cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzdHJlYW1zLmxlbmd0aDsgKytuKSB7XG4gICAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtc1tuXSkgJiYgIWlzV2ViU3RyZWFtKHN0cmVhbXNbbl0pKSB7XG4gICAgICAvLyBUT0RPKHJvbmFnKTogQWRkIGNoZWNrcyBmb3Igbm9uIHN0cmVhbXMuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBuIDwgc3RyZWFtcy5sZW5ndGggLSAxICYmXG4gICAgICAhKGlzUmVhZGFibGUoc3RyZWFtc1tuXSkgfHwgaXNSZWFkYWJsZVN0cmVhbShzdHJlYW1zW25dKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShzdHJlYW1zW25dKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoYHN0cmVhbXNbJHtufV1gLCBvcmdTdHJlYW1zW25dLCAnbXVzdCBiZSByZWFkYWJsZScpXG4gICAgfVxuICAgIGlmIChuID4gMCAmJiAhKGlzV3JpdGFibGUoc3RyZWFtc1tuXSkgfHwgaXNXcml0YWJsZVN0cmVhbShzdHJlYW1zW25dKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShzdHJlYW1zW25dKSkpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoYHN0cmVhbXNbJHtufV1gLCBvcmdTdHJlYW1zW25dLCAnbXVzdCBiZSB3cml0YWJsZScpXG4gICAgfVxuICB9XG4gIGxldCBvbmRyYWluXG4gIGxldCBvbmZpbmlzaFxuICBsZXQgb25yZWFkYWJsZVxuICBsZXQgb25jbG9zZVxuICBsZXQgZFxuICBmdW5jdGlvbiBvbmZpbmlzaGVkKGVycikge1xuICAgIGNvbnN0IGNiID0gb25jbG9zZVxuICAgIG9uY2xvc2UgPSBudWxsXG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpXG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGQuZGVzdHJveShlcnIpXG4gICAgfSBlbHNlIGlmICghcmVhZGFibGUgJiYgIXdyaXRhYmxlKSB7XG4gICAgICBkLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuICBjb25zdCBoZWFkID0gc3RyZWFtc1swXVxuICBjb25zdCB0YWlsID0gcGlwZWxpbmUoc3RyZWFtcywgb25maW5pc2hlZClcbiAgY29uc3Qgd3JpdGFibGUgPSAhIShpc1dyaXRhYmxlKGhlYWQpIHx8IGlzV3JpdGFibGVTdHJlYW0oaGVhZCkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0oaGVhZCkpXG4gIGNvbnN0IHJlYWRhYmxlID0gISEoaXNSZWFkYWJsZSh0YWlsKSB8fCBpc1JlYWRhYmxlU3RyZWFtKHRhaWwpIHx8IGlzVHJhbnNmb3JtU3RyZWFtKHRhaWwpKVxuXG4gIC8vIFRPRE8ocm9uYWcpOiBBdm9pZCBkb3VibGUgYnVmZmVyaW5nLlxuICAvLyBJbXBsZW1lbnQgV3JpdGFibGUvUmVhZGFibGUvRHVwbGV4IHRyYWl0cy5cbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMzUxNS5cbiAgZCA9IG5ldyBEdXBsZXgoe1xuICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICB3cml0YWJsZU9iamVjdE1vZGU6ICEhKGhlYWQgIT09IG51bGwgJiYgaGVhZCAhPT0gdW5kZWZpbmVkICYmIGhlYWQud3JpdGFibGVPYmplY3RNb2RlKSxcbiAgICByZWFkYWJsZU9iamVjdE1vZGU6ICEhKHRhaWwgIT09IG51bGwgJiYgdGFpbCAhPT0gdW5kZWZpbmVkICYmIHRhaWwucmVhZGFibGVPYmplY3RNb2RlKSxcbiAgICB3cml0YWJsZSxcbiAgICByZWFkYWJsZVxuICB9KVxuICBpZiAod3JpdGFibGUpIHtcbiAgICBpZiAoaXNOb2RlU3RyZWFtKGhlYWQpKSB7XG4gICAgICBkLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChoZWFkLndyaXRlKGNodW5rLCBlbmNvZGluZykpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25kcmFpbiA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQuX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGhlYWQuZW5kKClcbiAgICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgICAgfVxuICAgICAgaGVhZC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvbmRyYWluKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBvbmRyYWluXG4gICAgICAgICAgb25kcmFpbiA9IG51bGxcbiAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChpc1dlYlN0cmVhbShoZWFkKSkge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBpc1RyYW5zZm9ybVN0cmVhbShoZWFkKSA/IGhlYWQud3JpdGFibGUgOiBoZWFkXG4gICAgICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKVxuICAgICAgZC5fd3JpdGUgPSBhc3luYyBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeVxuICAgICAgICAgIHdyaXRlci53cml0ZShjaHVuaykuY2F0Y2goKCkgPT4ge30pXG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQuX2ZpbmFsID0gYXN5bmMgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5XG4gICAgICAgICAgd3JpdGVyLmNsb3NlKCkuY2F0Y2goKCkgPT4ge30pXG4gICAgICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdG9SZWFkID0gaXNUcmFuc2Zvcm1TdHJlYW0odGFpbCkgPyB0YWlsLnJlYWRhYmxlIDogdGFpbFxuICAgIGVvcyh0b1JlYWQsICgpID0+IHtcbiAgICAgIGlmIChvbmZpbmlzaCkge1xuICAgICAgICBjb25zdCBjYiA9IG9uZmluaXNoXG4gICAgICAgIG9uZmluaXNoID0gbnVsbFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBpZiAocmVhZGFibGUpIHtcbiAgICBpZiAoaXNOb2RlU3RyZWFtKHRhaWwpKSB7XG4gICAgICB0YWlsLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ucmVhZGFibGUpIHtcbiAgICAgICAgICBjb25zdCBjYiA9IG9ucmVhZGFibGVcbiAgICAgICAgICBvbnJlYWRhYmxlID0gbnVsbFxuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRhaWwub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5wdXNoKG51bGwpXG4gICAgICB9KVxuICAgICAgZC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBidWYgPSB0YWlsLnJlYWQoKVxuICAgICAgICAgIGlmIChidWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9ucmVhZGFibGUgPSBkLl9yZWFkXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkLnB1c2goYnVmKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1dlYlN0cmVhbSh0YWlsKSkge1xuICAgICAgY29uc3QgcmVhZGFibGUgPSBpc1RyYW5zZm9ybVN0cmVhbSh0YWlsKSA/IHRhaWwucmVhZGFibGUgOiB0YWlsXG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5nZXRSZWFkZXIoKVxuICAgICAgZC5fcmVhZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICAgICAgaWYgKCFkLnB1c2godmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgZC5wdXNoKG51bGwpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICBvbmRyYWluID0gbnVsbFxuICAgIG9uZmluaXNoID0gbnVsbFxuICAgIGlmIChvbmNsb3NlID09PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9uY2xvc2UgPSBjYWxsYmFja1xuICAgICAgaWYgKGlzTm9kZVN0cmVhbSh0YWlsKSkge1xuICAgICAgICBkZXN0cm95ZXIodGFpbCwgZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZFxufVxuIl0sIm5hbWVzIjpbInBpcGVsaW5lIiwicmVxdWlyZSIsIkR1cGxleCIsImRlc3Ryb3llciIsImlzTm9kZVN0cmVhbSIsImlzUmVhZGFibGUiLCJpc1dyaXRhYmxlIiwiaXNXZWJTdHJlYW0iLCJpc1RyYW5zZm9ybVN0cmVhbSIsImlzV3JpdGFibGVTdHJlYW0iLCJpc1JlYWRhYmxlU3RyZWFtIiwiQWJvcnRFcnJvciIsImNvZGVzIiwiRVJSX0lOVkFMSURfQVJHX1ZBTFVFIiwiRVJSX01JU1NJTkdfQVJHUyIsImVvcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb21wb3NlIiwic3RyZWFtcyIsImxlbmd0aCIsImZyb20iLCJvcmdTdHJlYW1zIiwiaWR4IiwibiIsIm9uZHJhaW4iLCJvbmZpbmlzaCIsIm9ucmVhZGFibGUiLCJvbmNsb3NlIiwiZCIsIm9uZmluaXNoZWQiLCJlcnIiLCJjYiIsImRlc3Ryb3kiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiaGVhZCIsInRhaWwiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJ1bmRlZmluZWQiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJ3cml0ZSIsIl9maW5hbCIsImVuZCIsIm9uIiwid3JpdGVyIiwiZ2V0V3JpdGVyIiwicmVhZHkiLCJjYXRjaCIsImNsb3NlIiwidG9SZWFkIiwicHVzaCIsIl9yZWFkIiwiYnVmIiwicmVhZCIsInJlYWRlciIsImdldFJlYWRlciIsInZhbHVlIiwiZG9uZSIsIl9kZXN0cm95Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/compose.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\");\n/* replacement end */ const { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst kDestroy = Symbol(\"kDestroy\");\nconst kConstruct = Symbol(\"kConstruct\");\nfunction checkError(err, w, r) {\n    if (err) {\n        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n        err.stack // eslint-disable-line no-unused-expressions\n        ;\n        if (w && !w.errored) {\n            w.errored = err;\n        }\n        if (r && !r.errored) {\n            r.errored = err;\n        }\n    }\n}\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err, cb) {\n    const r = this._readableState;\n    const w = this._writableState;\n    // With duplex streams we use the writable side for state.\n    const s = w || r;\n    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {\n        if (typeof cb === \"function\") {\n            cb();\n        }\n        return this;\n    }\n    // We set destroyed to true before firing error callbacks in order\n    // to make it re-entrance safe in case destroy() is called within callbacks\n    checkError(err, w, r);\n    if (w) {\n        w.destroyed = true;\n    }\n    if (r) {\n        r.destroyed = true;\n    }\n    // If still constructing then defer calling _destroy.\n    if (!s.constructed) {\n        this.once(kDestroy, function(er) {\n            _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n    } else {\n        _destroy(this, err, cb);\n    }\n    return this;\n}\nfunction _destroy(self, err, cb) {\n    let called = false;\n    function onDestroy(err) {\n        if (called) {\n            return;\n        }\n        called = true;\n        const r = self._readableState;\n        const w = self._writableState;\n        checkError(err, w, r);\n        if (w) {\n            w.closed = true;\n        }\n        if (r) {\n            r.closed = true;\n        }\n        if (typeof cb === \"function\") {\n            cb(err);\n        }\n        if (err) {\n            process.nextTick(emitErrorCloseNT, self, err);\n        } else {\n            process.nextTick(emitCloseNT, self);\n        }\n    }\n    try {\n        self._destroy(err || null, onDestroy);\n    } catch (err) {\n        onDestroy(err);\n    }\n}\nfunction emitErrorCloseNT(self, err) {\n    emitErrorNT(self, err);\n    emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n    const r = self._readableState;\n    const w = self._writableState;\n    if (w) {\n        w.closeEmitted = true;\n    }\n    if (r) {\n        r.closeEmitted = true;\n    }\n    if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose) {\n        self.emit(\"close\");\n    }\n}\nfunction emitErrorNT(self, err) {\n    const r = self._readableState;\n    const w = self._writableState;\n    if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted) {\n        return;\n    }\n    if (w) {\n        w.errorEmitted = true;\n    }\n    if (r) {\n        r.errorEmitted = true;\n    }\n    self.emit(\"error\", err);\n}\nfunction undestroy() {\n    const r = this._readableState;\n    const w = this._writableState;\n    if (r) {\n        r.constructed = true;\n        r.closed = false;\n        r.closeEmitted = false;\n        r.destroyed = false;\n        r.errored = null;\n        r.errorEmitted = false;\n        r.reading = false;\n        r.ended = r.readable === false;\n        r.endEmitted = r.readable === false;\n    }\n    if (w) {\n        w.constructed = true;\n        w.destroyed = false;\n        w.closed = false;\n        w.closeEmitted = false;\n        w.errored = null;\n        w.errorEmitted = false;\n        w.finalCalled = false;\n        w.prefinished = false;\n        w.ended = w.writable === false;\n        w.ending = w.writable === false;\n        w.finished = w.writable === false;\n    }\n}\nfunction errorOrDestroy(stream, err, sync) {\n    // We have tests that rely on errors being emitted\n    // in the same tick, so changing this is semver major.\n    // For now when you opt-in to autoDestroy we allow\n    // the error to be emitted nextTick. In a future\n    // semver major update we should change the default to this.\n    const r = stream._readableState;\n    const w = stream._writableState;\n    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {\n        return this;\n    }\n    if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy) stream.destroy(err);\n    else if (err) {\n        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n        err.stack // eslint-disable-line no-unused-expressions\n        ;\n        if (w && !w.errored) {\n            w.errored = err;\n        }\n        if (r && !r.errored) {\n            r.errored = err;\n        }\n        if (sync) {\n            process.nextTick(emitErrorNT, stream, err);\n        } else {\n            emitErrorNT(stream, err);\n        }\n    }\n}\nfunction construct(stream, cb) {\n    if (typeof stream._construct !== \"function\") {\n        return;\n    }\n    const r = stream._readableState;\n    const w = stream._writableState;\n    if (r) {\n        r.constructed = false;\n    }\n    if (w) {\n        w.constructed = false;\n    }\n    stream.once(kConstruct, cb);\n    if (stream.listenerCount(kConstruct) > 1) {\n        // Duplex\n        return;\n    }\n    process.nextTick(constructNT, stream);\n}\nfunction constructNT(stream) {\n    let called = false;\n    function onConstruct(err) {\n        if (called) {\n            errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK());\n            return;\n        }\n        called = true;\n        const r = stream._readableState;\n        const w = stream._writableState;\n        const s = w || r;\n        if (r) {\n            r.constructed = true;\n        }\n        if (w) {\n            w.constructed = true;\n        }\n        if (s.destroyed) {\n            stream.emit(kDestroy, err);\n        } else if (err) {\n            errorOrDestroy(stream, err, true);\n        } else {\n            process.nextTick(emitConstructNT, stream);\n        }\n    }\n    try {\n        stream._construct((err)=>{\n            process.nextTick(onConstruct, err);\n        });\n    } catch (err) {\n        process.nextTick(onConstruct, err);\n    }\n}\nfunction emitConstructNT(stream) {\n    stream.emit(kConstruct);\n}\nfunction isRequest(stream) {\n    return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === \"function\";\n}\nfunction emitCloseLegacy(stream) {\n    stream.emit(\"close\");\n}\nfunction emitErrorCloseLegacy(stream, err) {\n    stream.emit(\"error\", err);\n    process.nextTick(emitCloseLegacy, stream);\n}\n// Normalize destroy for legacy.\nfunction destroyer(stream, err) {\n    if (!stream || isDestroyed(stream)) {\n        return;\n    }\n    if (!err && !isFinished(stream)) {\n        err = new AbortError();\n    }\n    // TODO: Remove isRequest branches.\n    if (isServerRequest(stream)) {\n        stream.socket = null;\n        stream.destroy(err);\n    } else if (isRequest(stream)) {\n        stream.abort();\n    } else if (isRequest(stream.req)) {\n        stream.req.abort();\n    } else if (typeof stream.destroy === \"function\") {\n        stream.destroy(err);\n    } else if (typeof stream.close === \"function\") {\n        // TODO: Don't lose err?\n        stream.close();\n    } else if (err) {\n        process.nextTick(emitErrorCloseLegacy, stream, err);\n    } else {\n        process.nextTick(emitCloseLegacy, stream);\n    }\n    if (!stream.destroyed) {\n        stream[kIsDestroyed] = true;\n    }\n}\nmodule.exports = {\n    construct,\n    destroyer,\n    destroy,\n    undestroy,\n    errorOrDestroy\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEscUJBQXFCLEdBRXJCLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXhCLG1CQUFtQixHQUVuQixNQUFNLEVBQ0pDLGtCQUFrQixFQUNsQkMsT0FBTyxFQUFFQyxxQkFBcUIsRUFBRSxFQUNoQ0MsVUFBVSxFQUNYLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFSyxNQUFNLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFTSxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxlQUFlLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDM0UsTUFBTVUsV0FBV0wsT0FBTztBQUN4QixNQUFNTSxhQUFhTixPQUFPO0FBQzFCLFNBQVNPLFdBQVdDLEdBQUcsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQzNCLElBQUlGLEtBQUs7UUFDUCxrRkFBa0Y7UUFDbEZBLElBQUlHLEtBQUssQ0FBQyw0Q0FBNEM7O1FBRXRELElBQUlGLEtBQUssQ0FBQ0EsRUFBRUcsT0FBTyxFQUFFO1lBQ25CSCxFQUFFRyxPQUFPLEdBQUdKO1FBQ2Q7UUFDQSxJQUFJRSxLQUFLLENBQUNBLEVBQUVFLE9BQU8sRUFBRTtZQUNuQkYsRUFBRUUsT0FBTyxHQUFHSjtRQUNkO0lBQ0Y7QUFDRjtBQUVBLGdFQUFnRTtBQUNoRSwwQ0FBMEM7QUFDMUMsU0FBU0ssUUFBUUwsR0FBRyxFQUFFTSxFQUFFO0lBQ3RCLE1BQU1KLElBQUksSUFBSSxDQUFDSyxjQUFjO0lBQzdCLE1BQU1OLElBQUksSUFBSSxDQUFDTyxjQUFjO0lBQzdCLDBEQUEwRDtJQUMxRCxNQUFNQyxJQUFJUixLQUFLQztJQUNmLElBQUksTUFBTyxRQUFRRCxNQUFNUyxh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WUFBWTZDLFNBQVM7UUFDbEM7SUFDRjtJQUNBLElBQUksQ0FBQ3ZDLE9BQU8sQ0FBQ0wsV0FBVzRDLFNBQVM7UUFDL0J2QyxNQUFNLElBQUlUO0lBQ1o7SUFFQSxtQ0FBbUM7SUFDbkMsSUFBSUssZ0JBQWdCMkMsU0FBUztRQUMzQkEsT0FBT2UsTUFBTSxHQUFHO1FBQ2hCZixPQUFPbEMsT0FBTyxDQUFDTDtJQUNqQixPQUFPLElBQUlnRCxVQUFVVCxTQUFTO1FBQzVCQSxPQUFPVyxLQUFLO0lBQ2QsT0FBTyxJQUFJRixVQUFVVCxPQUFPZ0IsR0FBRyxHQUFHO1FBQ2hDaEIsT0FBT2dCLEdBQUcsQ0FBQ0wsS0FBSztJQUNsQixPQUFPLElBQUksT0FBT1gsT0FBT2xDLE9BQU8sS0FBSyxZQUFZO1FBQy9Da0MsT0FBT2xDLE9BQU8sQ0FBQ0w7SUFDakIsT0FBTyxJQUFJLE9BQU91QyxPQUFPaUIsS0FBSyxLQUFLLFlBQVk7UUFDN0Msd0JBQXdCO1FBQ3hCakIsT0FBT2lCLEtBQUs7SUFDZCxPQUFPLElBQUl4RCxLQUFLO1FBQ2RkLFFBQVFrQyxRQUFRLENBQUNnQyxzQkFBc0JiLFFBQVF2QztJQUNqRCxPQUFPO1FBQ0xkLFFBQVFrQyxRQUFRLENBQUMrQixpQkFBaUJaO0lBQ3BDO0lBQ0EsSUFBSSxDQUFDQSxPQUFPNUIsU0FBUyxFQUFFO1FBQ3JCNEIsTUFBTSxDQUFDOUMsYUFBYSxHQUFHO0lBQ3pCO0FBQ0Y7QUFDQWdFLE9BQU9DLE9BQU8sR0FBRztJQUNmaEI7SUFDQVc7SUFDQWhEO0lBQ0F1QjtJQUNBVTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcz83YjQxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuY29uc3Qge1xuICBhZ2dyZWdhdGVUd29FcnJvcnMsXG4gIGNvZGVzOiB7IEVSUl9NVUxUSVBMRV9DQUxMQkFDSyB9LFxuICBBYm9ydEVycm9yXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyBTeW1ib2wgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBrSXNEZXN0cm95ZWQsIGlzRGVzdHJveWVkLCBpc0ZpbmlzaGVkLCBpc1NlcnZlclJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qga0Rlc3Ryb3kgPSBTeW1ib2woJ2tEZXN0cm95JylcbmNvbnN0IGtDb25zdHJ1Y3QgPSBTeW1ib2woJ2tDb25zdHJ1Y3QnKVxuZnVuY3Rpb24gY2hlY2tFcnJvcihlcnIsIHcsIHIpIHtcbiAgaWYgKGVycikge1xuICAgIC8vIEF2b2lkIFY4IGxlYWssIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM0MTAzI2lzc3VlY29tbWVudC02NTIwMDIzNjRcbiAgICBlcnIuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIGlmICh3ICYmICF3LmVycm9yZWQpIHtcbiAgICAgIHcuZXJyb3JlZCA9IGVyclxuICAgIH1cbiAgICBpZiAociAmJiAhci5lcnJvcmVkKSB7XG4gICAgICByLmVycm9yZWQgPSBlcnJcbiAgICB9XG4gIH1cbn1cblxuLy8gQmFja3dhcmRzIGNvbXBhdC4gY2IoKSBpcyB1bmRvY3VtZW50ZWQgYW5kIHVudXNlZCBpbiBjb3JlIGJ1dFxuLy8gdW5mb3J0dW5hdGVseSBtaWdodCBiZSB1c2VkIGJ5IG1vZHVsZXMuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgY29uc3QgciA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgLy8gV2l0aCBkdXBsZXggc3RyZWFtcyB3ZSB1c2UgdGhlIHdyaXRhYmxlIHNpZGUgZm9yIHN0YXRlLlxuICBjb25zdCBzID0gdyB8fCByXG4gIGlmICgodyAhPT0gbnVsbCAmJiB3ICE9PSB1bmRlZmluZWQgJiYgdy5kZXN0cm95ZWQpIHx8IChyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLmRlc3Ryb3llZCkpIHtcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBXZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG4gIGNoZWNrRXJyb3IoZXJyLCB3LCByKVxuICBpZiAodykge1xuICAgIHcuZGVzdHJveWVkID0gdHJ1ZVxuICB9XG4gIGlmIChyKSB7XG4gICAgci5kZXN0cm95ZWQgPSB0cnVlXG4gIH1cblxuICAvLyBJZiBzdGlsbCBjb25zdHJ1Y3RpbmcgdGhlbiBkZWZlciBjYWxsaW5nIF9kZXN0cm95LlxuICBpZiAoIXMuY29uc3RydWN0ZWQpIHtcbiAgICB0aGlzLm9uY2Uoa0Rlc3Ryb3ksIGZ1bmN0aW9uIChlcikge1xuICAgICAgX2Rlc3Ryb3kodGhpcywgYWdncmVnYXRlVHdvRXJyb3JzKGVyLCBlcnIpLCBjYilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIF9kZXN0cm95KHRoaXMsIGVyciwgY2IpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIF9kZXN0cm95KHNlbGYsIGVyciwgY2IpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gIGZ1bmN0aW9uIG9uRGVzdHJveShlcnIpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIGNvbnN0IHIgPSBzZWxmLl9yZWFkYWJsZVN0YXRlXG4gICAgY29uc3QgdyA9IHNlbGYuX3dyaXRhYmxlU3RhdGVcbiAgICBjaGVja0Vycm9yKGVyciwgdywgcilcbiAgICBpZiAodykge1xuICAgICAgdy5jbG9zZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICByLmNsb3NlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IoZXJyKVxuICAgIH1cbiAgICBpZiAoZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckNsb3NlTlQsIHNlbGYsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgc2VsZilcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBzZWxmLl9kZXN0cm95KGVyciB8fCBudWxsLCBvbkRlc3Ryb3kpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG9uRGVzdHJveShlcnIpXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRFcnJvckNsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycilcbiAgZW1pdENsb3NlTlQoc2VsZilcbn1cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgY29uc3QgciA9IHNlbGYuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHNlbGYuX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHcpIHtcbiAgICB3LmNsb3NlRW1pdHRlZCA9IHRydWVcbiAgfVxuICBpZiAocikge1xuICAgIHIuY2xvc2VFbWl0dGVkID0gdHJ1ZVxuICB9XG4gIGlmICgodyAhPT0gbnVsbCAmJiB3ICE9PSB1bmRlZmluZWQgJiYgdy5lbWl0Q2xvc2UpIHx8IChyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLmVtaXRDbG9zZSkpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfVxufVxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIGNvbnN0IHIgPSBzZWxmLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSBzZWxmLl93cml0YWJsZVN0YXRlXG4gIGlmICgodyAhPT0gbnVsbCAmJiB3ICE9PSB1bmRlZmluZWQgJiYgdy5lcnJvckVtaXR0ZWQpIHx8IChyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLmVycm9yRW1pdHRlZCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodykge1xuICAgIHcuZXJyb3JFbWl0dGVkID0gdHJ1ZVxuICB9XG4gIGlmIChyKSB7XG4gICAgci5lcnJvckVtaXR0ZWQgPSB0cnVlXG4gIH1cbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgY29uc3QgciA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHIpIHtcbiAgICByLmNvbnN0cnVjdGVkID0gdHJ1ZVxuICAgIHIuY2xvc2VkID0gZmFsc2VcbiAgICByLmNsb3NlRW1pdHRlZCA9IGZhbHNlXG4gICAgci5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHIuZXJyb3JlZCA9IG51bGxcbiAgICByLmVycm9yRW1pdHRlZCA9IGZhbHNlXG4gICAgci5yZWFkaW5nID0gZmFsc2VcbiAgICByLmVuZGVkID0gci5yZWFkYWJsZSA9PT0gZmFsc2VcbiAgICByLmVuZEVtaXR0ZWQgPSByLnJlYWRhYmxlID09PSBmYWxzZVxuICB9XG4gIGlmICh3KSB7XG4gICAgdy5jb25zdHJ1Y3RlZCA9IHRydWVcbiAgICB3LmRlc3Ryb3llZCA9IGZhbHNlXG4gICAgdy5jbG9zZWQgPSBmYWxzZVxuICAgIHcuY2xvc2VFbWl0dGVkID0gZmFsc2VcbiAgICB3LmVycm9yZWQgPSBudWxsXG4gICAgdy5lcnJvckVtaXR0ZWQgPSBmYWxzZVxuICAgIHcuZmluYWxDYWxsZWQgPSBmYWxzZVxuICAgIHcucHJlZmluaXNoZWQgPSBmYWxzZVxuICAgIHcuZW5kZWQgPSB3LndyaXRhYmxlID09PSBmYWxzZVxuICAgIHcuZW5kaW5nID0gdy53cml0YWJsZSA9PT0gZmFsc2VcbiAgICB3LmZpbmlzaGVkID0gdy53cml0YWJsZSA9PT0gZmFsc2VcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIsIHN5bmMpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cblxuICBjb25zdCByID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgaWYgKCh3ICE9PSBudWxsICYmIHcgIT09IHVuZGVmaW5lZCAmJiB3LmRlc3Ryb3llZCkgfHwgKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIuZGVzdHJveWVkKSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKChyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLmF1dG9EZXN0cm95KSB8fCAodyAhPT0gbnVsbCAmJiB3ICE9PSB1bmRlZmluZWQgJiYgdy5hdXRvRGVzdHJveSkpXG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICBlbHNlIGlmIChlcnIpIHtcbiAgICAvLyBBdm9pZCBWOCBsZWFrLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDEwMyNpc3N1ZWNvbW1lbnQtNjUyMDAyMzY0XG4gICAgZXJyLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICBpZiAodyAmJiAhdy5lcnJvcmVkKSB7XG4gICAgICB3LmVycm9yZWQgPSBlcnJcbiAgICB9XG4gICAgaWYgKHIgJiYgIXIuZXJyb3JlZCkge1xuICAgICAgci5lcnJvcmVkID0gZXJyXG4gICAgfVxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCBzdHJlYW0sIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yTlQoc3RyZWFtLCBlcnIpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3Qoc3RyZWFtLCBjYikge1xuICBpZiAodHlwZW9mIHN0cmVhbS5fY29uc3RydWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgciA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGlmIChyKSB7XG4gICAgci5jb25zdHJ1Y3RlZCA9IGZhbHNlXG4gIH1cbiAgaWYgKHcpIHtcbiAgICB3LmNvbnN0cnVjdGVkID0gZmFsc2VcbiAgfVxuICBzdHJlYW0ub25jZShrQ29uc3RydWN0LCBjYilcbiAgaWYgKHN0cmVhbS5saXN0ZW5lckNvdW50KGtDb25zdHJ1Y3QpID4gMSkge1xuICAgIC8vIER1cGxleFxuICAgIHJldHVyblxuICB9XG4gIHByb2Nlc3MubmV4dFRpY2soY29uc3RydWN0TlQsIHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdE5UKHN0cmVhbSkge1xuICBsZXQgY2FsbGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gb25Db25zdHJ1Y3QoZXJyKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQgPyBlcnIgOiBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIGNvbnN0IHIgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgICBjb25zdCB3ID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gICAgY29uc3QgcyA9IHcgfHwgclxuICAgIGlmIChyKSB7XG4gICAgICByLmNvbnN0cnVjdGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAodykge1xuICAgICAgdy5jb25zdHJ1Y3RlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKHMuZGVzdHJveWVkKSB7XG4gICAgICBzdHJlYW0uZW1pdChrRGVzdHJveSwgZXJyKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyciwgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q29uc3RydWN0TlQsIHN0cmVhbSlcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBzdHJlYW0uX2NvbnN0cnVjdCgoZXJyKSA9PiB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKG9uQ29uc3RydWN0LCBlcnIpXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbkNvbnN0cnVjdCwgZXJyKVxuICB9XG59XG5mdW5jdGlvbiBlbWl0Q29uc3RydWN0TlQoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KGtDb25zdHJ1Y3QpXG59XG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiAoc3RyZWFtID09PSBudWxsIHx8IHN0cmVhbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc3RyZWFtLnNldEhlYWRlcikgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJ1xufVxuZnVuY3Rpb24gZW1pdENsb3NlTGVnYWN5KHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxufVxuZnVuY3Rpb24gZW1pdEVycm9yQ2xvc2VMZWdhY3koc3RyZWFtLCBlcnIpIHtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZUxlZ2FjeSwgc3RyZWFtKVxufVxuXG4vLyBOb3JtYWxpemUgZGVzdHJveSBmb3IgbGVnYWN5LlxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgZXJyKSB7XG4gIGlmICghc3RyZWFtIHx8IGlzRGVzdHJveWVkKHN0cmVhbSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWVyciAmJiAhaXNGaW5pc2hlZChzdHJlYW0pKSB7XG4gICAgZXJyID0gbmV3IEFib3J0RXJyb3IoKVxuICB9XG5cbiAgLy8gVE9ETzogUmVtb3ZlIGlzUmVxdWVzdCBicmFuY2hlcy5cbiAgaWYgKGlzU2VydmVyUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLnNvY2tldCA9IG51bGxcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH0gZWxzZSBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0uYWJvcnQoKVxuICB9IGVsc2UgaWYgKGlzUmVxdWVzdChzdHJlYW0ucmVxKSkge1xuICAgIHN0cmVhbS5yZXEuYWJvcnQoKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtLmNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVE9ETzogRG9uJ3QgbG9zZSBlcnI/XG4gICAgc3RyZWFtLmNsb3NlKClcbiAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckNsb3NlTGVnYWN5LCBzdHJlYW0sIGVycilcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZUxlZ2FjeSwgc3RyZWFtKVxuICB9XG4gIGlmICghc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgIHN0cmVhbVtrSXNEZXN0cm95ZWRdID0gdHJ1ZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uc3RydWN0LFxuICBkZXN0cm95ZXIsXG4gIGRlc3Ryb3ksXG4gIHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3lcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwicmVxdWlyZSIsImFnZ3JlZ2F0ZVR3b0Vycm9ycyIsImNvZGVzIiwiRVJSX01VTFRJUExFX0NBTExCQUNLIiwiQWJvcnRFcnJvciIsIlN5bWJvbCIsImtJc0Rlc3Ryb3llZCIsImlzRGVzdHJveWVkIiwiaXNGaW5pc2hlZCIsImlzU2VydmVyUmVxdWVzdCIsImtEZXN0cm95Iiwia0NvbnN0cnVjdCIsImNoZWNrRXJyb3IiLCJlcnIiLCJ3IiwiciIsInN0YWNrIiwiZXJyb3JlZCIsImRlc3Ryb3kiLCJjYiIsIl9yZWFkYWJsZVN0YXRlIiwiX3dyaXRhYmxlU3RhdGUiLCJzIiwidW5kZWZpbmVkIiwiZGVzdHJveWVkIiwiY29uc3RydWN0ZWQiLCJvbmNlIiwiZXIiLCJfZGVzdHJveSIsInNlbGYiLCJjYWxsZWQiLCJvbkRlc3Ryb3kiLCJjbG9zZWQiLCJuZXh0VGljayIsImVtaXRFcnJvckNsb3NlTlQiLCJlbWl0Q2xvc2VOVCIsImVtaXRFcnJvck5UIiwiY2xvc2VFbWl0dGVkIiwiZW1pdENsb3NlIiwiZW1pdCIsImVycm9yRW1pdHRlZCIsInVuZGVzdHJveSIsInJlYWRpbmciLCJlbmRlZCIsInJlYWRhYmxlIiwiZW5kRW1pdHRlZCIsImZpbmFsQ2FsbGVkIiwicHJlZmluaXNoZWQiLCJ3cml0YWJsZSIsImVuZGluZyIsImZpbmlzaGVkIiwiZXJyb3JPckRlc3Ryb3kiLCJzdHJlYW0iLCJzeW5jIiwiYXV0b0Rlc3Ryb3kiLCJjb25zdHJ1Y3QiLCJfY29uc3RydWN0IiwibGlzdGVuZXJDb3VudCIsImNvbnN0cnVjdE5UIiwib25Db25zdHJ1Y3QiLCJlbWl0Q29uc3RydWN0TlQiLCJpc1JlcXVlc3QiLCJzZXRIZWFkZXIiLCJhYm9ydCIsImVtaXRDbG9zZUxlZ2FjeSIsImVtaXRFcnJvckNsb3NlTGVnYWN5IiwiZGVzdHJveWVyIiwic29ja2V0IiwicmVxIiwiY2xvc2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n\nconst { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nmodule.exports = Duplex;\nconst Readable = __webpack_require__(/*! ./readable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js\");\nconst Writable = __webpack_require__(/*! ./writable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/writable.js\");\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);\nObjectSetPrototypeOf(Duplex, Readable);\n{\n    const keys = ObjectKeys(Writable.prototype);\n    // Allow the keys array to be GC'ed.\n    for(let i = 0; i < keys.length; i++){\n        const method = keys[i];\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n    }\n}function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options) {\n        this.allowHalfOpen = options.allowHalfOpen !== false;\n        if (options.readable === false) {\n            this._readableState.readable = false;\n            this._readableState.ended = true;\n            this._readableState.endEmitted = true;\n        }\n        if (options.writable === false) {\n            this._writableState.writable = false;\n            this._writableState.ending = true;\n            this._writableState.ended = true;\n            this._writableState.finished = true;\n        }\n    } else {\n        this.allowHalfOpen = true;\n    }\n}\nObjectDefineProperties(Duplex.prototype, {\n    writable: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\")\n    },\n    writableHighWaterMark: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\")\n    },\n    writableObjectMode: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\")\n    },\n    writableBuffer: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\")\n    },\n    writableLength: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\")\n    },\n    writableFinished: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\")\n    },\n    writableCorked: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\")\n    },\n    writableEnded: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\")\n    },\n    writableNeedDrain: {\n        __proto__: null,\n        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\")\n    },\n    destroyed: {\n        __proto__: null,\n        get () {\n            if (this._readableState === undefined || this._writableState === undefined) {\n                return false;\n            }\n            return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set (value) {\n            // Backward compatibility, the user is explicitly\n            // managing destroyed.\n            if (this._readableState && this._writableState) {\n                this._readableState.destroyed = value;\n                this._writableState.destroyed = value;\n            }\n        }\n    }\n});\nlet webStreamsAdapters;\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n    if (webStreamsAdapters === undefined) webStreamsAdapters = {};\n    return webStreamsAdapters;\n}\nDuplex.fromWeb = function(pair, options) {\n    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n};\nDuplex.toWeb = function(duplex) {\n    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\nlet duplexify;\nDuplex.from = function(body) {\n    if (!duplexify) {\n        duplexify = __webpack_require__(/*! ./duplexify */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplexify.js\");\n    }\n    return duplexify(body, \"body\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6Qyx1RUFBdUU7QUFDdkUsbUVBQW1FO0FBQ25FLHFFQUFxRTtBQUNyRSxZQUFZO0FBRVo7QUFFQSxNQUFNLEVBQ0pBLHNCQUFzQixFQUN0QkMsOEJBQThCLEVBQzlCQyxVQUFVLEVBQ1ZDLG9CQUFvQixFQUNyQixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaQyxPQUFPQyxPQUFPLEdBQUdDO0FBQ2pCLE1BQU1DLFdBQVdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDO0FBQ3pCRCxxQkFBcUJJLE9BQU9HLFNBQVMsRUFBRUYsU0FBU0UsU0FBUztBQUN6RFAscUJBQXFCSSxRQUFRQztBQUM3QjtJQUNFLE1BQU1HLE9BQU9ULFdBQVdPLFNBQVNDLFNBQVM7SUFDMUMsb0NBQW9DO0lBQ3BDLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRCxLQUFLRSxNQUFNLEVBQUVELElBQUs7UUFDcEMsTUFBTUUsU0FBU0gsSUFBSSxDQUFDQyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0wsT0FBT0csU0FBUyxDQUFDSSxPQUFPLEVBQUVQLE9BQU9HLFNBQVMsQ0FBQ0ksT0FBTyxHQUFHTCxTQUFT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QyxPQUFPbUMsT0FBTyxHQUFHLFNBQVVDLElBQUksRUFBRTVCLE9BQU87SUFDdEMsT0FBTzBCLGlCQUFpQkcsdUNBQXVDLENBQUNELE1BQU01QjtBQUN4RTtBQUNBUixPQUFPc0MsS0FBSyxHQUFHLFNBQVVDLE1BQU07SUFDN0IsT0FBT0wsaUJBQWlCTSxpQ0FBaUMsQ0FBQ0Q7QUFDNUQ7QUFDQSxJQUFJRTtBQUNKekMsT0FBTzBDLElBQUksR0FBRyxTQUFVQyxJQUFJO0lBQzFCLElBQUksQ0FBQ0YsV0FBVztRQUNkQSxZQUFZNUMsbUJBQU9BLENBQUM7SUFDdEI7SUFDQSxPQUFPNEMsVUFBVUUsTUFBTTtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2R1cGxleC5qcz84NDhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwZSBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBpY2FsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgT2JqZWN0RGVmaW5lUHJvcGVydGllcyxcbiAgT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBPYmplY3RLZXlzLFxuICBPYmplY3RTZXRQcm90b3R5cGVPZlxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXhcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUnKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoRHVwbGV4LnByb3RvdHlwZSwgUmVhZGFibGUucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoRHVwbGV4LCBSZWFkYWJsZSlcbntcbiAgY29uc3Qga2V5cyA9IE9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKVxuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0aG9kID0ga2V5c1tpXVxuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXVxuICB9XG59XG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucylcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKVxuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gb3B0aW9ucy5hbGxvd0hhbGZPcGVuICE9PSBmYWxzZVxuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUud3JpdGFibGUgPSBmYWxzZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSB0cnVlXG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZVxuICB9XG59XG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKER1cGxleC5wcm90b3R5cGUsIHtcbiAgd3JpdGFibGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlJylcbiAgfSxcbiAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnKVxuICB9LFxuICB3cml0YWJsZU9iamVjdE1vZGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlT2JqZWN0TW9kZScpXG4gIH0sXG4gIHdyaXRhYmxlQnVmZmVyOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicpXG4gIH0sXG4gIHdyaXRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcpXG4gIH0sXG4gIHdyaXRhYmxlRmluaXNoZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlRmluaXNoZWQnKVxuICB9LFxuICB3cml0YWJsZUNvcmtlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVDb3JrZWQnKVxuICB9LFxuICB3cml0YWJsZUVuZGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUVuZGVkJylcbiAgfSxcbiAgd3JpdGFibGVOZWVkRHJhaW46IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTmVlZERyYWluJylcbiAgfSxcbiAgZGVzdHJveWVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZC5cbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZVxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxubGV0IHdlYlN0cmVhbXNBZGFwdGVyc1xuXG4vLyBMYXp5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbmZ1bmN0aW9uIGxhenlXZWJTdHJlYW1zKCkge1xuICBpZiAod2ViU3RyZWFtc0FkYXB0ZXJzID09PSB1bmRlZmluZWQpIHdlYlN0cmVhbXNBZGFwdGVycyA9IHt9XG4gIHJldHVybiB3ZWJTdHJlYW1zQWRhcHRlcnNcbn1cbkR1cGxleC5mcm9tV2ViID0gZnVuY3Rpb24gKHBhaXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3U3RyZWFtRHVwbGV4RnJvbVJlYWRhYmxlV3JpdGFibGVQYWlyKHBhaXIsIG9wdGlvbnMpXG59XG5EdXBsZXgudG9XZWIgPSBmdW5jdGlvbiAoZHVwbGV4KSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1JlYWRhYmxlV3JpdGFibGVQYWlyRnJvbUR1cGxleChkdXBsZXgpXG59XG5sZXQgZHVwbGV4aWZ5XG5EdXBsZXguZnJvbSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIGlmICghZHVwbGV4aWZ5KSB7XG4gICAgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnLi9kdXBsZXhpZnknKVxuICB9XG4gIHJldHVybiBkdXBsZXhpZnkoYm9keSwgJ2JvZHknKVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdERlZmluZVByb3BlcnRpZXMiLCJPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJPYmplY3RLZXlzIiwiT2JqZWN0U2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIkR1cGxleCIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJwcm90b3R5cGUiLCJrZXlzIiwiaSIsImxlbmd0aCIsIm1ldGhvZCIsIm9wdGlvbnMiLCJjYWxsIiwiYWxsb3dIYWxmT3BlbiIsInJlYWRhYmxlIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRlZCIsImVuZEVtaXR0ZWQiLCJ3cml0YWJsZSIsIl93cml0YWJsZVN0YXRlIiwiZW5kaW5nIiwiZmluaXNoZWQiLCJfX3Byb3RvX18iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJ3cml0YWJsZUJ1ZmZlciIsIndyaXRhYmxlTGVuZ3RoIiwid3JpdGFibGVGaW5pc2hlZCIsIndyaXRhYmxlQ29ya2VkIiwid3JpdGFibGVFbmRlZCIsIndyaXRhYmxlTmVlZERyYWluIiwiZGVzdHJveWVkIiwiZ2V0IiwidW5kZWZpbmVkIiwic2V0IiwidmFsdWUiLCJ3ZWJTdHJlYW1zQWRhcHRlcnMiLCJsYXp5V2ViU3RyZWFtcyIsImZyb21XZWIiLCJwYWlyIiwibmV3U3RyZWFtRHVwbGV4RnJvbVJlYWRhYmxlV3JpdGFibGVQYWlyIiwidG9XZWIiLCJkdXBsZXgiLCJuZXdSZWFkYWJsZVdyaXRhYmxlUGFpckZyb21EdXBsZXgiLCJkdXBsZXhpZnkiLCJmcm9tIiwiYm9keSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplexify.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplexify.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\") /* replacement end */ ;\n\"use strict\";\nconst bufferModule = __webpack_require__(/*! buffer */ \"buffer\");\nconst { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nconst { AbortError, codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE } } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { destroyer } = __webpack_require__(/*! ./destroy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\nconst Readable = __webpack_require__(/*! ./readable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js\");\nconst Writable = __webpack_require__(/*! ./writable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/writable.js\");\nconst { createDeferredPromise } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nconst from = __webpack_require__(/*! ./from */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/from.js\");\nconst Blob = globalThis.Blob || bufferModule.Blob;\nconst isBlob = typeof Blob !== \"undefined\" ? function isBlob(b) {\n    return b instanceof Blob;\n} : function isBlob(b) {\n    return false;\n};\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController);\nconst { FunctionPrototypeCall } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n    constructor(options){\n        super(options);\n        // https://github.com/nodejs/node/pull/34385\n        if ((options === null || options === undefined ? undefined : options.readable) === false) {\n            this._readableState.readable = false;\n            this._readableState.ended = true;\n            this._readableState.endEmitted = true;\n        }\n        if ((options === null || options === undefined ? undefined : options.writable) === false) {\n            this._writableState.writable = false;\n            this._writableState.ending = true;\n            this._writableState.ended = true;\n            this._writableState.finished = true;\n        }\n    }\n}\nmodule.exports = function duplexify(body, name) {\n    if (isDuplexNodeStream(body)) {\n        return body;\n    }\n    if (isReadableNodeStream(body)) {\n        return _duplexify({\n            readable: body\n        });\n    }\n    if (isWritableNodeStream(body)) {\n        return _duplexify({\n            writable: body\n        });\n    }\n    if (isNodeStream(body)) {\n        return _duplexify({\n            writable: false,\n            readable: false\n        });\n    }\n    if (isReadableStream(body)) {\n        return _duplexify({\n            readable: Readable.fromWeb(body)\n        });\n    }\n    if (isWritableStream(body)) {\n        return _duplexify({\n            writable: Writable.fromWeb(body)\n        });\n    }\n    if (typeof body === \"function\") {\n        const { value, write, final, destroy } = fromAsyncGen(body);\n        if (isIterable(value)) {\n            return from(Duplexify, value, {\n                // TODO (ronag): highWaterMark?\n                objectMode: true,\n                write,\n                final,\n                destroy\n            });\n        }\n        const then = value === null || value === undefined ? undefined : value.then;\n        if (typeof then === \"function\") {\n            let d;\n            const promise = FunctionPrototypeCall(then, value, (val)=>{\n                if (val != null) {\n                    throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n                }\n            }, (err)=>{\n                destroyer(d, err);\n            });\n            return d = new Duplexify({\n                // TODO (ronag): highWaterMark?\n                objectMode: true,\n                readable: false,\n                write,\n                final (cb) {\n                    final(async ()=>{\n                        try {\n                            await promise;\n                            process.nextTick(cb, null);\n                        } catch (err) {\n                            process.nextTick(cb, err);\n                        }\n                    });\n                },\n                destroy\n            });\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n    }\n    if (isBlob(body)) {\n        return duplexify(body.arrayBuffer());\n    }\n    if (isIterable(body)) {\n        return from(Duplexify, body, {\n            // TODO (ronag): highWaterMark?\n            objectMode: true,\n            writable: false\n        });\n    }\n    if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable)) {\n        return Duplexify.fromWeb(body);\n    }\n    if (typeof (body === null || body === undefined ? undefined : body.writable) === \"object\" || typeof (body === null || body === undefined ? undefined : body.readable) === \"object\") {\n        const readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;\n        const writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;\n        return _duplexify({\n            readable,\n            writable\n        });\n    }\n    const then = body === null || body === undefined ? undefined : body.then;\n    if (typeof then === \"function\") {\n        let d;\n        FunctionPrototypeCall(then, body, (val)=>{\n            if (val != null) {\n                d.push(val);\n            }\n            d.push(null);\n        }, (err)=>{\n            destroyer(d, err);\n        });\n        return d = new Duplexify({\n            objectMode: true,\n            writable: false,\n            read () {}\n        });\n    }\n    throw new ERR_INVALID_ARG_TYPE(name, [\n        \"Blob\",\n        \"ReadableStream\",\n        \"WritableStream\",\n        \"Stream\",\n        \"Iterable\",\n        \"AsyncIterable\",\n        \"Function\",\n        \"{ readable, writable } pair\",\n        \"Promise\"\n    ], body);\n};\nfunction fromAsyncGen(fn) {\n    let { promise, resolve } = createDeferredPromise();\n    const ac = new AbortController();\n    const signal = ac.signal;\n    const value = fn(async function*() {\n        while(true){\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            process.nextTick(cb);\n            if (done) return;\n            if (signal.aborted) throw new AbortError(undefined, {\n                cause: signal.reason\n            });\n            ({ promise, resolve } = createDeferredPromise());\n            yield chunk;\n        }\n    }(), {\n        signal\n    });\n    return {\n        value,\n        write (chunk, encoding, cb) {\n            const _resolve = resolve;\n            resolve = null;\n            _resolve({\n                chunk,\n                done: false,\n                cb\n            });\n        },\n        final (cb) {\n            const _resolve = resolve;\n            resolve = null;\n            _resolve({\n                done: true,\n                cb\n            });\n        },\n        destroy (err, cb) {\n            ac.abort();\n            cb(err);\n        }\n    };\n}\nfunction _duplexify(pair) {\n    const r = pair.readable && typeof pair.readable.read !== \"function\" ? Readable.wrap(pair.readable) : pair.readable;\n    const w = pair.writable;\n    let readable = !!isReadable(r);\n    let writable = !!isWritable(w);\n    let ondrain;\n    let onfinish;\n    let onreadable;\n    let onclose;\n    let d;\n    function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n            cb(err);\n        } else if (err) {\n            d.destroy(err);\n        }\n    }\n    // TODO(ronag): Avoid double buffering.\n    // Implement Writable/Readable/Duplex traits.\n    // See, https://github.com/nodejs/node/pull/33515.\n    d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n        readable,\n        writable\n    });\n    if (writable) {\n        eos(w, (err)=>{\n            writable = false;\n            if (err) {\n                destroyer(r, err);\n            }\n            onfinished(err);\n        });\n        d._write = function(chunk, encoding, callback) {\n            if (w.write(chunk, encoding)) {\n                callback();\n            } else {\n                ondrain = callback;\n            }\n        };\n        d._final = function(callback) {\n            w.end();\n            onfinish = callback;\n        };\n        w.on(\"drain\", function() {\n            if (ondrain) {\n                const cb = ondrain;\n                ondrain = null;\n                cb();\n            }\n        });\n        w.on(\"finish\", function() {\n            if (onfinish) {\n                const cb = onfinish;\n                onfinish = null;\n                cb();\n            }\n        });\n    }\n    if (readable) {\n        eos(r, (err)=>{\n            readable = false;\n            if (err) {\n                destroyer(r, err);\n            }\n            onfinished(err);\n        });\n        r.on(\"readable\", function() {\n            if (onreadable) {\n                const cb = onreadable;\n                onreadable = null;\n                cb();\n            }\n        });\n        r.on(\"end\", function() {\n            d.push(null);\n        });\n        d._read = function() {\n            while(true){\n                const buf = r.read();\n                if (buf === null) {\n                    onreadable = d._read;\n                    return;\n                }\n                if (!d.push(buf)) {\n                    return;\n                }\n            }\n        };\n    }\n    d._destroy = function(err, callback) {\n        if (!err && onclose !== null) {\n            err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n            callback(err);\n        } else {\n            onclose = callback;\n            destroyer(w, err);\n            destroyer(r, err);\n        }\n    };\n    return d;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXhpZnkuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLEdBRXJCLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDLDBEQUV4QixtQkFBbUI7QUFFakI7QUFDRixNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQ0pFLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFlBQVksRUFDWkMsb0JBQW9CLEVBQ3BCQyxvQkFBb0IsRUFDcEJDLGtCQUFrQixFQUNsQkMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDakIsR0FBR1YsbUJBQU9BLENBQUM7QUFDWixNQUFNVyxNQUFNWCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQ0pZLFVBQVUsRUFDVkMsT0FBTyxFQUFFQyxvQkFBb0IsRUFBRUMsd0JBQXdCLEVBQUUsRUFDMUQsR0FBR2YsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVnQixTQUFTLEVBQUUsR0FBR2hCLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1pQixTQUFTakIsbUJBQU9BLENBQUM7QUFDdkIsTUFBTWtCLFdBQVdsQixtQkFBT0EsQ0FBQztBQUN6QixNQUFNbUIsV0FBV25CLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRW9CLHFCQUFxQixFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQztBQUMxQyxNQUFNcUIsT0FBT3JCLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1zQixPQUFPQyxXQUFXRCxJQUFJLElBQUlyQixhQUFhcUIsSUFBSTtBQUNqRCxNQUFNRSxTQUNKLE9BQU9GLFNBQVMsY0FDWixTQUFTRSxPQUFPQyxDQUFDO0lBQ2YsT0FBT0EsYUFBYUg7QUFDdEIsSUFDQSxTQUFTRSxPQUFPQyxDQUFDO0lBQ2YsT0FBTztBQUNUO0FBQ04sTUFBTUMsa0JBQWtC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QUFNO29CQUNoQlgsYUFBYTVCLEVBQUVzQyxLQUFLO29CQUNwQjtnQkFDRjtnQkFDQSxJQUFJLENBQUN0QyxFQUFFTyxJQUFJLENBQUNnQyxNQUFNO29CQUNoQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBdkMsRUFBRXdDLFFBQVEsR0FBRyxTQUFVckMsR0FBRyxFQUFFK0IsUUFBUTtRQUNsQyxJQUFJLENBQUMvQixPQUFPMEIsWUFBWSxNQUFNO1lBQzVCMUIsTUFBTSxJQUFJN0M7UUFDWjtRQUNBc0UsYUFBYTtRQUNiRixVQUFVO1FBQ1ZDLFdBQVc7UUFDWCxJQUFJRSxZQUFZLE1BQU07WUFDcEJLLFNBQVMvQjtRQUNYLE9BQU87WUFDTDBCLFVBQVVLO1lBQ1Z4RSxVQUFVK0QsR0FBR3RCO1lBQ2J6QyxVQUFVNkQsR0FBR3BCO1FBQ2Y7SUFDRjtJQUNBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXhpZnkuanM/YzViNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCBidWZmZXJNb2R1bGUgPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qge1xuICBpc1JlYWRhYmxlLFxuICBpc1dyaXRhYmxlLFxuICBpc0l0ZXJhYmxlLFxuICBpc05vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlTm9kZVN0cmVhbSxcbiAgaXNEdXBsZXhOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxuY29uc3Qge1xuICBBYm9ydEVycm9yLFxuICBjb2RlczogeyBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFIH1cbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IGRlc3Ryb3llciB9ID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUnKVxuY29uc3QgeyBjcmVhdGVEZWZlcnJlZFByb21pc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCBmcm9tID0gcmVxdWlyZSgnLi9mcm9tJylcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYnVmZmVyTW9kdWxlLkJsb2JcbmNvbnN0IGlzQmxvYiA9XG4gIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCbG9iXG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiBpc0Jsb2IoYikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmNvbnN0IHsgRnVuY3Rpb25Qcm90b3R5cGVDYWxsIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcblxuLy8gVGhpcyBpcyBuZWVkZWQgZm9yIHByZSBub2RlIDE3LlxuY2xhc3MgRHVwbGV4aWZ5IGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDM4NVxuXG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucmVhZGFibGUpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy53cml0YWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlID0gZmFsc2VcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gdHJ1ZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSB0cnVlXG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGR1cGxleGlmeShib2R5LCBuYW1lKSB7XG4gIGlmIChpc0R1cGxleE5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gYm9keVxuICB9XG4gIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbShib2R5KSkge1xuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHJlYWRhYmxlOiBib2R5XG4gICAgfSlcbiAgfVxuICBpZiAoaXNXcml0YWJsZU5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogYm9keVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzTm9kZVN0cmVhbShib2R5KSkge1xuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHJlYWRhYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICByZWFkYWJsZTogUmVhZGFibGUuZnJvbVdlYihib2R5KVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzV3JpdGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogV3JpdGFibGUuZnJvbVdlYihib2R5KVxuICAgIH0pXG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgd3JpdGUsIGZpbmFsLCBkZXN0cm95IH0gPSBmcm9tQXN5bmNHZW4oYm9keSlcbiAgICBpZiAoaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tKER1cGxleGlmeSwgdmFsdWUsIHtcbiAgICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB3cml0ZSxcbiAgICAgICAgZmluYWwsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbnN0IHRoZW4gPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdmFsdWUudGhlblxuICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IGRcbiAgICAgIGNvbnN0IHByb21pc2UgPSBGdW5jdGlvblByb3RvdHlwZUNhbGwoXG4gICAgICAgIHRoZW4sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAodmFsKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdudWxseScsICdib2R5JywgdmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIGRlc3Ryb3llcihkLCBlcnIpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiAoZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgICAgICAvLyBUT0RPIChyb25hZyk6IGhpZ2hXYXRlck1hcms/XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGUsXG4gICAgICAgIGZpbmFsKGNiKSB7XG4gICAgICAgICAgZmluYWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KSlcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnSXRlcmFibGUsIEFzeW5jSXRlcmFibGUgb3IgQXN5bmNGdW5jdGlvbicsIG5hbWUsIHZhbHVlKVxuICB9XG4gIGlmIChpc0Jsb2IoYm9keSkpIHtcbiAgICByZXR1cm4gZHVwbGV4aWZ5KGJvZHkuYXJyYXlCdWZmZXIoKSlcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmcm9tKER1cGxleGlmeSwgYm9keSwge1xuICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgaWYgKFxuICAgIGlzUmVhZGFibGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnJlYWRhYmxlKSAmJlxuICAgIGlzV3JpdGFibGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKVxuICApIHtcbiAgICByZXR1cm4gRHVwbGV4aWZ5LmZyb21XZWIoYm9keSlcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIChib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkud3JpdGFibGUpID09PSAnb2JqZWN0JyB8fFxuICAgIHR5cGVvZiAoYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnJlYWRhYmxlKSA9PT0gJ29iamVjdCdcbiAgKSB7XG4gICAgY29uc3QgcmVhZGFibGUgPVxuICAgICAgYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB1bmRlZmluZWQgJiYgYm9keS5yZWFkYWJsZVxuICAgICAgICA/IGlzUmVhZGFibGVOb2RlU3RyZWFtKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS5yZWFkYWJsZSlcbiAgICAgICAgICA/IGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBib2R5LnJlYWRhYmxlXG4gICAgICAgICAgOiBkdXBsZXhpZnkoYm9keS5yZWFkYWJsZSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICBjb25zdCB3cml0YWJsZSA9XG4gICAgICBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHVuZGVmaW5lZCAmJiBib2R5LndyaXRhYmxlXG4gICAgICAgID8gaXNXcml0YWJsZU5vZGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKVxuICAgICAgICAgID8gYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGJvZHkud3JpdGFibGVcbiAgICAgICAgICA6IGR1cGxleGlmeShib2R5LndyaXRhYmxlKVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHJlYWRhYmxlLFxuICAgICAgd3JpdGFibGVcbiAgICB9KVxuICB9XG4gIGNvbnN0IHRoZW4gPSBib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkudGhlblxuICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBsZXQgZFxuICAgIEZ1bmN0aW9uUHJvdG90eXBlQ2FsbChcbiAgICAgIHRoZW4sXG4gICAgICBib2R5LFxuICAgICAgKHZhbCkgPT4ge1xuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICBkLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICAgIGQucHVzaChudWxsKVxuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgZGVzdHJveWVyKGQsIGVycilcbiAgICAgIH1cbiAgICApXG4gICAgcmV0dXJuIChkID0gbmV3IER1cGxleGlmeSh7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgcmVhZCgpIHt9XG4gICAgfSkpXG4gIH1cbiAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgIG5hbWUsXG4gICAgW1xuICAgICAgJ0Jsb2InLFxuICAgICAgJ1JlYWRhYmxlU3RyZWFtJyxcbiAgICAgICdXcml0YWJsZVN0cmVhbScsXG4gICAgICAnU3RyZWFtJyxcbiAgICAgICdJdGVyYWJsZScsXG4gICAgICAnQXN5bmNJdGVyYWJsZScsXG4gICAgICAnRnVuY3Rpb24nLFxuICAgICAgJ3sgcmVhZGFibGUsIHdyaXRhYmxlIH0gcGFpcicsXG4gICAgICAnUHJvbWlzZSdcbiAgICBdLFxuICAgIGJvZHlcbiAgKVxufVxuZnVuY3Rpb24gZnJvbUFzeW5jR2VuKGZuKSB7XG4gIGxldCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIGNvbnN0IHNpZ25hbCA9IGFjLnNpZ25hbFxuICBjb25zdCB2YWx1ZSA9IGZuKFxuICAgIChhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgX3Byb21pc2UgPSBwcm9taXNlXG4gICAgICAgIHByb21pc2UgPSBudWxsXG4gICAgICAgIGNvbnN0IHsgY2h1bmssIGRvbmUsIGNiIH0gPSBhd2FpdCBfcHJvbWlzZVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgfSlcbiAgICAgICAgOyh7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpKVxuICAgICAgICB5aWVsZCBjaHVua1xuICAgICAgfVxuICAgIH0pKCksXG4gICAge1xuICAgICAgc2lnbmFsXG4gICAgfVxuICApXG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgY29uc3QgX3Jlc29sdmUgPSByZXNvbHZlXG4gICAgICByZXNvbHZlID0gbnVsbFxuICAgICAgX3Jlc29sdmUoe1xuICAgICAgICBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIGNiXG4gICAgICB9KVxuICAgIH0sXG4gICAgZmluYWwoY2IpIHtcbiAgICAgIGNvbnN0IF9yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgcmVzb2x2ZSA9IG51bGxcbiAgICAgIF9yZXNvbHZlKHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgY2JcbiAgICAgIH0pXG4gICAgfSxcbiAgICBkZXN0cm95KGVyciwgY2IpIHtcbiAgICAgIGFjLmFib3J0KClcbiAgICAgIGNiKGVycilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9kdXBsZXhpZnkocGFpcikge1xuICBjb25zdCByID0gcGFpci5yZWFkYWJsZSAmJiB0eXBlb2YgcGFpci5yZWFkYWJsZS5yZWFkICE9PSAnZnVuY3Rpb24nID8gUmVhZGFibGUud3JhcChwYWlyLnJlYWRhYmxlKSA6IHBhaXIucmVhZGFibGVcbiAgY29uc3QgdyA9IHBhaXIud3JpdGFibGVcbiAgbGV0IHJlYWRhYmxlID0gISFpc1JlYWRhYmxlKHIpXG4gIGxldCB3cml0YWJsZSA9ICEhaXNXcml0YWJsZSh3KVxuICBsZXQgb25kcmFpblxuICBsZXQgb25maW5pc2hcbiAgbGV0IG9ucmVhZGFibGVcbiAgbGV0IG9uY2xvc2VcbiAgbGV0IGRcbiAgZnVuY3Rpb24gb25maW5pc2hlZChlcnIpIHtcbiAgICBjb25zdCBjYiA9IG9uY2xvc2VcbiAgICBvbmNsb3NlID0gbnVsbFxuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBkLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8ocm9uYWcpOiBBdm9pZCBkb3VibGUgYnVmZmVyaW5nLlxuICAvLyBJbXBsZW1lbnQgV3JpdGFibGUvUmVhZGFibGUvRHVwbGV4IHRyYWl0cy5cbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMzUxNS5cbiAgZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICByZWFkYWJsZU9iamVjdE1vZGU6ICEhKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIucmVhZGFibGVPYmplY3RNb2RlKSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6ICEhKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcud3JpdGFibGVPYmplY3RNb2RlKSxcbiAgICByZWFkYWJsZSxcbiAgICB3cml0YWJsZVxuICB9KVxuICBpZiAod3JpdGFibGUpIHtcbiAgICBlb3ModywgKGVycikgPT4ge1xuICAgICAgd3JpdGFibGUgPSBmYWxzZVxuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZXN0cm95ZXIociwgZXJyKVxuICAgICAgfVxuICAgICAgb25maW5pc2hlZChlcnIpXG4gICAgfSlcbiAgICBkLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAody53cml0ZShjaHVuaywgZW5jb2RpbmcpKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZHJhaW4gPSBjYWxsYmFja1xuICAgICAgfVxuICAgIH1cbiAgICBkLl9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdy5lbmQoKVxuICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgIH1cbiAgICB3Lm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbmRyYWluKSB7XG4gICAgICAgIGNvbnN0IGNiID0gb25kcmFpblxuICAgICAgICBvbmRyYWluID0gbnVsbFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgICB3Lm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25maW5pc2gpIHtcbiAgICAgICAgY29uc3QgY2IgPSBvbmZpbmlzaFxuICAgICAgICBvbmZpbmlzaCA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgaWYgKHJlYWRhYmxlKSB7XG4gICAgZW9zKHIsIChlcnIpID0+IHtcbiAgICAgIHJlYWRhYmxlID0gZmFsc2VcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVzdHJveWVyKHIsIGVycilcbiAgICAgIH1cbiAgICAgIG9uZmluaXNoZWQoZXJyKVxuICAgIH0pXG4gICAgci5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25yZWFkYWJsZSkge1xuICAgICAgICBjb25zdCBjYiA9IG9ucmVhZGFibGVcbiAgICAgICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gICAgci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgZC5wdXNoKG51bGwpXG4gICAgfSlcbiAgICBkLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYnVmID0gci5yZWFkKClcbiAgICAgICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuICAgICAgICAgIG9ucmVhZGFibGUgPSBkLl9yZWFkXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkLnB1c2goYnVmKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICBvbmRyYWluID0gbnVsbFxuICAgIG9uZmluaXNoID0gbnVsbFxuICAgIGlmIChvbmNsb3NlID09PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9uY2xvc2UgPSBjYWxsYmFja1xuICAgICAgZGVzdHJveWVyKHcsIGVycilcbiAgICAgIGRlc3Ryb3llcihyLCBlcnIpXG4gICAgfVxuICB9XG4gIHJldHVybiBkXG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInJlcXVpcmUiLCJidWZmZXJNb2R1bGUiLCJpc1JlYWRhYmxlIiwiaXNXcml0YWJsZSIsImlzSXRlcmFibGUiLCJpc05vZGVTdHJlYW0iLCJpc1JlYWRhYmxlTm9kZVN0cmVhbSIsImlzV3JpdGFibGVOb2RlU3RyZWFtIiwiaXNEdXBsZXhOb2RlU3RyZWFtIiwiaXNSZWFkYWJsZVN0cmVhbSIsImlzV3JpdGFibGVTdHJlYW0iLCJlb3MiLCJBYm9ydEVycm9yIiwiY29kZXMiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSIsImRlc3Ryb3llciIsIkR1cGxleCIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJmcm9tIiwiQmxvYiIsImdsb2JhbFRoaXMiLCJpc0Jsb2IiLCJiIiwiQWJvcnRDb250cm9sbGVyIiwiRnVuY3Rpb25Qcm90b3R5cGVDYWxsIiwiRHVwbGV4aWZ5IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwidW5kZWZpbmVkIiwicmVhZGFibGUiLCJfcmVhZGFibGVTdGF0ZSIsImVuZGVkIiwiZW5kRW1pdHRlZCIsIndyaXRhYmxlIiwiX3dyaXRhYmxlU3RhdGUiLCJlbmRpbmciLCJmaW5pc2hlZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJkdXBsZXhpZnkiLCJib2R5IiwibmFtZSIsIl9kdXBsZXhpZnkiLCJmcm9tV2ViIiwidmFsdWUiLCJ3cml0ZSIsImZpbmFsIiwiZGVzdHJveSIsImZyb21Bc3luY0dlbiIsIm9iamVjdE1vZGUiLCJ0aGVuIiwiZCIsInByb21pc2UiLCJ2YWwiLCJlcnIiLCJjYiIsIm5leHRUaWNrIiwiYXJyYXlCdWZmZXIiLCJwdXNoIiwicmVhZCIsImZuIiwicmVzb2x2ZSIsImFjIiwic2lnbmFsIiwiX3Byb21pc2UiLCJjaHVuayIsImRvbmUiLCJhYm9ydGVkIiwiY2F1c2UiLCJyZWFzb24iLCJlbmNvZGluZyIsIl9yZXNvbHZlIiwiYWJvcnQiLCJwYWlyIiwiciIsIndyYXAiLCJ3Iiwib25kcmFpbiIsIm9uZmluaXNoIiwib25yZWFkYWJsZSIsIm9uY2xvc2UiLCJvbmZpbmlzaGVkIiwicmVhZGFibGVPYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwiX3dyaXRlIiwiY2FsbGJhY2siLCJfZmluYWwiLCJlbmQiLCJvbiIsIl9yZWFkIiwiYnVmIiwiX2Rlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplexify.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\");\n\"use strict\";\nconst { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;\nconst { kEmptyObject, once } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = __webpack_require__(/*! ../validators */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js\");\nconst { Promise, PromisePrototypeThen, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nlet addAbortListener;\nfunction isRequest(stream) {\n    return stream.setHeader && typeof stream.abort === \"function\";\n}\nconst nop = ()=>{};\nfunction eos(stream, options, callback) {\n    var _options$readable, _options$writable;\n    if (arguments.length === 2) {\n        callback = options;\n        options = kEmptyObject;\n    } else if (options == null) {\n        options = kEmptyObject;\n    } else {\n        validateObject(options, \"options\");\n    }\n    validateFunction(callback, \"callback\");\n    validateAbortSignal(options.signal, \"options.signal\");\n    callback = once(callback);\n    if (isReadableStream(stream) || isWritableStream(stream)) {\n        return eosWeb(stream, options, callback);\n    }\n    if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", [\n            \"ReadableStream\",\n            \"WritableStream\",\n            \"Stream\"\n        ], stream);\n    }\n    const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);\n    const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    const onlegacyfinish = ()=>{\n        if (!stream.writable) {\n            onfinish();\n        }\n    };\n    // TODO (ronag): Improve soft detection to include core modules and\n    // common ecosystem modules that do properly emit 'close' but fail\n    // this generic check.\n    let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;\n    let writableFinished = isWritableFinished(stream, false);\n    const onfinish = ()=>{\n        writableFinished = true;\n        // Stream should not be destroyed here. If it is that\n        // means that user space is doing something differently and\n        // we cannot trust willEmitClose.\n        if (stream.destroyed) {\n            willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.readable || readable)) {\n            return;\n        }\n        if (!readable || readableFinished) {\n            callback.call(stream);\n        }\n    };\n    let readableFinished = isReadableFinished(stream, false);\n    const onend = ()=>{\n        readableFinished = true;\n        // Stream should not be destroyed here. If it is that\n        // means that user space is doing something differently and\n        // we cannot trust willEmitClose.\n        if (stream.destroyed) {\n            willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.writable || writable)) {\n            return;\n        }\n        if (!writable || writableFinished) {\n            callback.call(stream);\n        }\n    };\n    const onerror = (err)=>{\n        callback.call(stream, err);\n    };\n    let closed = isClosed(stream);\n    const onclose = ()=>{\n        closed = true;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\") {\n            return callback.call(stream, errored);\n        }\n        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n            if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        if (writable && !writableFinished) {\n            if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        callback.call(stream);\n    };\n    const onclosed = ()=>{\n        closed = true;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\") {\n            return callback.call(stream, errored);\n        }\n        callback.call(stream);\n    };\n    const onrequest = ()=>{\n        stream.req.on(\"finish\", onfinish);\n    };\n    if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        if (!willEmitClose) {\n            stream.on(\"abort\", onclose);\n        }\n        if (stream.req) {\n            onrequest();\n        } else {\n            stream.on(\"request\", onrequest);\n        }\n    } else if (writable && !wState) {\n        // legacy streams\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n    }\n    // Not all streams will emit 'close' after 'aborted'.\n    if (!willEmitClose && typeof stream.aborted === \"boolean\") {\n        stream.on(\"aborted\", onclose);\n    }\n    stream.on(\"end\", onend);\n    stream.on(\"finish\", onfinish);\n    if (options.error !== false) {\n        stream.on(\"error\", onerror);\n    }\n    stream.on(\"close\", onclose);\n    if (closed) {\n        process.nextTick(onclose);\n    } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {\n        if (!willEmitClose) {\n            process.nextTick(onclosed);\n        }\n    } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {\n        process.nextTick(onclosed);\n    } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {\n        process.nextTick(onclosed);\n    } else if (rState && stream.req && stream.aborted) {\n        process.nextTick(onclosed);\n    }\n    const cleanup = ()=>{\n        callback = nop;\n        stream.removeListener(\"aborted\", onclose);\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n    };\n    if (options.signal && !closed) {\n        const abort = ()=>{\n            // Keep it because cleanup removes it.\n            const endCallback = callback;\n            cleanup();\n            endCallback.call(stream, new AbortError(undefined, {\n                cause: options.signal.reason\n            }));\n        };\n        if (options.signal.aborted) {\n            process.nextTick(abort);\n        } else {\n            addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").addAbortListener);\n            const disposable = addAbortListener(options.signal, abort);\n            const originalCallback = callback;\n            callback = once((...args)=>{\n                disposable[SymbolDispose]();\n                originalCallback.apply(stream, args);\n            });\n        }\n    }\n    return cleanup;\n}\nfunction eosWeb(stream, options, callback) {\n    let isAborted = false;\n    let abort = nop;\n    if (options.signal) {\n        abort = ()=>{\n            isAborted = true;\n            callback.call(stream, new AbortError(undefined, {\n                cause: options.signal.reason\n            }));\n        };\n        if (options.signal.aborted) {\n            process.nextTick(abort);\n        } else {\n            addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").addAbortListener);\n            const disposable = addAbortListener(options.signal, abort);\n            const originalCallback = callback;\n            callback = once((...args)=>{\n                disposable[SymbolDispose]();\n                originalCallback.apply(stream, args);\n            });\n        }\n    }\n    const resolverFn = (...args)=>{\n        if (!isAborted) {\n            process.nextTick(()=>callback.apply(stream, args));\n        }\n    };\n    PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);\n    return nop;\n}\nfunction finished(stream, opts) {\n    var _opts;\n    let autoCleanup = false;\n    if (opts === null) {\n        opts = kEmptyObject;\n    }\n    if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n        validateBoolean(opts.cleanup, \"cleanup\");\n        autoCleanup = opts.cleanup;\n    }\n    return new Promise((resolve, reject)=>{\n        const cleanup = eos(stream, opts, (err)=>{\n            if (autoCleanup) {\n                cleanup();\n            }\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\nmodule.exports = eos;\nmodule.exports.finished = finished;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixHQUVyQixNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQU10QjtBQUNGLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDdEMsTUFBTSxFQUFFRyxvQkFBb0IsRUFBRUMsMEJBQTBCLEVBQUUsR0FBR0Y7QUFDN0QsTUFBTSxFQUFFRyxZQUFZLEVBQUVDLElBQUksRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUN2QyxNQUFNLEVBQUVPLG1CQUFtQixFQUFFQyxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFQyxlQUFlLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDM0YsTUFBTSxFQUFFVyxPQUFPLEVBQUVDLG9CQUFvQixFQUFFQyxhQUFhLEVBQUUsR0FBR2IsbUJBQU9BLENBQUM7QUFDakUsTUFBTSxFQUNKYyxRQUFRLEVBQ1JDLFVBQVUsRUFDVkMsb0JBQW9CLEVBQ3BCQyxnQkFBZ0IsRUFDaEJDLGtCQUFrQixFQUNsQkMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1ZDLG9CQUFvQixFQUNwQkMsZ0JBQWdCLEVBQ2hCQyxrQkFBa0IsRUFDbEJDLGlCQUFpQixFQUNqQkMsWUFBWSxFQUNaQyxlQUFlQyxjQUFjLEVBQzdCQyxnQkFBZ0IsRUFDakIsR0FBRzVCLG1CQUFPQSxDQUFDO0FBQ1osSUFBSTZCO0FBQ0osU0FBU0MsVUFBVUMsTUFBTTtJQUN2QixPQUFPQSxPQUFPQyxTQUFTLElBQUksT0FBT0QsT0FBT0UsS0FBSyxLQUFLO0FBQ3JEO0FBQ0EsTUFBTUMsTUFBTSxLQUFPO0FBQ25CLFNBQVNDLElBQUlKLE1BQU0sRUFBRUssT0FBTyxFQUFFQyxRQUFRO0lBQ3BDLElBQUlDLG1C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QU0sRUFBRVQ7WUFDcEQsTUFBTTRDLG1CQUFtQnhDO1lBQ3pCQSxXQUFXL0IsS0FBSyxDQUFDLEdBQUd3RTtnQkFDbEJGLFVBQVUsQ0FBQy9ELGNBQWM7Z0JBQ3pCZ0UsaUJBQWlCRSxLQUFLLENBQUNoRCxRQUFRK0M7WUFDakM7UUFDRjtJQUNGO0lBQ0EsTUFBTUcsYUFBYSxDQUFDLEdBQUdIO1FBQ3JCLElBQUksQ0FBQ0UsV0FBVztZQUNkakYsUUFBUXNFLFFBQVEsQ0FBQyxJQUFNaEMsU0FBUzBDLEtBQUssQ0FBQ2hELFFBQVErQztRQUNoRDtJQUNGO0lBQ0FsRSxxQkFBcUJtQixNQUFNLENBQUNILGlCQUFpQixDQUFDc0QsT0FBTyxFQUFFRCxZQUFZQTtJQUNuRSxPQUFPL0M7QUFDVDtBQUNBLFNBQVNpRCxTQUFTcEQsTUFBTSxFQUFFcUQsSUFBSTtJQUM1QixJQUFJQztJQUNKLElBQUlDLGNBQWM7SUFDbEIsSUFBSUYsU0FBUyxNQUFNO1FBQ2pCQSxPQUFPL0U7SUFDVDtJQUNBLElBQUksQ0FBQ2dGLFFBQVFELElBQUcsTUFBTyxRQUFRQyxVQUFVeEMsYUFBYXdDLE1BQU1kLE9BQU8sRUFBRTtRQUNuRTdELGdCQUFnQjBFLEtBQUtiLE9BQU8sRUFBRTtRQUM5QmUsY0FBY0YsS0FBS2IsT0FBTztJQUM1QjtJQUNBLE9BQU8sSUFBSTVELFFBQVEsQ0FBQzRFLFNBQVNDO1FBQzNCLE1BQU1qQixVQUFVcEMsSUFBSUosUUFBUXFELE1BQU0sQ0FBQ3pCO1lBQ2pDLElBQUkyQixhQUFhO2dCQUNmZjtZQUNGO1lBQ0EsSUFBSVosS0FBSztnQkFDUDZCLE9BQU83QjtZQUNULE9BQU87Z0JBQ0w0QjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0FFLE9BQU9DLE9BQU8sR0FBR3ZEO0FBQ2pCc0QsdUJBQXVCLEdBQUdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcz9jMDdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuXG47KCd1c2Ugc3RyaWN0JylcbmNvbnN0IHsgQWJvcnRFcnJvciwgY29kZXMgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgRVJSX0lOVkFMSURfQVJHX1RZUEUsIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFIH0gPSBjb2Rlc1xuY29uc3QgeyBrRW1wdHlPYmplY3QsIG9uY2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCB7IHZhbGlkYXRlQWJvcnRTaWduYWwsIHZhbGlkYXRlRnVuY3Rpb24sIHZhbGlkYXRlT2JqZWN0LCB2YWxpZGF0ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3QgeyBQcm9taXNlLCBQcm9taXNlUHJvdG90eXBlVGhlbiwgU3ltYm9sRGlzcG9zZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7XG4gIGlzQ2xvc2VkLFxuICBpc1JlYWRhYmxlLFxuICBpc1JlYWRhYmxlTm9kZVN0cmVhbSxcbiAgaXNSZWFkYWJsZVN0cmVhbSxcbiAgaXNSZWFkYWJsZUZpbmlzaGVkLFxuICBpc1JlYWRhYmxlRXJyb3JlZCxcbiAgaXNXcml0YWJsZSxcbiAgaXNXcml0YWJsZU5vZGVTdHJlYW0sXG4gIGlzV3JpdGFibGVTdHJlYW0sXG4gIGlzV3JpdGFibGVGaW5pc2hlZCxcbiAgaXNXcml0YWJsZUVycm9yZWQsXG4gIGlzTm9kZVN0cmVhbSxcbiAgd2lsbEVtaXRDbG9zZTogX3dpbGxFbWl0Q2xvc2UsXG4gIGtJc0Nsb3NlZFByb21pc2Vcbn0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmxldCBhZGRBYm9ydExpc3RlbmVyXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbidcbn1cbmNvbnN0IG5vcCA9ICgpID0+IHt9XG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgX29wdGlvbnMkcmVhZGFibGUsIF9vcHRpb25zJHdyaXRhYmxlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IGtFbXB0eU9iamVjdFxuICB9IGVsc2UgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBrRW1wdHlPYmplY3RcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgdmFsaWRhdGVGdW5jdGlvbihjYWxsYmFjaywgJ2NhbGxiYWNrJylcbiAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHx8IGlzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBlb3NXZWIoc3RyZWFtLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgfVxuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdzdHJlYW0nLCBbJ1JlYWRhYmxlU3RyZWFtJywgJ1dyaXRhYmxlU3RyZWFtJywgJ1N0cmVhbSddLCBzdHJlYW0pXG4gIH1cbiAgY29uc3QgcmVhZGFibGUgPVxuICAgIChfb3B0aW9ucyRyZWFkYWJsZSA9IG9wdGlvbnMucmVhZGFibGUpICE9PSBudWxsICYmIF9vcHRpb25zJHJlYWRhYmxlICE9PSB1bmRlZmluZWRcbiAgICAgID8gX29wdGlvbnMkcmVhZGFibGVcbiAgICAgIDogaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtKVxuICBjb25zdCB3cml0YWJsZSA9XG4gICAgKF9vcHRpb25zJHdyaXRhYmxlID0gb3B0aW9ucy53cml0YWJsZSkgIT09IG51bGwgJiYgX29wdGlvbnMkd3JpdGFibGUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBfb3B0aW9ucyR3cml0YWJsZVxuICAgICAgOiBpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgb25sZWdhY3lmaW5pc2ggPSAoKSA9PiB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIHtcbiAgICAgIG9uZmluaXNoKClcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPIChyb25hZyk6IEltcHJvdmUgc29mdCBkZXRlY3Rpb24gdG8gaW5jbHVkZSBjb3JlIG1vZHVsZXMgYW5kXG4gIC8vIGNvbW1vbiBlY29zeXN0ZW0gbW9kdWxlcyB0aGF0IGRvIHByb3Blcmx5IGVtaXQgJ2Nsb3NlJyBidXQgZmFpbFxuICAvLyB0aGlzIGdlbmVyaWMgY2hlY2suXG4gIGxldCB3aWxsRW1pdENsb3NlID1cbiAgICBfd2lsbEVtaXRDbG9zZShzdHJlYW0pICYmIGlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSkgPT09IHJlYWRhYmxlICYmIGlzV3JpdGFibGVOb2RlU3RyZWFtKHN0cmVhbSkgPT09IHdyaXRhYmxlXG4gIGxldCB3cml0YWJsZUZpbmlzaGVkID0gaXNXcml0YWJsZUZpbmlzaGVkKHN0cmVhbSwgZmFsc2UpXG4gIGNvbnN0IG9uZmluaXNoID0gKCkgPT4ge1xuICAgIHdyaXRhYmxlRmluaXNoZWQgPSB0cnVlXG4gICAgLy8gU3RyZWFtIHNob3VsZCBub3QgYmUgZGVzdHJveWVkIGhlcmUuIElmIGl0IGlzIHRoYXRcbiAgICAvLyBtZWFucyB0aGF0IHVzZXIgc3BhY2UgaXMgZG9pbmcgc29tZXRoaW5nIGRpZmZlcmVudGx5IGFuZFxuICAgIC8vIHdlIGNhbm5vdCB0cnVzdCB3aWxsRW1pdENsb3NlLlxuICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICB3aWxsRW1pdENsb3NlID0gZmFsc2VcbiAgICB9XG4gICAgaWYgKHdpbGxFbWl0Q2xvc2UgJiYgKCFzdHJlYW0ucmVhZGFibGUgfHwgcmVhZGFibGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFyZWFkYWJsZSB8fCByZWFkYWJsZUZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSlcbiAgICB9XG4gIH1cbiAgbGV0IHJlYWRhYmxlRmluaXNoZWQgPSBpc1JlYWRhYmxlRmluaXNoZWQoc3RyZWFtLCBmYWxzZSlcbiAgY29uc3Qgb25lbmQgPSAoKSA9PiB7XG4gICAgcmVhZGFibGVGaW5pc2hlZCA9IHRydWVcbiAgICAvLyBTdHJlYW0gc2hvdWxkIG5vdCBiZSBkZXN0cm95ZWQgaGVyZS4gSWYgaXQgaXMgdGhhdFxuICAgIC8vIG1lYW5zIHRoYXQgdXNlciBzcGFjZSBpcyBkb2luZyBzb21ldGhpbmcgZGlmZmVyZW50bHkgYW5kXG4gICAgLy8gd2UgY2Fubm90IHRydXN0IHdpbGxFbWl0Q2xvc2UuXG4gICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgIHdpbGxFbWl0Q2xvc2UgPSBmYWxzZVxuICAgIH1cbiAgICBpZiAod2lsbEVtaXRDbG9zZSAmJiAoIXN0cmVhbS53cml0YWJsZSB8fCB3cml0YWJsZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXdyaXRhYmxlIHx8IHdyaXRhYmxlRmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKVxuICAgIH1cbiAgfVxuICBjb25zdCBvbmVycm9yID0gKGVycikgPT4ge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpXG4gIH1cbiAgbGV0IGNsb3NlZCA9IGlzQ2xvc2VkKHN0cmVhbSlcbiAgY29uc3Qgb25jbG9zZSA9ICgpID0+IHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gICAgY29uc3QgZXJyb3JlZCA9IGlzV3JpdGFibGVFcnJvcmVkKHN0cmVhbSkgfHwgaXNSZWFkYWJsZUVycm9yZWQoc3RyZWFtKVxuICAgIGlmIChlcnJvcmVkICYmIHR5cGVvZiBlcnJvcmVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyb3JlZClcbiAgICB9XG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUZpbmlzaGVkICYmIGlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghaXNSZWFkYWJsZUZpbmlzaGVkKHN0cmVhbSwgZmFsc2UpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpKVxuICAgIH1cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRmluaXNoZWQpIHtcbiAgICAgIGlmICghaXNXcml0YWJsZUZpbmlzaGVkKHN0cmVhbSwgZmFsc2UpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpKVxuICAgIH1cbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSlcbiAgfVxuICBjb25zdCBvbmNsb3NlZCA9ICgpID0+IHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gICAgY29uc3QgZXJyb3JlZCA9IGlzV3JpdGFibGVFcnJvcmVkKHN0cmVhbSkgfHwgaXNSZWFkYWJsZUVycm9yZWQoc3RyZWFtKVxuICAgIGlmIChlcnJvcmVkICYmIHR5cGVvZiBlcnJvcmVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyb3JlZClcbiAgICB9XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0pXG4gIH1cbiAgY29uc3Qgb25yZXF1ZXN0ID0gKCkgPT4ge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICB9XG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaClcbiAgICBpZiAoIXdpbGxFbWl0Q2xvc2UpIHtcbiAgICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKVxuICAgIH1cbiAgICBpZiAoc3RyZWFtLnJlcSkge1xuICAgICAgb25yZXF1ZXN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KVxuICAgIH1cbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhd1N0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKVxuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaClcbiAgfVxuXG4gIC8vIE5vdCBhbGwgc3RyZWFtcyB3aWxsIGVtaXQgJ2Nsb3NlJyBhZnRlciAnYWJvcnRlZCcuXG4gIGlmICghd2lsbEVtaXRDbG9zZSAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgIHN0cmVhbS5vbignYWJvcnRlZCcsIG9uY2xvc2UpXG4gIH1cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZClcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgaWYgKG9wdGlvbnMuZXJyb3IgIT09IGZhbHNlKSB7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpXG4gIH1cbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpXG4gIGlmIChjbG9zZWQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2UpXG4gIH0gZWxzZSBpZiAoXG4gICAgKHdTdGF0ZSAhPT0gbnVsbCAmJiB3U3RhdGUgIT09IHVuZGVmaW5lZCAmJiB3U3RhdGUuZXJyb3JFbWl0dGVkKSB8fFxuICAgIChyU3RhdGUgIT09IG51bGwgJiYgclN0YXRlICE9PSB1bmRlZmluZWQgJiYgclN0YXRlLmVycm9yRW1pdHRlZClcbiAgKSB7XG4gICAgaWYgKCF3aWxsRW1pdENsb3NlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VkKVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAhcmVhZGFibGUgJiZcbiAgICAoIXdpbGxFbWl0Q2xvc2UgfHwgaXNSZWFkYWJsZShzdHJlYW0pKSAmJlxuICAgICh3cml0YWJsZUZpbmlzaGVkIHx8IGlzV3JpdGFibGUoc3RyZWFtKSA9PT0gZmFsc2UpXG4gICkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25jbG9zZWQpXG4gIH0gZWxzZSBpZiAoXG4gICAgIXdyaXRhYmxlICYmXG4gICAgKCF3aWxsRW1pdENsb3NlIHx8IGlzV3JpdGFibGUoc3RyZWFtKSkgJiZcbiAgICAocmVhZGFibGVGaW5pc2hlZCB8fCBpc1JlYWRhYmxlKHN0cmVhbSkgPT09IGZhbHNlKVxuICApIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VkKVxuICB9IGVsc2UgaWYgKHJTdGF0ZSAmJiBzdHJlYW0ucmVxICYmIHN0cmVhbS5hYm9ydGVkKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlZClcbiAgfVxuICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgIGNhbGxiYWNrID0gbm9wXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydGVkJywgb25jbG9zZSlcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KVxuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpXG4gIH1cbiAgaWYgKG9wdGlvbnMuc2lnbmFsICYmICFjbG9zZWQpIHtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgIC8vIEtlZXAgaXQgYmVjYXVzZSBjbGVhbnVwIHJlbW92ZXMgaXQuXG4gICAgICBjb25zdCBlbmRDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgICBjbGVhbnVwKClcbiAgICAgIGVuZENhbGxiYWNrLmNhbGwoXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgY2F1c2U6IG9wdGlvbnMuc2lnbmFsLnJlYXNvblxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhYm9ydClcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQWJvcnRMaXN0ZW5lciA9IGFkZEFib3J0TGlzdGVuZXIgfHwgcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuYWRkQWJvcnRMaXN0ZW5lclxuICAgICAgY29uc3QgZGlzcG9zYWJsZSA9IGFkZEFib3J0TGlzdGVuZXIob3B0aW9ucy5zaWduYWwsIGFib3J0KVxuICAgICAgY29uc3Qgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IG9uY2UoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgZGlzcG9zYWJsZVtTeW1ib2xEaXNwb3NlXSgpXG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suYXBwbHkoc3RyZWFtLCBhcmdzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFudXBcbn1cbmZ1bmN0aW9uIGVvc1dlYihzdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGxldCBpc0Fib3J0ZWQgPSBmYWxzZVxuICBsZXQgYWJvcnQgPSBub3BcbiAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgYWJvcnQgPSAoKSA9PiB7XG4gICAgICBpc0Fib3J0ZWQgPSB0cnVlXG4gICAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICAgIGNhdXNlOiBvcHRpb25zLnNpZ25hbC5yZWFzb25cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWJvcnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZEFib3J0TGlzdGVuZXIgPSBhZGRBYm9ydExpc3RlbmVyIHx8IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmFkZEFib3J0TGlzdGVuZXJcbiAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBhZGRBYm9ydExpc3RlbmVyKG9wdGlvbnMuc2lnbmFsLCBhYm9ydClcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgPSBvbmNlKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGRpc3Bvc2FibGVbU3ltYm9sRGlzcG9zZV0oKVxuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc29sdmVyRm4gPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICghaXNBYm9ydGVkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IGNhbGxiYWNrLmFwcGx5KHN0cmVhbSwgYXJncykpXG4gICAgfVxuICB9XG4gIFByb21pc2VQcm90b3R5cGVUaGVuKHN0cmVhbVtrSXNDbG9zZWRQcm9taXNlXS5wcm9taXNlLCByZXNvbHZlckZuLCByZXNvbHZlckZuKVxuICByZXR1cm4gbm9wXG59XG5mdW5jdGlvbiBmaW5pc2hlZChzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIF9vcHRzXG4gIGxldCBhdXRvQ2xlYW51cCA9IGZhbHNlXG4gIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgb3B0cyA9IGtFbXB0eU9iamVjdFxuICB9XG4gIGlmICgoX29wdHMgPSBvcHRzKSAhPT0gbnVsbCAmJiBfb3B0cyAhPT0gdW5kZWZpbmVkICYmIF9vcHRzLmNsZWFudXApIHtcbiAgICB2YWxpZGF0ZUJvb2xlYW4ob3B0cy5jbGVhbnVwLCAnY2xlYW51cCcpXG4gICAgYXV0b0NsZWFudXAgPSBvcHRzLmNsZWFudXBcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXAgPSBlb3Moc3RyZWFtLCBvcHRzLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoYXV0b0NsZWFudXApIHtcbiAgICAgICAgY2xlYW51cCgpXG4gICAgICB9XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxubW9kdWxlLmV4cG9ydHMgPSBlb3Ncbm1vZHVsZS5leHBvcnRzLmZpbmlzaGVkID0gZmluaXNoZWRcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwicmVxdWlyZSIsIkFib3J0RXJyb3IiLCJjb2RlcyIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UiLCJrRW1wdHlPYmplY3QiLCJvbmNlIiwidmFsaWRhdGVBYm9ydFNpZ25hbCIsInZhbGlkYXRlRnVuY3Rpb24iLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRlQm9vbGVhbiIsIlByb21pc2UiLCJQcm9taXNlUHJvdG90eXBlVGhlbiIsIlN5bWJvbERpc3Bvc2UiLCJpc0Nsb3NlZCIsImlzUmVhZGFibGUiLCJpc1JlYWRhYmxlTm9kZVN0cmVhbSIsImlzUmVhZGFibGVTdHJlYW0iLCJpc1JlYWRhYmxlRmluaXNoZWQiLCJpc1JlYWRhYmxlRXJyb3JlZCIsImlzV3JpdGFibGUiLCJpc1dyaXRhYmxlTm9kZVN0cmVhbSIsImlzV3JpdGFibGVTdHJlYW0iLCJpc1dyaXRhYmxlRmluaXNoZWQiLCJpc1dyaXRhYmxlRXJyb3JlZCIsImlzTm9kZVN0cmVhbSIsIndpbGxFbWl0Q2xvc2UiLCJfd2lsbEVtaXRDbG9zZSIsImtJc0Nsb3NlZFByb21pc2UiLCJhZGRBYm9ydExpc3RlbmVyIiwiaXNSZXF1ZXN0Iiwic3RyZWFtIiwic2V0SGVhZGVyIiwiYWJvcnQiLCJub3AiLCJlb3MiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJfb3B0aW9ucyRyZWFkYWJsZSIsIl9vcHRpb25zJHdyaXRhYmxlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2lnbmFsIiwiZW9zV2ViIiwicmVhZGFibGUiLCJ1bmRlZmluZWQiLCJ3cml0YWJsZSIsIndTdGF0ZSIsIl93cml0YWJsZVN0YXRlIiwiclN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJvbmxlZ2FjeWZpbmlzaCIsIm9uZmluaXNoIiwid3JpdGFibGVGaW5pc2hlZCIsImRlc3Ryb3llZCIsInJlYWRhYmxlRmluaXNoZWQiLCJjYWxsIiwib25lbmQiLCJvbmVycm9yIiwiZXJyIiwiY2xvc2VkIiwib25jbG9zZSIsImVycm9yZWQiLCJvbmNsb3NlZCIsIm9ucmVxdWVzdCIsInJlcSIsIm9uIiwiYWJvcnRlZCIsImVycm9yIiwibmV4dFRpY2siLCJlcnJvckVtaXR0ZWQiLCJjbGVhbnVwIiwicmVtb3ZlTGlzdGVuZXIiLCJlbmRDYWxsYmFjayIsImNhdXNlIiwicmVhc29uIiwiZGlzcG9zYWJsZSIsIm9yaWdpbmFsQ2FsbGJhY2siLCJhcmdzIiwiYXBwbHkiLCJpc0Fib3J0ZWQiLCJyZXNvbHZlckZuIiwicHJvbWlzZSIsImZpbmlzaGVkIiwib3B0cyIsIl9vcHRzIiwiYXV0b0NsZWFudXAiLCJyZXNvbHZlIiwicmVqZWN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/from.js":
/*!***********************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/from.js ***!
  \***********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\");\n/* replacement end */ const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\").codes);\nfunction from(Readable, iterable, opts) {\n    let iterator;\n    if (typeof iterable === \"string\" || iterable instanceof Buffer) {\n        return new Readable({\n            objectMode: true,\n            ...opts,\n            read () {\n                this.push(iterable);\n                this.push(null);\n            }\n        });\n    }\n    let isAsync;\n    if (iterable && iterable[SymbolAsyncIterator]) {\n        isAsync = true;\n        iterator = iterable[SymbolAsyncIterator]();\n    } else if (iterable && iterable[SymbolIterator]) {\n        isAsync = false;\n        iterator = iterable[SymbolIterator]();\n    } else {\n        throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\n            \"Iterable\"\n        ], iterable);\n    }\n    const readable = new Readable({\n        objectMode: true,\n        highWaterMark: 1,\n        // TODO(ronag): What options should be allowed?\n        ...opts\n    });\n    // Flag to protect against _read\n    // being called before last iteration completion.\n    let reading = false;\n    readable._read = function() {\n        if (!reading) {\n            reading = true;\n            next();\n        }\n    };\n    readable._destroy = function(error, cb) {\n        PromisePrototypeThen(close(error), ()=>process.nextTick(cb, error), // nextTick is here in case cb throws\n        (e)=>process.nextTick(cb, e || error));\n    };\n    async function close(error) {\n        const hadError = error !== undefined && error !== null;\n        const hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n            const { value, done } = await iterator.throw(error);\n            await value;\n            if (done) {\n                return;\n            }\n        }\n        if (typeof iterator.return === \"function\") {\n            const { value } = await iterator.return();\n            await value;\n        }\n    }\n    async function next() {\n        for(;;){\n            try {\n                const { value, done } = isAsync ? await iterator.next() : iterator.next();\n                if (done) {\n                    readable.push(null);\n                } else {\n                    const res = value && typeof value.then === \"function\" ? await value : value;\n                    if (res === null) {\n                        reading = false;\n                        throw new ERR_STREAM_NULL_VALUES();\n                    } else if (readable.push(res)) {\n                        continue;\n                    } else {\n                        reading = false;\n                    }\n                }\n            } catch (err) {\n                readable.destroy(err);\n            }\n            break;\n        }\n    }\n    return readable;\n}\nmodule.exports = from;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEscUJBQXFCLEdBRXJCLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXhCLG1CQUFtQixHQUVuQixNQUFNLEVBQUVDLG9CQUFvQixFQUFFQyxtQkFBbUIsRUFBRUMsY0FBYyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzlFLE1BQU0sRUFBRUksTUFBTSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUssb0JBQW9CLEVBQUVDLHNCQUFzQixFQUFFLEdBQUdOLHVKQUFrQztBQUMzRixTQUFTUSxLQUFLQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsSUFBSTtJQUNwQyxJQUFJQztJQUNKLElBQUksT0FBT0YsYUFBYSxZQUFZQSxvQkFBb0JOLFFBQVE7UUFDOUQsT0FBTyxJQUFJSyxTQUFTO1lBQ2xCSSxZQUFZO1lBQ1osR0FBR0YsSUFBSTtZQUNQRztnQkFDRSxJQUFJLENBQUNDLElBQUksQ0FBQ0w7Z0JBQ1YsSUFBSSxDQUFDSyxJQUFJLENBQUM7WUFDWjtRQUNGO0lBQ0Y7SUFDQSxJQUFJQztJQUNKLElBQUlOLFlBQVlBLFFBQVEsQ0FBQ1Isb0JBQW9CLEVBQUU7UUFDN0NjLFVBQVU7UUFDVkosV0FBV0YsUUFBUSxDQUFDUixvQkFBb0I7SUFDMUMsT0FBTyxJQUFJUSxZQUFZQSxRQUFRLENBQUNQLGVBQWUsRUFBRTtRQUMvQ2EsVUFBVTtRQUNWSixXQUFXRixRQUFRLENBQUNQLGVBQWU7SUFDckMsT0FBTztRQUNMLE1BQU0sSUFBSUUscUJBQXFCLFlBQVk7WUFBQztTQUFXLEVBQUVLO0lBQzNEO0lBQ0EsTUFBTU8sV0FBVyxJQUFJUixTQUFTO1FBQzVCSSxZQUFZO1FBQ1pLLGVBQWU7UUFDZiwrQ0FBK0M7UUFDL0MsR0FBR1AsSUFBSTtJQUNUO0lBRUEsZ0NBQWdDO0lBQ2hDLGlEQUFpRDtJQUNqRCxJQUFJUSxVQUFVO0lBQ2RGLFNBQVNHLEtBQUssR0FBRztRQUNmLElBQUksQ0FBQ0QsU0FBUztZQUNaQSxVQUFVO1lBQ1ZFO1FBQ0Y7SUFDRjtJQUNBSixTQUFTSyxRQUFRLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxFQUFFO1FBQ3JDdkIscUJBQ0V3QixNQUFNRixRQUNOLElBQU14QixRQUFRMkIsUUFBUSxDQUFDRixJQUFJRCxRQUMzQixxQ0FBcUM7UUFDckMsQ0FBQ0ksSUFBTTVCLFFBQVEyQixRQUFRLENBQUNGLElBQUlHLEtBQUtKO0lBRXJDO0lBQ0EsZUFBZUUsTUFBTUYsS0FBSztRQUN4QixNQUFNSyxXQUFXTCxVQUFVTSxhQUFhTixVQUFVO1FBQ2xELE1BQU1PLFdBQVcsT0FBT2xCLFNBQVNtQixLQUFLLEtBQUs7UUFDM0MsSUFBSUgsWUFBWUUsVUFBVTtZQUN4QixNQUFNLEVBQUVFLEtBQUssRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTXJCLFNBQVNtQixLQUFLLENBQUNSO1lBQzdDLE1BQU1TO1lBQ04sSUFBSUMsTUFBTTtnQkFDUjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLE9BQU9yQixTQUFTc0IsTUFBTSxLQUFLLFlBQVk7WUFDekMsTUFBTSxFQUFFRixLQUFLLEVBQUUsR0FBRyxNQUFNcEIsU0FBU3NCLE1BQU07WUFDdkMsTUFBTUY7UUFDUjtJQUNGO0lBQ0EsZUFBZVg7UUFDYixPQUFTO1lBQ1AsSUFBSTtnQkFDRixNQUFNLEVBQUVXLEtBQUssRUFBRUMsSUFBSSxFQUFFLEdBQUdqQixVQUFVLE1BQU1KLFNBQVNTLElBQUksS0FBS1QsU0FBU1MsSUFBSTtnQkFDdkUsSUFBSVksTUFBTTtvQkFDUmhCLFNBQVNGLElBQUksQ0FBQztnQkFDaEIsT0FBTztvQkFDTCxNQUFNb0IsTUFBTUgsU0FBUyxPQUFPQSxNQUFNSSxJQUFJLEtBQUssYUFBYSxNQUFNSixRQUFRQTtvQkFDdEUsSUFBSUcsUUFBUSxNQUFNO3dCQUNoQmhCLFVBQVU7d0JBQ1YsTUFBTSxJQUFJYjtvQkFDWixPQUFPLElBQUlXLFNBQVNGLElBQUksQ0FBQ29CLE1BQU07d0JBQzdCO29CQUNGLE9BQU87d0JBQ0xoQixVQUFVO29CQUNaO2dCQUNGO1lBQ0YsRUFBRSxPQUFPa0IsS0FBSztnQkFDWnBCLFNBQVNxQixPQUFPLENBQUNEO1lBQ25CO1lBQ0E7UUFDRjtJQUNGO0lBQ0EsT0FBT3BCO0FBQ1Q7QUFDQXNCLE9BQU9DLE9BQU8sR0FBR2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS5qcz8wN2RkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuY29uc3QgeyBQcm9taXNlUHJvdG90eXBlVGhlbiwgU3ltYm9sQXN5bmNJdGVyYXRvciwgU3ltYm9sSXRlcmF0b3IgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfU1RSRUFNX05VTExfVkFMVUVTIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpLmNvZGVzXG5mdW5jdGlvbiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cykge1xuICBsZXQgaXRlcmF0b3JcbiAgaWYgKHR5cGVvZiBpdGVyYWJsZSA9PT0gJ3N0cmluZycgfHwgaXRlcmFibGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVhZCgpIHtcbiAgICAgICAgdGhpcy5wdXNoKGl0ZXJhYmxlKVxuICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGxldCBpc0FzeW5jXG4gIGlmIChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2xBc3luY0l0ZXJhdG9yXSkge1xuICAgIGlzQXN5bmMgPSB0cnVlXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2xBc3luY0l0ZXJhdG9yXSgpXG4gIH0gZWxzZSBpZiAoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sSXRlcmF0b3JdKSB7XG4gICAgaXNBc3luYyA9IGZhbHNlXG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2xJdGVyYXRvcl0oKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnaXRlcmFibGUnLCBbJ0l0ZXJhYmxlJ10sIGl0ZXJhYmxlKVxuICB9XG4gIGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlKHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIGhpZ2hXYXRlck1hcms6IDEsXG4gICAgLy8gVE9ETyhyb25hZyk6IFdoYXQgb3B0aW9ucyBzaG91bGQgYmUgYWxsb3dlZD9cbiAgICAuLi5vcHRzXG4gIH0pXG5cbiAgLy8gRmxhZyB0byBwcm90ZWN0IGFnYWluc3QgX3JlYWRcbiAgLy8gYmVpbmcgY2FsbGVkIGJlZm9yZSBsYXN0IGl0ZXJhdGlvbiBjb21wbGV0aW9uLlxuICBsZXQgcmVhZGluZyA9IGZhbHNlXG4gIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVhZGluZykge1xuICAgICAgcmVhZGluZyA9IHRydWVcbiAgICAgIG5leHQoKVxuICAgIH1cbiAgfVxuICByZWFkYWJsZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnJvciwgY2IpIHtcbiAgICBQcm9taXNlUHJvdG90eXBlVGhlbihcbiAgICAgIGNsb3NlKGVycm9yKSxcbiAgICAgICgpID0+IHByb2Nlc3MubmV4dFRpY2soY2IsIGVycm9yKSxcbiAgICAgIC8vIG5leHRUaWNrIGlzIGhlcmUgaW4gY2FzZSBjYiB0aHJvd3NcbiAgICAgIChlKSA9PiBwcm9jZXNzLm5leHRUaWNrKGNiLCBlIHx8IGVycm9yKVxuICAgIClcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjbG9zZShlcnJvcikge1xuICAgIGNvbnN0IGhhZEVycm9yID0gZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBlcnJvciAhPT0gbnVsbFxuICAgIGNvbnN0IGhhc1Rocm93ID0gdHlwZW9mIGl0ZXJhdG9yLnRocm93ID09PSAnZnVuY3Rpb24nXG4gICAgaWYgKGhhZEVycm9yICYmIGhhc1Rocm93KSB7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyYXRvci50aHJvdyhlcnJvcilcbiAgICAgIGF3YWl0IHZhbHVlXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICBhd2FpdCB2YWx1ZVxuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlzQXN5bmMgPyBhd2FpdCBpdGVyYXRvci5uZXh0KCkgOiBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICByZWFkYWJsZS5wdXNoKG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgPyBhd2FpdCB2YWx1ZSA6IHZhbHVlXG4gICAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkYWJsZS5wdXNoKHJlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlYWRhYmxlLmRlc3Ryb3koZXJyKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlYWRhYmxlXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZyb21cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwicmVxdWlyZSIsIlByb21pc2VQcm90b3R5cGVUaGVuIiwiU3ltYm9sQXN5bmNJdGVyYXRvciIsIlN5bWJvbEl0ZXJhdG9yIiwiQnVmZmVyIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfU1RSRUFNX05VTExfVkFMVUVTIiwiY29kZXMiLCJmcm9tIiwiUmVhZGFibGUiLCJpdGVyYWJsZSIsIm9wdHMiLCJpdGVyYXRvciIsIm9iamVjdE1vZGUiLCJyZWFkIiwicHVzaCIsImlzQXN5bmMiLCJyZWFkYWJsZSIsImhpZ2hXYXRlck1hcmsiLCJyZWFkaW5nIiwiX3JlYWQiLCJuZXh0IiwiX2Rlc3Ryb3kiLCJlcnJvciIsImNiIiwiY2xvc2UiLCJuZXh0VGljayIsImUiLCJoYWRFcnJvciIsInVuZGVmaW5lZCIsImhhc1Rocm93IiwidGhyb3ciLCJ2YWx1ZSIsImRvbmUiLCJyZXR1cm4iLCJyZXMiLCJ0aGVuIiwiZXJyIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/from.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/legacy.js":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/legacy.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { ArrayIsArray, ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\");\nfunction Stream(opts) {\n    EE.call(this, opts);\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype);\nObjectSetPrototypeOf(Stream, EE);\nStream.prototype.pipe = function(dest, options) {\n    const source = this;\n    function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === false && source.pause) {\n            source.pause();\n        }\n    }\n    source.on(\"data\", ondata);\n    function ondrain() {\n        if (source.readable && source.resume) {\n            source.resume();\n        }\n    }\n    dest.on(\"drain\", ondrain);\n    // If the 'end' option is not supplied, dest.end() will be called when\n    // source gets the 'end' or 'close' events.  Only dest.end() once.\n    if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on(\"end\", onend);\n        source.on(\"close\", onclose);\n    }\n    let didOnEnd = false;\n    function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n    }\n    function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === \"function\") dest.destroy();\n    }\n    // Don't leave dangling pipes when there are errors.\n    function onerror(er) {\n        cleanup();\n        if (EE.listenerCount(this, \"error\") === 0) {\n            this.emit(\"error\", er);\n        }\n    }\n    prependListener(source, \"error\", onerror);\n    prependListener(dest, \"error\", onerror);\n    // Remove all the event listeners that were added.\n    function cleanup() {\n        source.removeListener(\"data\", ondata);\n        dest.removeListener(\"drain\", ondrain);\n        source.removeListener(\"end\", onend);\n        source.removeListener(\"close\", onclose);\n        source.removeListener(\"error\", onerror);\n        dest.removeListener(\"error\", onerror);\n        source.removeListener(\"end\", cleanup);\n        source.removeListener(\"close\", cleanup);\n        dest.removeListener(\"close\", cleanup);\n    }\n    source.on(\"end\", cleanup);\n    source.on(\"close\", cleanup);\n    dest.on(\"close\", cleanup);\n    dest.emit(\"pipe\", source);\n    // Allow for unix-like usage: A.pipe(B).pipe(C)\n    return dest;\n};\nfunction prependListener(emitter, event, fn) {\n    // Sadly this is not cacheable as some libraries bundle their own\n    // event emitter implementation with them.\n    if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n    else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);\n    else emitter._events[event] = [\n        fn,\n        emitter._events[event]\n    ];\n}\nmodule.exports = {\n    Stream,\n    prependListener\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9sZWdhY3kuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFlBQVksRUFBRUMsb0JBQW9CLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDdkQsTUFBTSxFQUFFQyxjQUFjQyxFQUFFLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDckMsU0FBU0csT0FBT0MsSUFBSTtJQUNsQkYsR0FBR0csSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDaEI7QUFDQUwscUJBQXFCSSxPQUFPRyxTQUFTLEVBQUVKLEdBQUdJLFNBQVM7QUFDbkRQLHFCQUFxQkksUUFBUUQ7QUFDN0JDLE9BQU9HLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHLFNBQVVDLElBQUksRUFBRUMsT0FBTztJQUM3QyxNQUFNQyxTQUFTLElBQUk7SUFDbkIsU0FBU0MsT0FBT0MsS0FBSztRQUNuQixJQUFJSixLQUFLSyxRQUFRLElBQUlMLEtBQUtNLEtBQUssQ0FBQ0YsV0FBVyxTQUFTRixPQUFPSyxLQUFLLEVBQUU7WUFDaEVMLE9BQU9LLEtBQUs7UUFDZDtJQUNGO0lBQ0FMLE9BQU9NLEVBQUUsQ0FBQyxRQUFRTDtJQUNsQixTQUFTTTtRQUNQLElBQUlQLE9BQU9RLFFBQVEsSUFBSVIsT0FBT1MsTUFBTSxFQUFFO1lBQ3BDVCxPQUFPUyxNQUFNO1FBQ2Y7SUFDRjtJQUNBWCxLQUFLUSxFQUFFLENBQUMsU0FBU0M7SUFFakIsc0VBQXNFO0lBQ3RFLGtFQUFrRTtJQUNsRSxJQUFJLENBQUNULEtBQUtZLFFBQVEsSUFBSyxFQUFDWCxXQUFXQSxRQUFRWSxHQUFHLEtBQUssS0FBSSxHQUFJO1FBQ3pEWCxPQUFPTSxFQUFFLENBQUMsT0FBT007UUFDakJaLE9BQU9NLEVBQUUsQ0FBQyxTQUFTTztJQUNyQjtJQUNBLElBQUlDLFdBQVc7SUFDZixTQUFTRjtRQUNQLElBQUlFLFVBQVU7UUFDZEEsV0FBVztRQUNYaEIsS0FBS2EsR0FBRztJQUNWO0lBQ0EsU0FBU0U7UUFDUCxJQUFJQyxVQUFVO1FBQ2RBLFdBQVc7UUFDWCxJQUFJLE9BQU9oQixLQUFLaUIsT0FBTyxLQUFLLFlBQVlqQixLQUFLaUIsT0FBTztJQUN0RDtJQUVBLG9EQUFvRDtJQUNwRCxTQUFTQyxRQUFRQyxFQUFFO1FBQ2pCQztRQUNBLElBQUkxQixHQUFHMkIsYUFBYSxDQUFDLElBQUksRUFBRSxhQUFhLEdBQUc7WUFDekMsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBU0g7UUFDckI7SUFDRjtJQUNBSSxnQkFBZ0JyQixRQUFRLFNBQVNnQjtJQUNqQ0ssZ0JBQWdCdkIsTUFBTSxTQUFTa0I7SUFFL0Isa0RBQWtEO0lBQ2xELFNBQVNFO1FBQ1BsQixPQUFPc0IsY0FBYyxDQUFDLFFBQVFyQjtRQUM5QkgsS0FBS3dCLGNBQWMsQ0FBQyxTQUFTZjtRQUM3QlAsT0FBT3NCLGNBQWMsQ0FBQyxPQUFPVjtRQUM3QlosT0FBT3NCLGNBQWMsQ0FBQyxTQUFTVDtRQUMvQmIsT0FBT3NCLGNBQWMsQ0FBQyxTQUFTTjtRQUMvQmxCLEtBQUt3QixjQUFjLENBQUMsU0FBU047UUFDN0JoQixPQUFPc0IsY0FBYyxDQUFDLE9BQU9KO1FBQzdCbEIsT0FBT3NCLGNBQWMsQ0FBQyxTQUFTSjtRQUMvQnBCLEtBQUt3QixjQUFjLENBQUMsU0FBU0o7SUFDL0I7SUFDQWxCLE9BQU9NLEVBQUUsQ0FBQyxPQUFPWTtJQUNqQmxCLE9BQU9NLEVBQUUsQ0FBQyxTQUFTWTtJQUNuQnBCLEtBQUtRLEVBQUUsQ0FBQyxTQUFTWTtJQUNqQnBCLEtBQUtzQixJQUFJLENBQUMsUUFBUXBCO0lBRWxCLCtDQUErQztJQUMvQyxPQUFPRjtBQUNUO0FBQ0EsU0FBU3VCLGdCQUFnQkUsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLEVBQUU7SUFDekMsaUVBQWlFO0lBQ2pFLDBDQUEwQztJQUMxQyxJQUFJLE9BQU9GLFFBQVFGLGVBQWUsS0FBSyxZQUFZLE9BQU9FLFFBQVFGLGVBQWUsQ0FBQ0csT0FBT0M7SUFFekYsNEVBQTRFO0lBQzVFLDJFQUEyRTtJQUMzRSx5RUFBeUU7SUFDekUsNEVBQTRFO0lBQzVFLElBQUksQ0FBQ0YsUUFBUUcsT0FBTyxJQUFJLENBQUNILFFBQVFHLE9BQU8sQ0FBQ0YsTUFBTSxFQUFFRCxRQUFRakIsRUFBRSxDQUFDa0IsT0FBT0M7U0FDOUQsSUFBSXJDLGFBQWFtQyxRQUFRRyxPQUFPLENBQUNGLE1BQU0sR0FBR0QsUUFBUUcsT0FBTyxDQUFDRixNQUFNLENBQUNHLE9BQU8sQ0FBQ0Y7U0FDekVGLFFBQVFHLE9BQU8sQ0FBQ0YsTUFBTSxHQUFHO1FBQUNDO1FBQUlGLFFBQVFHLE9BQU8sQ0FBQ0YsTUFBTTtLQUFDO0FBQzVEO0FBQ0FJLE9BQU9DLE9BQU8sR0FBRztJQUNmcEM7SUFDQTRCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9sZWdhY3kuanM/MmY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBBcnJheUlzQXJyYXksIE9iamVjdFNldFByb3RvdHlwZU9mIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmZ1bmN0aW9uIFN0cmVhbShvcHRzKSB7XG4gIEVFLmNhbGwodGhpcywgb3B0cylcbn1cbk9iamVjdFNldFByb3RvdHlwZU9mKFN0cmVhbS5wcm90b3R5cGUsIEVFLnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFN0cmVhbSwgRUUpXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2UgPSB0aGlzXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlICYmIGRlc3Qud3JpdGUoY2h1bmspID09PSBmYWxzZSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgIHNvdXJjZS5wYXVzZSgpXG4gICAgfVxuICB9XG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSlcbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pXG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZClcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSlcbiAgfVxuICBsZXQgZGlkT25FbmQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVyblxuICAgIGRpZE9uRW5kID0gdHJ1ZVxuICAgIGRlc3QuZW5kKClcbiAgfVxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuXG4gICAgZGlkT25FbmQgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpXG4gIH1cblxuICAvLyBEb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKClcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxuICBwcmVwZW5kTGlzdGVuZXIoc291cmNlLCAnZXJyb3InLCBvbmVycm9yKVxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcilcblxuICAvLyBSZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKVxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cClcbiAgfVxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApXG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKVxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSlcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdFxufVxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbilcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKVxuICBlbHNlIGlmIChBcnJheUlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbilcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN0cmVhbSxcbiAgcHJlcGVuZExpc3RlbmVyXG59XG4iXSwibmFtZXMiOlsiQXJyYXlJc0FycmF5IiwiT2JqZWN0U2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwiRUUiLCJTdHJlYW0iLCJvcHRzIiwiY2FsbCIsInByb3RvdHlwZSIsInBpcGUiLCJkZXN0Iiwib3B0aW9ucyIsInNvdXJjZSIsIm9uZGF0YSIsImNodW5rIiwid3JpdGFibGUiLCJ3cml0ZSIsInBhdXNlIiwib24iLCJvbmRyYWluIiwicmVhZGFibGUiLCJyZXN1bWUiLCJfaXNTdGRpbyIsImVuZCIsIm9uZW5kIiwib25jbG9zZSIsImRpZE9uRW5kIiwiZGVzdHJveSIsIm9uZXJyb3IiLCJlciIsImNsZWFudXAiLCJsaXN0ZW5lckNvdW50IiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdHRlciIsImV2ZW50IiwiZm4iLCJfZXZlbnRzIiwidW5zaGlmdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/legacy.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/operators.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/operators.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController);\nconst { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE }, AbortError } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { validateAbortSignal, validateInteger, validateObject } = __webpack_require__(/*! ../validators */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js\");\nconst kWeakHandler = (__webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\").Symbol)(\"kWeak\");\nconst kResistStopPropagation = (__webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\").Symbol)(\"kResistStopPropagation\");\nconst { finished } = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nconst staticCompose = __webpack_require__(/*! ./compose */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/compose.js\");\nconst { addAbortSignalNoValidate } = __webpack_require__(/*! ./add-abort-signal */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\");\nconst { isWritable, isNodeStream } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst { deprecate } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nconst { ArrayPrototypePush, Boolean, MathFloor, Number, NumberIsNaN, Promise, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst kEmpty = Symbol(\"kEmpty\");\nconst kEof = Symbol(\"kEof\");\nfunction compose(stream, options) {\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    if (isNodeStream(stream) && !isWritable(stream)) {\n        throw new ERR_INVALID_ARG_VALUE(\"stream\", stream, \"must be writable\");\n    }\n    const composedStream = staticCompose(this, stream);\n    if (options !== null && options !== undefined && options.signal) {\n        // Not validating as we already validated before\n        addAbortSignalNoValidate(options.signal, composedStream);\n    }\n    return composedStream;\n}\nfunction map(fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\n            \"Function\",\n            \"AsyncFunction\"\n        ], fn);\n    }\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    let concurrency = 1;\n    if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n        concurrency = MathFloor(options.concurrency);\n    }\n    let highWaterMark = concurrency - 1;\n    if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n        highWaterMark = MathFloor(options.highWaterMark);\n    }\n    validateInteger(concurrency, \"options.concurrency\", 1);\n    validateInteger(highWaterMark, \"options.highWaterMark\", 0);\n    highWaterMark += concurrency;\n    return (async function* map() {\n        const signal = (__webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").AbortSignalAny)([\n            options === null || options === undefined ? undefined : options.signal\n        ].filter(Boolean));\n        const stream = this;\n        const queue = [];\n        const signalOpt = {\n            signal\n        };\n        let next;\n        let resume;\n        let done = false;\n        let cnt = 0;\n        function onCatch() {\n            done = true;\n            afterItemProcessed();\n        }\n        function afterItemProcessed() {\n            cnt -= 1;\n            maybeResume();\n        }\n        function maybeResume() {\n            if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n                resume();\n                resume = null;\n            }\n        }\n        async function pump() {\n            try {\n                for await (let val of stream){\n                    if (done) {\n                        return;\n                    }\n                    if (signal.aborted) {\n                        throw new AbortError();\n                    }\n                    try {\n                        val = fn(val, signalOpt);\n                        if (val === kEmpty) {\n                            continue;\n                        }\n                        val = PromiseResolve(val);\n                    } catch (err) {\n                        val = PromiseReject(err);\n                    }\n                    cnt += 1;\n                    PromisePrototypeThen(val, afterItemProcessed, onCatch);\n                    queue.push(val);\n                    if (next) {\n                        next();\n                        next = null;\n                    }\n                    if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n                        await new Promise((resolve)=>{\n                            resume = resolve;\n                        });\n                    }\n                }\n                queue.push(kEof);\n            } catch (err) {\n                const val = PromiseReject(err);\n                PromisePrototypeThen(val, afterItemProcessed, onCatch);\n                queue.push(val);\n            } finally{\n                done = true;\n                if (next) {\n                    next();\n                    next = null;\n                }\n            }\n        }\n        pump();\n        try {\n            while(true){\n                while(queue.length > 0){\n                    const val = await queue[0];\n                    if (val === kEof) {\n                        return;\n                    }\n                    if (signal.aborted) {\n                        throw new AbortError();\n                    }\n                    if (val !== kEmpty) {\n                        yield val;\n                    }\n                    queue.shift();\n                    maybeResume();\n                }\n                await new Promise((resolve)=>{\n                    next = resolve;\n                });\n            }\n        } finally{\n            done = true;\n            if (resume) {\n                resume();\n                resume = null;\n            }\n        }\n    }).call(this);\n}\nfunction asIndexedPairs(options = undefined) {\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    return (async function* asIndexedPairs() {\n        let index = 0;\n        for await (const val of this){\n            var _options$signal;\n            if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {\n                throw new AbortError({\n                    cause: options.signal.reason\n                });\n            }\n            yield [\n                index++,\n                val\n            ];\n        }\n    }).call(this);\n}\nasync function some(fn, options = undefined) {\n    for await (const unused of filter.call(this, fn, options)){\n        return true;\n    }\n    return false;\n}\nasync function every(fn, options = undefined) {\n    if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\n            \"Function\",\n            \"AsyncFunction\"\n        ], fn);\n    }\n    // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n    return !await some.call(this, async (...args)=>{\n        return !await fn(...args);\n    }, options);\n}\nasync function find(fn, options) {\n    for await (const result of filter.call(this, fn, options)){\n        return result;\n    }\n    return undefined;\n}\nasync function forEach(fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\n            \"Function\",\n            \"AsyncFunction\"\n        ], fn);\n    }\n    async function forEachFn(value, options) {\n        await fn(value, options);\n        return kEmpty;\n    }\n    // eslint-disable-next-line no-unused-vars\n    for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\n            \"Function\",\n            \"AsyncFunction\"\n        ], fn);\n    }\n    async function filterFn(value, options) {\n        if (await fn(value, options)) {\n            return value;\n        }\n        return kEmpty;\n    }\n    return map.call(this, filterFn, options);\n}\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n    constructor(){\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n    }\n}\nasync function reduce(reducer, initialValue, options) {\n    var _options$signal2;\n    if (typeof reducer !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"reducer\", [\n            \"Function\",\n            \"AsyncFunction\"\n        ], reducer);\n    }\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    let hasInitialValue = arguments.length > 1;\n    if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {\n        const err = new AbortError(undefined, {\n            cause: options.signal.reason\n        });\n        this.once(\"error\", ()=>{}) // The error is already propagated\n        ;\n        await finished(this.destroy(err));\n        throw err;\n    }\n    const ac = new AbortController();\n    const signal = ac.signal;\n    if (options !== null && options !== undefined && options.signal) {\n        const opts = {\n            once: true,\n            [kWeakHandler]: this,\n            [kResistStopPropagation]: true\n        };\n        options.signal.addEventListener(\"abort\", ()=>ac.abort(), opts);\n    }\n    let gotAnyItemFromStream = false;\n    try {\n        for await (const value of this){\n            var _options$signal3;\n            gotAnyItemFromStream = true;\n            if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {\n                throw new AbortError();\n            }\n            if (!hasInitialValue) {\n                initialValue = value;\n                hasInitialValue = true;\n            } else {\n                initialValue = await reducer(initialValue, value, {\n                    signal\n                });\n            }\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue) {\n            throw new ReduceAwareErrMissingArgs();\n        }\n    } finally{\n        ac.abort();\n    }\n    return initialValue;\n}\nasync function toArray(options) {\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    const result = [];\n    for await (const val of this){\n        var _options$signal4;\n        if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {\n            throw new AbortError(undefined, {\n                cause: options.signal.reason\n            });\n        }\n        ArrayPrototypePush(result, val);\n    }\n    return result;\n}\nfunction flatMap(fn, options) {\n    const values = map.call(this, fn, options);\n    return (async function* flatMap() {\n        for await (const val of values){\n            yield* val;\n        }\n    }).call(this);\n}\nfunction toIntegerOrInfinity(number) {\n    // We coerce here to align with the spec\n    // https://github.com/tc39/proposal-iterator-helpers/issues/169\n    number = Number(number);\n    if (NumberIsNaN(number)) {\n        return 0;\n    }\n    if (number < 0) {\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n    }\n    return number;\n}\nfunction drop(number, options = undefined) {\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    number = toIntegerOrInfinity(number);\n    return (async function* drop() {\n        var _options$signal5;\n        if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {\n            throw new AbortError();\n        }\n        for await (const val of this){\n            var _options$signal6;\n            if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {\n                throw new AbortError();\n            }\n            if (number-- <= 0) {\n                yield val;\n            }\n        }\n    }).call(this);\n}\nfunction take(number, options = undefined) {\n    if (options != null) {\n        validateObject(options, \"options\");\n    }\n    if ((options === null || options === undefined ? undefined : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n    }\n    number = toIntegerOrInfinity(number);\n    return (async function* take() {\n        var _options$signal7;\n        if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {\n            throw new AbortError();\n        }\n        for await (const val of this){\n            var _options$signal8;\n            if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {\n                throw new AbortError();\n            }\n            if (number-- > 0) {\n                yield val;\n            }\n            // Don't get another item from iterator in case we reached the end\n            if (number <= 0) {\n                return;\n            }\n        }\n    }).call(this);\n}\nmodule.exports.streamReturningOperators = {\n    asIndexedPairs: deprecate(asIndexedPairs, \"readable.asIndexedPairs will be removed in a future version.\"),\n    drop,\n    filter,\n    flatMap,\n    map,\n    take,\n    compose\n};\nmodule.exports.promiseReturningOperators = {\n    every,\n    forEach,\n    reduce,\n    toArray,\n    some,\n    find\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9vcGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxrQkFBa0JDLFdBQVdELGVBQWUsSUFBSUUsZ0lBQTJDO0FBQ2pHLE1BQU0sRUFDSkMsT0FBTyxFQUFFQyxxQkFBcUIsRUFBRUMsb0JBQW9CLEVBQUVDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRSxFQUMxRkMsVUFBVSxFQUNYLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTyxtQkFBbUIsRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDekUsTUFBTVUsZUFBZVYsa0tBQXdDLENBQUM7QUFDOUQsTUFBTVkseUJBQXlCWixrS0FBd0MsQ0FBQztBQUN4RSxNQUFNLEVBQUVhLFFBQVEsRUFBRSxHQUFHYixtQkFBT0EsQ0FBQztBQUM3QixNQUFNYyxnQkFBZ0JkLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRWUsd0JBQXdCLEVBQUUsR0FBR2YsbUJBQU9BLENBQUM7QUFDN0MsTUFBTSxFQUFFZ0IsVUFBVSxFQUFFQyxZQUFZLEVBQUUsR0FBR2pCLG1CQUFPQSxDQUFDO0FBQzdDLE1BQU0sRUFBRWtCLFNBQVMsRUFBRSxHQUFHbEIsbUJBQU9BLENBQUM7QUFDOUIsTUFBTSxFQUNKbUIsa0JBQWtCLEVBQ2xCQyxPQUFPLEVBQ1BDLFNBQVMsRUFDVEMsTUFBTSxFQUNOQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUEMsYUFBYSxFQUNiQyxjQUFjLEVBQ2RDLG9CQUFvQixFQUNwQmhCLE1BQU0sRUFDUCxHQUFHWCxtQkFBT0EsQ0FBQztBQUNaLE1BQU00QixTQUFTakIsT0FBTztBQUN0QixNQUFNa0IsT0FBT2xCLE9BQU87QUFDcEIsU0FBU21CLFFBQVFDLE1BQU0sRUFBRUMsT0FB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LFlBQVksUUFBUUEsWUFBWUMsWUFBWUEsWUFBWUQsUUFBUUUsTUFBTSxLQUFLLE1BQU07UUFDcEYzQixvQkFBb0J5QixRQUFRRSxNQUFNLEVBQUU7SUFDdEM7SUFDQStELFNBQVNELG9CQUFvQkM7SUFDN0IsT0FBTyxpQkFBZ0JJO1FBQ3JCLElBQUlDO1FBQ0osSUFDRXRFLFlBQVksUUFDWkEsWUFBWUMsYUFDWixDQUFDcUUsbUJBQW1CdEUsUUFBUUUsTUFBTSxNQUFNLFFBQ3hDb0UscUJBQXFCckUsYUFDckJxRSxpQkFBaUJoRCxPQUFPLEVBQ3hCO1lBQ0EsTUFBTSxJQUFJaEQ7UUFDWjtRQUNBLFdBQVcsTUFBTStDLE9BQU8sSUFBSSxDQUFFO1lBQzVCLElBQUlrRDtZQUNKLElBQ0V2RSxZQUFZLFFBQ1pBLFlBQVlDLGFBQ1osQ0FBQ3NFLG1CQUFtQnZFLFFBQVFFLE1BQU0sTUFBTSxRQUN4Q3FFLHFCQUFxQnRFLGFBQ3JCc0UsaUJBQWlCakQsT0FBTyxFQUN4QjtnQkFDQSxNQUFNLElBQUloRDtZQUNaO1lBQ0EsSUFBSTJGLFdBQVcsR0FBRztnQkFDaEIsTUFBTTVDO1lBQ1I7WUFFQSxrRUFBa0U7WUFDbEUsSUFBSTRDLFVBQVUsR0FBRztnQkFDZjtZQUNGO1FBQ0Y7SUFDRixHQUFFdEMsSUFBSSxDQUFDLElBQUk7QUFDYjtBQUNBNkMsdUNBQXVDLEdBQUc7SUFDeEM1QyxnQkFBZ0IxQyxVQUFVMEMsZ0JBQWdCO0lBQzFDc0M7SUFDQXpEO0lBQ0FxRDtJQUNBMUQ7SUFDQWlFO0lBQ0F2RTtBQUNGO0FBQ0EwRSx3Q0FBd0MsR0FBRztJQUN6Q3JDO0lBQ0FJO0lBQ0FPO0lBQ0FjO0lBQ0EzQjtJQUNBSTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvb3BlcmF0b3JzLmpzPzZmMzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmNvbnN0IHtcbiAgY29kZXM6IHsgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX01JU1NJTkdfQVJHUywgRVJSX09VVF9PRl9SQU5HRSB9LFxuICBBYm9ydEVycm9yXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyB2YWxpZGF0ZUFib3J0U2lnbmFsLCB2YWxpZGF0ZUludGVnZXIsIHZhbGlkYXRlT2JqZWN0IH0gPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJylcbmNvbnN0IGtXZWFrSGFuZGxlciA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKS5TeW1ib2woJ2tXZWFrJylcbmNvbnN0IGtSZXNpc3RTdG9wUHJvcGFnYXRpb24gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJykuU3ltYm9sKCdrUmVzaXN0U3RvcFByb3BhZ2F0aW9uJylcbmNvbnN0IHsgZmluaXNoZWQgfSA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpXG5jb25zdCBzdGF0aWNDb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJylcbmNvbnN0IHsgYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlIH0gPSByZXF1aXJlKCcuL2FkZC1hYm9ydC1zaWduYWwnKVxuY29uc3QgeyBpc1dyaXRhYmxlLCBpc05vZGVTdHJlYW0gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgeyBkZXByZWNhdGUgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCB7XG4gIEFycmF5UHJvdG90eXBlUHVzaCxcbiAgQm9vbGVhbixcbiAgTWF0aEZsb29yLFxuICBOdW1iZXIsXG4gIE51bWJlcklzTmFOLFxuICBQcm9taXNlLFxuICBQcm9taXNlUmVqZWN0LFxuICBQcm9taXNlUmVzb2x2ZSxcbiAgUHJvbWlzZVByb3RvdHlwZVRoZW4sXG4gIFN5bWJvbFxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3Qga0VtcHR5ID0gU3ltYm9sKCdrRW1wdHknKVxuY29uc3Qga0VvZiA9IFN5bWJvbCgna0VvZicpXG5mdW5jdGlvbiBjb21wb3NlKHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgaWYgKGlzTm9kZVN0cmVhbShzdHJlYW0pICYmICFpc1dyaXRhYmxlKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdzdHJlYW0nLCBzdHJlYW0sICdtdXN0IGJlIHdyaXRhYmxlJylcbiAgfVxuICBjb25zdCBjb21wb3NlZFN0cmVhbSA9IHN0YXRpY0NvbXBvc2UodGhpcywgc3RyZWFtKVxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAvLyBOb3QgdmFsaWRhdGluZyBhcyB3ZSBhbHJlYWR5IHZhbGlkYXRlZCBiZWZvcmVcbiAgICBhZGRBYm9ydFNpZ25hbE5vVmFsaWRhdGUob3B0aW9ucy5zaWduYWwsIGNvbXBvc2VkU3RyZWFtKVxuICB9XG4gIHJldHVybiBjb21wb3NlZFN0cmVhbVxufVxuZnVuY3Rpb24gbWFwKGZuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgWydGdW5jdGlvbicsICdBc3luY0Z1bmN0aW9uJ10sIGZuKVxuICB9XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBsZXQgY29uY3VycmVuY3kgPSAxXG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmNvbmN1cnJlbmN5KSAhPSBudWxsKSB7XG4gICAgY29uY3VycmVuY3kgPSBNYXRoRmxvb3Iob3B0aW9ucy5jb25jdXJyZW5jeSlcbiAgfVxuICBsZXQgaGlnaFdhdGVyTWFyayA9IGNvbmN1cnJlbmN5IC0gMVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrKSAhPSBudWxsKSB7XG4gICAgaGlnaFdhdGVyTWFyayA9IE1hdGhGbG9vcihvcHRpb25zLmhpZ2hXYXRlck1hcmspXG4gIH1cbiAgdmFsaWRhdGVJbnRlZ2VyKGNvbmN1cnJlbmN5LCAnb3B0aW9ucy5jb25jdXJyZW5jeScsIDEpXG4gIHZhbGlkYXRlSW50ZWdlcihoaWdoV2F0ZXJNYXJrLCAnb3B0aW9ucy5oaWdoV2F0ZXJNYXJrJywgMClcbiAgaGlnaFdhdGVyTWFyayArPSBjb25jdXJyZW5jeVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIG1hcCgpIHtcbiAgICBjb25zdCBzaWduYWwgPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5BYm9ydFNpZ25hbEFueShcbiAgICAgIFtvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsXS5maWx0ZXIoQm9vbGVhbilcbiAgICApXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpc1xuICAgIGNvbnN0IHF1ZXVlID0gW11cbiAgICBjb25zdCBzaWduYWxPcHQgPSB7XG4gICAgICBzaWduYWxcbiAgICB9XG4gICAgbGV0IG5leHRcbiAgICBsZXQgcmVzdW1lXG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuICAgIGxldCBjbnQgPSAwXG4gICAgZnVuY3Rpb24gb25DYXRjaCgpIHtcbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBhZnRlckl0ZW1Qcm9jZXNzZWQoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZnRlckl0ZW1Qcm9jZXNzZWQoKSB7XG4gICAgICBjbnQgLT0gMVxuICAgICAgbWF5YmVSZXN1bWUoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZVJlc3VtZSgpIHtcbiAgICAgIGlmIChyZXN1bWUgJiYgIWRvbmUgJiYgY250IDwgY29uY3VycmVuY3kgJiYgcXVldWUubGVuZ3RoIDwgaGlnaFdhdGVyTWFyaykge1xuICAgICAgICByZXN1bWUoKVxuICAgICAgICByZXN1bWUgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGxldCB2YWwgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbCA9IGZuKHZhbCwgc2lnbmFsT3B0KVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0ga0VtcHR5KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBQcm9taXNlUmVzb2x2ZSh2YWwpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB2YWwgPSBQcm9taXNlUmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgY250ICs9IDFcbiAgICAgICAgICBQcm9taXNlUHJvdG90eXBlVGhlbih2YWwsIGFmdGVySXRlbVByb2Nlc3NlZCwgb25DYXRjaClcbiAgICAgICAgICBxdWV1ZS5wdXNoKHZhbClcbiAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dCgpXG4gICAgICAgICAgICBuZXh0ID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRvbmUgJiYgKHF1ZXVlLmxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrIHx8IGNudCA+PSBjb25jdXJyZW5jeSkpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VtZSA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnB1c2goa0VvZilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCB2YWwgPSBQcm9taXNlUmVqZWN0KGVycilcbiAgICAgICAgUHJvbWlzZVByb3RvdHlwZVRoZW4odmFsLCBhZnRlckl0ZW1Qcm9jZXNzZWQsIG9uQ2F0Y2gpXG4gICAgICAgIHF1ZXVlLnB1c2godmFsKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0KClcbiAgICAgICAgICBuZXh0ID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHB1bXAoKVxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGF3YWl0IHF1ZXVlWzBdXG4gICAgICAgICAgaWYgKHZhbCA9PT0ga0VvZikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsICE9PSBrRW1wdHkpIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5zaGlmdCgpXG4gICAgICAgICAgbWF5YmVSZXN1bWUoKVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgbmV4dCA9IHJlc29sdmVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIGlmIChyZXN1bWUpIHtcbiAgICAgICAgcmVzdW1lKClcbiAgICAgICAgcmVzdW1lID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5mdW5jdGlvbiBhc0luZGV4ZWRQYWlycyhvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIGFzSW5kZXhlZFBhaXJzKCkge1xuICAgIGxldCBpbmRleCA9IDBcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgICB2YXIgX29wdGlvbnMkc2lnbmFsXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChfb3B0aW9ucyRzaWduYWwgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsLmFib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcih7XG4gICAgICAgICAgY2F1c2U6IG9wdGlvbnMuc2lnbmFsLnJlYXNvblxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgeWllbGQgW2luZGV4KyssIHZhbF1cbiAgICB9XG4gIH0uY2FsbCh0aGlzKVxufVxuYXN5bmMgZnVuY3Rpb24gc29tZShmbiwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICBmb3IgYXdhaXQgKGNvbnN0IHVudXNlZCBvZiBmaWx0ZXIuY2FsbCh0aGlzLCBmbiwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuYXN5bmMgZnVuY3Rpb24gZXZlcnkoZm4sIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgZm4pXG4gIH1cbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVfTW9yZ2FuJTI3c19sYXdzXG4gIHJldHVybiAhKGF3YWl0IHNvbWUuY2FsbChcbiAgICB0aGlzLFxuICAgIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4gIShhd2FpdCBmbiguLi5hcmdzKSlcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKSlcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmQoZm4sIG9wdGlvbnMpIHtcbiAgZm9yIGF3YWl0IChjb25zdCByZXN1bHQgb2YgZmlsdGVyLmNhbGwodGhpcywgZm4sIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG4gIHJldHVybiB1bmRlZmluZWRcbn1cbmFzeW5jIGZ1bmN0aW9uIGZvckVhY2goZm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgZm4pXG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZm9yRWFjaEZuKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgZm4odmFsdWUsIG9wdGlvbnMpXG4gICAgcmV0dXJuIGtFbXB0eVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBmb3IgYXdhaXQgKGNvbnN0IHVudXNlZCBvZiBtYXAuY2FsbCh0aGlzLCBmb3JFYWNoRm4sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGZpbHRlcihmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsIFsnRnVuY3Rpb24nLCAnQXN5bmNGdW5jdGlvbiddLCBmbilcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmaWx0ZXJGbih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChhd2FpdCBmbih2YWx1ZSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICByZXR1cm4ga0VtcHR5XG4gIH1cbiAgcmV0dXJuIG1hcC5jYWxsKHRoaXMsIGZpbHRlckZuLCBvcHRpb25zKVxufVxuXG4vLyBTcGVjaWZpYyB0byBwcm92aWRlIGJldHRlciBlcnJvciB0byByZWR1Y2Ugc2luY2UgdGhlIGFyZ3VtZW50IGlzIG9ubHlcbi8vIG1pc3NpbmcgaWYgdGhlIHN0cmVhbSBoYXMgbm8gaXRlbXMgaW4gaXQgLSBidXQgdGhlIGNvZGUgaXMgc3RpbGwgYXBwcm9wcmlhdGVcbmNsYXNzIFJlZHVjZUF3YXJlRXJyTWlzc2luZ0FyZ3MgZXh0ZW5kcyBFUlJfTUlTU0lOR19BUkdTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3JlZHVjZScpXG4gICAgdGhpcy5tZXNzYWdlID0gJ1JlZHVjZSBvZiBhbiBlbXB0eSBzdHJlYW0gcmVxdWlyZXMgYW4gaW5pdGlhbCB2YWx1ZSdcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVkdWNlKHJlZHVjZXIsIGluaXRpYWxWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkc2lnbmFsMlxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3JlZHVjZXInLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgcmVkdWNlcilcbiAgfVxuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgbGV0IGhhc0luaXRpYWxWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gIGlmIChcbiAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgKF9vcHRpb25zJHNpZ25hbDIgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICBfb3B0aW9ucyRzaWduYWwyICE9PSB1bmRlZmluZWQgJiZcbiAgICBfb3B0aW9ucyRzaWduYWwyLmFib3J0ZWRcbiAgKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgfSlcbiAgICB0aGlzLm9uY2UoJ2Vycm9yJywgKCkgPT4ge30pIC8vIFRoZSBlcnJvciBpcyBhbHJlYWR5IHByb3BhZ2F0ZWRcbiAgICBhd2FpdCBmaW5pc2hlZCh0aGlzLmRlc3Ryb3koZXJyKSlcbiAgICB0aHJvdyBlcnJcbiAgfVxuICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBjb25zdCBzaWduYWwgPSBhYy5zaWduYWxcbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBba1dlYWtIYW5kbGVyXTogdGhpcyxcbiAgICAgIFtrUmVzaXN0U3RvcFByb3BhZ2F0aW9uXTogdHJ1ZVxuICAgIH1cbiAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGFjLmFib3J0KCksIG9wdHMpXG4gIH1cbiAgbGV0IGdvdEFueUl0ZW1Gcm9tU3RyZWFtID0gZmFsc2VcbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRzaWduYWwzXG4gICAgICBnb3RBbnlJdGVtRnJvbVN0cmVhbSA9IHRydWVcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKF9vcHRpb25zJHNpZ25hbDMgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsMyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDMuYWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IHZhbHVlXG4gICAgICAgIGhhc0luaXRpYWxWYWx1ZSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGF3YWl0IHJlZHVjZXIoaW5pdGlhbFZhbHVlLCB2YWx1ZSwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdvdEFueUl0ZW1Gcm9tU3RyZWFtICYmICFoYXNJbml0aWFsVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBSZWR1Y2VBd2FyZUVyck1pc3NpbmdBcmdzKClcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYWMuYWJvcnQoKVxuICB9XG4gIHJldHVybiBpbml0aWFsVmFsdWVcbn1cbmFzeW5jIGZ1bmN0aW9uIHRvQXJyYXkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgIHZhciBfb3B0aW9ucyRzaWduYWw0XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX29wdGlvbnMkc2lnbmFsNCA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw0LmFib3J0ZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgICB9KVxuICAgIH1cbiAgICBBcnJheVByb3RvdHlwZVB1c2gocmVzdWx0LCB2YWwpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuZnVuY3Rpb24gZmxhdE1hcChmbiwgb3B0aW9ucykge1xuICBjb25zdCB2YWx1ZXMgPSBtYXAuY2FsbCh0aGlzLCBmbiwgb3B0aW9ucylcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiBmbGF0TWFwKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgICAgeWllbGQqIHZhbFxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5mdW5jdGlvbiB0b0ludGVnZXJPckluZmluaXR5KG51bWJlcikge1xuICAvLyBXZSBjb2VyY2UgaGVyZSB0byBhbGlnbiB3aXRoIHRoZSBzcGVjXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWl0ZXJhdG9yLWhlbHBlcnMvaXNzdWVzLzE2OVxuICBudW1iZXIgPSBOdW1iZXIobnVtYmVyKVxuICBpZiAoTnVtYmVySXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKG51bWJlciA8IDApIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRSgnbnVtYmVyJywgJz49IDAnLCBudW1iZXIpXG4gIH1cbiAgcmV0dXJuIG51bWJlclxufVxuZnVuY3Rpb24gZHJvcChudW1iZXIsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkobnVtYmVyKVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIGRyb3AoKSB7XG4gICAgdmFyIF9vcHRpb25zJHNpZ25hbDVcbiAgICBpZiAoXG4gICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChfb3B0aW9ucyRzaWduYWw1ID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw1ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDUuYWJvcnRlZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgICB2YXIgX29wdGlvbnMkc2lnbmFsNlxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoX29wdGlvbnMkc2lnbmFsNiA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWw2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsNi5hYm9ydGVkXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgfVxuICAgICAgaWYgKG51bWJlci0tIDw9IDApIHtcbiAgICAgICAgeWllbGQgdmFsXG4gICAgICB9XG4gICAgfVxuICB9LmNhbGwodGhpcylcbn1cbmZ1bmN0aW9uIHRha2UobnVtYmVyLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5KG51bWJlcilcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiB0YWtlKCkge1xuICAgIHZhciBfb3B0aW9ucyRzaWduYWw3XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX29wdGlvbnMkc2lnbmFsNyA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw3LmFib3J0ZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgICAgdmFyIF9vcHRpb25zJHNpZ25hbDhcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKF9vcHRpb25zJHNpZ25hbDggPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsOCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDguYWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKClcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXItLSA+IDApIHtcbiAgICAgICAgeWllbGQgdmFsXG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGdldCBhbm90aGVyIGl0ZW0gZnJvbSBpdGVyYXRvciBpbiBjYXNlIHdlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgaWYgKG51bWJlciA8PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5tb2R1bGUuZXhwb3J0cy5zdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMgPSB7XG4gIGFzSW5kZXhlZFBhaXJzOiBkZXByZWNhdGUoYXNJbmRleGVkUGFpcnMsICdyZWFkYWJsZS5hc0luZGV4ZWRQYWlycyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4nKSxcbiAgZHJvcCxcbiAgZmlsdGVyLFxuICBmbGF0TWFwLFxuICBtYXAsXG4gIHRha2UsXG4gIGNvbXBvc2Vcbn1cbm1vZHVsZS5leHBvcnRzLnByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnMgPSB7XG4gIGV2ZXJ5LFxuICBmb3JFYWNoLFxuICByZWR1Y2UsXG4gIHRvQXJyYXksXG4gIHNvbWUsXG4gIGZpbmRcbn1cbiJdLCJuYW1lcyI6WyJBYm9ydENvbnRyb2xsZXIiLCJnbG9iYWxUaGlzIiwicmVxdWlyZSIsImNvZGVzIiwiRVJSX0lOVkFMSURfQVJHX1ZBTFVFIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfTUlTU0lOR19BUkdTIiwiRVJSX09VVF9PRl9SQU5HRSIsIkFib3J0RXJyb3IiLCJ2YWxpZGF0ZUFib3J0U2lnbmFsIiwidmFsaWRhdGVJbnRlZ2VyIiwidmFsaWRhdGVPYmplY3QiLCJrV2Vha0hhbmRsZXIiLCJTeW1ib2wiLCJrUmVzaXN0U3RvcFByb3BhZ2F0aW9uIiwiZmluaXNoZWQiLCJzdGF0aWNDb21wb3NlIiwiYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlIiwiaXNXcml0YWJsZSIsImlzTm9kZVN0cmVhbSIsImRlcHJlY2F0ZSIsIkFycmF5UHJvdG90eXBlUHVzaCIsIkJvb2xlYW4iLCJNYXRoRmxvb3IiLCJOdW1iZXIiLCJOdW1iZXJJc05hTiIsIlByb21pc2UiLCJQcm9taXNlUmVqZWN0IiwiUHJvbWlzZVJlc29sdmUiLCJQcm9taXNlUHJvdG90eXBlVGhlbiIsImtFbXB0eSIsImtFb2YiLCJjb21wb3NlIiwic3RyZWFtIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsInNpZ25hbCIsImNvbXBvc2VkU3RyZWFtIiwibWFwIiwiZm4iLCJjb25jdXJyZW5jeSIsImhpZ2hXYXRlck1hcmsiLCJBYm9ydFNpZ25hbEFueSIsImZpbHRlciIsInF1ZXVlIiwic2lnbmFsT3B0IiwibmV4dCIsInJlc3VtZSIsImRvbmUiLCJjbnQiLCJvbkNhdGNoIiwiYWZ0ZXJJdGVtUHJvY2Vzc2VkIiwibWF5YmVSZXN1bWUiLCJsZW5ndGgiLCJwdW1wIiwidmFsIiwiYWJvcnRlZCIsImVyciIsInB1c2giLCJyZXNvbHZlIiwic2hpZnQiLCJjYWxsIiwiYXNJbmRleGVkUGFpcnMiLCJpbmRleCIsIl9vcHRpb25zJHNpZ25hbCIsImNhdXNlIiwicmVhc29uIiwic29tZSIsInVudXNlZCIsImV2ZXJ5IiwiYXJncyIsImZpbmQiLCJyZXN1bHQiLCJmb3JFYWNoIiwiZm9yRWFjaEZuIiwidmFsdWUiLCJmaWx0ZXJGbiIsIlJlZHVjZUF3YXJlRXJyTWlzc2luZ0FyZ3MiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJyZWR1Y2UiLCJyZWR1Y2VyIiwiaW5pdGlhbFZhbHVlIiwiX29wdGlvbnMkc2lnbmFsMiIsImhhc0luaXRpYWxWYWx1ZSIsImFyZ3VtZW50cyIsIm9uY2UiLCJkZXN0cm95IiwiYWMiLCJvcHRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0IiwiZ290QW55SXRlbUZyb21TdHJlYW0iLCJfb3B0aW9ucyRzaWduYWwzIiwidG9BcnJheSIsIl9vcHRpb25zJHNpZ25hbDQiLCJmbGF0TWFwIiwidmFsdWVzIiwidG9JbnRlZ2VyT3JJbmZpbml0eSIsIm51bWJlciIsImRyb3AiLCJfb3B0aW9ucyRzaWduYWw1IiwiX29wdGlvbnMkc2lnbmFsNiIsInRha2UiLCJfb3B0aW9ucyRzaWduYWw3IiwiX29wdGlvbnMkc2lnbmFsOCIsIm1vZHVsZSIsImV4cG9ydHMiLCJzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMiLCJwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/operators.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/passthrough.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/passthrough.js ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nconst { ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nmodule.exports = PassThrough;\nconst Transform = __webpack_require__(/*! ./transform */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/transform.js\");\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);\nObjectSetPrototypeOf(PassThrough, Transform);\nfunction PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n}\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9wYXNzdGhyb3VnaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBRXpDLHdCQUF3QjtBQUN4Qiw0REFBNEQ7QUFDNUQseUNBQXlDO0FBRXpDO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUN6Q0MsT0FBT0MsT0FBTyxHQUFHQztBQUNqQixNQUFNQyxZQUFZSixtQkFBT0EsQ0FBQztBQUMxQkQscUJBQXFCSSxZQUFZRSxTQUFTLEVBQUVELFVBQVVDLFNBQVM7QUFDL0ROLHFCQUFxQkksYUFBYUM7QUFDbEMsU0FBU0QsWUFBWUcsT0FBTztJQUMxQixJQUFJLENBQUUsS0FBSSxZQUFZSCxXQUFVLEdBQUksT0FBTyxJQUFJQSxZQUFZRztJQUMzREYsVUFBVUcsSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDdkI7QUFDQUgsWUFBWUUsU0FBUyxDQUFDRyxVQUFVLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDOURBLEdBQUcsTUFBTUY7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoLmpzPzNjN2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBPYmplY3RTZXRQcm90b3R5cGVPZiB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpXG5PYmplY3RTZXRQcm90b3R5cGVPZihQYXNzVGhyb3VnaC5wcm90b3R5cGUsIFRyYW5zZm9ybS5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpXG59XG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdFNldFByb3RvdHlwZU9mIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJQYXNzVGhyb3VnaCIsIlRyYW5zZm9ybSIsInByb3RvdHlwZSIsIm9wdGlvbnMiLCJjYWxsIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/passthrough.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\");\n\"use strict\";\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nconst { once } = __webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\nconst { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { validateFunction, validateAbortSignal } = __webpack_require__(/*! ../validators */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js\");\nconst { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = __webpack_require__(/*! ./utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController);\nlet PassThrough;\nlet Readable;\nlet addAbortListener;\nfunction destroyer(stream, reading, writing) {\n    let finished = false;\n    stream.on(\"close\", ()=>{\n        finished = true;\n    });\n    const cleanup = eos(stream, {\n        readable: reading,\n        writable: writing\n    }, (err)=>{\n        finished = !err;\n    });\n    return {\n        destroy: (err)=>{\n            if (finished) return;\n            finished = true;\n            destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup\n    };\n}\nfunction popCallback(streams) {\n    // Streams should never be an empty array. It should always contain at least\n    // a single stream. Therefore optimize for the average case instead of\n    // checking for length === 0 as well.\n    validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\");\n    return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n    if (isIterable(val)) {\n        return val;\n    } else if (isReadableNodeStream(val)) {\n        // Legacy streams are not Iterable.\n        return fromReadable(val);\n    }\n    throw new ERR_INVALID_ARG_TYPE(\"val\", [\n        \"Readable\",\n        \"Iterable\",\n        \"AsyncIterable\"\n    ], val);\n}\nasync function* fromReadable(val) {\n    if (!Readable) {\n        Readable = __webpack_require__(/*! ./readable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js\");\n    }\n    yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n    let error;\n    let onresolve = null;\n    const resume = (err)=>{\n        if (err) {\n            error = err;\n        }\n        if (onresolve) {\n            const callback = onresolve;\n            onresolve = null;\n            callback();\n        }\n    };\n    const wait = ()=>new Promise((resolve, reject)=>{\n            if (error) {\n                reject(error);\n            } else {\n                onresolve = ()=>{\n                    if (error) {\n                        reject(error);\n                    } else {\n                        resolve();\n                    }\n                };\n            }\n        });\n    writable.on(\"drain\", resume);\n    const cleanup = eos(writable, {\n        readable: false\n    }, resume);\n    try {\n        if (writable.writableNeedDrain) {\n            await wait();\n        }\n        for await (const chunk of iterable){\n            if (!writable.write(chunk)) {\n                await wait();\n            }\n        }\n        if (end) {\n            writable.end();\n            await wait();\n        }\n        finish();\n    } catch (err) {\n        finish(error !== err ? aggregateTwoErrors(error, err) : err);\n    } finally{\n        cleanup();\n        writable.off(\"drain\", resume);\n    }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n    if (isTransformStream(writable)) {\n        writable = writable.writable;\n    }\n    // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n    const writer = writable.getWriter();\n    try {\n        for await (const chunk of readable){\n            await writer.ready;\n            writer.write(chunk).catch(()=>{});\n        }\n        await writer.ready;\n        if (end) {\n            await writer.close();\n        }\n        finish();\n    } catch (err) {\n        try {\n            await writer.abort(err);\n            finish(err);\n        } catch (err) {\n            finish(err);\n        }\n    }\n}\nfunction pipeline(...streams) {\n    return pipelineImpl(streams, once(popCallback(streams)));\n}\nfunction pipelineImpl(streams, callback, opts) {\n    if (streams.length === 1 && ArrayIsArray(streams[0])) {\n        streams = streams[0];\n    }\n    if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n    }\n    const ac = new AbortController();\n    const signal = ac.signal;\n    const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n    // Need to cleanup event listeners if last stream is readable\n    // https://github.com/nodejs/node/issues/35452\n    const lastStreamCleanup = [];\n    validateAbortSignal(outerSignal, \"options.signal\");\n    function abort() {\n        finishImpl(new AbortError());\n    }\n    addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").addAbortListener);\n    let disposable;\n    if (outerSignal) {\n        disposable = addAbortListener(outerSignal, abort);\n    }\n    let error;\n    let value;\n    const destroys = [];\n    let finishCount = 0;\n    function finish(err) {\n        finishImpl(err, --finishCount === 0);\n    }\n    function finishImpl(err, final) {\n        var _disposable;\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\")) {\n            error = err;\n        }\n        if (!error && !final) {\n            return;\n        }\n        while(destroys.length){\n            destroys.shift()(error);\n        }\n        ;\n        (_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]();\n        ac.abort();\n        if (final) {\n            if (!error) {\n                lastStreamCleanup.forEach((fn)=>fn());\n            }\n            process.nextTick(callback, error, value);\n        }\n    }\n    let ret;\n    for(let i = 0; i < streams.length; i++){\n        const stream = streams[i];\n        const reading = i < streams.length - 1;\n        const writing = i > 0;\n        const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n        const isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n            if (end) {\n                const { destroy, cleanup } = destroyer(stream, reading, writing);\n                destroys.push(destroy);\n                if (isReadable(stream) && isLastStream) {\n                    lastStreamCleanup.push(cleanup);\n                }\n            }\n            // Catch stream errors that occur after pipe/pump has completed.\n            function onError(err) {\n                if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n                    finish(err);\n                }\n            }\n            stream.on(\"error\", onError);\n            if (isReadable(stream) && isLastStream) {\n                lastStreamCleanup.push(()=>{\n                    stream.removeListener(\"error\", onError);\n                });\n            }\n        }\n        if (i === 0) {\n            if (typeof stream === \"function\") {\n                ret = stream({\n                    signal\n                });\n                if (!isIterable(ret)) {\n                    throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n                }\n            } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n                ret = stream;\n            } else {\n                ret = Duplex.from(stream);\n            }\n        } else if (typeof stream === \"function\") {\n            if (isTransformStream(ret)) {\n                var _ret;\n                ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);\n            } else {\n                ret = makeAsyncIterable(ret);\n            }\n            ret = stream(ret, {\n                signal\n            });\n            if (reading) {\n                if (!isIterable(ret, true)) {\n                    throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n                }\n            } else {\n                var _ret2;\n                if (!PassThrough) {\n                    PassThrough = __webpack_require__(/*! ./passthrough */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/passthrough.js\");\n                }\n                // If the last argument to pipeline is not a stream\n                // we must create a proxy stream so that pipeline(...)\n                // always returns a stream which can be further\n                // composed through `.pipe(stream)`.\n                const pt = new PassThrough({\n                    objectMode: true\n                });\n                // Handle Promises/A+ spec, `then` could be a getter that throws on\n                // second use.\n                const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;\n                if (typeof then === \"function\") {\n                    finishCount++;\n                    then.call(ret, (val)=>{\n                        value = val;\n                        if (val != null) {\n                            pt.write(val);\n                        }\n                        if (end) {\n                            pt.end();\n                        }\n                        process.nextTick(finish);\n                    }, (err)=>{\n                        pt.destroy(err);\n                        process.nextTick(finish, err);\n                    });\n                } else if (isIterable(ret, true)) {\n                    finishCount++;\n                    pumpToNode(ret, pt, finish, {\n                        end\n                    });\n                } else if (isReadableStream(ret) || isTransformStream(ret)) {\n                    const toRead = ret.readable || ret;\n                    finishCount++;\n                    pumpToNode(toRead, pt, finish, {\n                        end\n                    });\n                } else {\n                    throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n                }\n                ret = pt;\n                const { destroy, cleanup } = destroyer(ret, false, true);\n                destroys.push(destroy);\n                if (isLastStream) {\n                    lastStreamCleanup.push(cleanup);\n                }\n            }\n        } else if (isNodeStream(stream)) {\n            if (isReadableNodeStream(ret)) {\n                finishCount += 2;\n                const cleanup = pipe(ret, stream, finish, {\n                    end\n                });\n                if (isReadable(stream) && isLastStream) {\n                    lastStreamCleanup.push(cleanup);\n                }\n            } else if (isTransformStream(ret) || isReadableStream(ret)) {\n                const toRead = ret.readable || ret;\n                finishCount++;\n                pumpToNode(toRead, stream, finish, {\n                    end\n                });\n            } else if (isIterable(ret)) {\n                finishCount++;\n                pumpToNode(ret, stream, finish, {\n                    end\n                });\n            } else {\n                throw new ERR_INVALID_ARG_TYPE(\"val\", [\n                    \"Readable\",\n                    \"Iterable\",\n                    \"AsyncIterable\",\n                    \"ReadableStream\",\n                    \"TransformStream\"\n                ], ret);\n            }\n            ret = stream;\n        } else if (isWebStream(stream)) {\n            if (isReadableNodeStream(ret)) {\n                finishCount++;\n                pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n                    end\n                });\n            } else if (isReadableStream(ret) || isIterable(ret)) {\n                finishCount++;\n                pumpToWeb(ret, stream, finish, {\n                    end\n                });\n            } else if (isTransformStream(ret)) {\n                finishCount++;\n                pumpToWeb(ret.readable, stream, finish, {\n                    end\n                });\n            } else {\n                throw new ERR_INVALID_ARG_TYPE(\"val\", [\n                    \"Readable\",\n                    \"Iterable\",\n                    \"AsyncIterable\",\n                    \"ReadableStream\",\n                    \"TransformStream\"\n                ], ret);\n            }\n            ret = stream;\n        } else {\n            ret = Duplex.from(stream);\n        }\n    }\n    if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {\n        process.nextTick(abort);\n    }\n    return ret;\n}\nfunction pipe(src, dst, finish, { end }) {\n    let ended = false;\n    dst.on(\"close\", ()=>{\n        if (!ended) {\n            // Finish if the destination closes before the source has completed.\n            finish(new ERR_STREAM_PREMATURE_CLOSE());\n        }\n    });\n    src.pipe(dst, {\n        end: false\n    }) // If end is true we already will have a listener to end dst.\n    ;\n    if (end) {\n        // Compat. Before node v10.12.0 stdio used to throw an error so\n        // pipe() did/does not end() stdio destinations.\n        // Now they allow it but \"secretly\" don't close the underlying fd.\n        function endFn() {\n            ended = true;\n            dst.end();\n        }\n        if (isReadableFinished(src)) {\n            // End the destination if the source has already ended.\n            process.nextTick(endFn);\n        } else {\n            src.once(\"end\", endFn);\n        }\n    } else {\n        finish();\n    }\n    eos(src, {\n        readable: true,\n        writable: false\n    }, (err)=>{\n        const rState = src._readableState;\n        if (err && err.code === \"ERR_STREAM_PREMATURE_CLOSE\" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {\n            // Some readable streams will emit 'close' before 'end'. However, since\n            // this is on the readable side 'end' should still be emitted if the\n            // stream has been ended and no error emitted. This should be allowed in\n            // favor of backwards compatibility. Since the stream is piped to a\n            // destination this should not result in any observable difference.\n            // We don't need to check if this is a writable premature close since\n            // eos will only fail with premature close on the reading side for\n            // duplex streams.\n            src.once(\"end\", finish).once(\"error\", finish);\n        } else {\n            finish(err);\n        }\n    });\n    return eos(dst, {\n        readable: false,\n        writable: true\n    }, finish);\n}\nmodule.exports = {\n    pipelineImpl,\n    pipeline\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsR0FFckIsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFNdEI7QUFDRixNQUFNLEVBQUVDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxtQkFBbUIsRUFBRUMsYUFBYSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzlFLE1BQU1LLE1BQU1MLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRU0sSUFBSSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1PLGNBQWNQLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1RLFNBQVNSLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFDSlMsa0JBQWtCLEVBQ2xCQyxPQUFPLEVBQ0xDLG9CQUFvQixFQUNwQkMsd0JBQXdCLEVBQ3hCQyxnQkFBZ0IsRUFDaEJDLG9CQUFvQixFQUNwQkMsMEJBQTBCLEVBQzNCLEVBQ0RDLFVBQVUsRUFDWCxHQUFHaEIsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVpQixnQkFBZ0IsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR2xCLG1CQUFPQSxDQUFDO0FBQzFELE1BQU0sRUFDSm1CLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxvQkFBb0IsRUFDcEJDLFlBQVksRUFDWkMsaUJBQWlCLEVBQ2pCQyxXQUFXLEVBQ1hDLGdCQUFnQixFQUNoQkMsa0JBQWtCLEVBQ25CLEdBQUcxQixtQkFBT0EsQ0FBQztBQUNaLE1BQU0yQixrQkFBa0JDLFdBQVdELGVBQWUsSUFBSTNCLGdJQUEyQztBQUNqRyxJQUFJNkI7QUFDSixJQUFJQztBQUNKLElBQUlDO0FBQ0osU0FBU0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDekMsSUFBSUMsV0FBVztJQUNmSCxPQUFP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Mkc7UUFDbEI7SUFDRixPQUFPO1FBQ0wzRDtJQUNGO0lBQ0FqRCxJQUNFeUcsS0FDQTtRQUNFdkUsVUFBVTtRQUNWQyxVQUFVO0lBQ1osR0FDQSxDQUFDQztRQUNDLE1BQU15RSxTQUFTSixJQUFJSyxjQUFjO1FBQ2pDLElBQ0UxRSxPQUNBQSxJQUFJZ0QsSUFBSSxLQUFLLGdDQUNieUIsVUFDQUEsT0FBT0YsS0FBSyxJQUNaLENBQUNFLE9BQU9FLE9BQU8sSUFDZixDQUFDRixPQUFPRyxZQUFZLEVBQ3BCO1lBQ0EsdUVBQXVFO1lBQ3ZFLG9FQUFvRTtZQUNwRSx3RUFBd0U7WUFDeEUsbUVBQW1FO1lBQ25FLG1FQUFtRTtZQUNuRSxxRUFBcUU7WUFDckUsa0VBQWtFO1lBQ2xFLGtCQUFrQjtZQUNsQlAsSUFBSXhHLElBQUksQ0FBQyxPQUFPZ0QsUUFBUWhELElBQUksQ0FBQyxTQUFTZ0Q7UUFDeEMsT0FBTztZQUNMQSxPQUFPYjtRQUNUO0lBQ0Y7SUFFRixPQUFPcEMsSUFDTDBHLEtBQ0E7UUFDRXhFLFVBQVU7UUFDVkMsVUFBVTtJQUNaLEdBQ0FjO0FBRUo7QUFDQWdFLE9BQU9DLE9BQU8sR0FBRztJQUNmNUM7SUFDQUQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzPzBmZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG4vLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3QgeyBBcnJheUlzQXJyYXksIFByb21pc2UsIFN5bWJvbEFzeW5jSXRlcmF0b3IsIFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IHsgb25jZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJylcbmNvbnN0IGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IHtcbiAgYWdncmVnYXRlVHdvRXJyb3JzLFxuICBjb2Rlczoge1xuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXG4gIH0sXG4gIEFib3J0RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IHZhbGlkYXRlRnVuY3Rpb24sIHZhbGlkYXRlQWJvcnRTaWduYWwgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3Qge1xuICBpc0l0ZXJhYmxlLFxuICBpc1JlYWRhYmxlLFxuICBpc1JlYWRhYmxlTm9kZVN0cmVhbSxcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1RyYW5zZm9ybVN0cmVhbSxcbiAgaXNXZWJTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVGaW5pc2hlZFxufSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgfHwgcmVxdWlyZSgnYWJvcnQtY29udHJvbGxlcicpLkFib3J0Q29udHJvbGxlclxubGV0IFBhc3NUaHJvdWdoXG5sZXQgUmVhZGFibGVcbmxldCBhZGRBYm9ydExpc3RlbmVyXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nKSB7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlXG4gIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgZmluaXNoZWQgPSB0cnVlXG4gIH0pXG4gIGNvbnN0IGNsZWFudXAgPSBlb3MoXG4gICAgc3RyZWFtLFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIGZpbmlzaGVkID0gIWVyclxuICAgIH1cbiAgKVxuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IChlcnIpID0+IHtcbiAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuXG4gICAgICBmaW5pc2hlZCA9IHRydWVcbiAgICAgIGRlc3Ryb3lJbXBsLmRlc3Ryb3llcihzdHJlYW0sIGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSlcbiAgICB9LFxuICAgIGNsZWFudXBcbiAgfVxufVxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICAvLyBTdHJlYW1zIHNob3VsZCBuZXZlciBiZSBhbiBlbXB0eSBhcnJheS4gSXQgc2hvdWxkIGFsd2F5cyBjb250YWluIGF0IGxlYXN0XG4gIC8vIGEgc2luZ2xlIHN0cmVhbS4gVGhlcmVmb3JlIG9wdGltaXplIGZvciB0aGUgYXZlcmFnZSBjYXNlIGluc3RlYWQgb2ZcbiAgLy8gY2hlY2tpbmcgZm9yIGxlbmd0aCA9PT0gMCBhcyB3ZWxsLlxuICB2YWxpZGF0ZUZ1bmN0aW9uKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSwgJ3N0cmVhbXNbc3RyZWFtLmxlbmd0aCAtIDFdJylcbiAgcmV0dXJuIHN0cmVhbXMucG9wKClcbn1cbmZ1bmN0aW9uIG1ha2VBc3luY0l0ZXJhYmxlKHZhbCkge1xuICBpZiAoaXNJdGVyYWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbFxuICB9IGVsc2UgaWYgKGlzUmVhZGFibGVOb2RlU3RyZWFtKHZhbCkpIHtcbiAgICAvLyBMZWdhY3kgc3RyZWFtcyBhcmUgbm90IEl0ZXJhYmxlLlxuICAgIHJldHVybiBmcm9tUmVhZGFibGUodmFsKVxuICB9XG4gIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgndmFsJywgWydSZWFkYWJsZScsICdJdGVyYWJsZScsICdBc3luY0l0ZXJhYmxlJ10sIHZhbClcbn1cbmFzeW5jIGZ1bmN0aW9uKiBmcm9tUmVhZGFibGUodmFsKSB7XG4gIGlmICghUmVhZGFibGUpIHtcbiAgICBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuICB9XG4gIHlpZWxkKiBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sQXN5bmNJdGVyYXRvcl0uY2FsbCh2YWwpXG59XG5hc3luYyBmdW5jdGlvbiBwdW1wVG9Ob2RlKGl0ZXJhYmxlLCB3cml0YWJsZSwgZmluaXNoLCB7IGVuZCB9KSB7XG4gIGxldCBlcnJvclxuICBsZXQgb25yZXNvbHZlID0gbnVsbFxuICBjb25zdCByZXN1bWUgPSAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG4gICAgaWYgKG9ucmVzb2x2ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBvbnJlc29sdmVcbiAgICAgIG9ucmVzb2x2ZSA9IG51bGxcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cbiAgY29uc3Qgd2FpdCA9ICgpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ucmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgd3JpdGFibGUub24oJ2RyYWluJywgcmVzdW1lKVxuICBjb25zdCBjbGVhbnVwID0gZW9zKFxuICAgIHdyaXRhYmxlLFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgcmVzdW1lXG4gIClcbiAgdHJ5IHtcbiAgICBpZiAod3JpdGFibGUud3JpdGFibGVOZWVkRHJhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQoKVxuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhYmxlKSB7XG4gICAgICBpZiAoIXdyaXRhYmxlLndyaXRlKGNodW5rKSkge1xuICAgICAgICBhd2FpdCB3YWl0KClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgd3JpdGFibGUuZW5kKClcbiAgICAgIGF3YWl0IHdhaXQoKVxuICAgIH1cbiAgICBmaW5pc2goKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBmaW5pc2goZXJyb3IgIT09IGVyciA/IGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlcnJvciwgZXJyKSA6IGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhbnVwKClcbiAgICB3cml0YWJsZS5vZmYoJ2RyYWluJywgcmVzdW1lKVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwdW1wVG9XZWIocmVhZGFibGUsIHdyaXRhYmxlLCBmaW5pc2gsIHsgZW5kIH0pIHtcbiAgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHdyaXRhYmxlKSkge1xuICAgIHdyaXRhYmxlID0gd3JpdGFibGUud3JpdGFibGVcbiAgfVxuICAvLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNleGFtcGxlLW1hbnVhbC13cml0ZS13aXRoLWJhY2twcmVzc3VyZVxuICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKVxuICB0cnkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZGFibGUpIHtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeVxuICAgICAgd3JpdGVyLndyaXRlKGNodW5rKS5jYXRjaCgoKSA9PiB7fSlcbiAgICB9XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5XG4gICAgaWYgKGVuZCkge1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKClcbiAgICB9XG4gICAgZmluaXNoKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdyaXRlci5hYm9ydChlcnIpXG4gICAgICBmaW5pc2goZXJyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZmluaXNoKGVycilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBpcGVsaW5lKC4uLnN0cmVhbXMpIHtcbiAgcmV0dXJuIHBpcGVsaW5lSW1wbChzdHJlYW1zLCBvbmNlKHBvcENhbGxiYWNrKHN0cmVhbXMpKSlcbn1cbmZ1bmN0aW9uIHBpcGVsaW5lSW1wbChzdHJlYW1zLCBjYWxsYmFjaywgb3B0cykge1xuICBpZiAoc3RyZWFtcy5sZW5ndGggPT09IDEgJiYgQXJyYXlJc0FycmF5KHN0cmVhbXNbMF0pKSB7XG4gICAgc3RyZWFtcyA9IHN0cmVhbXNbMF1cbiAgfVxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKVxuICB9XG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIGNvbnN0IHNpZ25hbCA9IGFjLnNpZ25hbFxuICBjb25zdCBvdXRlclNpZ25hbCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0cy5zaWduYWxcblxuICAvLyBOZWVkIHRvIGNsZWFudXAgZXZlbnQgbGlzdGVuZXJzIGlmIGxhc3Qgc3RyZWFtIGlzIHJlYWRhYmxlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU0NTJcbiAgY29uc3QgbGFzdFN0cmVhbUNsZWFudXAgPSBbXVxuICB2YWxpZGF0ZUFib3J0U2lnbmFsKG91dGVyU2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBmaW5pc2hJbXBsKG5ldyBBYm9ydEVycm9yKCkpXG4gIH1cbiAgYWRkQWJvcnRMaXN0ZW5lciA9IGFkZEFib3J0TGlzdGVuZXIgfHwgcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuYWRkQWJvcnRMaXN0ZW5lclxuICBsZXQgZGlzcG9zYWJsZVxuICBpZiAob3V0ZXJTaWduYWwpIHtcbiAgICBkaXNwb3NhYmxlID0gYWRkQWJvcnRMaXN0ZW5lcihvdXRlclNpZ25hbCwgYWJvcnQpXG4gIH1cbiAgbGV0IGVycm9yXG4gIGxldCB2YWx1ZVxuICBjb25zdCBkZXN0cm95cyA9IFtdXG4gIGxldCBmaW5pc2hDb3VudCA9IDBcbiAgZnVuY3Rpb24gZmluaXNoKGVycikge1xuICAgIGZpbmlzaEltcGwoZXJyLCAtLWZpbmlzaENvdW50ID09PSAwKVxuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaEltcGwoZXJyLCBmaW5hbCkge1xuICAgIHZhciBfZGlzcG9zYWJsZVxuICAgIGlmIChlcnIgJiYgKCFlcnJvciB8fCBlcnJvci5jb2RlID09PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSkge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG4gICAgaWYgKCFlcnJvciAmJiAhZmluYWwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB3aGlsZSAoZGVzdHJveXMubGVuZ3RoKSB7XG4gICAgICBkZXN0cm95cy5zaGlmdCgpKGVycm9yKVxuICAgIH1cbiAgICA7KF9kaXNwb3NhYmxlID0gZGlzcG9zYWJsZSkgPT09IG51bGwgfHwgX2Rpc3Bvc2FibGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9kaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKClcbiAgICBhYy5hYm9ydCgpXG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIGxhc3RTdHJlYW1DbGVhbnVwLmZvckVhY2goKGZuKSA9PiBmbigpKVxuICAgICAgfVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKVxuICAgIH1cbiAgfVxuICBsZXQgcmV0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN0cmVhbSA9IHN0cmVhbXNbaV1cbiAgICBjb25zdCByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIGNvbnN0IHdyaXRpbmcgPSBpID4gMFxuICAgIGNvbnN0IGVuZCA9IHJlYWRpbmcgfHwgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0cy5lbmQpICE9PSBmYWxzZVxuICAgIGNvbnN0IGlzTGFzdFN0cmVhbSA9IGkgPT09IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIGlmIChpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBjb25zdCB7IGRlc3Ryb3ksIGNsZWFudXAgfSA9IGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcpXG4gICAgICAgIGRlc3Ryb3lzLnB1c2goZGVzdHJveSlcbiAgICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSAmJiBpc0xhc3RTdHJlYW0pIHtcbiAgICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5wdXNoKGNsZWFudXApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2F0Y2ggc3RyZWFtIGVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIHBpcGUvcHVtcCBoYXMgY29tcGxldGVkLlxuICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIubmFtZSAhPT0gJ0Fib3J0RXJyb3InICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICAgICAgZmluaXNoKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pICYmIGlzTGFzdFN0cmVhbSkge1xuICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5wdXNoKCgpID0+IHtcbiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldCA9IHN0cmVhbSh7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pXG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnSXRlcmFibGUsIEFzeW5jSXRlcmFibGUgb3IgU3RyZWFtJywgJ3NvdXJjZScsIHJldClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKHN0cmVhbSkgfHwgaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShzdHJlYW0pKSB7XG4gICAgICAgIHJldCA9IHN0cmVhbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gRHVwbGV4LmZyb20oc3RyZWFtKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHJldCkpIHtcbiAgICAgICAgdmFyIF9yZXRcbiAgICAgICAgcmV0ID0gbWFrZUFzeW5jSXRlcmFibGUoKF9yZXQgPSByZXQpID09PSBudWxsIHx8IF9yZXQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9yZXQucmVhZGFibGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBtYWtlQXN5bmNJdGVyYWJsZShyZXQpXG4gICAgICB9XG4gICAgICByZXQgPSBzdHJlYW0ocmV0LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSlcbiAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXQsIHRydWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnQXN5bmNJdGVyYWJsZScsIGB0cmFuc2Zvcm1bJHtpIC0gMX1dYCwgcmV0KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JldDJcbiAgICAgICAgaWYgKCFQYXNzVGhyb3VnaCkge1xuICAgICAgICAgIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9wYXNzdGhyb3VnaCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbGFzdCBhcmd1bWVudCB0byBwaXBlbGluZSBpcyBub3QgYSBzdHJlYW1cbiAgICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgYSBwcm94eSBzdHJlYW0gc28gdGhhdCBwaXBlbGluZSguLi4pXG4gICAgICAgIC8vIGFsd2F5cyByZXR1cm5zIGEgc3RyZWFtIHdoaWNoIGNhbiBiZSBmdXJ0aGVyXG4gICAgICAgIC8vIGNvbXBvc2VkIHRocm91Z2ggYC5waXBlKHN0cmVhbSlgLlxuXG4gICAgICAgIGNvbnN0IHB0ID0gbmV3IFBhc3NUaHJvdWdoKHtcbiAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gSGFuZGxlIFByb21pc2VzL0ErIHNwZWMsIGB0aGVuYCBjb3VsZCBiZSBhIGdldHRlciB0aGF0IHRocm93cyBvblxuICAgICAgICAvLyBzZWNvbmQgdXNlLlxuICAgICAgICBjb25zdCB0aGVuID0gKF9yZXQyID0gcmV0KSA9PT0gbnVsbCB8fCBfcmV0MiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3JldDIudGhlblxuICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgKHZhbCkgPT4ge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbFxuICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdC53cml0ZSh2YWwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIHB0LmVuZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2gpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwdC5kZXN0cm95KGVycilcbiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2gsIGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShyZXQsIHRydWUpKSB7XG4gICAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICAgIHB1bXBUb05vZGUocmV0LCBwdCwgZmluaXNoLCB7XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKGlzUmVhZGFibGVTdHJlYW0ocmV0KSB8fCBpc1RyYW5zZm9ybVN0cmVhbShyZXQpKSB7XG4gICAgICAgICAgY29uc3QgdG9SZWFkID0gcmV0LnJlYWRhYmxlIHx8IHJldFxuICAgICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgICBwdW1wVG9Ob2RlKHRvUmVhZCwgcHQsIGZpbmlzaCwge1xuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdBc3luY0l0ZXJhYmxlIG9yIFByb21pc2UnLCAnZGVzdGluYXRpb24nLCByZXQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gcHRcbiAgICAgICAgY29uc3QgeyBkZXN0cm95LCBjbGVhbnVwIH0gPSBkZXN0cm95ZXIocmV0LCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgZGVzdHJveXMucHVzaChkZXN0cm95KVxuICAgICAgICBpZiAoaXNMYXN0U3RyZWFtKSB7XG4gICAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAucHVzaChjbGVhbnVwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgICAgaWYgKGlzUmVhZGFibGVOb2RlU3RyZWFtKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQgKz0gMlxuICAgICAgICBjb25zdCBjbGVhbnVwID0gcGlwZShyZXQsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkgJiYgaXNMYXN0U3RyZWFtKSB7XG4gICAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAucHVzaChjbGVhbnVwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHJldCkgfHwgaXNSZWFkYWJsZVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGNvbnN0IHRvUmVhZCA9IHJldC5yZWFkYWJsZSB8fCByZXRcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9Ob2RlKHRvUmVhZCwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvTm9kZShyZXQsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICAgICAgJ3ZhbCcsXG4gICAgICAgICAgWydSZWFkYWJsZScsICdJdGVyYWJsZScsICdBc3luY0l0ZXJhYmxlJywgJ1JlYWRhYmxlU3RyZWFtJywgJ1RyYW5zZm9ybVN0cmVhbSddLFxuICAgICAgICAgIHJldFxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXQgPSBzdHJlYW1cbiAgICB9IGVsc2UgaWYgKGlzV2ViU3RyZWFtKHN0cmVhbSkpIHtcbiAgICAgIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvV2ViKG1ha2VBc3luY0l0ZXJhYmxlKHJldCksIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZGFibGVTdHJlYW0ocmV0KSB8fCBpc0l0ZXJhYmxlKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9XZWIocmV0LCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChpc1RyYW5zZm9ybVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvV2ViKHJldC5yZWFkYWJsZSwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICAndmFsJyxcbiAgICAgICAgICBbJ1JlYWRhYmxlJywgJ0l0ZXJhYmxlJywgJ0FzeW5jSXRlcmFibGUnLCAnUmVhZGFibGVTdHJlYW0nLCAnVHJhbnNmb3JtU3RyZWFtJ10sXG4gICAgICAgICAgcmV0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldCA9IHN0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSBEdXBsZXguZnJvbShzdHJlYW0pXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICAoc2lnbmFsICE9PSBudWxsICYmIHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmIHNpZ25hbC5hYm9ydGVkKSB8fFxuICAgIChvdXRlclNpZ25hbCAhPT0gbnVsbCAmJiBvdXRlclNpZ25hbCAhPT0gdW5kZWZpbmVkICYmIG91dGVyU2lnbmFsLmFib3J0ZWQpXG4gICkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soYWJvcnQpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gcGlwZShzcmMsIGRzdCwgZmluaXNoLCB7IGVuZCB9KSB7XG4gIGxldCBlbmRlZCA9IGZhbHNlXG4gIGRzdC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgaWYgKCFlbmRlZCkge1xuICAgICAgLy8gRmluaXNoIGlmIHRoZSBkZXN0aW5hdGlvbiBjbG9zZXMgYmVmb3JlIHRoZSBzb3VyY2UgaGFzIGNvbXBsZXRlZC5cbiAgICAgIGZpbmlzaChuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKSlcbiAgICB9XG4gIH0pXG4gIHNyYy5waXBlKGRzdCwge1xuICAgIGVuZDogZmFsc2VcbiAgfSkgLy8gSWYgZW5kIGlzIHRydWUgd2UgYWxyZWFkeSB3aWxsIGhhdmUgYSBsaXN0ZW5lciB0byBlbmQgZHN0LlxuXG4gIGlmIChlbmQpIHtcbiAgICAvLyBDb21wYXQuIEJlZm9yZSBub2RlIHYxMC4xMi4wIHN0ZGlvIHVzZWQgdG8gdGhyb3cgYW4gZXJyb3Igc29cbiAgICAvLyBwaXBlKCkgZGlkL2RvZXMgbm90IGVuZCgpIHN0ZGlvIGRlc3RpbmF0aW9ucy5cbiAgICAvLyBOb3cgdGhleSBhbGxvdyBpdCBidXQgXCJzZWNyZXRseVwiIGRvbid0IGNsb3NlIHRoZSB1bmRlcmx5aW5nIGZkLlxuXG4gICAgZnVuY3Rpb24gZW5kRm4oKSB7XG4gICAgICBlbmRlZCA9IHRydWVcbiAgICAgIGRzdC5lbmQoKVxuICAgIH1cbiAgICBpZiAoaXNSZWFkYWJsZUZpbmlzaGVkKHNyYykpIHtcbiAgICAgIC8vIEVuZCB0aGUgZGVzdGluYXRpb24gaWYgdGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBlbmRlZC5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoKClcbiAgfVxuICBlb3MoXG4gICAgc3JjLFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBjb25zdCByU3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmIChcbiAgICAgICAgZXJyICYmXG4gICAgICAgIGVyci5jb2RlID09PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnICYmXG4gICAgICAgIHJTdGF0ZSAmJlxuICAgICAgICByU3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIXJTdGF0ZS5lcnJvcmVkICYmXG4gICAgICAgICFyU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgLy8gU29tZSByZWFkYWJsZSBzdHJlYW1zIHdpbGwgZW1pdCAnY2xvc2UnIGJlZm9yZSAnZW5kJy4gSG93ZXZlciwgc2luY2VcbiAgICAgICAgLy8gdGhpcyBpcyBvbiB0aGUgcmVhZGFibGUgc2lkZSAnZW5kJyBzaG91bGQgc3RpbGwgYmUgZW1pdHRlZCBpZiB0aGVcbiAgICAgICAgLy8gc3RyZWFtIGhhcyBiZWVuIGVuZGVkIGFuZCBubyBlcnJvciBlbWl0dGVkLiBUaGlzIHNob3VsZCBiZSBhbGxvd2VkIGluXG4gICAgICAgIC8vIGZhdm9yIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBTaW5jZSB0aGUgc3RyZWFtIGlzIHBpcGVkIHRvIGFcbiAgICAgICAgLy8gZGVzdGluYXRpb24gdGhpcyBzaG91bGQgbm90IHJlc3VsdCBpbiBhbnkgb2JzZXJ2YWJsZSBkaWZmZXJlbmNlLlxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGlmIHRoaXMgaXMgYSB3cml0YWJsZSBwcmVtYXR1cmUgY2xvc2Ugc2luY2VcbiAgICAgICAgLy8gZW9zIHdpbGwgb25seSBmYWlsIHdpdGggcHJlbWF0dXJlIGNsb3NlIG9uIHRoZSByZWFkaW5nIHNpZGUgZm9yXG4gICAgICAgIC8vIGR1cGxleCBzdHJlYW1zLlxuICAgICAgICBzcmMub25jZSgnZW5kJywgZmluaXNoKS5vbmNlKCdlcnJvcicsIGZpbmlzaClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaChlcnIpXG4gICAgICB9XG4gICAgfVxuICApXG4gIHJldHVybiBlb3MoXG4gICAgZHN0LFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBmaW5pc2hcbiAgKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBpcGVsaW5lSW1wbCxcbiAgcGlwZWxpbmVcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwicmVxdWlyZSIsIkFycmF5SXNBcnJheSIsIlByb21pc2UiLCJTeW1ib2xBc3luY0l0ZXJhdG9yIiwiU3ltYm9sRGlzcG9zZSIsImVvcyIsIm9uY2UiLCJkZXN0cm95SW1wbCIsIkR1cGxleCIsImFnZ3JlZ2F0ZVR3b0Vycm9ycyIsImNvZGVzIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUiLCJFUlJfTUlTU0lOR19BUkdTIiwiRVJSX1NUUkVBTV9ERVNUUk9ZRUQiLCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSIsIkFib3J0RXJyb3IiLCJ2YWxpZGF0ZUZ1bmN0aW9uIiwidmFsaWRhdGVBYm9ydFNpZ25hbCIsImlzSXRlcmFibGUiLCJpc1JlYWRhYmxlIiwiaXNSZWFkYWJsZU5vZGVTdHJlYW0iLCJpc05vZGVTdHJlYW0iLCJpc1RyYW5zZm9ybVN0cmVhbSIsImlzV2ViU3RyZWFtIiwiaXNSZWFkYWJsZVN0cmVhbSIsImlzUmVhZGFibGVGaW5pc2hlZCIsIkFib3J0Q29udHJvbGxlciIsImdsb2JhbFRoaXMiLCJQYXNzVGhyb3VnaCIsIlJlYWRhYmxlIiwiYWRkQWJvcnRMaXN0ZW5lciIsImRlc3Ryb3llciIsInN0cmVhbSIsInJlYWRpbmciLCJ3cml0aW5nIiwiZmluaXNoZWQiLCJvbiIsImNsZWFudXAiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiZXJyIiwiZGVzdHJveSIsInBvcENhbGxiYWNrIiwic3RyZWFtcyIsImxlbmd0aCIsInBvcCIsIm1ha2VBc3luY0l0ZXJhYmxlIiwidmFsIiwiZnJvbVJlYWRhYmxlIiwicHJvdG90eXBlIiwiY2FsbCIsInB1bXBUb05vZGUiLCJpdGVyYWJsZSIsImZpbmlzaCIsImVuZCIsImVycm9yIiwib25yZXNvbHZlIiwicmVzdW1lIiwiY2FsbGJhY2siLCJ3YWl0IiwicmVzb2x2ZSIsInJlamVjdCIsIndyaXRhYmxlTmVlZERyYWluIiwiY2h1bmsiLCJ3cml0ZSIsIm9mZiIsInB1bXBUb1dlYiIsIndyaXRlciIsImdldFdyaXRlciIsInJlYWR5IiwiY2F0Y2giLCJjbG9zZSIsImFib3J0IiwicGlwZWxpbmUiLCJwaXBlbGluZUltcGwiLCJvcHRzIiwiYWMiLCJzaWduYWwiLCJvdXRlclNpZ25hbCIsInVuZGVmaW5lZCIsImxhc3RTdHJlYW1DbGVhbnVwIiwiZmluaXNoSW1wbCIsImRpc3Bvc2FibGUiLCJ2YWx1ZSIsImRlc3Ryb3lzIiwiZmluaXNoQ291bnQiLCJmaW5hbCIsIl9kaXNwb3NhYmxlIiwiY29kZSIsInNoaWZ0IiwiZm9yRWFjaCIsImZuIiwibmV4dFRpY2siLCJyZXQiLCJpIiwiaXNMYXN0U3RyZWFtIiwicHVzaCIsIm9uRXJyb3IiLCJuYW1lIiwicmVtb3ZlTGlzdGVuZXIiLCJmcm9tIiwiX3JldCIsIl9yZXQyIiwicHQiLCJvYmplY3RNb2RlIiwidGhlbiIsInRvUmVhZCIsInBpcGUiLCJhYm9ydGVkIiwic3JjIiwiZHN0IiwiZW5kZWQiLCJlbmRGbiIsInJTdGF0ZSIsIl9yZWFkYWJsZVN0YXRlIiwiZXJyb3JlZCIsImVycm9yRW1pdHRlZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/pipeline.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\");\n\"use strict\";\nconst { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\");\nconst { Stream, prependListener } = __webpack_require__(/*! ./legacy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/legacy.js\");\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\");\nconst eos = __webpack_require__(/*! ./end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nlet debug = (__webpack_require__(/*! ../../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").debuglog)(\"stream\", (fn)=>{\n    debug = fn;\n});\nconst BufferList = __webpack_require__(/*! ./buffer_list */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nconst { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js\");\nconst { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError } = __webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { validateObject } = __webpack_require__(/*! ../validators */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js\");\nconst kPaused = Symbol(\"kPaused\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst from = __webpack_require__(/*! ./from */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/from.js\");\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Readable, Stream);\nconst nop = ()=>{};\nconst { errorOrDestroy } = destroyImpl;\nconst kObjectMode = 1 << 0;\nconst kEnded = 1 << 1;\nconst kEndEmitted = 1 << 2;\nconst kReading = 1 << 3;\nconst kConstructed = 1 << 4;\nconst kSync = 1 << 5;\nconst kNeedReadable = 1 << 6;\nconst kEmittedReadable = 1 << 7;\nconst kReadableListening = 1 << 8;\nconst kResumeScheduled = 1 << 9;\nconst kErrorEmitted = 1 << 10;\nconst kEmitClose = 1 << 11;\nconst kAutoDestroy = 1 << 12;\nconst kDestroyed = 1 << 13;\nconst kClosed = 1 << 14;\nconst kCloseEmitted = 1 << 15;\nconst kMultiAwaitDrain = 1 << 16;\nconst kReadingMore = 1 << 17;\nconst kDataEmitted = 1 << 18;\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n    return {\n        enumerable: false,\n        get () {\n            return (this.state & bit) !== 0;\n        },\n        set (value) {\n            if (value) this.state |= bit;\n            else this.state &= ~bit;\n        }\n    };\n}\nObjectDefineProperties(ReadableState.prototype, {\n    objectMode: makeBitMapDescriptor(kObjectMode),\n    ended: makeBitMapDescriptor(kEnded),\n    endEmitted: makeBitMapDescriptor(kEndEmitted),\n    reading: makeBitMapDescriptor(kReading),\n    // Stream is still being constructed and cannot be\n    // destroyed until construction finished or failed.\n    // Async construction is opt in, therefore we start as\n    // constructed.\n    constructed: makeBitMapDescriptor(kConstructed),\n    // A flag to be able to tell if the event 'readable'/'data' is emitted\n    // immediately, or on a later tick.  We set this to true at first, because\n    // any actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first read call.\n    sync: makeBitMapDescriptor(kSync),\n    // Whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    needReadable: makeBitMapDescriptor(kNeedReadable),\n    emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n    readableListening: makeBitMapDescriptor(kReadableListening),\n    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n    // True if the error was already emitted and should not be thrown again.\n    errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n    emitClose: makeBitMapDescriptor(kEmitClose),\n    autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n    // Has it been destroyed.\n    destroyed: makeBitMapDescriptor(kDestroyed),\n    // Indicates whether the stream has finished destroying.\n    closed: makeBitMapDescriptor(kClosed),\n    // True if close has been emitted or would have been emitted\n    // depending on emitClose.\n    closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n    // If true, a maybeReadMore has been scheduled.\n    readingMore: makeBitMapDescriptor(kReadingMore),\n    dataEmitted: makeBitMapDescriptor(kDataEmitted)\n});\nfunction ReadableState(options, stream, isDuplex) {\n    // Duplex streams are both readable and writable, but share\n    // the same options object.\n    // However, some cases require setting options to different\n    // values for the readable and the writable sides of the duplex stream.\n    // These options can be provided separately as readableXXX and writableXXX.\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\n    // Bit map field to store ReadableState more effciently with 1 bit per field\n    // instead of a V8 slot per field.\n    this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;\n    // Object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away.\n    if (options && options.objectMode) this.state |= kObjectMode;\n    if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;\n    // The point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    this.highWaterMark = options ? getHighWaterMark(this, options, \"readableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(false);\n    // A linked list is used to store data chunks instead of an array because the\n    // linked list can remove elements from the beginning faster than\n    // array.shift().\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = [];\n    this.flowing = null;\n    this[kPaused] = null;\n    // Should close be emitted on destroy. Defaults to true.\n    if (options && options.emitClose === false) this.state &= ~kEmitClose;\n    // Should .destroy() be called after 'end' (and potentially 'finish').\n    if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;\n    // Indicates whether the stream has errored. When true no further\n    // _read calls, 'data' or 'readable' events should occur. This is needed\n    // since when autoDestroy is disabled we need a way to tell whether the\n    // stream has failed.\n    this.errored = null;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options && options.defaultEncoding || \"utf8\";\n    // Ref the piped dest which we need a drain event on it\n    // type: null | Writable | Set<Writable>.\n    this.awaitDrainWriters = null;\n    this.decoder = null;\n    this.encoding = null;\n    if (options && options.encoding) {\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\nfunction Readable(options) {\n    if (!(this instanceof Readable)) return new Readable(options);\n    // Checking for a Stream.Duplex instance is faster here instead of inside\n    // the ReadableState constructor, at least with V8 6.5.\n    const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\n    this._readableState = new ReadableState(options, this, isDuplex);\n    if (options) {\n        if (typeof options.read === \"function\") this._read = options.read;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.construct === \"function\") this._construct = options.construct;\n        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);\n    }\n    Stream.call(this, options);\n    destroyImpl.construct(this, ()=>{\n        if (this._readableState.needReadable) {\n            maybeReadMore(this, this._readableState);\n        }\n    });\n}\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err, cb) {\n    cb(err);\n};\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n    this.destroy(err);\n};\nReadable.prototype[SymbolAsyncDispose] = function() {\n    let error;\n    if (!this.destroyed) {\n        error = this.readableEnded ? null : new AbortError();\n        this.destroy(error);\n    }\n    return new Promise((resolve, reject)=>eos(this, (err)=>err && err !== error ? reject(err) : resolve(null)));\n};\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n    return readableAddChunk(this, chunk, encoding, false);\n};\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk, encoding) {\n    return readableAddChunk(this, chunk, encoding, true);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n    debug(\"readableAddChunk\", chunk);\n    const state = stream._readableState;\n    let err;\n    if ((state.state & kObjectMode) === 0) {\n        if (typeof chunk === \"string\") {\n            encoding = encoding || state.defaultEncoding;\n            if (state.encoding !== encoding) {\n                if (addToFront && state.encoding) {\n                    // When unshifting, if state.encoding is set, we have to save\n                    // the string in the BufferList with the state encoding.\n                    chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n                } else {\n                    chunk = Buffer.from(chunk, encoding);\n                    encoding = \"\";\n                }\n            }\n        } else if (chunk instanceof Buffer) {\n            encoding = \"\";\n        } else if (Stream._isUint8Array(chunk)) {\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n            encoding = \"\";\n        } else if (chunk != null) {\n            err = new ERR_INVALID_ARG_TYPE(\"chunk\", [\n                \"string\",\n                \"Buffer\",\n                \"Uint8Array\"\n            ], chunk);\n        }\n    }\n    if (err) {\n        errorOrDestroy(stream, err);\n    } else if (chunk === null) {\n        state.state &= ~kReading;\n        onEofChunk(stream, state);\n    } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {\n        if (addToFront) {\n            if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n            else if (state.destroyed || state.errored) return false;\n            else addChunk(stream, state, chunk, true);\n        } else if (state.ended) {\n            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n        } else if (state.destroyed || state.errored) {\n            return false;\n        } else {\n            state.state &= ~kReading;\n            if (state.decoder && !encoding) {\n                chunk = state.decoder.write(chunk);\n                if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\n                else maybeReadMore(stream, state);\n            } else {\n                addChunk(stream, state, chunk, false);\n            }\n        }\n    } else if (!addToFront) {\n        state.state &= ~kReading;\n        maybeReadMore(stream, state);\n    }\n    // We can push more data if we are below the highWaterMark.\n    // Also, if we have no data yet, we can stand some more bytes.\n    // This is to work around cases where hwm=0, such as the repl.\n    return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        // Use the guard to avoid creating `Set()` repeatedly\n        // when we have multiple pipes.\n        if ((state.state & kMultiAwaitDrain) !== 0) {\n            state.awaitDrainWriters.clear();\n        } else {\n            state.awaitDrainWriters = null;\n        }\n        state.dataEmitted = true;\n        stream.emit(\"data\", chunk);\n    } else {\n        // Update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);\n    }\n    maybeReadMore(stream, state);\n}\nReadable.prototype.isPaused = function() {\n    const state = this._readableState;\n    return state[kPaused] === true || state.flowing === false;\n};\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n    const decoder = new StringDecoder(enc);\n    this._readableState.decoder = decoder;\n    // If setEncoding(null), decoder.encoding equals utf8.\n    this._readableState.encoding = this._readableState.decoder.encoding;\n    const buffer = this._readableState.buffer;\n    // Iterate over current buffer to convert already stored Buffers:\n    let content = \"\";\n    for (const data of buffer){\n        content += decoder.write(data);\n    }\n    buffer.clear();\n    if (content !== \"\") buffer.push(content);\n    this._readableState.length = content.length;\n    return this;\n};\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n    if (n > MAX_HWM) {\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n    } else {\n        // Get the next highest power of 2 to prevent increasing hwm excessively in\n        // tiny amounts.\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n    }\n    return n;\n}\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if ((state.state & kObjectMode) !== 0) return 1;\n    if (NumberIsNaN(n)) {\n        // Only flow one buffer at a time.\n        if (state.flowing && state.length) return state.buffer.first().length;\n        return state.length;\n    }\n    if (n <= state.length) return n;\n    return state.ended ? state.length : 0;\n}\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n    debug(\"read\", n);\n    // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n    // in this scenario, so we are doing it manually.\n    if (n === undefined) {\n        n = NaN;\n    } else if (!NumberIsInteger(n)) {\n        n = NumberParseInt(n, 10);\n    }\n    const state = this._readableState;\n    const nOrig = n;\n    // If we're asking for more than the current hwm, then raise the hwm.\n    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n    if (n !== 0) state.state &= ~kEmittedReadable;\n    // If we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n        debug(\"read: emitReadable\", state.length, state.ended);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this);\n        return null;\n    }\n    n = howMuchToRead(n, state);\n    // If we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        if (state.length === 0) endReadable(this);\n        return null;\n    }\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n    // if we need a readable event, then we need to do some reading.\n    let doRead = (state.state & kNeedReadable) !== 0;\n    debug(\"need readable\", doRead);\n    // If we currently have less than the highWaterMark, then also read some.\n    if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        debug(\"length less than watermark\", doRead);\n    }\n    // However, if we've ended, then there's no point, if we're already\n    // reading, then it's unnecessary, if we're constructing we have to wait,\n    // and if we're destroyed or errored, then it's not allowed,\n    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n        doRead = false;\n        debug(\"reading, ended or constructing\", doRead);\n    } else if (doRead) {\n        debug(\"do read\");\n        state.state |= kReading | kSync;\n        // If the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.state |= kNeedReadable;\n        // Call internal read method\n        try {\n            this._read(state.highWaterMark);\n        } catch (err) {\n            errorOrDestroy(this, err);\n        }\n        state.state &= ~kSync;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n    }\n    let ret;\n    if (n > 0) ret = fromList(n, state);\n    else ret = null;\n    if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        n = 0;\n    } else {\n        state.length -= n;\n        if (state.multiAwaitDrain) {\n            state.awaitDrainWriters.clear();\n        } else {\n            state.awaitDrainWriters = null;\n        }\n    }\n    if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) endReadable(this);\n    }\n    if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n        state.dataEmitted = true;\n        this.emit(\"data\", ret);\n    }\n    return ret;\n};\nfunction onEofChunk(stream, state) {\n    debug(\"onEofChunk\");\n    if (state.ended) return;\n    if (state.decoder) {\n        const chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    if (state.sync) {\n        // If we are sync, wait until next tick to emit the data.\n        // Otherwise we risk emitting data in the flow()\n        // the readable code triggers during a read() call.\n        emitReadable(stream);\n    } else {\n        // Emit 'readable' now to make sure it gets picked up.\n        state.needReadable = false;\n        state.emittedReadable = true;\n        // We have to emit readable now that we are EOF. Modules\n        // in the ecosystem (e.g. dicer) rely on this event being sync.\n        emitReadable_(stream);\n    }\n}\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n    const state = stream._readableState;\n    debug(\"emitReadable\", state.needReadable, state.emittedReadable);\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n        debug(\"emitReadable\", state.flowing);\n        state.emittedReadable = true;\n        process.nextTick(emitReadable_, stream);\n    }\n}\nfunction emitReadable_(stream) {\n    const state = stream._readableState;\n    debug(\"emitReadable_\", state.destroyed, state.length, state.ended);\n    if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n        stream.emit(\"readable\");\n        state.emittedReadable = false;\n    }\n    // The stream needs another readable event if:\n    // 1. It is not flowing, as the flow mechanism will take\n    //    care of it.\n    // 2. It is not ended.\n    // 3. It is below the highWaterMark, so we can schedule\n    //    another readable later.\n    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n    flow(stream);\n}\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore && state.constructed) {\n        state.readingMore = true;\n        process.nextTick(maybeReadMore_, stream, state);\n    }\n}\nfunction maybeReadMore_(stream, state) {\n    // Attempt to read more data if we should.\n    //\n    // The conditions for reading more data are (one of):\n    // - Not enough data buffered (state.length < state.highWaterMark). The loop\n    //   is responsible for filling the buffer with enough data if such data\n    //   is available. If highWaterMark is 0 and we are not in the flowing mode\n    //   we should _not_ attempt to buffer any extra data. We'll get more data\n    //   when the stream consumer calls read() instead.\n    // - No data in the buffer, and the stream is in flowing mode. In this mode\n    //   the loop below is responsible for ensuring read() is called. Failing to\n    //   call read here would abort the flow and there's no other mechanism for\n    //   continuing the flow if the stream consumer has just subscribed to the\n    //   'data' event.\n    //\n    // In addition to the above conditions to keep reading data, the following\n    // conditions prevent the data from being read:\n    // - The stream has ended (state.ended).\n    // - There is already a pending 'read' operation (state.reading). This is a\n    //   case where the stream has called the implementation defined _read()\n    //   method, but they are processing the call asynchronously and have _not_\n    //   called push() with new data. In this case we skip performing more\n    //   read()s. The execution ends in this method again after the _read() ends\n    //   up calling push() with more data.\n    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){\n        const len = state.length;\n        debug(\"maybeReadMore read 0\");\n        stream.read(0);\n        if (len === state.length) break;\n    }\n    state.readingMore = false;\n}\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n    throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n};\nReadable.prototype.pipe = function(dest, pipeOpts) {\n    const src = this;\n    const state = this._readableState;\n    if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain) {\n            state.multiAwaitDrain = true;\n            state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [\n                state.awaitDrainWriters\n            ] : []);\n        }\n    }\n    state.pipes.push(dest);\n    debug(\"pipe count=%d opts=%j\", state.pipes.length, pipeOpts);\n    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n    const endFn = doEnd ? onend : unpipe;\n    if (state.endEmitted) process.nextTick(endFn);\n    else src.once(\"end\", endFn);\n    dest.on(\"unpipe\", onunpipe);\n    function onunpipe(readable, unpipeInfo) {\n        debug(\"onunpipe\");\n        if (readable === src) {\n            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                unpipeInfo.hasUnpiped = true;\n                cleanup();\n            }\n        }\n    }\n    function onend() {\n        debug(\"onend\");\n        dest.end();\n    }\n    let ondrain;\n    let cleanedUp = false;\n    function cleanup() {\n        debug(\"cleanup\");\n        // Cleanup event handlers once the pipe is broken.\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        if (ondrain) {\n            dest.removeListener(\"drain\", ondrain);\n        }\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", unpipe);\n        src.removeListener(\"data\", ondata);\n        cleanedUp = true;\n        // If the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n    }\n    function pause() {\n        // If the user unpiped during `dest.write()`, it is possible\n        // to get stuck in a permanently paused state if that write\n        // also returned false.\n        // => Check whether `dest` is still a piping destination.\n        if (!cleanedUp) {\n            if (state.pipes.length === 1 && state.pipes[0] === dest) {\n                debug(\"false write response, pause\", 0);\n                state.awaitDrainWriters = dest;\n                state.multiAwaitDrain = false;\n            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n                debug(\"false write response, pause\", state.awaitDrainWriters.size);\n                state.awaitDrainWriters.add(dest);\n            }\n            src.pause();\n        }\n        if (!ondrain) {\n            // When the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n            ondrain = pipeOnDrain(src, dest);\n            dest.on(\"drain\", ondrain);\n        }\n    }\n    src.on(\"data\", ondata);\n    function ondata(chunk) {\n        debug(\"ondata\");\n        const ret = dest.write(chunk);\n        debug(\"dest.write\", ret);\n        if (ret === false) {\n            pause();\n        }\n    }\n    // If the dest has an error, then stop piping into it.\n    // However, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (dest.listenerCount(\"error\") === 0) {\n            const s = dest._writableState || dest._readableState;\n            if (s && !s.errorEmitted) {\n                // User incorrectly emitted 'error' directly on the stream.\n                errorOrDestroy(dest, er);\n            } else {\n                dest.emit(\"error\", er);\n            }\n        }\n    }\n    // Make sure our error handler is attached before userland ones.\n    prependListener(dest, \"error\", onerror);\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n    }\n    dest.once(\"close\", onclose);\n    function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n    }\n    dest.once(\"finish\", onfinish);\n    function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n    }\n    // Tell the dest that it's being piped to.\n    dest.emit(\"pipe\", src);\n    // Start the flow if it hasn't been started already.\n    if (dest.writableNeedDrain === true) {\n        pause();\n    } else if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n    }\n    return dest;\n};\nfunction pipeOnDrain(src, dest) {\n    return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        // `ondrain` will call directly,\n        // `this` maybe not a reference to dest,\n        // so we use the real dest here.\n        if (state.awaitDrainWriters === dest) {\n            debug(\"pipeOnDrain\", 1);\n            state.awaitDrainWriters = null;\n        } else if (state.multiAwaitDrain) {\n            debug(\"pipeOnDrain\", state.awaitDrainWriters.size);\n            state.awaitDrainWriters.delete(dest);\n        }\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\")) {\n            src.resume();\n        }\n    };\n}\nReadable.prototype.unpipe = function(dest) {\n    const state = this._readableState;\n    const unpipeInfo = {\n        hasUnpiped: false\n    };\n    // If we're not piping anywhere, then do nothing.\n    if (state.pipes.length === 0) return this;\n    if (!dest) {\n        // remove all.\n        const dests = state.pipes;\n        state.pipes = [];\n        this.pause();\n        for(let i = 0; i < dests.length; i++)dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: false\n        });\n        return this;\n    }\n    // Try to find the right one.\n    const index = ArrayPrototypeIndexOf(state.pipes, dest);\n    if (index === -1) return this;\n    state.pipes.splice(index, 1);\n    if (state.pipes.length === 0) this.pause();\n    dest.emit(\"unpipe\", this, unpipeInfo);\n    return this;\n};\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev, fn) {\n    const res = Stream.prototype.on.call(this, ev, fn);\n    const state = this._readableState;\n    if (ev === \"data\") {\n        // Update readableListening so that resume() may be a no-op\n        // a few lines down. This is needed to support once('readable').\n        state.readableListening = this.listenerCount(\"readable\") > 0;\n        // Try start flowing on next tick if stream isn't explicitly paused.\n        if (state.flowing !== false) this.resume();\n    } else if (ev === \"readable\") {\n        if (!state.endEmitted && !state.readableListening) {\n            state.readableListening = state.needReadable = true;\n            state.flowing = false;\n            state.emittedReadable = false;\n            debug(\"on readable\", state.length, state.reading);\n            if (state.length) {\n                emitReadable(this);\n            } else if (!state.reading) {\n                process.nextTick(nReadingNextTick, this);\n            }\n        }\n    }\n    return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function(ev, fn) {\n    const res = Stream.prototype.removeListener.call(this, ev, fn);\n    if (ev === \"readable\") {\n        // We need to check if there is someone still listening to\n        // readable and reset the state. However this needs to happen\n        // after readable has been emitted but before I/O (nextTick) to\n        // support once('readable', fn) cycles. This means that calling\n        // resume within the same tick will have no\n        // effect.\n        process.nextTick(updateReadableListening, this);\n    }\n    return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\nReadable.prototype.removeAllListeners = function(ev) {\n    const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n    if (ev === \"readable\" || ev === undefined) {\n        // We need to check if there is someone still listening to\n        // readable and reset the state. However this needs to happen\n        // after readable has been emitted but before I/O (nextTick) to\n        // support once('readable', fn) cycles. This means that calling\n        // resume within the same tick will have no\n        // effect.\n        process.nextTick(updateReadableListening, this);\n    }\n    return res;\n};\nfunction updateReadableListening(self) {\n    const state = self._readableState;\n    state.readableListening = self.listenerCount(\"readable\") > 0;\n    if (state.resumeScheduled && state[kPaused] === false) {\n        // Flowing needs to be set to true now, otherwise\n        // the upcoming resume will not flow.\n        state.flowing = true;\n    // Crude way to check if we should resume.\n    } else if (self.listenerCount(\"data\") > 0) {\n        self.resume();\n    } else if (!state.readableListening) {\n        state.flowing = null;\n    }\n}\nfunction nReadingNextTick(self) {\n    debug(\"readable nexttick read 0\");\n    self.read(0);\n}\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n    const state = this._readableState;\n    if (!state.flowing) {\n        debug(\"resume\");\n        // We flow only if there is no one listening\n        // for readable, but we still have to call\n        // resume().\n        state.flowing = !state.readableListening;\n        resume(this, state);\n    }\n    state[kPaused] = false;\n    return this;\n};\nfunction resume(stream, state) {\n    if (!state.resumeScheduled) {\n        state.resumeScheduled = true;\n        process.nextTick(resume_, stream, state);\n    }\n}\nfunction resume_(stream, state) {\n    debug(\"resume\", state.reading);\n    if (!state.reading) {\n        stream.read(0);\n    }\n    state.resumeScheduled = false;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function() {\n    debug(\"call pause flowing=%j\", this._readableState.flowing);\n    if (this._readableState.flowing !== false) {\n        debug(\"pause\");\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n    }\n    this._readableState[kPaused] = true;\n    return this;\n};\nfunction flow(stream) {\n    const state = stream._readableState;\n    debug(\"flow\", state.flowing);\n    while(state.flowing && stream.read() !== null);\n}\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n    let paused = false;\n    // TODO (ronag): Should this.destroy(err) emit\n    // 'error' on the wrapped stream? Would require\n    // a static factory method, e.g. Readable.wrap(stream).\n    stream.on(\"data\", (chunk)=>{\n        if (!this.push(chunk) && stream.pause) {\n            paused = true;\n            stream.pause();\n        }\n    });\n    stream.on(\"end\", ()=>{\n        this.push(null);\n    });\n    stream.on(\"error\", (err)=>{\n        errorOrDestroy(this, err);\n    });\n    stream.on(\"close\", ()=>{\n        this.destroy();\n    });\n    stream.on(\"destroy\", ()=>{\n        this.destroy();\n    });\n    this._read = ()=>{\n        if (paused && stream.resume) {\n            paused = false;\n            stream.resume();\n        }\n    };\n    // Proxy all the other methods. Important when wrapping filters and duplexes.\n    const streamKeys = ObjectKeys(stream);\n    for(let j = 1; j < streamKeys.length; j++){\n        const i = streamKeys[j];\n        if (this[i] === undefined && typeof stream[i] === \"function\") {\n            this[i] = stream[i].bind(stream);\n        }\n    }\n    return this;\n};\nReadable.prototype[SymbolAsyncIterator] = function() {\n    return streamToAsyncIterator(this);\n};\nReadable.prototype.iterator = function(options) {\n    if (options !== undefined) {\n        validateObject(options, \"options\");\n    }\n    return streamToAsyncIterator(this, options);\n};\nfunction streamToAsyncIterator(stream, options) {\n    if (typeof stream.read !== \"function\") {\n        stream = Readable.wrap(stream, {\n            objectMode: true\n        });\n    }\n    const iter = createAsyncIterator(stream, options);\n    iter.stream = stream;\n    return iter;\n}\nasync function* createAsyncIterator(stream, options) {\n    let callback = nop;\n    function next(resolve) {\n        if (this === stream) {\n            callback();\n            callback = nop;\n        } else {\n            callback = resolve;\n        }\n    }\n    stream.on(\"readable\", next);\n    let error;\n    const cleanup = eos(stream, {\n        writable: false\n    }, (err)=>{\n        error = err ? aggregateTwoErrors(error, err) : null;\n        callback();\n        callback = nop;\n    });\n    try {\n        while(true){\n            const chunk = stream.destroyed ? null : stream.read();\n            if (chunk !== null) {\n                yield chunk;\n            } else if (error) {\n                throw error;\n            } else if (error === null) {\n                return;\n            } else {\n                await new Promise(next);\n            }\n        }\n    } catch (err) {\n        error = aggregateTwoErrors(error, err);\n        throw error;\n    } finally{\n        if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {\n            destroyImpl.destroyer(stream, null);\n        } else {\n            stream.off(\"readable\", next);\n            cleanup();\n        }\n    }\n}\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n    readable: {\n        __proto__: null,\n        get () {\n            const r = this._readableState;\n            // r.readable === false means that this is part of a Duplex stream\n            // where the readable side was disabled upon construction.\n            // Compat. The user might manually disable readable side through\n            // deprecated setter.\n            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set (val) {\n            // Backwards compat.\n            if (this._readableState) {\n                this._readableState.readable = !!val;\n            }\n        }\n    },\n    readableDidRead: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState.dataEmitted;\n        }\n    },\n    readableAborted: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n        }\n    },\n    readableHighWaterMark: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState.highWaterMark;\n        }\n    },\n    readableBuffer: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState && this._readableState.buffer;\n        }\n    },\n    readableFlowing: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return this._readableState.flowing;\n        },\n        set: function(state) {\n            if (this._readableState) {\n                this._readableState.flowing = state;\n            }\n        }\n    },\n    readableLength: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState.length;\n        }\n    },\n    readableObjectMode: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.objectMode : false;\n        }\n    },\n    readableEncoding: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.encoding : null;\n        }\n    },\n    errored: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.errored : null;\n        }\n    },\n    closed: {\n        __proto__: null,\n        get () {\n            return this._readableState ? this._readableState.closed : false;\n        }\n    },\n    destroyed: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.destroyed : false;\n        },\n        set (value) {\n            // We ignore the value if the stream\n            // has not been initialized yet.\n            if (!this._readableState) {\n                return;\n            }\n            // Backward compatibility, the user is explicitly\n            // managing destroyed.\n            this._readableState.destroyed = value;\n        }\n    },\n    readableEnded: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._readableState ? this._readableState.endEmitted : false;\n        }\n    }\n});\nObjectDefineProperties(ReadableState.prototype, {\n    // Legacy getter for `pipesCount`.\n    pipesCount: {\n        __proto__: null,\n        get () {\n            return this.pipes.length;\n        }\n    },\n    // Legacy property for `paused`.\n    paused: {\n        __proto__: null,\n        get () {\n            return this[kPaused] !== false;\n        },\n        set (value) {\n            this[kPaused] = !!value;\n        }\n    }\n});\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n    // nothing buffered.\n    if (state.length === 0) return null;\n    let ret;\n    if (state.objectMode) ret = state.buffer.shift();\n    else if (!n || n >= state.length) {\n        // Read it all, truncate the list.\n        if (state.decoder) ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n    } else {\n        // read part of list.\n        ret = state.buffer.consume(n, state.decoder);\n    }\n    return ret;\n}\nfunction endReadable(stream) {\n    const state = stream._readableState;\n    debug(\"endReadable\", state.endEmitted);\n    if (!state.endEmitted) {\n        state.ended = true;\n        process.nextTick(endReadableNT, state, stream);\n    }\n}\nfunction endReadableNT(state, stream) {\n    debug(\"endReadableNT\", state.endEmitted, state.length);\n    // Check that we didn't get one last unshift.\n    if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.emit(\"end\");\n        if (stream.writable && stream.allowHalfOpen === false) {\n            process.nextTick(endWritableNT, stream);\n        } else if (state.autoDestroy) {\n            // In case of duplex streams we need a way to detect\n            // if the writable side is ready for autoDestroy as well.\n            const wState = stream._writableState;\n            const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'\n            // if writable is explicitly set to false.\n            (wState.finished || wState.writable === false);\n            if (autoDestroy) {\n                stream.destroy();\n            }\n        }\n    }\n}\nfunction endWritableNT(stream) {\n    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n    if (writable) {\n        stream.end();\n    }\n}\nReadable.from = function(iterable, opts) {\n    return from(Readable, iterable, opts);\n};\nlet webStreamsAdapters;\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n    if (webStreamsAdapters === undefined) webStreamsAdapters = {};\n    return webStreamsAdapters;\n}\nReadable.fromWeb = function(readableStream, options) {\n    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n};\nReadable.toWeb = function(streamReadable, options) {\n    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);\n};\nReadable.wrap = function(src, options) {\n    var _ref, _src$readableObjectMo;\n    return new Readable({\n        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,\n        ...options,\n        destroy (err, callback) {\n            destroyImpl.destroyer(src, err);\n            callback(err);\n        }\n    }).wrap(src);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsR0FFckIsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUF3QnRCO0FBQ0YsTUFBTSxFQUNKQyxxQkFBcUIsRUFDckJDLGVBQWUsRUFDZkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2RDLHNCQUFzQixFQUN0QkMsVUFBVSxFQUNWQyxvQkFBb0IsRUFDcEJDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxrQkFBa0IsRUFDbEJDLG1CQUFtQixFQUNuQkMsTUFBTSxFQUNQLEdBQUdaLG1CQUFPQSxDQUFDO0FBQ1phLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJBLFNBQVNDLGFBQWEsR0FBR0E7QUFDekIsTUFBTSxFQUFFQyxjQUFjQyxFQUFFLEVBQUUsR0FBR2xCLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRW1CLE1BQU0sRUFBRUMsZUFBZSxFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQztBQUM1QyxNQUFNLEVBQUVxQixNQUFNLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRXNCLGNBQWMsRUFBRSxHQUFHdEIsbUJBQU9BLENBQUM7QUFDbkMsTUFBTXVCLE1BQU12QixtQkFBT0EsQ0FBQztBQUNwQixJQUFJd0IsUUFBUXhCLHNKQUFtQyxDQUFDLFVBQVUsQ0FBQzBCO0lBQ3pERixRQUFRRTtBQUNWO0FBQ0EsTUFBTUMsYUFBYTNCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU00QixjQUFjNUIsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFFNkIsZ0JBQWdCLEVBQUVDLHVCQUF1QixFQUFFLEdBQUc5QixtQkFBT0EsQ0FBQztBQUM5RCxNQUFNLEVBQ0orQixrQkFBa0IsRUFDbEJDLE9BQU8sRUFDTEMsb0JBQW9CLEVBQ3BCQyww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QytHLE9BQ0E7UUFDTixHQUFHekssT0FBTztRQUNWaUIsU0FBUVMsR0FBRyxFQUFFMEcsUUFBUTtZQUNuQm5NLFlBQVl1TSxTQUFTLENBQUM5RCxLQUFLaEQ7WUFDM0IwRyxTQUFTMUc7UUFDWDtJQUNGLEdBQUdpRyxJQUFJLENBQUNqRDtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcmVhZGFibGUuanM/MDg2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG47KCd1c2Ugc3RyaWN0JylcbmNvbnN0IHtcbiAgQXJyYXlQcm90b3R5cGVJbmRleE9mLFxuICBOdW1iZXJJc0ludGVnZXIsXG4gIE51bWJlcklzTmFOLFxuICBOdW1iZXJQYXJzZUludCxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydGllcyxcbiAgT2JqZWN0S2V5cyxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YsXG4gIFByb21pc2UsXG4gIFNhZmVTZXQsXG4gIFN5bWJvbEFzeW5jRGlzcG9zZSxcbiAgU3ltYm9sQXN5bmNJdGVyYXRvcixcbiAgU3ltYm9sXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZVxuY29uc3QgeyBFdmVudEVtaXR0ZXI6IEVFIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgeyBTdHJlYW0sIHByZXBlbmRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuL2FkZC1hYm9ydC1zaWduYWwnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmxldCBkZWJ1ZyA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmRlYnVnbG9nKCdzdHJlYW0nLCAoZm4pID0+IHtcbiAgZGVidWcgPSBmblxufSlcbmNvbnN0IEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2J1ZmZlcl9saXN0JylcbmNvbnN0IGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IHsgZ2V0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuY29uc3Qge1xuICBhZ2dyZWdhdGVUd29FcnJvcnMsXG4gIGNvZGVzOiB7XG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX09VVF9PRl9SQU5HRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlRcbiAgfSxcbiAgQWJvcnRFcnJvclxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgdmFsaWRhdGVPYmplY3QgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3Qga1BhdXNlZCA9IFN5bWJvbCgna1BhdXNlZCcpXG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IGZyb20gPSByZXF1aXJlKCcuL2Zyb20nKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUmVhZGFibGUucHJvdG90eXBlLCBTdHJlYW0ucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUmVhZGFibGUsIFN0cmVhbSlcbmNvbnN0IG5vcCA9ICgpID0+IHt9XG5jb25zdCB7IGVycm9yT3JEZXN0cm95IH0gPSBkZXN0cm95SW1wbFxuY29uc3Qga09iamVjdE1vZGUgPSAxIDw8IDBcbmNvbnN0IGtFbmRlZCA9IDEgPDwgMVxuY29uc3Qga0VuZEVtaXR0ZWQgPSAxIDw8IDJcbmNvbnN0IGtSZWFkaW5nID0gMSA8PCAzXG5jb25zdCBrQ29uc3RydWN0ZWQgPSAxIDw8IDRcbmNvbnN0IGtTeW5jID0gMSA8PCA1XG5jb25zdCBrTmVlZFJlYWRhYmxlID0gMSA8PCA2XG5jb25zdCBrRW1pdHRlZFJlYWRhYmxlID0gMSA8PCA3XG5jb25zdCBrUmVhZGFibGVMaXN0ZW5pbmcgPSAxIDw8IDhcbmNvbnN0IGtSZXN1bWVTY2hlZHVsZWQgPSAxIDw8IDlcbmNvbnN0IGtFcnJvckVtaXR0ZWQgPSAxIDw8IDEwXG5jb25zdCBrRW1pdENsb3NlID0gMSA8PCAxMVxuY29uc3Qga0F1dG9EZXN0cm95ID0gMSA8PCAxMlxuY29uc3Qga0Rlc3Ryb3llZCA9IDEgPDwgMTNcbmNvbnN0IGtDbG9zZWQgPSAxIDw8IDE0XG5jb25zdCBrQ2xvc2VFbWl0dGVkID0gMSA8PCAxNVxuY29uc3Qga011bHRpQXdhaXREcmFpbiA9IDEgPDwgMTZcbmNvbnN0IGtSZWFkaW5nTW9yZSA9IDEgPDwgMTdcbmNvbnN0IGtEYXRhRW1pdHRlZCA9IDEgPDwgMThcblxuLy8gVE9ETyhiZW5qYW1pbmdyKSBpdCBpcyBsaWtlbHkgc2xvd2VyIHRvIGRvIGl0IHRoaXMgd2F5IHRoYW4gd2l0aCBmcmVlIGZ1bmN0aW9uc1xuZnVuY3Rpb24gbWFrZUJpdE1hcERlc2NyaXB0b3IoYml0KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLnN0YXRlICYgYml0KSAhPT0gMFxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHRoaXMuc3RhdGUgfD0gYml0XG4gICAgICBlbHNlIHRoaXMuc3RhdGUgJj0gfmJpdFxuICAgIH1cbiAgfVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0YXRlLnByb3RvdHlwZSwge1xuICBvYmplY3RNb2RlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrT2JqZWN0TW9kZSksXG4gIGVuZGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW5kZWQpLFxuICBlbmRFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW5kRW1pdHRlZCksXG4gIHJlYWRpbmc6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkaW5nKSxcbiAgLy8gU3RyZWFtIGlzIHN0aWxsIGJlaW5nIGNvbnN0cnVjdGVkIGFuZCBjYW5ub3QgYmVcbiAgLy8gZGVzdHJveWVkIHVudGlsIGNvbnN0cnVjdGlvbiBmaW5pc2hlZCBvciBmYWlsZWQuXG4gIC8vIEFzeW5jIGNvbnN0cnVjdGlvbiBpcyBvcHQgaW4sIHRoZXJlZm9yZSB3ZSBzdGFydCBhc1xuICAvLyBjb25zdHJ1Y3RlZC5cbiAgY29uc3RydWN0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDb25zdHJ1Y3RlZCksXG4gIC8vIEEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgc3luYzogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1N5bmMpLFxuICAvLyBXaGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgbmVlZFJlYWRhYmxlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrTmVlZFJlYWRhYmxlKSxcbiAgZW1pdHRlZFJlYWRhYmxlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW1pdHRlZFJlYWRhYmxlKSxcbiAgcmVhZGFibGVMaXN0ZW5pbmc6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkYWJsZUxpc3RlbmluZyksXG4gIHJlc3VtZVNjaGVkdWxlZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1Jlc3VtZVNjaGVkdWxlZCksXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluLlxuICBlcnJvckVtaXR0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFcnJvckVtaXR0ZWQpLFxuICBlbWl0Q2xvc2U6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFbWl0Q2xvc2UpLFxuICBhdXRvRGVzdHJveTogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0F1dG9EZXN0cm95KSxcbiAgLy8gSGFzIGl0IGJlZW4gZGVzdHJveWVkLlxuICBkZXN0cm95ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtEZXN0cm95ZWQpLFxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBmaW5pc2hlZCBkZXN0cm95aW5nLlxuICBjbG9zZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDbG9zZWQpLFxuICAvLyBUcnVlIGlmIGNsb3NlIGhhcyBiZWVuIGVtaXR0ZWQgb3Igd291bGQgaGF2ZSBiZWVuIGVtaXR0ZWRcbiAgLy8gZGVwZW5kaW5nIG9uIGVtaXRDbG9zZS5cbiAgY2xvc2VFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrQ2xvc2VFbWl0dGVkKSxcbiAgbXVsdGlBd2FpdERyYWluOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrTXVsdGlBd2FpdERyYWluKSxcbiAgLy8gSWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZC5cbiAgcmVhZGluZ01vcmU6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkaW5nTW9yZSksXG4gIGRhdGFFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRGF0YUVtaXR0ZWQpXG59KVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcblxuICAvLyBCaXQgbWFwIGZpZWxkIHRvIHN0b3JlIFJlYWRhYmxlU3RhdGUgbW9yZSBlZmZjaWVudGx5IHdpdGggMSBiaXQgcGVyIGZpZWxkXG4gIC8vIGluc3RlYWQgb2YgYSBWOCBzbG90IHBlciBmaWVsZC5cbiAgdGhpcy5zdGF0ZSA9IGtFbWl0Q2xvc2UgfCBrQXV0b0Rlc3Ryb3kgfCBrQ29uc3RydWN0ZWQgfCBrU3luY1xuICAvLyBPYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheS5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlKSB0aGlzLnN0YXRlIHw9IGtPYmplY3RNb2RlXG4gIGlmIChpc0R1cGxleCAmJiBvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlKSB0aGlzLnN0YXRlIHw9IGtPYmplY3RNb2RlXG5cbiAgLy8gVGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRpb25zXG4gICAgPyBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleClcbiAgICA6IGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKGZhbHNlKVxuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KCkuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKVxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5waXBlcyA9IFtdXG4gIHRoaXMuZmxvd2luZyA9IG51bGxcbiAgdGhpc1trUGF1c2VkXSA9IG51bGxcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVtaXRDbG9zZSA9PT0gZmFsc2UpIHRoaXMuc3RhdGUgJj0gfmtFbWl0Q2xvc2VcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJykuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKSB0aGlzLnN0YXRlICY9IH5rQXV0b0Rlc3Ryb3lcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBlcnJvcmVkLiBXaGVuIHRydWUgbm8gZnVydGhlclxuICAvLyBfcmVhZCBjYWxscywgJ2RhdGEnIG9yICdyZWFkYWJsZScgZXZlbnRzIHNob3VsZCBvY2N1ci4gVGhpcyBpcyBuZWVkZWRcbiAgLy8gc2luY2Ugd2hlbiBhdXRvRGVzdHJveSBpcyBkaXNhYmxlZCB3ZSBuZWVkIGEgd2F5IHRvIHRlbGwgd2hldGhlciB0aGVcbiAgLy8gc3RyZWFtIGhhcyBmYWlsZWQuXG4gIHRoaXMuZXJyb3JlZCA9IG51bGxcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKSB8fCAndXRmOCdcblxuICAvLyBSZWYgdGhlIHBpcGVkIGRlc3Qgd2hpY2ggd2UgbmVlZCBhIGRyYWluIGV2ZW50IG9uIGl0XG4gIC8vIHR5cGU6IG51bGwgfCBXcml0YWJsZSB8IFNldDxXcml0YWJsZT4uXG4gIHRoaXMuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gIHRoaXMuZGVjb2RlciA9IG51bGxcbiAgdGhpcy5lbmNvZGluZyA9IG51bGxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfVxufVxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjUuXG4gIGNvbnN0IGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3lcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9jb25zdHJ1Y3QgPSBvcHRpb25zLmNvbnN0cnVjdFxuICAgIGlmIChvcHRpb25zLnNpZ25hbCAmJiAhaXNEdXBsZXgpIGFkZEFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCB0aGlzKVxuICB9XG4gIFN0cmVhbS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIGRlc3Ryb3lJbXBsLmNvbnN0cnVjdCh0aGlzLCAoKSA9PiB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlKSB7XG4gICAgICBtYXliZVJlYWRNb3JlKHRoaXMsIHRoaXMuX3JlYWRhYmxlU3RhdGUpXG4gICAgfVxuICB9KVxufVxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveVxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKVxufVxuUmVhZGFibGUucHJvdG90eXBlW0VFLmNhcHR1cmVSZWplY3Rpb25TeW1ib2xdID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmRlc3Ryb3koZXJyKVxufVxuUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbEFzeW5jRGlzcG9zZV0gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBlcnJvclxuICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgZXJyb3IgPSB0aGlzLnJlYWRhYmxlRW5kZWQgPyBudWxsIDogbmV3IEFib3J0RXJyb3IoKVxuICAgIHRoaXMuZGVzdHJveShlcnJvcilcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gZW9zKHRoaXMsIChlcnIpID0+IChlcnIgJiYgZXJyICE9PSBlcnJvciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShudWxsKSkpKVxufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKCkuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCB0cnVlKVxufVxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKVxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBsZXQgZXJyXG4gIGlmICgoc3RhdGUuc3RhdGUgJiBrT2JqZWN0TW9kZSkgPT09IDApIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2RpbmdcbiAgICAgIGlmIChzdGF0ZS5lbmNvZGluZyAhPT0gZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQgJiYgc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgICAvLyBXaGVuIHVuc2hpZnRpbmcsIGlmIHN0YXRlLmVuY29kaW5nIGlzIHNldCwgd2UgaGF2ZSB0byBzYXZlXG4gICAgICAgICAgLy8gdGhlIHN0cmluZyBpbiB0aGUgQnVmZmVyTGlzdCB3aXRoIHRoZSBzdGF0ZSBlbmNvZGluZy5cbiAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZykudG9TdHJpbmcoc3RhdGUuZW5jb2RpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgIH0gZWxzZSBpZiAoU3RyZWFtLl9pc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICBjaHVuayA9IFN0cmVhbS5fdWludDhBcnJheVRvQnVmZmVyKGNodW5rKVxuICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgIH0gZWxzZSBpZiAoY2h1bmsgIT0gbnVsbCkge1xuICAgICAgZXJyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKVxuICAgIH1cbiAgfVxuICBpZiAoZXJyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5zdGF0ZSAmPSB+a1JlYWRpbmdcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoKHN0YXRlLnN0YXRlICYga09iamVjdE1vZGUpICE9PSAwIHx8IChjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSkge1xuICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICBpZiAoKHN0YXRlLnN0YXRlICYga0VuZEVtaXR0ZWQpICE9PSAwKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpXG4gICAgICBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQgfHwgc3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gICAgICBlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSlcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCB8fCBzdGF0ZS5lcnJvcmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc3RhdGUgJj0gfmtSZWFkaW5nXG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKVxuICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSlcbiAgICAgICAgZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUuc3RhdGUgJj0gfmtSZWFkaW5nXG4gICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApXG59XG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMgJiYgc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICAvLyBVc2UgdGhlIGd1YXJkIHRvIGF2b2lkIGNyZWF0aW5nIGBTZXQoKWAgcmVwZWF0ZWRseVxuICAgIC8vIHdoZW4gd2UgaGF2ZSBtdWx0aXBsZSBwaXBlcy5cbiAgICBpZiAoKHN0YXRlLnN0YXRlICYga011bHRpQXdhaXREcmFpbikgIT09IDApIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLmNsZWFyKClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gICAgfVxuICAgIHN0YXRlLmRhdGFFbWl0dGVkID0gdHJ1ZVxuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgLy8gVXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspXG4gICAgZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuaylcbiAgICBpZiAoKHN0YXRlLnN0YXRlICYga05lZWRSZWFkYWJsZSkgIT09IDApIGVtaXRSZWFkYWJsZShzdHJlYW0pXG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKVxufVxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgcmV0dXJuIHN0YXRlW2tQYXVzZWRdID09PSB0cnVlIHx8IHN0YXRlLmZsb3dpbmcgPT09IGZhbHNlXG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyXG4gIC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4LlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nXG4gIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIGxldCBjb250ZW50ID0gJydcbiAgZm9yIChjb25zdCBkYXRhIG9mIGJ1ZmZlcikge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShkYXRhKVxuICB9XG4gIGJ1ZmZlci5jbGVhcigpXG4gIGlmIChjb250ZW50ICE9PSAnJykgYnVmZmVyLnB1c2goY29udGVudClcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCLlxuY29uc3QgTUFYX0hXTSA9IDB4NDAwMDAwMDBcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPiBNQVhfSFdNKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UoJ3NpemUnLCAnPD0gMUdpQicsIG4pXG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzLlxuICAgIG4tLVxuICAgIG4gfD0gbiA+Pj4gMVxuICAgIG4gfD0gbiA+Pj4gMlxuICAgIG4gfD0gbiA+Pj4gNFxuICAgIG4gfD0gbiA+Pj4gOFxuICAgIG4gfD0gbiA+Pj4gMTZcbiAgICBuKytcbiAgfVxuICByZXR1cm4gblxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSkgcmV0dXJuIDBcbiAgaWYgKChzdGF0ZS5zdGF0ZSAmIGtPYmplY3RNb2RlKSAhPT0gMCkgcmV0dXJuIDFcbiAgaWYgKE51bWJlcklzTmFOKG4pKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lLlxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5maXJzdCgpLmxlbmd0aFxuICAgIHJldHVybiBzdGF0ZS5sZW5ndGhcbiAgfVxuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuXG4gIHJldHVybiBzdGF0ZS5lbmRlZCA/IHN0YXRlLmxlbmd0aCA6IDBcbn1cblxuLy8gWW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKVxuICAvLyBTYW1lIGFzIHBhcnNlSW50KHVuZGVmaW5lZCwgMTApLCBob3dldmVyIFY4IDcuMyBwZXJmb3JtYW5jZSByZWdyZXNzZWRcbiAgLy8gaW4gdGhpcyBzY2VuYXJpbywgc28gd2UgYXJlIGRvaW5nIGl0IG1hbnVhbGx5LlxuICBpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbiA9IE5hTlxuICB9IGVsc2UgaWYgKCFOdW1iZXJJc0ludGVnZXIobikpIHtcbiAgICBuID0gTnVtYmVyUGFyc2VJbnQobiwgMTApXG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IG5PcmlnID0gblxuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKVxuICBpZiAobiAhPT0gMCkgc3RhdGUuc3RhdGUgJj0gfmtFbWl0dGVkUmVhZGFibGVcblxuICAvLyBJZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChcbiAgICBuID09PSAwICYmXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZClcbiAgKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcylcbiAgICBlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpXG5cbiAgLy8gSWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICBsZXQgZG9SZWFkID0gKHN0YXRlLnN0YXRlICYga05lZWRSZWFkYWJsZSkgIT09IDBcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpXG5cbiAgLy8gSWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZVxuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZClcbiAgfVxuXG4gIC8vIEhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LCBpZiB3ZSdyZSBjb25zdHJ1Y3Rpbmcgd2UgaGF2ZSB0byB3YWl0LFxuICAvLyBhbmQgaWYgd2UncmUgZGVzdHJveWVkIG9yIGVycm9yZWQsIHRoZW4gaXQncyBub3QgYWxsb3dlZCxcbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcgfHwgc3RhdGUuZGVzdHJveWVkIHx8IHN0YXRlLmVycm9yZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgZG9SZWFkID0gZmFsc2VcbiAgICBkZWJ1ZygncmVhZGluZywgZW5kZWQgb3IgY29uc3RydWN0aW5nJywgZG9SZWFkKVxuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJylcbiAgICBzdGF0ZS5zdGF0ZSB8PSBrUmVhZGluZyB8IGtTeW5jXG4gICAgLy8gSWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5zdGF0ZSB8PSBrTmVlZFJlYWRhYmxlXG5cbiAgICAvLyBDYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gICAgc3RhdGUuc3RhdGUgJj0gfmtTeW5jXG5cbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSlcbiAgfVxuICBsZXQgcmV0XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpXG4gIGVsc2UgcmV0ID0gbnVsbFxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgICBuID0gMFxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuXG4gICAgaWYgKHN0YXRlLm11bHRpQXdhaXREcmFpbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuY2xlYXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlXG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKVxuICB9XG4gIGlmIChyZXQgIT09IG51bGwgJiYgIXN0YXRlLmVycm9yRW1pdHRlZCAmJiAhc3RhdGUuY2xvc2VFbWl0dGVkKSB7XG4gICAgc3RhdGUuZGF0YUVtaXR0ZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpXG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgY29uc3QgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gSWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGwuXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSlcbiAgfSBlbHNlIHtcbiAgICAvLyBFbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWVcbiAgICAvLyBXZSBoYXZlIHRvIGVtaXQgcmVhZGFibGUgbm93IHRoYXQgd2UgYXJlIEVPRi4gTW9kdWxlc1xuICAgIC8vIGluIHRoZSBlY29zeXN0ZW0gKGUuZy4gZGljZXIpIHJlbHkgb24gdGhpcyBldmVudCBiZWluZyBzeW5jLlxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKVxuICB9XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2VcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZylcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKVxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAhc3RhdGUuZXJyb3JlZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZjpcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFya1xuICBmbG93KHN0cmVhbSlcbn1cblxuLy8gQXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSAmJiBzdGF0ZS5jb25zdHJ1Y3RlZCkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZVxuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpXG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoXG4gICAgIXN0YXRlLnJlYWRpbmcgJiZcbiAgICAhc3RhdGUuZW5kZWQgJiZcbiAgICAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKVxuICApIHtcbiAgICBjb25zdCBsZW4gPSBzdGF0ZS5sZW5ndGhcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKVxuICAgIHN0cmVhbS5yZWFkKDApXG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gRGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrXG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZVxufVxuXG4vLyBBYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRocm93IG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpXG59XG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICBjb25zdCBzcmMgPSB0aGlzXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoc3RhdGUucGlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFzdGF0ZS5tdWx0aUF3YWl0RHJhaW4pIHtcbiAgICAgIHN0YXRlLm11bHRpQXdhaXREcmFpbiA9IHRydWVcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbmV3IFNhZmVTZXQoc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPyBbc3RhdGUuYXdhaXREcmFpbldyaXRlcnNdIDogW10pXG4gICAgfVxuICB9XG4gIHN0YXRlLnBpcGVzLnB1c2goZGVzdClcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzLmxlbmd0aCwgcGlwZU9wdHMpXG4gIGNvbnN0IGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVyclxuICBjb25zdCBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGVcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pXG4gIGVsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKVxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSlcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKVxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWVcbiAgICAgICAgY2xlYW51cCgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpXG4gICAgZGVzdC5lbmQoKVxuICB9XG4gIGxldCBvbmRyYWluXG4gIGxldCBjbGVhbmVkVXAgPSBmYWxzZVxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJylcbiAgICAvLyBDbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuLlxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgICBpZiAob25kcmFpbikge1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKVxuICAgIH1cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSlcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgY2xlYW5lZFVwID0gdHJ1ZVxuXG4gICAgLy8gSWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAob25kcmFpbiAmJiBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKClcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgaWYgKCFjbGVhbmVkVXApIHtcbiAgICAgIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDEgJiYgc3RhdGUucGlwZXNbMF0gPT09IGRlc3QpIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIDApXG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gZGVzdFxuICAgICAgICBzdGF0ZS5tdWx0aUF3YWl0RHJhaW4gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPiAxICYmIHN0YXRlLnBpcGVzLmluY2x1ZGVzKGRlc3QpKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5zaXplKVxuICAgICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5hZGQoZGVzdClcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpXG4gICAgfVxuICAgIGlmICghb25kcmFpbikge1xuICAgICAgLy8gV2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAgICAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gICAgICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAgICAgLy8gdG9vIHNsb3cuXG4gICAgICBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjLCBkZXN0KVxuICAgICAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKVxuICAgIH1cbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKVxuICAgIGNvbnN0IHJldCA9IGRlc3Qud3JpdGUoY2h1bmspXG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIHBhdXNlKClcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gSG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcilcbiAgICB1bnBpcGUoKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBpZiAoZGVzdC5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICBjb25zdCBzID0gZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAocyAmJiAhcy5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgLy8gVXNlciBpbmNvcnJlY3RseSBlbWl0dGVkICdlcnJvcicgZGlyZWN0bHkgb24gdGhlIHN0cmVhbS5cbiAgICAgICAgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcilcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICAgIHVucGlwZSgpXG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICAgIHVucGlwZSgpXG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKVxuICAgIHNyYy51bnBpcGUoZGVzdClcbiAgfVxuXG4gIC8vIFRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvLlxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpXG5cbiAgLy8gU3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmIChkZXN0LndyaXRhYmxlTmVlZERyYWluID09PSB0cnVlKSB7XG4gICAgcGF1c2UoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJylcbiAgICBzcmMucmVzdW1lKClcbiAgfVxuICByZXR1cm4gZGVzdFxufVxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjLCBkZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIGNvbnN0IHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlXG5cbiAgICAvLyBgb25kcmFpbmAgd2lsbCBjYWxsIGRpcmVjdGx5LFxuICAgIC8vIGB0aGlzYCBtYXliZSBub3QgYSByZWZlcmVuY2UgdG8gZGVzdCxcbiAgICAvLyBzbyB3ZSB1c2UgdGhlIHJlYWwgZGVzdCBoZXJlLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9PT0gZGVzdCkge1xuICAgICAgZGVidWcoJ3BpcGVPbkRyYWluJywgMSlcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoc3RhdGUubXVsdGlBd2FpdERyYWluKSB7XG4gICAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5zaXplKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuZGVsZXRlKGRlc3QpXG4gICAgfVxuICAgIGlmICgoIXN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzIHx8IHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLnNpemUgPT09IDApICYmIHNyYy5saXN0ZW5lckNvdW50KCdkYXRhJykpIHtcbiAgICAgIHNyYy5yZXN1bWUoKVxuICAgIH1cbiAgfVxufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH1cblxuICAvLyBJZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgY29uc3QgZGVzdHMgPSBzdGF0ZS5waXBlc1xuICAgIHN0YXRlLnBpcGVzID0gW11cbiAgICB0aGlzLnBhdXNlKClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3RzLmxlbmd0aDsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gVHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgY29uc3QgaW5kZXggPSBBcnJheVByb3RvdHlwZUluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSlcbiAgaWYgKHN0YXRlLnBpcGVzLmxlbmd0aCA9PT0gMCkgdGhpcy5wYXVzZSgpXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gU2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmcuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIGNvbnN0IHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuXG4gICAgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZC5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKClcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZVxuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZVxuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKVxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcylcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub25cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgY29uc3QgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbilcbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuUmVhZGFibGUucHJvdG90eXBlLm9mZiA9IFJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lclxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICBjb25zdCByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICBjb25zdCBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGVcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgc3RhdGVba1BhdXNlZF0gPT09IGZhbHNlKSB7XG4gICAgLy8gRmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZVxuXG4gICAgLy8gQ3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWUuXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBudWxsXG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJylcbiAgc2VsZi5yZWFkKDApXG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJylcbiAgICAvLyBXZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpLlxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmdcbiAgICByZXN1bWUodGhpcywgc3RhdGUpXG4gIH1cbiAgc3RhdGVba1BhdXNlZF0gPSBmYWxzZVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKVxuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApXG4gIH1cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2VcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gIGZsb3coc3RyZWFtKVxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMClcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZylcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKVxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZVtrUGF1c2VkXSA9IHRydWVcbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZylcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCk7XG59XG5cbi8vIFdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICBsZXQgcGF1c2VkID0gZmFsc2VcblxuICAvLyBUT0RPIChyb25hZyk6IFNob3VsZCB0aGlzLmRlc3Ryb3koZXJyKSBlbWl0XG4gIC8vICdlcnJvcicgb24gdGhlIHdyYXBwZWQgc3RyZWFtPyBXb3VsZCByZXF1aXJlXG4gIC8vIGEgc3RhdGljIGZhY3RvcnkgbWV0aG9kLCBlLmcuIFJlYWRhYmxlLndyYXAoc3RyZWFtKS5cblxuICBzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICBpZiAoIXRoaXMucHVzaChjaHVuaykgJiYgc3RyZWFtLnBhdXNlKSB7XG4gICAgICBwYXVzZWQgPSB0cnVlXG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH1cbiAgfSlcbiAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gIH0pXG4gIHN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgZXJyb3JPckRlc3Ryb3kodGhpcywgZXJyKVxuICB9KVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH0pXG4gIHN0cmVhbS5vbignZGVzdHJveScsICgpID0+IHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9KVxuICB0aGlzLl9yZWFkID0gKCkgPT4ge1xuICAgIGlmIChwYXVzZWQgJiYgc3RyZWFtLnJlc3VtZSkge1xuICAgICAgcGF1c2VkID0gZmFsc2VcbiAgICAgIHN0cmVhbS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy4gSW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGNvbnN0IHN0cmVhbUtleXMgPSBPYmplY3RLZXlzKHN0cmVhbSlcbiAgZm9yIChsZXQgaiA9IDE7IGogPCBzdHJlYW1LZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgaSA9IHN0cmVhbUtleXNbal1cbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBzdHJlYW1baV0uYmluZChzdHJlYW0pXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5SZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzdHJlYW1Ub0FzeW5jSXRlcmF0b3IodGhpcylcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVRvQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zKVxufVxuZnVuY3Rpb24gc3RyZWFtVG9Bc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0cmVhbS5yZWFkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtID0gUmVhZGFibGUud3JhcChzdHJlYW0sIHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KVxuICB9XG4gIGNvbnN0IGl0ZXIgPSBjcmVhdGVBc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucylcbiAgaXRlci5zdHJlYW0gPSBzdHJlYW1cbiAgcmV0dXJuIGl0ZXJcbn1cbmFzeW5jIGZ1bmN0aW9uKiBjcmVhdGVBc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBsZXQgY2FsbGJhY2sgPSBub3BcbiAgZnVuY3Rpb24gbmV4dChyZXNvbHZlKSB7XG4gICAgaWYgKHRoaXMgPT09IHN0cmVhbSkge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgY2FsbGJhY2sgPSBub3BcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBuZXh0KVxuICBsZXQgZXJyb3JcbiAgY29uc3QgY2xlYW51cCA9IGVvcyhcbiAgICBzdHJlYW0sXG4gICAge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBlcnJvciA9IGVyciA/IGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlcnJvciwgZXJyKSA6IG51bGxcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGNhbGxiYWNrID0gbm9wXG4gICAgfVxuICApXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gc3RyZWFtLmRlc3Ryb3llZCA/IG51bGwgOiBzdHJlYW0ucmVhZCgpXG4gICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgeWllbGQgY2h1bmtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShuZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBhZ2dyZWdhdGVUd29FcnJvcnMoZXJyb3IsIGVycilcbiAgICB0aHJvdyBlcnJvclxuICB9IGZpbmFsbHkge1xuICAgIGlmIChcbiAgICAgIChlcnJvciB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRlc3Ryb3lPblJldHVybikgIT09IGZhbHNlKSAmJlxuICAgICAgKGVycm9yID09PSB1bmRlZmluZWQgfHwgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmF1dG9EZXN0cm95KVxuICAgICkge1xuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHN0cmVhbSwgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm9mZigncmVhZGFibGUnLCBuZXh0KVxuICAgICAgY2xlYW51cCgpXG4gICAgfVxuICB9XG59XG5cbi8vIE1ha2luZyBpdCBleHBsaWNpdCB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZVxuLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4vLyB1c2VybGFuZCB3aWxsIGZhaWwuXG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlLnByb3RvdHlwZSwge1xuICByZWFkYWJsZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICAgICAgLy8gci5yZWFkYWJsZSA9PT0gZmFsc2UgbWVhbnMgdGhhdCB0aGlzIGlzIHBhcnQgb2YgYSBEdXBsZXggc3RyZWFtXG4gICAgICAvLyB3aGVyZSB0aGUgcmVhZGFibGUgc2lkZSB3YXMgZGlzYWJsZWQgdXBvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICAvLyBDb21wYXQuIFRoZSB1c2VyIG1pZ2h0IG1hbnVhbGx5IGRpc2FibGUgcmVhZGFibGUgc2lkZSB0aHJvdWdoXG4gICAgICAvLyBkZXByZWNhdGVkIHNldHRlci5cbiAgICAgIHJldHVybiAhIXIgJiYgci5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgIXIuZGVzdHJveWVkICYmICFyLmVycm9yRW1pdHRlZCAmJiAhci5lbmRFbWl0dGVkXG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0LlxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9ICEhdmFsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZWFkYWJsZURpZFJlYWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZFxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVBYm9ydGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlICE9PSBmYWxzZSAmJlxuICAgICAgICAodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgfHwgdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkKSAmJlxuICAgICAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkXG4gICAgICApXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUhpZ2hXYXRlck1hcms6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUJ1ZmZlcjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUZsb3dpbmc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aFxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVPYmplY3RNb2RlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlRW5jb2Rpbmc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgPyB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nIDogbnVsbFxuICAgIH1cbiAgfSxcbiAgZXJyb3JlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3JlZCA6IG51bGxcbiAgICB9XG4gIH0sXG4gIGNsb3NlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuY2xvc2VkIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3llZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkIDogZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgLy8gV2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQuXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUVuZGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkIDogZmFsc2VcbiAgICB9XG4gIH1cbn0pXG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RhdGUucHJvdG90eXBlLCB7XG4gIC8vIExlZ2FjeSBnZXR0ZXIgZm9yIGBwaXBlc0NvdW50YC5cbiAgcGlwZXNDb3VudDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5waXBlcy5sZW5ndGhcbiAgICB9XG4gIH0sXG4gIC8vIExlZ2FjeSBwcm9wZXJ0eSBmb3IgYHBhdXNlZGAuXG4gIHBhdXNlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1trUGF1c2VkXSAhPT0gZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdGhpc1trUGF1c2VkXSA9ICEhdmFsdWVcbiAgICB9XG4gIH1cbn0pXG5cbi8vIEV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWQuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gIGxldCByZXRcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpXG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gUmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0LlxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJylcbiAgICBlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKVxuICAgIGVsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKClcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdC5cbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKVxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWVcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pXG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aClcblxuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lcnJvcmVkICYmICFzdGF0ZS5jbG9zZUVtaXR0ZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWVcbiAgICBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICBpZiAoc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbmRXcml0YWJsZU5ULCBzdHJlYW0pXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGwuXG4gICAgICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgICAgIGNvbnN0IGF1dG9EZXN0cm95ID1cbiAgICAgICAgIXdTdGF0ZSB8fFxuICAgICAgICAod1N0YXRlLmF1dG9EZXN0cm95ICYmXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IHRoZSB3cml0YWJsZSB0byBldmVyICdmaW5pc2gnXG4gICAgICAgICAgLy8gaWYgd3JpdGFibGUgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgKHdTdGF0ZS5maW5pc2hlZCB8fCB3U3RhdGUud3JpdGFibGUgPT09IGZhbHNlKSlcbiAgICAgIGlmIChhdXRvRGVzdHJveSkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbmRXcml0YWJsZU5UKHN0cmVhbSkge1xuICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS53cml0YWJsZSAmJiAhc3RyZWFtLndyaXRhYmxlRW5kZWQgJiYgIXN0cmVhbS5kZXN0cm95ZWRcbiAgaWYgKHdyaXRhYmxlKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gIH1cbn1cblJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKVxufVxubGV0IHdlYlN0cmVhbXNBZGFwdGVyc1xuXG4vLyBMYXp5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbmZ1bmN0aW9uIGxhenlXZWJTdHJlYW1zKCkge1xuICBpZiAod2ViU3RyZWFtc0FkYXB0ZXJzID09PSB1bmRlZmluZWQpIHdlYlN0cmVhbXNBZGFwdGVycyA9IHt9XG4gIHJldHVybiB3ZWJTdHJlYW1zQWRhcHRlcnNcbn1cblJlYWRhYmxlLmZyb21XZWIgPSBmdW5jdGlvbiAocmVhZGFibGVTdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3U3RyZWFtUmVhZGFibGVGcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIG9wdGlvbnMpXG59XG5SZWFkYWJsZS50b1dlYiA9IGZ1bmN0aW9uIChzdHJlYW1SZWFkYWJsZSwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdSZWFkYWJsZVN0cmVhbUZyb21TdHJlYW1SZWFkYWJsZShzdHJlYW1SZWFkYWJsZSwgb3B0aW9ucylcbn1cblJlYWRhYmxlLndyYXAgPSBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmLCBfc3JjJHJlYWRhYmxlT2JqZWN0TW9cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7XG4gICAgb2JqZWN0TW9kZTpcbiAgICAgIChfcmVmID1cbiAgICAgICAgKF9zcmMkcmVhZGFibGVPYmplY3RNbyA9IHNyYy5yZWFkYWJsZU9iamVjdE1vZGUpICE9PSBudWxsICYmIF9zcmMkcmVhZGFibGVPYmplY3RNbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBfc3JjJHJlYWRhYmxlT2JqZWN0TW9cbiAgICAgICAgICA6IHNyYy5vYmplY3RNb2RlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfcmVmXG4gICAgICAgIDogdHJ1ZSxcbiAgICAuLi5vcHRpb25zLFxuICAgIGRlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHNyYywgZXJyKVxuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgfSkud3JhcChzcmMpXG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInJlcXVpcmUiLCJBcnJheVByb3RvdHlwZUluZGV4T2YiLCJOdW1iZXJJc0ludGVnZXIiLCJOdW1iZXJJc05hTiIsIk51bWJlclBhcnNlSW50IiwiT2JqZWN0RGVmaW5lUHJvcGVydGllcyIsIk9iamVjdEtleXMiLCJPYmplY3RTZXRQcm90b3R5cGVPZiIsIlByb21pc2UiLCJTYWZlU2V0IiwiU3ltYm9sQXN5bmNEaXNwb3NlIiwiU3ltYm9sQXN5bmNJdGVyYXRvciIsIlN5bWJvbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFkYWJsZSIsIlJlYWRhYmxlU3RhdGUiLCJFdmVudEVtaXR0ZXIiLCJFRSIsIlN0cmVhbSIsInByZXBlbmRMaXN0ZW5lciIsIkJ1ZmZlciIsImFkZEFib3J0U2lnbmFsIiwiZW9zIiwiZGVidWciLCJkZWJ1Z2xvZyIsImZuIiwiQnVmZmVyTGlzdCIsImRlc3Ryb3lJbXBsIiwiZ2V0SGlnaFdhdGVyTWFyayIsImdldERlZmF1bHRIaWdoV2F0ZXJNYXJrIiwiYWdncmVnYXRlVHdvRXJyb3JzIiwiY29kZXMiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIiwiRVJSX09VVF9PRl9SQU5HRSIsIkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YiLCJFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UIiwiQWJvcnRFcnJvciIsInZhbGlkYXRlT2JqZWN0Iiwia1BhdXNlZCIsIlN0cmluZ0RlY29kZXIiLCJmcm9tIiwicHJvdG90eXBlIiwibm9wIiwiZXJyb3JPckRlc3Ryb3kiLCJrT2JqZWN0TW9kZSIsImtFbmRlZCIsImtFbmRFbWl0dGVkIiwia1JlYWRpbmciLCJrQ29uc3RydWN0ZWQiLCJrU3luYyIsImtOZWVkUmVhZGFibGUiLCJrRW1pdHRlZFJlYWRhYmxlIiwia1JlYWRhYmxlTGlzdGVuaW5nIiwia1Jlc3VtZVNjaGVkdWxlZCIsImtFcnJvckVtaXR0ZWQiLCJrRW1pdENsb3NlIiwia0F1dG9EZXN0cm95Iiwia0Rlc3Ryb3llZCIsImtDbG9zZWQiLCJrQ2xvc2VFbWl0dGVkIiwia011bHRpQXdhaXREcmFpbiIsImtSZWFkaW5nTW9yZSIsImtEYXRhRW1pdHRlZCIsIm1ha2VCaXRNYXBEZXNjcmlwdG9yIiwiYml0IiwiZW51bWVyYWJsZSIsImdldCIsInN0YXRlIiwic2V0IiwidmFsdWUiLCJvYmplY3RNb2RlIiwiZW5kZWQiLCJlbmRFbWl0dGVkIiwicmVhZGluZyIsImNvbnN0cnVjdGVkIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiZXJyb3JFbWl0dGVkIiwiZW1pdENsb3NlIiwiYXV0b0Rlc3Ryb3kiLCJkZXN0cm95ZWQiLCJjbG9zZWQiLCJjbG9zZUVtaXR0ZWQiLCJtdWx0aUF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRhdGFFbWl0dGVkIiwib3B0aW9ucyIsInN0cmVhbSIsImlzRHVwbGV4IiwicmVhZGFibGVPYmplY3RNb2RlIiwiaGlnaFdhdGVyTWFyayIsImJ1ZmZlciIsImxlbmd0aCIsInBpcGVzIiwiZmxvd2luZyIsImVycm9yZWQiLCJkZWZhdWx0RW5jb2RpbmciLCJhd2FpdERyYWluV3JpdGVycyIsImRlY29kZXIiLCJlbmNvZGluZyIsIl9yZWFkYWJsZVN0YXRlIiwicmVhZCIsIl9yZWFkIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiY29uc3RydWN0IiwiX2NvbnN0cnVjdCIsInNpZ25hbCIsImNhbGwiLCJtYXliZVJlYWRNb3JlIiwiX3VuZGVzdHJveSIsInVuZGVzdHJveSIsImVyciIsImNiIiwiY2FwdHVyZVJlamVjdGlvblN5bWJvbCIsImVycm9yIiwicmVhZGFibGVFbmRlZCIsInJlc29sdmUiLCJyZWplY3QiLCJwdXNoIiwiY2h1bmsiLCJyZWFkYWJsZUFkZENodW5rIiwidW5zaGlmdCIsImFkZFRvRnJvbnQiLCJ0b1N0cmluZyIsIl9pc1VpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwib25Fb2ZDaHVuayIsImFkZENodW5rIiwid3JpdGUiLCJsaXN0ZW5lckNvdW50IiwiY2xlYXIiLCJlbWl0IiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsImVuYyIsImNvbnRlbnQiLCJkYXRhIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwibiIsImhvd011Y2hUb1JlYWQiLCJmaXJzdCIsInVuZGVmaW5lZCIsIk5hTiIsIm5PcmlnIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJyZXQiLCJmcm9tTGlzdCIsImVuZCIsImVtaXRSZWFkYWJsZV8iLCJuZXh0VGljayIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsImxlbiIsInBpcGUiLCJkZXN0IiwicGlwZU9wdHMiLCJzcmMiLCJkb0VuZCIsInN0ZG91dCIsInN0ZGVyciIsImVuZEZuIiwib25lbmQiLCJ1bnBpcGUiLCJvbmNlIiwib24iLCJvbnVucGlwZSIsInJlYWRhYmxlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJjbGVhbnVwIiwib25kcmFpbiIsImNsZWFuZWRVcCIsInJlbW92ZUxpc3RlbmVyIiwib25jbG9zZSIsIm9uZmluaXNoIiwib25lcnJvciIsIm9uZGF0YSIsIl93cml0YWJsZVN0YXRlIiwibmVlZERyYWluIiwicGF1c2UiLCJpbmNsdWRlcyIsInNpemUiLCJhZGQiLCJwaXBlT25EcmFpbiIsImVyIiwicyIsIndyaXRhYmxlTmVlZERyYWluIiwicmVzdW1lIiwicGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCIsImRlbGV0ZSIsImRlc3RzIiwiaSIsImluZGV4Iiwic3BsaWNlIiwiZXYiLCJyZXMiLCJuUmVhZGluZ05leHRUaWNrIiwiYWRkTGlzdGVuZXIiLCJ1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsImFwcGx5IiwiYXJndW1lbnRzIiwic2VsZiIsInJlc3VtZV8iLCJ3cmFwIiwicGF1c2VkIiwic3RyZWFtS2V5cyIsImoiLCJiaW5kIiwic3RyZWFtVG9Bc3luY0l0ZXJhdG9yIiwiaXRlcmF0b3IiLCJpdGVyIiwiY3JlYXRlQXN5bmNJdGVyYXRvciIsImNhbGxiYWNrIiwibmV4dCIsIndyaXRhYmxlIiwiZGVzdHJveU9uUmV0dXJuIiwiZGVzdHJveWVyIiwiX19wcm90b19fIiwiciIsInZhbCIsInJlYWRhYmxlRGlkUmVhZCIsInJlYWRhYmxlQWJvcnRlZCIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsInJlYWRhYmxlQnVmZmVyIiwicmVhZGFibGVGbG93aW5nIiwicmVhZGFibGVMZW5ndGgiLCJyZWFkYWJsZUVuY29kaW5nIiwicGlwZXNDb3VudCIsIl9mcm9tTGlzdCIsInNoaWZ0Iiwiam9pbiIsImNvbmNhdCIsImNvbnN1bWUiLCJlbmRSZWFkYWJsZU5UIiwiYWxsb3dIYWxmT3BlbiIsImVuZFdyaXRhYmxlTlQiLCJ3U3RhdGUiLCJmaW5pc2hlZCIsIndyaXRhYmxlRW5kZWQiLCJpdGVyYWJsZSIsIm9wdHMiLCJ3ZWJTdHJlYW1zQWRhcHRlcnMiLCJsYXp5V2ViU3RyZWFtcyIsImZyb21XZWIiLCJyZWFkYWJsZVN0cmVhbSIsIm5ld1N0cmVhbVJlYWRhYmxlRnJvbVJlYWRhYmxlU3RyZWFtIiwidG9XZWIiLCJzdHJlYW1SZWFkYWJsZSIsIm5ld1JlYWRhYmxlU3RyZWFtRnJvbVN0cmVhbVJlYWRhYmxlIiwiX3JlZiIsIl9zcmMkcmVhZGFibGVPYmplY3RNbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { MathFloor, NumberIsInteger } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { validateInteger } = __webpack_require__(/*! ../validators */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js\");\nconst { ERR_INVALID_ARG_VALUE } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\").codes);\nlet defaultHighWaterMarkBytes = 16 * 1024;\nlet defaultHighWaterMarkObjectMode = 16;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getDefaultHighWaterMark(objectMode) {\n    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;\n}\nfunction setDefaultHighWaterMark(objectMode, value) {\n    validateInteger(value, \"value\", 0);\n    if (objectMode) {\n        defaultHighWaterMarkObjectMode = value;\n    } else {\n        defaultHighWaterMarkBytes = value;\n    }\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n    if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n            const name = isDuplex ? `options.${duplexKey}` : \"options.highWaterMark\";\n            throw new ERR_INVALID_ARG_VALUE(name, hwm);\n        }\n        return MathFloor(hwm);\n    }\n    // Default value\n    return getDefaultHighWaterMark(state.objectMode);\n}\nmodule.exports = {\n    getHighWaterMark,\n    getDefaultHighWaterMark,\n    setDefaultHighWaterMark\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFQyxlQUFlLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDL0MsTUFBTSxFQUFFQyxlQUFlLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDcEMsTUFBTSxFQUFFRSxxQkFBcUIsRUFBRSxHQUFHRix1SkFBa0M7QUFDcEUsSUFBSUksNEJBQTRCLEtBQUs7QUFDckMsSUFBSUMsaUNBQWlDO0FBQ3JDLFNBQVNDLGtCQUFrQkMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLFNBQVM7SUFDckQsT0FBT0YsUUFBUUcsYUFBYSxJQUFJLE9BQU9ILFFBQVFHLGFBQWEsR0FBR0YsV0FBV0QsT0FBTyxDQUFDRSxVQUFVLEdBQUc7QUFDakc7QUFDQSxTQUFTRSx3QkFBd0JDLFVBQVU7SUFDekMsT0FBT0EsYUFBYVAsaUNBQWlDRDtBQUN2RDtBQUNBLFNBQVNTLHdCQUF3QkQsVUFBVSxFQUFFRSxLQUFLO0lBQ2hEYixnQkFBZ0JhLE9BQU8sU0FBUztJQUNoQyxJQUFJRixZQUFZO1FBQ2RQLGlDQUFpQ1M7SUFDbkMsT0FBTztRQUNMViw0QkFBNEJVO0lBQzlCO0FBQ0Y7QUFDQSxTQUFTQyxpQkFBaUJDLEtBQUssRUFBRVQsT0FBTyxFQUFFRSxTQUFTLEVBQUVELFFBQVE7SUFDM0QsTUFBTVMsTUFBTVgsa0JBQWtCQyxTQUFTQyxVQUFVQztJQUNqRCxJQUFJUSxPQUFPLE1BQU07UUFDZixJQUFJLENBQUNsQixnQkFBZ0JrQixRQUFRQSxNQUFNLEdBQUc7WUFDcEMsTUFBTUMsT0FBT1YsV0FBVyxDQUFDLFFBQVEsRUFBRUMsVUFBVSxDQUFDLEdBQUc7WUFDakQsTUFBTSxJQUFJUCxzQkFBc0JnQixNQUFNRDtRQUN4QztRQUNBLE9BQU9uQixVQUFVbUI7SUFDbkI7SUFFQSxnQkFBZ0I7SUFDaEIsT0FBT04sd0JBQXdCSyxNQUFNSixVQUFVO0FBQ2pEO0FBQ0FPLE9BQU9DLE9BQU8sR0FBRztJQUNmTDtJQUNBSjtJQUNBRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanM/MjdhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBNYXRoRmxvb3IsIE51bWJlcklzSW50ZWdlciB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IHZhbGlkYXRlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19WQUxVRSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKS5jb2Rlc1xubGV0IGRlZmF1bHRIaWdoV2F0ZXJNYXJrQnl0ZXMgPSAxNiAqIDEwMjRcbmxldCBkZWZhdWx0SGlnaFdhdGVyTWFya09iamVjdE1vZGUgPSAxNlxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGxcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKG9iamVjdE1vZGUpIHtcbiAgcmV0dXJuIG9iamVjdE1vZGUgPyBkZWZhdWx0SGlnaFdhdGVyTWFya09iamVjdE1vZGUgOiBkZWZhdWx0SGlnaFdhdGVyTWFya0J5dGVzXG59XG5mdW5jdGlvbiBzZXREZWZhdWx0SGlnaFdhdGVyTWFyayhvYmplY3RNb2RlLCB2YWx1ZSkge1xuICB2YWxpZGF0ZUludGVnZXIodmFsdWUsICd2YWx1ZScsIDApXG4gIGlmIChvYmplY3RNb2RlKSB7XG4gICAgZGVmYXVsdEhpZ2hXYXRlck1hcmtPYmplY3RNb2RlID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0SGlnaFdhdGVyTWFya0J5dGVzID0gdmFsdWVcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICBjb25zdCBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KVxuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlcklzSW50ZWdlcihod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpc0R1cGxleCA/IGBvcHRpb25zLiR7ZHVwbGV4S2V5fWAgOiAnb3B0aW9ucy5oaWdoV2F0ZXJNYXJrJ1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShuYW1lLCBod20pXG4gICAgfVxuICAgIHJldHVybiBNYXRoRmxvb3IoaHdtKVxuICB9XG5cbiAgLy8gRGVmYXVsdCB2YWx1ZVxuICByZXR1cm4gZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsoc3RhdGUub2JqZWN0TW9kZSlcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrLFxuICBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayxcbiAgc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmtcbn1cbiJdLCJuYW1lcyI6WyJNYXRoRmxvb3IiLCJOdW1iZXJJc0ludGVnZXIiLCJyZXF1aXJlIiwidmFsaWRhdGVJbnRlZ2VyIiwiRVJSX0lOVkFMSURfQVJHX1ZBTFVFIiwiY29kZXMiLCJkZWZhdWx0SGlnaFdhdGVyTWFya0J5dGVzIiwiZGVmYXVsdEhpZ2hXYXRlck1hcmtPYmplY3RNb2RlIiwiaGlnaFdhdGVyTWFya0Zyb20iLCJvcHRpb25zIiwiaXNEdXBsZXgiLCJkdXBsZXhLZXkiLCJoaWdoV2F0ZXJNYXJrIiwiZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsiLCJvYmplY3RNb2RlIiwic2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsiLCJ2YWx1ZSIsImdldEhpZ2hXYXRlck1hcmsiLCJzdGF0ZSIsImh3bSIsIm5hbWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/transform.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/transform.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nconst { ObjectSetPrototypeOf, Symbol } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nmodule.exports = Transform;\nconst { ERR_METHOD_NOT_IMPLEMENTED } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\").codes);\nconst Duplex = __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\nconst { getHighWaterMark } = __webpack_require__(/*! ./state */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js\");\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);\nObjectSetPrototypeOf(Transform, Duplex);\nconst kCallback = Symbol(\"kCallback\");\nfunction Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    // TODO (ronag): This should preferably always be\n    // applied but would be semver-major. Or even better;\n    // make Transform a Readable with the Writable interface.\n    const readableHighWaterMark = options ? getHighWaterMark(this, options, \"readableHighWaterMark\", true) : null;\n    if (readableHighWaterMark === 0) {\n        // A Duplex will buffer both on the writable and readable side while\n        // a Transform just wants to buffer hwm number of elements. To avoid\n        // buffering twice we disable buffering on the writable side.\n        options = {\n            ...options,\n            highWaterMark: null,\n            readableHighWaterMark,\n            // TODO (ronag): 0 is not optimal since we have\n            // a \"bug\" where we check needDrain before calling _write and not after.\n            // Refs: https://github.com/nodejs/node/pull/32887\n            // Refs: https://github.com/nodejs/node/pull/35941\n            writableHighWaterMark: options.writableHighWaterMark || 0\n        };\n    }\n    Duplex.call(this, options);\n    // We have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n    this[kCallback] = null;\n    if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n    }\n    // When the writable side finishes, then flush out anything remaining.\n    // Backwards compat. Some Transform streams incorrectly implement _final\n    // instead of or in addition to _flush. By using 'prefinish' instead of\n    // implementing _final we continue supporting this unfortunate use case.\n    this.on(\"prefinish\", prefinish);\n}\nfunction final(cb) {\n    if (typeof this._flush === \"function\" && !this.destroyed) {\n        this._flush((er, data)=>{\n            if (er) {\n                if (cb) {\n                    cb(er);\n                } else {\n                    this.destroy(er);\n                }\n                return;\n            }\n            if (data != null) {\n                this.push(data);\n            }\n            this.push(null);\n            if (cb) {\n                cb();\n            }\n        });\n    } else {\n        this.push(null);\n        if (cb) {\n            cb();\n        }\n    }\n}\nfunction prefinish() {\n    if (this._final !== final) {\n        final.call(this);\n    }\n}\nTransform.prototype._final = final;\nTransform.prototype._transform = function(chunk, encoding, callback) {\n    throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n};\nTransform.prototype._write = function(chunk, encoding, callback) {\n    const rState = this._readableState;\n    const wState = this._writableState;\n    const length = rState.length;\n    this._transform(chunk, encoding, (err, val)=>{\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (val != null) {\n            this.push(val);\n        }\n        if (wState.ended || // Backwards compat.\n        length === rState.length || // Backwards compat.\n        rState.length < rState.highWaterMark) {\n            callback();\n        } else {\n            this[kCallback] = callback;\n        }\n    });\n};\nTransform.prototype._read = function() {\n    if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null;\n        callback();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0uanMiLCJtYXBwaW5ncyI6IkFBQUEsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUV6QyxnRUFBZ0U7QUFDaEUsOERBQThEO0FBQzlELHVFQUF1RTtBQUN2RSxzRUFBc0U7QUFDdEUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRixnRUFBZ0U7QUFDaEUscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSwwREFBMEQ7QUFDMUQsRUFBRTtBQUNGLHlCQUF5QjtBQUN6QixFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHNFQUFzRTtBQUN0RSxtRUFBbUU7QUFDbkUsZ0VBQWdFO0FBQ2hFLG9EQUFvRDtBQUNwRCxFQUFFO0FBQ0YsdUVBQXVFO0FBQ3ZFLG9FQUFvRTtBQUNwRSxxRUFBcUU7QUFDckUsdUVBQXVFO0FBQ3ZFLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEUsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLG9FQUFvRTtBQUNwRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEUscUVBQXFFO0FBQ3JFLG9FQUFvRTtBQUNwRSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSx5RUFBeUU7QUFD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LENBQUNwQixjQUFjO0lBQ2xDLE1BQU1xQixTQUFTLElBQUksQ0FBQ0MsY0FBYztJQUNsQyxNQUFNQyxTQUFTSCxPQUFPRyxNQUFNO0lBQzVCLElBQUksQ0FBQ3BCLFVBQVUsQ0FBQ2EsT0FBT0MsVUFBVSxDQUFDTyxLQUFLQztRQUNyQyxJQUFJRCxLQUFLO1lBQ1BOLFNBQVNNO1lBQ1Q7UUFDRjtRQUNBLElBQUlDLE9BQU8sTUFBTTtZQUNmLElBQUksQ0FBQ1gsSUFBSSxDQUFDVztRQUNaO1FBQ0EsSUFDRUosT0FBT0ssS0FBSyxJQUNaLG9CQUFvQjtRQUNwQkgsV0FBV0gsT0FBT0csTUFBTSxJQUN4QixvQkFBb0I7UUFDcEJILE9BQU9HLE1BQU0sR0FBR0gsT0FBT3ZCLGFBQWEsRUFDcEM7WUFDQXFCO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQ3hCLFVBQVUsR0FBR3dCO1FBQ3BCO0lBQ0Y7QUFDRjtBQUNBOUIsVUFBVUssU0FBUyxDQUFDa0MsS0FBSyxHQUFHO0lBQzFCLElBQUksSUFBSSxDQUFDakMsVUFBVSxFQUFFO1FBQ25CLE1BQU13QixXQUFXLElBQUksQ0FBQ3hCLFVBQVU7UUFDaEMsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEJ3QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0uanM/ZDM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBPYmplY3RTZXRQcm90b3R5cGVPZiwgU3ltYm9sIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtXG5jb25zdCB7IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpLmNvZGVzXG5jb25zdCBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleCcpXG5jb25zdCB7IGdldEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtLnByb3RvdHlwZSwgRHVwbGV4LnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFRyYW5zZm9ybSwgRHVwbGV4KVxuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdrQ2FsbGJhY2snKVxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgLy8gVE9ETyAocm9uYWcpOiBUaGlzIHNob3VsZCBwcmVmZXJhYmx5IGFsd2F5cyBiZVxuICAvLyBhcHBsaWVkIGJ1dCB3b3VsZCBiZSBzZW12ZXItbWFqb3IuIE9yIGV2ZW4gYmV0dGVyO1xuICAvLyBtYWtlIFRyYW5zZm9ybSBhIFJlYWRhYmxlIHdpdGggdGhlIFdyaXRhYmxlIGludGVyZmFjZS5cbiAgY29uc3QgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucyA/IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHRydWUpIDogbnVsbFxuICBpZiAocmVhZGFibGVIaWdoV2F0ZXJNYXJrID09PSAwKSB7XG4gICAgLy8gQSBEdXBsZXggd2lsbCBidWZmZXIgYm90aCBvbiB0aGUgd3JpdGFibGUgYW5kIHJlYWRhYmxlIHNpZGUgd2hpbGVcbiAgICAvLyBhIFRyYW5zZm9ybSBqdXN0IHdhbnRzIHRvIGJ1ZmZlciBod20gbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyBhdm9pZFxuICAgIC8vIGJ1ZmZlcmluZyB0d2ljZSB3ZSBkaXNhYmxlIGJ1ZmZlcmluZyBvbiB0aGUgd3JpdGFibGUgc2lkZS5cbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhpZ2hXYXRlck1hcms6IG51bGwsXG4gICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcmssXG4gICAgICAvLyBUT0RPIChyb25hZyk6IDAgaXMgbm90IG9wdGltYWwgc2luY2Ugd2UgaGF2ZVxuICAgICAgLy8gYSBcImJ1Z1wiIHdoZXJlIHdlIGNoZWNrIG5lZWREcmFpbiBiZWZvcmUgY2FsbGluZyBfd3JpdGUgYW5kIG5vdCBhZnRlci5cbiAgICAgIC8vIFJlZnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyODg3XG4gICAgICAvLyBSZWZzOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNTk0MVxuICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyayB8fCAwXG4gICAgfVxuICB9XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpXG5cbiAgLy8gV2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZVxuICB0aGlzW2tDYWxsYmFja10gPSBudWxsXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaFxuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICAvLyBCYWNrd2FyZHMgY29tcGF0LiBTb21lIFRyYW5zZm9ybSBzdHJlYW1zIGluY29ycmVjdGx5IGltcGxlbWVudCBfZmluYWxcbiAgLy8gaW5zdGVhZCBvZiBvciBpbiBhZGRpdGlvbiB0byBfZmx1c2guIEJ5IHVzaW5nICdwcmVmaW5pc2gnIGluc3RlYWQgb2ZcbiAgLy8gaW1wbGVtZW50aW5nIF9maW5hbCB3ZSBjb250aW51ZSBzdXBwb3J0aW5nIHRoaXMgdW5mb3J0dW5hdGUgdXNlIGNhc2UuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaClcbn1cbmZ1bmN0aW9uIGZpbmFsKGNiKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goKGVyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSlcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMucHVzaChudWxsKVxuICAgIGlmIChjYikge1xuICAgICAgY2IoKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICBpZiAodGhpcy5fZmluYWwgIT09IGZpbmFsKSB7XG4gICAgZmluYWwuY2FsbCh0aGlzKVxuICB9XG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9maW5hbCA9IGZpbmFsXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aHJvdyBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpXG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJTdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgd1N0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCBsZW5ndGggPSByU3RhdGUubGVuZ3RoXG4gIHRoaXMuX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIChlcnIsIHZhbCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIHRoaXMucHVzaCh2YWwpXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHdTdGF0ZS5lbmRlZCB8fFxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdC5cbiAgICAgIGxlbmd0aCA9PT0gclN0YXRlLmxlbmd0aCB8fFxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdC5cbiAgICAgIHJTdGF0ZS5sZW5ndGggPCByU3RhdGUuaGlnaFdhdGVyTWFya1xuICAgICkge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tDYWxsYmFja10gPSBjYWxsYmFja1xuICAgIH1cbiAgfSlcbn1cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzW2tDYWxsYmFja10pIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXNba0NhbGxiYWNrXVxuICAgIHRoaXNba0NhbGxiYWNrXSA9IG51bGxcbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJPYmplY3RTZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiVHJhbnNmb3JtIiwiRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQiLCJjb2RlcyIsIkR1cGxleCIsImdldEhpZ2hXYXRlck1hcmsiLCJwcm90b3R5cGUiLCJrQ2FsbGJhY2siLCJvcHRpb25zIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwiaGlnaFdhdGVyTWFyayIsIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsImNhbGwiLCJfcmVhZGFibGVTdGF0ZSIsInN5bmMiLCJ0cmFuc2Zvcm0iLCJfdHJhbnNmb3JtIiwiZmx1c2giLCJfZmx1c2giLCJvbiIsInByZWZpbmlzaCIsImZpbmFsIiwiY2IiLCJkZXN0cm95ZWQiLCJlciIsImRhdGEiLCJkZXN0cm95IiwicHVzaCIsIl9maW5hbCIsImNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsIl93cml0ZSIsInJTdGF0ZSIsIndTdGF0ZSIsIl93cml0YWJsZVN0YXRlIiwibGVuZ3RoIiwiZXJyIiwidmFsIiwiZW5kZWQiLCJfcmVhZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/transform.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js":
/*!************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { SymbolAsyncIterator, SymbolIterator, SymbolFor } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor(\"nodejs.stream.destroyed\");\nconst kIsErrored = SymbolFor(\"nodejs.stream.errored\");\nconst kIsReadable = SymbolFor(\"nodejs.stream.readable\");\nconst kIsWritable = SymbolFor(\"nodejs.stream.writable\");\nconst kIsDisturbed = SymbolFor(\"nodejs.stream.disturbed\");\nconst kIsClosedPromise = SymbolFor(\"nodejs.webstream.isClosedPromise\");\nconst kControllerErrorFunction = SymbolFor(\"nodejs.webstream.controllerErrorFunction\");\nfunction isReadableNodeStream(obj, strict = false) {\n    var _obj$_readableState;\n    return !!(obj && typeof obj.pipe === \"function\" && typeof obj.on === \"function\" && (!strict || typeof obj.pause === \"function\" && typeof obj.resume === \"function\") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && // Duplex\n    (!obj._writableState || obj._readableState) // Writable has .pipe.\n    );\n}\nfunction isWritableNodeStream(obj) {\n    var _obj$_writableState;\n    return !!(obj && typeof obj.write === \"function\" && typeof obj.on === \"function\" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false) // Duplex\n    );\n}\nfunction isDuplexNodeStream(obj) {\n    return !!(obj && typeof obj.pipe === \"function\" && obj._readableState && typeof obj.on === \"function\" && typeof obj.write === \"function\");\n}\nfunction isNodeStream(obj) {\n    return obj && (obj._readableState || obj._writableState || typeof obj.write === \"function\" && typeof obj.on === \"function\" || typeof obj.pipe === \"function\" && typeof obj.on === \"function\");\n}\nfunction isReadableStream(obj) {\n    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === \"function\" && typeof obj.getReader === \"function\" && typeof obj.cancel === \"function\");\n}\nfunction isWritableStream(obj) {\n    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === \"function\" && typeof obj.abort === \"function\");\n}\nfunction isTransformStream(obj) {\n    return !!(obj && !isNodeStream(obj) && typeof obj.readable === \"object\" && typeof obj.writable === \"object\");\n}\nfunction isWebStream(obj) {\n    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);\n}\nfunction isIterable(obj, isAsync) {\n    if (obj == null) return false;\n    if (isAsync === true) return typeof obj[SymbolAsyncIterator] === \"function\";\n    if (isAsync === false) return typeof obj[SymbolIterator] === \"function\";\n    return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n}\nfunction isDestroyed(stream) {\n    if (!isNodeStream(stream)) return null;\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    const state = wState || rState;\n    return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);\n}\n// Have been end():d.\nfunction isWritableEnded(stream) {\n    if (!isWritableNodeStream(stream)) return null;\n    if (stream.writableEnded === true) return true;\n    const wState = stream._writableState;\n    if (wState !== null && wState !== undefined && wState.errored) return false;\n    if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== \"boolean\") return null;\n    return wState.ended;\n}\n// Have emitted 'finish'.\nfunction isWritableFinished(stream, strict) {\n    if (!isWritableNodeStream(stream)) return null;\n    if (stream.writableFinished === true) return true;\n    const wState = stream._writableState;\n    if (wState !== null && wState !== undefined && wState.errored) return false;\n    if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== \"boolean\") return null;\n    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);\n}\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n    if (!isReadableNodeStream(stream)) return null;\n    if (stream.readableEnded === true) return true;\n    const rState = stream._readableState;\n    if (!rState || rState.errored) return false;\n    if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== \"boolean\") return null;\n    return rState.ended;\n}\n// Have emitted 'end'.\nfunction isReadableFinished(stream, strict) {\n    if (!isReadableNodeStream(stream)) return null;\n    const rState = stream._readableState;\n    if (rState !== null && rState !== undefined && rState.errored) return false;\n    if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== \"boolean\") return null;\n    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);\n}\nfunction isReadable(stream) {\n    if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n    if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== \"boolean\") return null;\n    if (isDestroyed(stream)) return false;\n    return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n}\nfunction isWritable(stream) {\n    if (stream && stream[kIsWritable] != null) return stream[kIsWritable];\n    if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== \"boolean\") return null;\n    if (isDestroyed(stream)) return false;\n    return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n}\nfunction isFinished(stream, opts) {\n    if (!isNodeStream(stream)) {\n        return null;\n    }\n    if (isDestroyed(stream)) {\n        return true;\n    }\n    if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {\n        return false;\n    }\n    if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {\n        return false;\n    }\n    return true;\n}\nfunction isWritableErrored(stream) {\n    var _stream$_writableStat, _stream$_writableStat2;\n    if (!isNodeStream(stream)) {\n        return null;\n    }\n    if (stream.writableErrored) {\n        return stream.writableErrored;\n    }\n    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;\n}\nfunction isReadableErrored(stream) {\n    var _stream$_readableStat, _stream$_readableStat2;\n    if (!isNodeStream(stream)) {\n        return null;\n    }\n    if (stream.readableErrored) {\n        return stream.readableErrored;\n    }\n    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;\n}\nfunction isClosed(stream) {\n    if (!isNodeStream(stream)) {\n        return null;\n    }\n    if (typeof stream.closed === \"boolean\") {\n        return stream.closed;\n    }\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === \"boolean\" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === \"boolean\") {\n        return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);\n    }\n    if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream)) {\n        return stream._closed;\n    }\n    return null;\n}\nfunction isOutgoingMessage(stream) {\n    return typeof stream._closed === \"boolean\" && typeof stream._defaultKeepAlive === \"boolean\" && typeof stream._removedConnection === \"boolean\" && typeof stream._removedContLen === \"boolean\";\n}\nfunction isServerResponse(stream) {\n    return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n}\nfunction isServerRequest(stream) {\n    var _stream$req;\n    return typeof stream._consuming === \"boolean\" && typeof stream._dumped === \"boolean\" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;\n}\nfunction willEmitClose(stream) {\n    if (!isNodeStream(stream)) return null;\n    const wState = stream._writableState;\n    const rState = stream._readableState;\n    const state = wState || rState;\n    return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);\n}\nfunction isDisturbed(stream) {\n    var _stream$kIsDisturbed;\n    return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));\n}\nfunction isErrored(stream) {\n    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;\n    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));\n}\nmodule.exports = {\n    isDestroyed,\n    kIsDestroyed,\n    isDisturbed,\n    kIsDisturbed,\n    isErrored,\n    kIsErrored,\n    isReadable,\n    kIsReadable,\n    kIsClosedPromise,\n    kControllerErrorFunction,\n    kIsWritable,\n    isClosed,\n    isDuplexNodeStream,\n    isFinished,\n    isIterable,\n    isReadableNodeStream,\n    isReadableStream,\n    isReadableEnded,\n    isReadableFinished,\n    isReadableErrored,\n    isNodeStream,\n    isWebStream,\n    isWritable,\n    isWritableNodeStream,\n    isWritableStream,\n    isWritableEnded,\n    isWritableFinished,\n    isWritableErrored,\n    isServerRequest,\n    isServerResponse,\n    willEmitClose,\n    isTransformStream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsbUJBQW1CLEVBQUVDLGNBQWMsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRW5FLDREQUE0RDtBQUM1RCwwREFBMEQ7QUFDMUQsNkRBQTZEO0FBQzdELCtDQUErQztBQUMvQyxNQUFNQyxlQUFlRixVQUFVO0FBQy9CLE1BQU1HLGFBQWFILFVBQVU7QUFDN0IsTUFBTUksY0FBY0osVUFBVTtBQUM5QixNQUFNSyxjQUFjTCxVQUFVO0FBQzlCLE1BQU1NLGVBQWVOLFVBQVU7QUFDL0IsTUFBTU8sbUJBQW1CUCxVQUFVO0FBQ25DLE1BQU1RLDJCQUEyQlIsVUFBVTtBQUMzQyxTQUFTUyxxQkFBcUJDLEdBQUcsRUFBRUMsU0FBUyxLQUFLO0lBQy9DLElBQUlDO0lBQ0osT0FBTyxDQUFDLENBRUpGLENBQUFBLE9BQ0EsT0FBT0EsSUFBSUcsSUFBSSxLQUFLLGNBQ3BCLE9BQU9ILElBQUlJLEVBQUUsS0FBSyxjQUNqQixFQUFDSCxVQUFXLE9BQU9ELElBQUlLLEtBQUssS0FBSyxjQUFjLE9BQU9MLElBQUlNLE1BQU0sS0FBSyxVQUFVLEtBQy9FLEVBQUNOLElBQUlPLGNBQWMsSUFDbEIsQ0FBQyxDQUFDTCxzQkFBc0JGLElBQUlRLGNBQWMsTUFBTSxRQUFRTix3QkFBd0JPLFlBQzVFQSxZQUNBUCxvQkFBb0JRLFFBQVEsTUFBTSxLQUFJLEtBQzVDLFNBQVM7SUFDUixFQUFDVixJQUFJTyxjQUFjLElBQUlQLElBQUlRLGNBQWMsRUFDMUMsc0JBQXNCO0lBRG9CO0FBR2hEO0FBRUEsU0FBU0cscUJBQXFCWCxHQUFHO0lBQy9CLElBQUlZO0lBQ0osT0FBTyxDQUFDLENBRUpaLENBQUFBLE9BQ0EsT0FBT0Es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QUF5QjNELE9BQU90QixjQUFjLE1BQU0sUUFBUWlGLDJCQUEyQi9FLFlBQ3hGQSxZQUNBK0UsdUJBQXVCRyxZQUFZLE1BQU0sUUFBUVQsVUFBVXpFLFlBQzdEeUUsUUFDQSxDQUFDTyx5QkFBeUI1RCxPQUFPckIsY0FBYyxNQUFNLFFBQVFpRiwyQkFBMkJoRixZQUN4RkEsWUFDQWdGLHVCQUF1QnJELE9BQU8sTUFBTSxRQUFRNkMsU0FBU3hFLFlBQ3ZEd0UsT0FDQSxDQUFDUyx5QkFBeUI3RCxPQUFPdEIsY0FBYyxNQUFNLFFBQVFtRiwyQkFBMkJqRixZQUN4RkEsWUFDQWlGLHVCQUF1QnRELE9BQU87QUFFdEM7QUFDQXdELE9BQU9DLE9BQU8sR0FBRztJQUNmakU7SUFDQXBDO0lBQ0FvRjtJQUNBaEY7SUFDQW9GO0lBQ0F2RjtJQUNBcUQ7SUFDQXBEO0lBQ0FHO0lBQ0FDO0lBQ0FIO0lBQ0ErRDtJQUNBM0M7SUFDQWlDO0lBQ0F0QjtJQUNBM0I7SUFDQWtCO0lBQ0F5QjtJQUNBRTtJQUNBVTtJQUNBdEM7SUFDQVM7SUFDQXNCO0lBQ0FwQztJQUNBVTtJQUNBYTtJQUNBSTtJQUNBWTtJQUNBaUI7SUFDQUY7SUFDQVE7SUFDQWpEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy91dGlscy5qcz9lMGMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFN5bWJvbEFzeW5jSXRlcmF0b3IsIFN5bWJvbEl0ZXJhdG9yLCBTeW1ib2xGb3IgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuXG4vLyBXZSBuZWVkIHRvIHVzZSBTeW1ib2xGb3IgdG8gbWFrZSB0aGVzZSBnbG9iYWxseSBhdmFpbGFibGVcbi8vIGZvciBpbnRlcm9wdCB3aXRoIHJlYWRhYmxlLXN0cmVhbSwgaS5lLiByZWFkYWJsZS1zdHJlYW1cbi8vIGFuZCBub2RlIGNvcmUgbmVlZHMgdG8gYmUgYWJsZSB0byByZWFkL3dyaXRlIHByaXZhdGUgc3RhdGVcbi8vIGZyb20gZWFjaCBvdGhlciBmb3IgcHJvcGVyIGludGVyb3BlcmFiaWxpdHkuXG5jb25zdCBrSXNEZXN0cm95ZWQgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0uZGVzdHJveWVkJylcbmNvbnN0IGtJc0Vycm9yZWQgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0uZXJyb3JlZCcpXG5jb25zdCBrSXNSZWFkYWJsZSA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS5yZWFkYWJsZScpXG5jb25zdCBrSXNXcml0YWJsZSA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS53cml0YWJsZScpXG5jb25zdCBrSXNEaXN0dXJiZWQgPSBTeW1ib2xGb3IoJ25vZGVqcy5zdHJlYW0uZGlzdHVyYmVkJylcbmNvbnN0IGtJc0Nsb3NlZFByb21pc2UgPSBTeW1ib2xGb3IoJ25vZGVqcy53ZWJzdHJlYW0uaXNDbG9zZWRQcm9taXNlJylcbmNvbnN0IGtDb250cm9sbGVyRXJyb3JGdW5jdGlvbiA9IFN5bWJvbEZvcignbm9kZWpzLndlYnN0cmVhbS5jb250cm9sbGVyRXJyb3JGdW5jdGlvbicpXG5mdW5jdGlvbiBpc1JlYWRhYmxlTm9kZVN0cmVhbShvYmosIHN0cmljdCA9IGZhbHNlKSB7XG4gIHZhciBfb2JqJF9yZWFkYWJsZVN0YXRlXG4gIHJldHVybiAhIShcbiAgICAoXG4gICAgICBvYmogJiZcbiAgICAgIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIG9iai5vbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKCFzdHJpY3QgfHwgKHR5cGVvZiBvYmoucGF1c2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5yZXN1bWUgPT09ICdmdW5jdGlvbicpKSAmJlxuICAgICAgKCFvYmouX3dyaXRhYmxlU3RhdGUgfHxcbiAgICAgICAgKChfb2JqJF9yZWFkYWJsZVN0YXRlID0gb2JqLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfb2JqJF9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogX29iaiRfcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSkgIT09IGZhbHNlKSAmJlxuICAgICAgLy8gRHVwbGV4XG4gICAgICAoIW9iai5fd3JpdGFibGVTdGF0ZSB8fCBvYmouX3JlYWRhYmxlU3RhdGUpXG4gICAgKSAvLyBXcml0YWJsZSBoYXMgLnBpcGUuXG4gIClcbn1cblxuZnVuY3Rpb24gaXNXcml0YWJsZU5vZGVTdHJlYW0ob2JqKSB7XG4gIHZhciBfb2JqJF93cml0YWJsZVN0YXRlXG4gIHJldHVybiAhIShcbiAgICAoXG4gICAgICBvYmogJiZcbiAgICAgIHR5cGVvZiBvYmoud3JpdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICghb2JqLl9yZWFkYWJsZVN0YXRlIHx8XG4gICAgICAgICgoX29iaiRfd3JpdGFibGVTdGF0ZSA9IG9iai5fd3JpdGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX29iaiRfd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IF9vYmokX3dyaXRhYmxlU3RhdGUud3JpdGFibGUpICE9PSBmYWxzZSlcbiAgICApIC8vIER1cGxleFxuICApXG59XG5cbmZ1bmN0aW9uIGlzRHVwbGV4Tm9kZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKFxuICAgIG9iaiAmJlxuICAgIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIG9iai5fcmVhZGFibGVTdGF0ZSAmJlxuICAgIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqLndyaXRlID09PSAnZnVuY3Rpb24nXG4gIClcbn1cbmZ1bmN0aW9uIGlzTm9kZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuIChcbiAgICBvYmogJiZcbiAgICAob2JqLl9yZWFkYWJsZVN0YXRlIHx8XG4gICAgICBvYmouX3dyaXRhYmxlU3RhdGUgfHxcbiAgICAgICh0eXBlb2Ygb2JqLndyaXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAodHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicpKVxuICApXG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKG9iaikge1xuICByZXR1cm4gISEoXG4gICAgb2JqICYmXG4gICAgIWlzTm9kZVN0cmVhbShvYmopICYmXG4gICAgdHlwZW9mIG9iai5waXBlVGhyb3VnaCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iai5jYW5jZWwgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuZnVuY3Rpb24gaXNXcml0YWJsZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAmJiAhaXNOb2RlU3RyZWFtKG9iaikgJiYgdHlwZW9mIG9iai5nZXRXcml0ZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5hYm9ydCA9PT0gJ2Z1bmN0aW9uJylcbn1cbmZ1bmN0aW9uIGlzVHJhbnNmb3JtU3RyZWFtKG9iaikge1xuICByZXR1cm4gISEob2JqICYmICFpc05vZGVTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLnJlYWRhYmxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLndyaXRhYmxlID09PSAnb2JqZWN0Jylcbn1cbmZ1bmN0aW9uIGlzV2ViU3RyZWFtKG9iaikge1xuICByZXR1cm4gaXNSZWFkYWJsZVN0cmVhbShvYmopIHx8IGlzV3JpdGFibGVTdHJlYW0ob2JqKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShvYmopXG59XG5mdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaiwgaXNBc3luYykge1xuICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZVxuICBpZiAoaXNBc3luYyA9PT0gdHJ1ZSkgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbiAgaWYgKGlzQXN5bmMgPT09IGZhbHNlKSByZXR1cm4gdHlwZW9mIG9ialtTeW1ib2xJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbiAgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9ialtTeW1ib2xJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbn1cbmZ1bmN0aW9uIGlzRGVzdHJveWVkKHN0cmVhbSkge1xuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHN0YXRlID0gd1N0YXRlIHx8IHJTdGF0ZVxuICByZXR1cm4gISEoc3RyZWFtLmRlc3Ryb3llZCB8fCBzdHJlYW1ba0lzRGVzdHJveWVkXSB8fCAoc3RhdGUgIT09IG51bGwgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5kZXN0cm95ZWQpKVxufVxuXG4vLyBIYXZlIGJlZW4gZW5kKCk6ZC5cbmZ1bmN0aW9uIGlzV3JpdGFibGVFbmRlZChzdHJlYW0pIHtcbiAgaWYgKCFpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBpZiAoc3RyZWFtLndyaXRhYmxlRW5kZWQgPT09IHRydWUpIHJldHVybiB0cnVlXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAod1N0YXRlICE9PSBudWxsICYmIHdTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHdTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAod1N0YXRlID09PSBudWxsIHx8IHdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogd1N0YXRlLmVuZGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd1N0YXRlLmVuZGVkXG59XG5cbi8vIEhhdmUgZW1pdHRlZCAnZmluaXNoJy5cbmZ1bmN0aW9uIGlzV3JpdGFibGVGaW5pc2hlZChzdHJlYW0sIHN0cmljdCkge1xuICBpZiAoIWlzV3JpdGFibGVOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGlmIChzdHJlYW0ud3JpdGFibGVGaW5pc2hlZCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWVcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGlmICh3U3RhdGUgIT09IG51bGwgJiYgd1N0YXRlICE9PSB1bmRlZmluZWQgJiYgd1N0YXRlLmVycm9yZWQpIHJldHVybiBmYWxzZVxuICBpZiAodHlwZW9mICh3U3RhdGUgPT09IG51bGwgfHwgd1N0YXRlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB3U3RhdGUuZmluaXNoZWQpICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG4gIHJldHVybiAhISh3U3RhdGUuZmluaXNoZWQgfHwgKHN0cmljdCA9PT0gZmFsc2UgJiYgd1N0YXRlLmVuZGVkID09PSB0cnVlICYmIHdTdGF0ZS5sZW5ndGggPT09IDApKVxufVxuXG4vLyBIYXZlIGJlZW4gcHVzaChudWxsKTpkLlxuZnVuY3Rpb24gaXNSZWFkYWJsZUVuZGVkKHN0cmVhbSkge1xuICBpZiAoIWlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGlmIChzdHJlYW0ucmVhZGFibGVFbmRlZCA9PT0gdHJ1ZSkgcmV0dXJuIHRydWVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmICghclN0YXRlIHx8IHJTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmVuZGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gclN0YXRlLmVuZGVkXG59XG5cbi8vIEhhdmUgZW1pdHRlZCAnZW5kJy5cbmZ1bmN0aW9uIGlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0sIHN0cmljdCkge1xuICBpZiAoIWlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoclN0YXRlICE9PSBudWxsICYmIHJTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHJTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmVuZEVtaXR0ZWQpICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG4gIHJldHVybiAhIShyU3RhdGUuZW5kRW1pdHRlZCB8fCAoc3RyaWN0ID09PSBmYWxzZSAmJiByU3RhdGUuZW5kZWQgPT09IHRydWUgJiYgclN0YXRlLmxlbmd0aCA9PT0gMCkpXG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtICYmIHN0cmVhbVtrSXNSZWFkYWJsZV0gIT0gbnVsbCkgcmV0dXJuIHN0cmVhbVtrSXNSZWFkYWJsZV1cbiAgaWYgKHR5cGVvZiAoc3RyZWFtID09PSBudWxsIHx8IHN0cmVhbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc3RyZWFtLnJlYWRhYmxlKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICBpZiAoaXNEZXN0cm95ZWQoc3RyZWFtKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pICYmIHN0cmVhbS5yZWFkYWJsZSAmJiAhaXNSZWFkYWJsZUZpbmlzaGVkKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGUoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0gJiYgc3RyZWFtW2tJc1dyaXRhYmxlXSAhPSBudWxsKSByZXR1cm4gc3RyZWFtW2tJc1dyaXRhYmxlXVxuICBpZiAodHlwZW9mIChzdHJlYW0gPT09IG51bGwgfHwgc3RyZWFtID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzdHJlYW0ud3JpdGFibGUpICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG4gIGlmIChpc0Rlc3Ryb3llZChzdHJlYW0pKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGlzV3JpdGFibGVOb2RlU3RyZWFtKHN0cmVhbSkgJiYgc3RyZWFtLndyaXRhYmxlICYmICFpc1dyaXRhYmxlRW5kZWQoc3RyZWFtKVxufVxuZnVuY3Rpb24gaXNGaW5pc2hlZChzdHJlYW0sIG9wdHMpIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKGlzRGVzdHJveWVkKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICgob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRzLnJlYWRhYmxlKSAhPT0gZmFsc2UgJiYgaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdHMud3JpdGFibGUpICE9PSBmYWxzZSAmJiBpc1dyaXRhYmxlKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuZnVuY3Rpb24gaXNXcml0YWJsZUVycm9yZWQoc3RyZWFtKSB7XG4gIHZhciBfc3RyZWFtJF93cml0YWJsZVN0YXQsIF9zdHJlYW0kX3dyaXRhYmxlU3RhdDJcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHN0cmVhbS53cml0YWJsZUVycm9yZWQpIHtcbiAgICByZXR1cm4gc3RyZWFtLndyaXRhYmxlRXJyb3JlZFxuICB9XG4gIHJldHVybiAoX3N0cmVhbSRfd3JpdGFibGVTdGF0ID1cbiAgICAoX3N0cmVhbSRfd3JpdGFibGVTdGF0MiA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX3N0cmVhbSRfd3JpdGFibGVTdGF0MiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBfc3RyZWFtJF93cml0YWJsZVN0YXQyLmVycm9yZWQpICE9PSBudWxsICYmIF9zdHJlYW0kX3dyaXRhYmxlU3RhdCAhPT0gdW5kZWZpbmVkXG4gICAgPyBfc3RyZWFtJF93cml0YWJsZVN0YXRcbiAgICA6IG51bGxcbn1cbmZ1bmN0aW9uIGlzUmVhZGFibGVFcnJvcmVkKHN0cmVhbSkge1xuICB2YXIgX3N0cmVhbSRfcmVhZGFibGVTdGF0LCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQyXG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChzdHJlYW0ucmVhZGFibGVFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5yZWFkYWJsZUVycm9yZWRcbiAgfVxuICByZXR1cm4gKF9zdHJlYW0kX3JlYWRhYmxlU3RhdCA9XG4gICAgKF9zdHJlYW0kX3JlYWRhYmxlU3RhdDIgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDIgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogX3N0cmVhbSRfcmVhZGFibGVTdGF0Mi5lcnJvcmVkKSAhPT0gbnVsbCAmJiBfc3RyZWFtJF9yZWFkYWJsZVN0YXQgIT09IHVuZGVmaW5lZFxuICAgID8gX3N0cmVhbSRfcmVhZGFibGVTdGF0XG4gICAgOiBudWxsXG59XG5mdW5jdGlvbiBpc0Nsb3NlZChzdHJlYW0pIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJlYW0uY2xvc2VkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gc3RyZWFtLmNsb3NlZFxuICB9XG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgaWYgKFxuICAgIHR5cGVvZiAod1N0YXRlID09PSBudWxsIHx8IHdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogd1N0YXRlLmNsb3NlZCkgPT09ICdib29sZWFuJyB8fFxuICAgIHR5cGVvZiAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmNsb3NlZCkgPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHdTdGF0ZSA9PT0gbnVsbCB8fCB3U3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHdTdGF0ZS5jbG9zZWQpIHx8XG4gICAgICAoclN0YXRlID09PSBudWxsIHx8IHJTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogclN0YXRlLmNsb3NlZClcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJlYW0uX2Nsb3NlZCA9PT0gJ2Jvb2xlYW4nICYmIGlzT3V0Z29pbmdNZXNzYWdlKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gc3RyZWFtLl9jbG9zZWRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuZnVuY3Rpb24gaXNPdXRnb2luZ01lc3NhZ2Uoc3RyZWFtKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0cmVhbS5fY2xvc2VkID09PSAnYm9vbGVhbicgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLl9kZWZhdWx0S2VlcEFsaXZlID09PSAnYm9vbGVhbicgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLl9yZW1vdmVkQ29ubmVjdGlvbiA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fcmVtb3ZlZENvbnRMZW4gPT09ICdib29sZWFuJ1xuICApXG59XG5mdW5jdGlvbiBpc1NlcnZlclJlc3BvbnNlKHN0cmVhbSkge1xuICByZXR1cm4gdHlwZW9mIHN0cmVhbS5fc2VudDEwMCA9PT0gJ2Jvb2xlYW4nICYmIGlzT3V0Z29pbmdNZXNzYWdlKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGlzU2VydmVyUmVxdWVzdChzdHJlYW0pIHtcbiAgdmFyIF9zdHJlYW0kcmVxXG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0cmVhbS5fY29uc3VtaW5nID09PSAnYm9vbGVhbicgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLl9kdW1wZWQgPT09ICdib29sZWFuJyAmJlxuICAgICgoX3N0cmVhbSRyZXEgPSBzdHJlYW0ucmVxKSA9PT0gbnVsbCB8fCBfc3RyZWFtJHJlcSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3N0cmVhbSRyZXEudXBncmFkZU9yQ29ubmVjdCkgPT09XG4gICAgICB1bmRlZmluZWRcbiAgKVxufVxuZnVuY3Rpb24gd2lsbEVtaXRDbG9zZShzdHJlYW0pIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkgcmV0dXJuIG51bGxcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCBzdGF0ZSA9IHdTdGF0ZSB8fCByU3RhdGVcbiAgcmV0dXJuIChcbiAgICAoIXN0YXRlICYmIGlzU2VydmVyUmVzcG9uc2Uoc3RyZWFtKSkgfHwgISEoc3RhdGUgJiYgc3RhdGUuYXV0b0Rlc3Ryb3kgJiYgc3RhdGUuZW1pdENsb3NlICYmIHN0YXRlLmNsb3NlZCA9PT0gZmFsc2UpXG4gIClcbn1cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkKHN0cmVhbSkge1xuICB2YXIgX3N0cmVhbSRrSXNEaXN0dXJiZWRcbiAgcmV0dXJuICEhKFxuICAgIHN0cmVhbSAmJlxuICAgICgoX3N0cmVhbSRrSXNEaXN0dXJiZWQgPSBzdHJlYW1ba0lzRGlzdHVyYmVkXSkgIT09IG51bGwgJiYgX3N0cmVhbSRrSXNEaXN0dXJiZWQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBfc3RyZWFtJGtJc0Rpc3R1cmJlZFxuICAgICAgOiBzdHJlYW0ucmVhZGFibGVEaWRSZWFkIHx8IHN0cmVhbS5yZWFkYWJsZUFib3J0ZWQpXG4gIClcbn1cbmZ1bmN0aW9uIGlzRXJyb3JlZChzdHJlYW0pIHtcbiAgdmFyIF9yZWYsXG4gICAgX3JlZjIsXG4gICAgX3JlZjMsXG4gICAgX3JlZjQsXG4gICAgX3JlZjUsXG4gICAgX3N0cmVhbSRrSXNFcnJvcmVkLFxuICAgIF9zdHJlYW0kX3JlYWRhYmxlU3RhdDMsXG4gICAgX3N0cmVhbSRfd3JpdGFibGVTdGF0MyxcbiAgICBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0LFxuICAgIF9zdHJlYW0kX3dyaXRhYmxlU3RhdDRcbiAgcmV0dXJuICEhKFxuICAgIHN0cmVhbSAmJlxuICAgICgoX3JlZiA9XG4gICAgICAoX3JlZjIgPVxuICAgICAgICAoX3JlZjMgPVxuICAgICAgICAgIChfcmVmNCA9XG4gICAgICAgICAgICAoX3JlZjUgPVxuICAgICAgICAgICAgICAoX3N0cmVhbSRrSXNFcnJvcmVkID0gc3RyZWFtW2tJc0Vycm9yZWRdKSAhPT0gbnVsbCAmJiBfc3RyZWFtJGtJc0Vycm9yZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gX3N0cmVhbSRrSXNFcnJvcmVkXG4gICAgICAgICAgICAgICAgOiBzdHJlYW0ucmVhZGFibGVFcnJvcmVkKSAhPT0gbnVsbCAmJiBfcmVmNSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gX3JlZjVcbiAgICAgICAgICAgICAgOiBzdHJlYW0ud3JpdGFibGVFcnJvcmVkKSAhPT0gbnVsbCAmJiBfcmVmNCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IF9yZWY0XG4gICAgICAgICAgICA6IChfc3RyZWFtJF9yZWFkYWJsZVN0YXQzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQzID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDMuZXJyb3JFbWl0dGVkKSAhPT0gbnVsbCAmJiBfcmVmMyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBfcmVmM1xuICAgICAgICAgIDogKF9zdHJlYW0kX3dyaXRhYmxlU3RhdDMgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBfc3RyZWFtJF93cml0YWJsZVN0YXQzLmVycm9yRW1pdHRlZCkgIT09IG51bGwgJiYgX3JlZjIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IF9yZWYyXG4gICAgICAgIDogKF9zdHJlYW0kX3JlYWRhYmxlU3RhdDQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDQuZXJyb3JlZCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IF9yZWZcbiAgICAgIDogKF9zdHJlYW0kX3dyaXRhYmxlU3RhdDQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDQgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogX3N0cmVhbSRfd3JpdGFibGVTdGF0NC5lcnJvcmVkKVxuICApXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZXN0cm95ZWQsXG4gIGtJc0Rlc3Ryb3llZCxcbiAgaXNEaXN0dXJiZWQsXG4gIGtJc0Rpc3R1cmJlZCxcbiAgaXNFcnJvcmVkLFxuICBrSXNFcnJvcmVkLFxuICBpc1JlYWRhYmxlLFxuICBrSXNSZWFkYWJsZSxcbiAga0lzQ2xvc2VkUHJvbWlzZSxcbiAga0NvbnRyb2xsZXJFcnJvckZ1bmN0aW9uLFxuICBrSXNXcml0YWJsZSxcbiAgaXNDbG9zZWQsXG4gIGlzRHVwbGV4Tm9kZVN0cmVhbSxcbiAgaXNGaW5pc2hlZCxcbiAgaXNJdGVyYWJsZSxcbiAgaXNSZWFkYWJsZU5vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVFbmRlZCxcbiAgaXNSZWFkYWJsZUZpbmlzaGVkLFxuICBpc1JlYWRhYmxlRXJyb3JlZCxcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1dlYlN0cmVhbSxcbiAgaXNXcml0YWJsZSxcbiAgaXNXcml0YWJsZU5vZGVTdHJlYW0sXG4gIGlzV3JpdGFibGVTdHJlYW0sXG4gIGlzV3JpdGFibGVFbmRlZCxcbiAgaXNXcml0YWJsZUZpbmlzaGVkLFxuICBpc1dyaXRhYmxlRXJyb3JlZCxcbiAgaXNTZXJ2ZXJSZXF1ZXN0LFxuICBpc1NlcnZlclJlc3BvbnNlLFxuICB3aWxsRW1pdENsb3NlLFxuICBpc1RyYW5zZm9ybVN0cmVhbVxufVxuIl0sIm5hbWVzIjpbIlN5bWJvbEFzeW5jSXRlcmF0b3IiLCJTeW1ib2xJdGVyYXRvciIsIlN5bWJvbEZvciIsInJlcXVpcmUiLCJrSXNEZXN0cm95ZWQiLCJrSXNFcnJvcmVkIiwia0lzUmVhZGFibGUiLCJrSXNXcml0YWJsZSIsImtJc0Rpc3R1cmJlZCIsImtJc0Nsb3NlZFByb21pc2UiLCJrQ29udHJvbGxlckVycm9yRnVuY3Rpb24iLCJpc1JlYWRhYmxlTm9kZVN0cmVhbSIsIm9iaiIsInN0cmljdCIsIl9vYmokX3JlYWRhYmxlU3RhdGUiLCJwaXBlIiwib24iLCJwYXVzZSIsInJlc3VtZSIsIl93cml0YWJsZVN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJ1bmRlZmluZWQiLCJyZWFkYWJsZSIsImlzV3JpdGFibGVOb2RlU3RyZWFtIiwiX29iaiRfd3JpdGFibGVTdGF0ZSIsIndyaXRlIiwid3JpdGFibGUiLCJpc0R1cGxleE5vZGVTdHJlYW0iLCJpc05vZGVTdHJlYW0iLCJpc1JlYWRhYmxlU3RyZWFtIiwicGlwZVRocm91Z2giLCJnZXRSZWFkZXIiLCJjYW5jZWwiLCJpc1dyaXRhYmxlU3RyZWFtIiwiZ2V0V3JpdGVyIiwiYWJvcnQiLCJpc1RyYW5zZm9ybVN0cmVhbSIsImlzV2ViU3RyZWFtIiwiaXNJdGVyYWJsZSIsImlzQXN5bmMiLCJpc0Rlc3Ryb3llZCIsInN0cmVhbSIsIndTdGF0ZSIsInJTdGF0ZSIsInN0YXRlIiwiZGVzdHJveWVkIiwiaXNXcml0YWJsZUVuZGVkIiwid3JpdGFibGVFbmRlZCIsImVycm9yZWQiLCJlbmRlZCIsImlzV3JpdGFibGVGaW5pc2hlZCIsIndyaXRhYmxlRmluaXNoZWQiLCJmaW5pc2hlZCIsImxlbmd0aCIsImlzUmVhZGFibGVFbmRlZCIsInJlYWRhYmxlRW5kZWQiLCJpc1JlYWRhYmxlRmluaXNoZWQiLCJlbmRFbWl0dGVkIiwiaXNSZWFkYWJsZSIsImlzV3JpdGFibGUiLCJpc0ZpbmlzaGVkIiwib3B0cyIsImlzV3JpdGFibGVFcnJvcmVkIiwiX3N0cmVhbSRfd3JpdGFibGVTdGF0IiwiX3N0cmVhbSRfd3JpdGFibGVTdGF0MiIsIndyaXRhYmxlRXJyb3JlZCIsImlzUmVhZGFibGVFcnJvcmVkIiwiX3N0cmVhbSRfcmVhZGFibGVTdGF0IiwiX3N0cmVhbSRfcmVhZGFibGVTdGF0MiIsInJlYWRhYmxlRXJyb3JlZCIsImlzQ2xvc2VkIiwiY2xvc2VkIiwiX2Nsb3NlZCIsImlzT3V0Z29pbmdNZXNzYWdlIiwiX2RlZmF1bHRLZWVwQWxpdmUiLCJfcmVtb3ZlZENvbm5lY3Rpb24iLCJfcmVtb3ZlZENvbnRMZW4iLCJpc1NlcnZlclJlc3BvbnNlIiwiX3NlbnQxMDAiLCJpc1NlcnZlclJlcXVlc3QiLCJfc3RyZWFtJHJlcSIsIl9jb25zdW1pbmciLCJfZHVtcGVkIiwicmVxIiwidXBncmFkZU9yQ29ubmVjdCIsIndpbGxFbWl0Q2xvc2UiLCJhdXRvRGVzdHJveSIsImVtaXRDbG9zZSIsImlzRGlzdHVyYmVkIiwiX3N0cmVhbSRrSXNEaXN0dXJiZWQiLCJyZWFkYWJsZURpZFJlYWQiLCJyZWFkYWJsZUFib3J0ZWQiLCJpc0Vycm9yZWQiLCJfcmVmIiwiX3JlZjIiLCJfcmVmMyIsIl9yZWY0IiwiX3JlZjUiLCJfc3RyZWFtJGtJc0Vycm9yZWQiLCJfc3RyZWFtJF9yZWFkYWJsZVN0YXQzIiwiX3N0cmVhbSRfd3JpdGFibGVTdGF0MyIsIl9zdHJlYW0kX3JlYWRhYmxlU3RhdDQiLCJfc3RyZWFtJF93cml0YWJsZVN0YXQ0IiwiZXJyb3JFbWl0dGVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/writable.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/writable.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */ const process = __webpack_require__(/*! process/ */ \"(ssr)/../node_modules/process/index.js\");\n\"use strict\";\nconst { ArrayPrototypeSlice, Error, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol, SymbolHasInstance } = __webpack_require__(/*! ../../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\nconst { EventEmitter: EE } = __webpack_require__(/*! events */ \"events\");\nconst Stream = (__webpack_require__(/*! ./legacy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/legacy.js\").Stream);\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst destroyImpl = __webpack_require__(/*! ./destroy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nconst { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\");\nconst { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js\");\nconst { ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = (__webpack_require__(/*! ../../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\").codes);\nconst { errorOrDestroy } = destroyImpl;\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Writable, Stream);\nfunction nop() {}\nconst kOnFinished = Symbol(\"kOnFinished\");\nfunction WritableState(options, stream, isDuplex) {\n    // Duplex streams are both readable and writable, but share\n    // the same options object.\n    // However, some cases require setting options to different\n    // values for the readable and the writable sides of the duplex stream,\n    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\n    // Object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!(options && options.objectMode);\n    if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n    // The point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write().\n    this.highWaterMark = options ? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(false);\n    // if _final has been called.\n    this.finalCalled = false;\n    // drain event flag.\n    this.needDrain = false;\n    // At the start of calling end()\n    this.ending = false;\n    // When end() has been called, and returned.\n    this.ended = false;\n    // When 'finish' is emitted.\n    this.finished = false;\n    // Has it been destroyed\n    this.destroyed = false;\n    // Should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    const noDecode = !!(options && options.decodeStrings === false);\n    this.decodeStrings = !noDecode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options && options.defaultEncoding || \"utf8\";\n    // Not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n    // A flag to see when we're in the middle of a write.\n    this.writing = false;\n    // When true all writes will be buffered until .uncork() call.\n    this.corked = 0;\n    // A flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // A flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n    // The callback that's passed to _write(chunk, cb).\n    this.onwrite = onwrite.bind(undefined, stream);\n    // The callback that the user supplies to write(chunk, encoding, cb).\n    this.writecb = null;\n    // The amount that is being written when _write is called.\n    this.writelen = 0;\n    // Storage for data passed to the afterWrite() callback in case of\n    // synchronous _write() completion.\n    this.afterWriteTickInfo = null;\n    resetBuffer(this);\n    // Number of pending user-supplied write callbacks\n    // this must be 0 before 'finish' can be emitted.\n    this.pendingcb = 0;\n    // Stream is still being constructed and cannot be\n    // destroyed until construction finished or failed.\n    // Async construction is opt in, therefore we start as\n    // constructed.\n    this.constructed = true;\n    // Emit prefinish if the only thing we're waiting for is _write cbs\n    // This is relevant for synchronous Transform streams.\n    this.prefinished = false;\n    // True if the error was already emitted and should not be thrown again.\n    this.errorEmitted = false;\n    // Should close be emitted on destroy. Defaults to true.\n    this.emitClose = !options || options.emitClose !== false;\n    // Should .destroy() be called after 'finish' (and potentially 'end').\n    this.autoDestroy = !options || options.autoDestroy !== false;\n    // Indicates whether the stream has errored. When true all write() calls\n    // should return false. This is needed since when autoDestroy\n    // is disabled we need a way to tell whether the stream has failed.\n    this.errored = null;\n    // Indicates whether the stream has finished destroying.\n    this.closed = false;\n    // True if close has been emitted or would have been emitted\n    // depending on emitClose.\n    this.closeEmitted = false;\n    this[kOnFinished] = [];\n}\nfunction resetBuffer(state) {\n    state.buffered = [];\n    state.bufferedIndex = 0;\n    state.allBuffers = true;\n    state.allNoop = true;\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n};\nObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n    __proto__: null,\n    get () {\n        return this.buffered.length - this.bufferedIndex;\n    }\n});\nfunction Writable(options) {\n    // Writable ctor is applied to Duplexes, too.\n    // `realHasInstance` is necessary because using plain `instanceof`\n    // would return false, as no `_writableState` property is attached.\n    // Trying to use the custom `instanceof` for Writable here will also break the\n    // Node.js LazyTransform implementation, which has a non-trivial getter for\n    // `_writableState` that would lead to infinite recursion.\n    // Checking for a Stream.Duplex instance is faster here instead of inside\n    // the WritableState constructor, at least with V8 6.5.\n    const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\n    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);\n    this._writableState = new WritableState(options, this, isDuplex);\n    if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n        if (typeof options.construct === \"function\") this._construct = options.construct;\n        if (options.signal) addAbortSignal(options.signal, this);\n    }\n    Stream.call(this, options);\n    destroyImpl.construct(this, ()=>{\n        const state = this._writableState;\n        if (!state.writing) {\n            clearBuffer(this, state);\n        }\n        finishMaybe(this, state);\n    });\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n    __proto__: null,\n    value: function(object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;\n        if (this !== Writable) return false;\n        return object && object._writableState instanceof WritableState;\n    }\n});\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction _write(stream, chunk, encoding, cb) {\n    const state = stream._writableState;\n    if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = state.defaultEncoding;\n    } else {\n        if (!encoding) encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\") cb = nop;\n    }\n    if (chunk === null) {\n        throw new ERR_STREAM_NULL_VALUES();\n    } else if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n            if (state.decodeStrings !== false) {\n                chunk = Buffer.from(chunk, encoding);\n                encoding = \"buffer\";\n            }\n        } else if (chunk instanceof Buffer) {\n            encoding = \"buffer\";\n        } else if (Stream._isUint8Array(chunk)) {\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n            encoding = \"buffer\";\n        } else {\n            throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\n                \"string\",\n                \"Buffer\",\n                \"Uint8Array\"\n            ], chunk);\n        }\n    }\n    let err;\n    if (state.ending) {\n        err = new ERR_STREAM_WRITE_AFTER_END();\n    } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"write\");\n    }\n    if (err) {\n        process.nextTick(cb, err);\n        errorOrDestroy(stream, err, true);\n        return err;\n    }\n    state.pendingcb++;\n    return writeOrBuffer(stream, state, chunk, encoding, cb);\n}\nWritable.prototype.write = function(chunk, encoding, cb) {\n    return _write(this, chunk, encoding, cb) === true;\n};\nWritable.prototype.cork = function() {\n    this._writableState.corked++;\n};\nWritable.prototype.uncork = function() {\n    const state = this._writableState;\n    if (state.corked) {\n        state.corked--;\n        if (!state.writing) clearBuffer(this, state);\n    }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n    // node::ParseEncoding() requires lower case.\n    if (typeof encoding === \"string\") encoding = StringPrototypeToLowerCase(encoding);\n    if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n    this._writableState.defaultEncoding = encoding;\n    return this;\n};\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    // stream._write resets state.length\n    const ret = state.length < state.highWaterMark;\n    // We must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked || state.errored || !state.constructed) {\n        state.buffered.push({\n            chunk,\n            encoding,\n            callback\n        });\n        if (state.allBuffers && encoding !== \"buffer\") {\n            state.allBuffers = false;\n        }\n        if (state.allNoop && callback !== nop) {\n            state.allNoop = false;\n        }\n    } else {\n        state.writelen = len;\n        state.writecb = callback;\n        state.writing = true;\n        state.sync = true;\n        stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n    }\n    // Return false if errored or destroyed in order to break\n    // any synchronous while(stream.write(data)) loops.\n    return ret && !state.errored && !state.destroyed;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n    else if (writev) stream._writev(chunk, state.onwrite);\n    else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\nfunction onwriteError(stream, state, er, cb) {\n    --state.pendingcb;\n    cb(er);\n    // Ensure callbacks are invoked even when autoDestroy is\n    // not enabled. Passing `er` here doesn't make sense since\n    // it's related to one specific write, not to the buffered\n    // writes.\n    errorBuffer(state);\n    // This can emit error, but error must always follow cb.\n    errorOrDestroy(stream, er);\n}\nfunction onwrite(stream, er) {\n    const state = stream._writableState;\n    const sync = state.sync;\n    const cb = state.writecb;\n    if (typeof cb !== \"function\") {\n        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n        return;\n    }\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n    if (er) {\n        // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n        er.stack // eslint-disable-line no-unused-expressions\n        ;\n        if (!state.errored) {\n            state.errored = er;\n        }\n        // In case of duplex streams we need to notify the readable side of the\n        // error.\n        if (stream._readableState && !stream._readableState.errored) {\n            stream._readableState.errored = er;\n        }\n        if (sync) {\n            process.nextTick(onwriteError, stream, state, er, cb);\n        } else {\n            onwriteError(stream, state, er, cb);\n        }\n    } else {\n        if (state.buffered.length > state.bufferedIndex) {\n            clearBuffer(stream, state);\n        }\n        if (sync) {\n            // It is a common case that the callback passed to .write() is always\n            // the same. In that case, we do not schedule a new nextTick(), but\n            // rather just increase a counter, to improve performance and avoid\n            // memory allocations.\n            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n                state.afterWriteTickInfo.count++;\n            } else {\n                state.afterWriteTickInfo = {\n                    count: 1,\n                    cb,\n                    stream,\n                    state\n                };\n                process.nextTick(afterWriteTick, state.afterWriteTickInfo);\n            }\n        } else {\n            afterWrite(stream, state, 1, cb);\n        }\n    }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n    state.afterWriteTickInfo = null;\n    return afterWrite(stream, state, count, cb);\n}\nfunction afterWrite(stream, state, count, cb) {\n    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n    if (needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n    }\n    while(count-- > 0){\n        state.pendingcb--;\n        cb();\n    }\n    if (state.destroyed) {\n        errorBuffer(state);\n    }\n    finishMaybe(stream, state);\n}\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n    if (state.writing) {\n        return;\n    }\n    for(let n = state.bufferedIndex; n < state.buffered.length; ++n){\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n];\n        const len = state.objectMode ? 1 : chunk.length;\n        state.length -= len;\n        callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED(\"write\"));\n    }\n    const onfinishCallbacks = state[kOnFinished].splice(0);\n    for(let i = 0; i < onfinishCallbacks.length; i++){\n        var _state$errored2;\n        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED(\"end\"));\n    }\n    resetBuffer(state);\n}\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n        return;\n    }\n    const { buffered, bufferedIndex, objectMode } = state;\n    const bufferedLength = buffered.length - bufferedIndex;\n    if (!bufferedLength) {\n        return;\n    }\n    let i = bufferedIndex;\n    state.bufferProcessing = true;\n    if (bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop ? nop : (err)=>{\n            for(let n = i; n < buffered.length; ++n){\n                buffered[n].callback(err);\n            }\n        };\n        // Make a copy of `buffered` if it's going to be used by `callback` above,\n        // since `doWrite` will mutate the array.\n        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers;\n        doWrite(stream, state, true, state.length, chunks, \"\", callback);\n        resetBuffer(state);\n    } else {\n        do {\n            const { chunk, encoding, callback } = buffered[i];\n            buffered[i++] = null;\n            const len = objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, callback);\n        }while (i < buffered.length && !state.writing);\n        if (i === buffered.length) {\n            resetBuffer(state);\n        } else if (i > 256) {\n            buffered.splice(0, i);\n            state.bufferedIndex = 0;\n        } else {\n            state.bufferedIndex = i;\n        }\n    }\n    state.bufferProcessing = false;\n}\nWritable.prototype._write = function(chunk, encoding, cb) {\n    if (this._writev) {\n        this._writev([\n            {\n                chunk,\n                encoding\n            }\n        ], cb);\n    } else {\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n    }\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function(chunk, encoding, cb) {\n    const state = this._writableState;\n    if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    let err;\n    if (chunk !== null && chunk !== undefined) {\n        const ret = _write(this, chunk, encoding);\n        if (ret instanceof Error) {\n            err = ret;\n        }\n    }\n    // .end() fully uncorks.\n    if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n    }\n    if (err) {\n    // Do nothing...\n    } else if (!state.errored && !state.ending) {\n        // This is forgiving in terms of unnecessary calls to end() and can hide\n        // logic errors. However, usually such errors are harmless and causing a\n        // hard error can be disproportionately destructive. It is not always\n        // trivial for the user to determine whether end() needs to be called\n        // or not.\n        state.ending = true;\n        finishMaybe(this, state, true);\n        state.ended = true;\n    } else if (state.finished) {\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n    } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"end\");\n    }\n    if (typeof cb === \"function\") {\n        if (err || state.finished) {\n            process.nextTick(cb, err);\n        } else {\n            state[kOnFinished].push(cb);\n        }\n    }\n    return this;\n};\nfunction needFinish(state) {\n    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;\n}\nfunction callFinal(stream, state) {\n    let called = false;\n    function onFinish(err) {\n        if (called) {\n            errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());\n            return;\n        }\n        called = true;\n        state.pendingcb--;\n        if (err) {\n            const onfinishCallbacks = state[kOnFinished].splice(0);\n            for(let i = 0; i < onfinishCallbacks.length; i++){\n                onfinishCallbacks[i](err);\n            }\n            errorOrDestroy(stream, err, state.sync);\n        } else if (needFinish(state)) {\n            state.prefinished = true;\n            stream.emit(\"prefinish\");\n            // Backwards compat. Don't check state.sync here.\n            // Some streams assume 'finish' will be emitted\n            // asynchronously relative to _final callback.\n            state.pendingcb++;\n            process.nextTick(finish, stream, state);\n        }\n    }\n    state.sync = true;\n    state.pendingcb++;\n    try {\n        stream._final(onFinish);\n    } catch (err) {\n        onFinish(err);\n    }\n    state.sync = false;\n}\nfunction prefinish(stream, state) {\n    if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === \"function\" && !state.destroyed) {\n            state.finalCalled = true;\n            callFinal(stream, state);\n        } else {\n            state.prefinished = true;\n            stream.emit(\"prefinish\");\n        }\n    }\n}\nfunction finishMaybe(stream, state, sync) {\n    if (needFinish(state)) {\n        prefinish(stream, state);\n        if (state.pendingcb === 0) {\n            if (sync) {\n                state.pendingcb++;\n                process.nextTick((stream, state)=>{\n                    if (needFinish(state)) {\n                        finish(stream, state);\n                    } else {\n                        state.pendingcb--;\n                    }\n                }, stream, state);\n            } else if (needFinish(state)) {\n                state.pendingcb++;\n                finish(stream, state);\n            }\n        }\n    }\n}\nfunction finish(stream, state) {\n    state.pendingcb--;\n    state.finished = true;\n    const onfinishCallbacks = state[kOnFinished].splice(0);\n    for(let i = 0; i < onfinishCallbacks.length; i++){\n        onfinishCallbacks[i]();\n    }\n    stream.emit(\"finish\");\n    if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well.\n        const rState = stream._readableState;\n        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false);\n        if (autoDestroy) {\n            stream.destroy();\n        }\n    }\n}\nObjectDefineProperties(Writable.prototype, {\n    closed: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.closed : false;\n        }\n    },\n    destroyed: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.destroyed : false;\n        },\n        set (value) {\n            // Backward compatibility, the user is explicitly managing destroyed.\n            if (this._writableState) {\n                this._writableState.destroyed = value;\n            }\n        }\n    },\n    writable: {\n        __proto__: null,\n        get () {\n            const w = this._writableState;\n            // w.writable === false means that this is part of a Duplex stream\n            // where the writable side was disabled upon construction.\n            // Compat. The user might manually disable writable side through\n            // deprecated setter.\n            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set (val) {\n            // Backwards compatible.\n            if (this._writableState) {\n                this._writableState.writable = !!val;\n            }\n        }\n    },\n    writableFinished: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.finished : false;\n        }\n    },\n    writableObjectMode: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.objectMode : false;\n        }\n    },\n    writableBuffer: {\n        __proto__: null,\n        get () {\n            return this._writableState && this._writableState.getBuffer();\n        }\n    },\n    writableEnded: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.ending : false;\n        }\n    },\n    writableNeedDrain: {\n        __proto__: null,\n        get () {\n            const wState = this._writableState;\n            if (!wState) return false;\n            return !wState.destroyed && !wState.ending && wState.needDrain;\n        }\n    },\n    writableHighWaterMark: {\n        __proto__: null,\n        get () {\n            return this._writableState && this._writableState.highWaterMark;\n        }\n    },\n    writableCorked: {\n        __proto__: null,\n        get () {\n            return this._writableState ? this._writableState.corked : 0;\n        }\n    },\n    writableLength: {\n        __proto__: null,\n        get () {\n            return this._writableState && this._writableState.length;\n        }\n    },\n    errored: {\n        __proto__: null,\n        enumerable: false,\n        get () {\n            return this._writableState ? this._writableState.errored : null;\n        }\n    },\n    writableAborted: {\n        __proto__: null,\n        enumerable: false,\n        get: function() {\n            return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);\n        }\n    }\n});\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err, cb) {\n    const state = this._writableState;\n    // Invoke pending callbacks.\n    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n        process.nextTick(errorBuffer, state);\n    }\n    destroy.call(this, err, cb);\n    return this;\n};\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n    cb(err);\n};\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n    this.destroy(err);\n};\nlet webStreamsAdapters;\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n    if (webStreamsAdapters === undefined) webStreamsAdapters = {};\n    return webStreamsAdapters;\n}\nWritable.fromWeb = function(writableStream, options) {\n    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n};\nWritable.toWeb = function(streamWritable) {\n    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy93cml0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsR0FFckIsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUE0QnRCO0FBQ0YsTUFBTSxFQUNKQyxtQkFBbUIsRUFDbkJDLEtBQUssRUFDTEMsa0NBQWtDLEVBQ2xDQyxvQkFBb0IsRUFDcEJDLHNCQUFzQixFQUN0QkMsb0JBQW9CLEVBQ3BCQywwQkFBMEIsRUFDMUJDLE1BQU0sRUFDTkMsaUJBQWlCLEVBQ2xCLEdBQUdULG1CQUFPQSxDQUFDO0FBQ1pVLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJBLFNBQVNDLGFBQWEsR0FBR0E7QUFDekIsTUFBTSxFQUFFQyxjQUFjQyxFQUFFLEVBQUUsR0FBR2YsbUJBQU9BLENBQUM7QUFDckMsTUFBTWdCLFNBQVNoQiwySkFBMEI7QUFDekMsTUFBTSxFQUFFaUIsTUFBTSxFQUFFLEdBQUdqQixtQkFBT0EsQ0FBQztBQUMzQixNQUFNa0IsY0FBY2xCLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRW1CLGNBQWMsRUFBRSxHQUFHbkIsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFFb0IsZ0JBQWdCLEVBQUVDLHVCQUF1QixFQUFFLEdBQUdyQixtQkFBT0EsQ0FBQztBQUM5RCxNQUFNLEVBQ0pzQixvQkFBb0IsRUFDcEJDLDBCQUEwQixFQUMxQkMscUJBQXFCLEVBQ3JCQyxzQkFBc0IsRUFDdEJDLG9CQUFvQixFQUNwQkMsMkJBQTJCLEVBQzNCQyxzQkFBc0IsRUFDdEJDLDBCQUEwQixFQUMxQkMsb0JBQW9CLEVBQ3JCLEdBQUc5Qix1SkFBa0M7QUFDdEMsTUFBTSxFQUFFZ0MsY0FBYyxFQUFFLEdBQUdkO0FBQzNCWixxQkFBcUJNLFNBQVNxQixTQUFTLEVBQUVqQixPQUFPaUIsU0FBUztBQUN6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QVk0SSxTQUFTO0FBQ3JEbEosU0FBU3FCLFNBQVMsQ0FBQ3FELFFBQVEsR0FBRyxTQUFVbUIsR0FBRyxFQUFFTCxFQUFFO0lBQzdDQSxHQUFHSztBQUNMO0FBQ0E3RixTQUFTcUIsU0FBUyxDQUFDbEIsR0FBR2dKLHNCQUFzQixDQUFDLEdBQUcsU0FBVXRELEdBQUc7SUFDM0QsSUFBSSxDQUFDcEIsT0FBTyxDQUFDb0I7QUFDZjtBQUNBLElBQUl1RDtBQUVKLG9DQUFvQztBQUNwQyxTQUFTQztJQUNQLElBQUlELHVCQUF1QnRHLFdBQVdzRyxxQkFBcUIsQ0FBQztJQUM1RCxPQUFPQTtBQUNUO0FBQ0FwSixTQUFTc0osT0FBTyxHQUFHLFNBQVVDLGNBQWMsRUFBRS9ILE9BQU87SUFDbEQsT0FBTzZILGlCQUFpQkcsbUNBQW1DLENBQUNELGdCQUFnQi9IO0FBQzlFO0FBQ0F4QixTQUFTeUosS0FBSyxHQUFHLFNBQVVDLGNBQWM7SUFDdkMsT0FBT0wsaUJBQWlCTSxtQ0FBbUMsQ0FBQ0Q7QUFDOUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy93cml0YWJsZS5qcz9mYTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCB7XG4gIEFycmF5UHJvdG90eXBlU2xpY2UsXG4gIEVycm9yLFxuICBGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlLFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydGllcyxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YsXG4gIFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlLFxuICBTeW1ib2wsXG4gIFN5bWJvbEhhc0luc3RhbmNlXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZVxuY29uc3QgeyBFdmVudEVtaXR0ZXI6IEVFIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnLi9sZWdhY3knKS5TdHJlYW1cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2Rlc3Ryb3knKVxuY29uc3QgeyBhZGRBYm9ydFNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hZGQtYWJvcnQtc2lnbmFsJylcbmNvbnN0IHsgZ2V0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuY29uc3Qge1xuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gIEVSUl9TVFJFQU1fQUxSRUFEWV9GSU5JU0hFRCxcbiAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gIEVSUl9VTktOT1dOX0VOQ09ESU5HXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKS5jb2Rlc1xuY29uc3QgeyBlcnJvck9yRGVzdHJveSB9ID0gZGVzdHJveUltcGxcbk9iamVjdFNldFByb3RvdHlwZU9mKFdyaXRhYmxlLnByb3RvdHlwZSwgU3RyZWFtLnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFdyaXRhYmxlLCBTdHJlYW0pXG5mdW5jdGlvbiBub3AoKSB7fVxuY29uc3Qga09uRmluaXNoZWQgPSBTeW1ib2woJ2tPbkZpbmlzaGVkJylcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcblxuICAvLyBPYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIShvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSlcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISEob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSlcblxuICAvLyBUaGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKCkuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IG9wdGlvbnNcbiAgICA/IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KVxuICAgIDogZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsoZmFsc2UpXG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZC5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlXG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZVxuICAvLyBBdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlXG4gIC8vIFdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWQuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZVxuICAvLyBXaGVuICdmaW5pc2gnIGlzIGVtaXR0ZWQuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZVxuXG4gIC8vIEhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgLy8gU2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICBjb25zdCBub0RlY29kZSA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZSlcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlXG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHRFbmNvZGluZykgfHwgJ3V0ZjgnXG5cbiAgLy8gTm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgLy8gQSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2VcblxuICAvLyBXaGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsLlxuICB0aGlzLmNvcmtlZCA9IDBcblxuICAvLyBBIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZVxuXG4gIC8vIEEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlXG5cbiAgLy8gVGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLCBjYikuXG4gIHRoaXMub253cml0ZSA9IG9ud3JpdGUuYmluZCh1bmRlZmluZWQsIHN0cmVhbSlcblxuICAvLyBUaGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKS5cbiAgdGhpcy53cml0ZWNiID0gbnVsbFxuXG4gIC8vIFRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDBcblxuICAvLyBTdG9yYWdlIGZvciBkYXRhIHBhc3NlZCB0byB0aGUgYWZ0ZXJXcml0ZSgpIGNhbGxiYWNrIGluIGNhc2Ugb2ZcbiAgLy8gc3luY2hyb25vdXMgX3dyaXRlKCkgY29tcGxldGlvbi5cbiAgdGhpcy5hZnRlcldyaXRlVGlja0luZm8gPSBudWxsXG4gIHJlc2V0QnVmZmVyKHRoaXMpXG5cbiAgLy8gTnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkLlxuICB0aGlzLnBlbmRpbmdjYiA9IDBcblxuICAvLyBTdHJlYW0gaXMgc3RpbGwgYmVpbmcgY29uc3RydWN0ZWQgYW5kIGNhbm5vdCBiZVxuICAvLyBkZXN0cm95ZWQgdW50aWwgY29uc3RydWN0aW9uIGZpbmlzaGVkIG9yIGZhaWxlZC5cbiAgLy8gQXN5bmMgY29uc3RydWN0aW9uIGlzIG9wdCBpbiwgdGhlcmVmb3JlIHdlIHN0YXJ0IGFzXG4gIC8vIGNvbnN0cnVjdGVkLlxuICB0aGlzLmNvbnN0cnVjdGVkID0gdHJ1ZVxuXG4gIC8vIEVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXMuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZVxuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluLlxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlXG5cbiAgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgdGhpcy5lbWl0Q2xvc2UgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2VcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJykuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmF1dG9EZXN0cm95ICE9PSBmYWxzZVxuXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGVycm9yZWQuIFdoZW4gdHJ1ZSBhbGwgd3JpdGUoKSBjYWxsc1xuICAvLyBzaG91bGQgcmV0dXJuIGZhbHNlLiBUaGlzIGlzIG5lZWRlZCBzaW5jZSB3aGVuIGF1dG9EZXN0cm95XG4gIC8vIGlzIGRpc2FibGVkIHdlIG5lZWQgYSB3YXkgdG8gdGVsbCB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGZhaWxlZC5cbiAgdGhpcy5lcnJvcmVkID0gbnVsbFxuXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHJlYW0gaGFzIGZpbmlzaGVkIGRlc3Ryb3lpbmcuXG4gIHRoaXMuY2xvc2VkID0gZmFsc2VcblxuICAvLyBUcnVlIGlmIGNsb3NlIGhhcyBiZWVuIGVtaXR0ZWQgb3Igd291bGQgaGF2ZSBiZWVuIGVtaXR0ZWRcbiAgLy8gZGVwZW5kaW5nIG9uIGVtaXRDbG9zZS5cbiAgdGhpcy5jbG9zZUVtaXR0ZWQgPSBmYWxzZVxuICB0aGlzW2tPbkZpbmlzaGVkXSA9IFtdXG59XG5mdW5jdGlvbiByZXNldEJ1ZmZlcihzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJlZCA9IFtdXG4gIHN0YXRlLmJ1ZmZlcmVkSW5kZXggPSAwXG4gIHN0YXRlLmFsbEJ1ZmZlcnMgPSB0cnVlXG4gIHN0YXRlLmFsbE5vb3AgPSB0cnVlXG59XG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHJldHVybiBBcnJheVByb3RvdHlwZVNsaWNlKHRoaXMuYnVmZmVyZWQsIHRoaXMuYnVmZmVyZWRJbmRleClcbn1cbk9iamVjdERlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyZWRSZXF1ZXN0Q291bnQnLCB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkLmxlbmd0aCAtIHRoaXMuYnVmZmVyZWRJbmRleFxuICB9XG59KVxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNS5cbiAgY29uc3QgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgcmVxdWlyZSgnLi9kdXBsZXgnKVxuICBpZiAoIWlzRHVwbGV4ICYmICFGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKVxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGVcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9jb25zdHJ1Y3QgPSBvcHRpb25zLmNvbnN0cnVjdFxuICAgIGlmIChvcHRpb25zLnNpZ25hbCkgYWRkQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsIHRoaXMpXG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcywgb3B0aW9ucylcbiAgZGVzdHJveUltcGwuY29uc3RydWN0KHRoaXMsICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKVxuICAgIH1cbiAgICBmaW5pc2hNYXliZSh0aGlzLCBzdGF0ZSlcbiAgfSlcbn1cbk9iamVjdERlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2xIYXNJbnN0YW5jZSwge1xuICBfX3Byb3RvX186IG51bGwsXG4gIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKEZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2UodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWVcbiAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZVxuICB9XG59KVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSlcbn1cbmZ1bmN0aW9uIF93cml0ZShzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZ1xuICB9IGVsc2Uge1xuICAgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nXG4gICAgZWxzZSBpZiAoZW5jb2RpbmcgIT09ICdidWZmZXInICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZylcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcFxuICB9XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKClcbiAgfSBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInXG4gICAgfSBlbHNlIGlmIChTdHJlYW0uX2lzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIGNodW5rID0gU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspXG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuaylcbiAgICB9XG4gIH1cbiAgbGV0IGVyclxuICBpZiAoc3RhdGUuZW5kaW5nKSB7XG4gICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKClcbiAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICBlcnIgPSBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJylcbiAgfVxuICBpZiAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKVxuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyLCB0cnVlKVxuICAgIHJldHVybiBlcnJcbiAgfVxuICBzdGF0ZS5wZW5kaW5nY2IrK1xuICByZXR1cm4gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKVxufVxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgcmV0dXJuIF93cml0ZSh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGNiKSA9PT0gdHJ1ZVxufVxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKytcbn1cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS1cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKVxuICB9XG59XG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBTdHJpbmdQcm90b3R5cGVUb0xvd2VyQ2FzZShlbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZylcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZ1xuICByZXR1cm4gdGhpc1xufVxuXG4vLyBJZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoXG4gIHN0YXRlLmxlbmd0aCArPSBsZW5cblxuICAvLyBzdHJlYW0uX3dyaXRlIHJlc2V0cyBzdGF0ZS5sZW5ndGhcbiAgY29uc3QgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFya1xuICAvLyBXZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWVcbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkIHx8IHN0YXRlLmVycm9yZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgc3RhdGUuYnVmZmVyZWQucHVzaCh7XG4gICAgICBjaHVuayxcbiAgICAgIGVuY29kaW5nLFxuICAgICAgY2FsbGJhY2tcbiAgICB9KVxuICAgIGlmIChzdGF0ZS5hbGxCdWZmZXJzICYmIGVuY29kaW5nICE9PSAnYnVmZmVyJykge1xuICAgICAgc3RhdGUuYWxsQnVmZmVycyA9IGZhbHNlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5hbGxOb29wICYmIGNhbGxiYWNrICE9PSBub3ApIHtcbiAgICAgIHN0YXRlLmFsbE5vb3AgPSBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS53cml0ZWxlbiA9IGxlblxuICAgIHN0YXRlLndyaXRlY2IgPSBjYWxsYmFja1xuICAgIHN0YXRlLndyaXRpbmcgPSB0cnVlXG4gICAgc3RhdGUuc3luYyA9IHRydWVcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSlcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2VcbiAgfVxuXG4gIC8vIFJldHVybiBmYWxzZSBpZiBlcnJvcmVkIG9yIGRlc3Ryb3llZCBpbiBvcmRlciB0byBicmVha1xuICAvLyBhbnkgc3luY2hyb25vdXMgd2hpbGUoc3RyZWFtLndyaXRlKGRhdGEpKSBsb29wcy5cbiAgcmV0dXJuIHJldCAmJiAhc3RhdGUuZXJyb3JlZCAmJiAhc3RhdGUuZGVzdHJveWVkXG59XG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuXG4gIHN0YXRlLndyaXRlY2IgPSBjYlxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZVxuICBzdGF0ZS5zeW5jID0gdHJ1ZVxuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSlcbiAgZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSlcbiAgZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSlcbiAgc3RhdGUuc3luYyA9IGZhbHNlXG59XG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiXG4gIGNiKGVyKVxuICAvLyBFbnN1cmUgY2FsbGJhY2tzIGFyZSBpbnZva2VkIGV2ZW4gd2hlbiBhdXRvRGVzdHJveSBpc1xuICAvLyBub3QgZW5hYmxlZC4gUGFzc2luZyBgZXJgIGhlcmUgZG9lc24ndCBtYWtlIHNlbnNlIHNpbmNlXG4gIC8vIGl0J3MgcmVsYXRlZCB0byBvbmUgc3BlY2lmaWMgd3JpdGUsIG5vdCB0byB0aGUgYnVmZmVyZWRcbiAgLy8gd3JpdGVzLlxuICBlcnJvckJ1ZmZlcihzdGF0ZSlcbiAgLy8gVGhpcyBjYW4gZW1pdCBlcnJvciwgYnV0IGVycm9yIG11c3QgYWx3YXlzIGZvbGxvdyBjYi5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcilcbn1cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCBzeW5jID0gc3RhdGUuc3luY1xuICBjb25zdCBjYiA9IHN0YXRlLndyaXRlY2JcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKVxuICAgIHJldHVyblxuICB9XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZVxuICBzdGF0ZS53cml0ZWNiID0gbnVsbFxuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW5cbiAgc3RhdGUud3JpdGVsZW4gPSAwXG4gIGlmIChlcikge1xuICAgIC8vIEF2b2lkIFY4IGxlYWssIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM0MTAzI2lzc3VlY29tbWVudC02NTIwMDIzNjRcbiAgICBlci5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgaWYgKCFzdGF0ZS5lcnJvcmVkKSB7XG4gICAgICBzdGF0ZS5lcnJvcmVkID0gZXJcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgdG8gbm90aWZ5IHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZVxuICAgIC8vIGVycm9yLlxuICAgIGlmIChzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkKSB7XG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZXJyb3JlZCA9IGVyXG4gICAgfVxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKG9ud3JpdGVFcnJvciwgc3RyZWFtLCBzdGF0ZSwgZXIsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgZXIsIGNiKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUuYnVmZmVyZWQubGVuZ3RoID4gc3RhdGUuYnVmZmVyZWRJbmRleCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSlcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0IGlzIGEgY29tbW9uIGNhc2UgdGhhdCB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIC53cml0ZSgpIGlzIGFsd2F5c1xuICAgICAgLy8gdGhlIHNhbWUuIEluIHRoYXQgY2FzZSwgd2UgZG8gbm90IHNjaGVkdWxlIGEgbmV3IG5leHRUaWNrKCksIGJ1dFxuICAgICAgLy8gcmF0aGVyIGp1c3QgaW5jcmVhc2UgYSBjb3VudGVyLCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGFuZCBhdm9pZFxuICAgICAgLy8gbWVtb3J5IGFsbG9jYXRpb25zLlxuICAgICAgaWYgKHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mbyAhPT0gbnVsbCAmJiBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8uY2IgPT09IGNiKSB7XG4gICAgICAgIHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mby5jb3VudCsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8gPSB7XG4gICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgY2IsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlVGljaywgc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIDEsIGNiKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWZ0ZXJXcml0ZVRpY2soeyBzdHJlYW0sIHN0YXRlLCBjb3VudCwgY2IgfSkge1xuICBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8gPSBudWxsXG4gIHJldHVybiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGNvdW50LCBjYilcbn1cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgY291bnQsIGNiKSB7XG4gIGNvbnN0IG5lZWREcmFpbiA9ICFzdGF0ZS5lbmRpbmcgJiYgIXN0cmVhbS5kZXN0cm95ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpblxuICBpZiAobmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tXG4gICAgY2IoKVxuICB9XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICBlcnJvckJ1ZmZlcihzdGF0ZSlcbiAgfVxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKVxufVxuXG4vLyBJZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gaW52b2tlIGNhbGxiYWNrcy5cbmZ1bmN0aW9uIGVycm9yQnVmZmVyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZm9yIChsZXQgbiA9IHN0YXRlLmJ1ZmZlcmVkSW5kZXg7IG4gPCBzdGF0ZS5idWZmZXJlZC5sZW5ndGg7ICsrbikge1xuICAgIHZhciBfc3RhdGUkZXJyb3JlZFxuICAgIGNvbnN0IHsgY2h1bmssIGNhbGxiYWNrIH0gPSBzdGF0ZS5idWZmZXJlZFtuXVxuICAgIGNvbnN0IGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoXG4gICAgc3RhdGUubGVuZ3RoIC09IGxlblxuICAgIGNhbGxiYWNrKFxuICAgICAgKF9zdGF0ZSRlcnJvcmVkID0gc3RhdGUuZXJyb3JlZCkgIT09IG51bGwgJiYgX3N0YXRlJGVycm9yZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IF9zdGF0ZSRlcnJvcmVkXG4gICAgICAgIDogbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpXG4gICAgKVxuICB9XG4gIGNvbnN0IG9uZmluaXNoQ2FsbGJhY2tzID0gc3RhdGVba09uRmluaXNoZWRdLnNwbGljZSgwKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZmluaXNoQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9zdGF0ZSRlcnJvcmVkMlxuICAgIG9uZmluaXNoQ2FsbGJhY2tzW2ldKFxuICAgICAgKF9zdGF0ZSRlcnJvcmVkMiA9IHN0YXRlLmVycm9yZWQpICE9PSBudWxsICYmIF9zdGF0ZSRlcnJvcmVkMiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gX3N0YXRlJGVycm9yZWQyXG4gICAgICAgIDogbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdlbmQnKVxuICAgIClcbiAgfVxuICByZXNldEJ1ZmZlcihzdGF0ZSlcbn1cblxuLy8gSWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXQuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jb3JrZWQgfHwgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyB8fCBzdGF0ZS5kZXN0cm95ZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgeyBidWZmZXJlZCwgYnVmZmVyZWRJbmRleCwgb2JqZWN0TW9kZSB9ID0gc3RhdGVcbiAgY29uc3QgYnVmZmVyZWRMZW5ndGggPSBidWZmZXJlZC5sZW5ndGggLSBidWZmZXJlZEluZGV4XG4gIGlmICghYnVmZmVyZWRMZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgaSA9IGJ1ZmZlcmVkSW5kZXhcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWVcbiAgaWYgKGJ1ZmZlcmVkTGVuZ3RoID4gMSAmJiBzdHJlYW0uX3dyaXRldikge1xuICAgIHN0YXRlLnBlbmRpbmdjYiAtPSBidWZmZXJlZExlbmd0aCAtIDFcbiAgICBjb25zdCBjYWxsYmFjayA9IHN0YXRlLmFsbE5vb3BcbiAgICAgID8gbm9wXG4gICAgICA6IChlcnIpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBuID0gaTsgbiA8IGJ1ZmZlcmVkLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICBidWZmZXJlZFtuXS5jYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgYGJ1ZmZlcmVkYCBpZiBpdCdzIGdvaW5nIHRvIGJlIHVzZWQgYnkgYGNhbGxiYWNrYCBhYm92ZSxcbiAgICAvLyBzaW5jZSBgZG9Xcml0ZWAgd2lsbCBtdXRhdGUgdGhlIGFycmF5LlxuICAgIGNvbnN0IGNodW5rcyA9IHN0YXRlLmFsbE5vb3AgJiYgaSA9PT0gMCA/IGJ1ZmZlcmVkIDogQXJyYXlQcm90b3R5cGVTbGljZShidWZmZXJlZCwgaSlcbiAgICBjaHVua3MuYWxsQnVmZmVycyA9IHN0YXRlLmFsbEJ1ZmZlcnNcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgY2h1bmtzLCAnJywgY2FsbGJhY2spXG4gICAgcmVzZXRCdWZmZXIoc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgY29uc3QgeyBjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrIH0gPSBidWZmZXJlZFtpXVxuICAgICAgYnVmZmVyZWRbaSsrXSA9IG51bGxcbiAgICAgIGNvbnN0IGxlbiA9IG9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG4gICAgfSB3aGlsZSAoaSA8IGJ1ZmZlcmVkLmxlbmd0aCAmJiAhc3RhdGUud3JpdGluZylcbiAgICBpZiAoaSA9PT0gYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICByZXNldEJ1ZmZlcihzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGkgPiAyNTYpIHtcbiAgICAgIGJ1ZmZlcmVkLnNwbGljZSgwLCBpKVxuICAgICAgc3RhdGUuYnVmZmVyZWRJbmRleCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRJbmRleCA9IGlcbiAgICB9XG4gIH1cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlXG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKHRoaXMuX3dyaXRldikge1xuICAgIHRoaXMuX3dyaXRldihcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIGNodW5rLFxuICAgICAgICAgIGVuY29kaW5nXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBjYlxuICAgIClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJylcbiAgfVxufVxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rXG4gICAgY2h1bmsgPSBudWxsXG4gICAgZW5jb2RpbmcgPSBudWxsXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gbnVsbFxuICB9XG4gIGxldCBlcnJcbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCByZXQgPSBfd3JpdGUodGhpcywgY2h1bmssIGVuY29kaW5nKVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZXJyID0gcmV0XG4gICAgfVxuICB9XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3MuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxXG4gICAgdGhpcy51bmNvcmsoKVxuICB9XG4gIGlmIChlcnIpIHtcbiAgICAvLyBEbyBub3RoaW5nLi4uXG4gIH0gZWxzZSBpZiAoIXN0YXRlLmVycm9yZWQgJiYgIXN0YXRlLmVuZGluZykge1xuICAgIC8vIFRoaXMgaXMgZm9yZ2l2aW5nIGluIHRlcm1zIG9mIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGVuZCgpIGFuZCBjYW4gaGlkZVxuICAgIC8vIGxvZ2ljIGVycm9ycy4gSG93ZXZlciwgdXN1YWxseSBzdWNoIGVycm9ycyBhcmUgaGFybWxlc3MgYW5kIGNhdXNpbmcgYVxuICAgIC8vIGhhcmQgZXJyb3IgY2FuIGJlIGRpc3Byb3BvcnRpb25hdGVseSBkZXN0cnVjdGl2ZS4gSXQgaXMgbm90IGFsd2F5c1xuICAgIC8vIHRyaXZpYWwgZm9yIHRoZSB1c2VyIHRvIGRldGVybWluZSB3aGV0aGVyIGVuZCgpIG5lZWRzIHRvIGJlIGNhbGxlZFxuICAgIC8vIG9yIG5vdC5cblxuICAgIHN0YXRlLmVuZGluZyA9IHRydWVcbiAgICBmaW5pc2hNYXliZSh0aGlzLCBzdGF0ZSwgdHJ1ZSlcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWVcbiAgfSBlbHNlIGlmIChzdGF0ZS5maW5pc2hlZCkge1xuICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX0FMUkVBRFlfRklOSVNIRUQoJ2VuZCcpXG4gIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdlbmQnKVxuICB9XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZXJyIHx8IHN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlW2tPbkZpbmlzaGVkXS5wdXNoKGNiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVuZGluZyAmJlxuICAgICFzdGF0ZS5kZXN0cm95ZWQgJiZcbiAgICBzdGF0ZS5jb25zdHJ1Y3RlZCAmJlxuICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICFzdGF0ZS5lcnJvcmVkICYmXG4gICAgc3RhdGUuYnVmZmVyZWQubGVuZ3RoID09PSAwICYmXG4gICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgIXN0YXRlLndyaXRpbmcgJiZcbiAgICAhc3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgIXN0YXRlLmNsb3NlRW1pdHRlZFxuICApXG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBsZXQgY2FsbGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gb25GaW5pc2goZXJyKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQgPyBlcnIgOiBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgc3RhdGUucGVuZGluZ2NiLS1cbiAgICBpZiAoZXJyKSB7XG4gICAgICBjb25zdCBvbmZpbmlzaENhbGxiYWNrcyA9IHN0YXRlW2tPbkZpbmlzaGVkXS5zcGxpY2UoMClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25maW5pc2hDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb25maW5pc2hDYWxsYmFja3NbaV0oZXJyKVxuICAgICAgfVxuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIsIHN0YXRlLnN5bmMpXG4gICAgfSBlbHNlIGlmIChuZWVkRmluaXNoKHN0YXRlKSkge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJylcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQuIERvbid0IGNoZWNrIHN0YXRlLnN5bmMgaGVyZS5cbiAgICAgIC8vIFNvbWUgc3RyZWFtcyBhc3N1bWUgJ2ZpbmlzaCcgd2lsbCBiZSBlbWl0dGVkXG4gICAgICAvLyBhc3luY2hyb25vdXNseSByZWxhdGl2ZSB0byBfZmluYWwgY2FsbGJhY2suXG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrK1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2gsIHN0cmVhbSwgc3RhdGUpXG4gICAgfVxuICB9XG4gIHN0YXRlLnN5bmMgPSB0cnVlXG4gIHN0YXRlLnBlbmRpbmdjYisrXG4gIHRyeSB7XG4gICAgc3RyZWFtLl9maW5hbChvbkZpbmlzaClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb25GaW5pc2goZXJyKVxuICB9XG4gIHN0YXRlLnN5bmMgPSBmYWxzZVxufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlXG4gICAgICBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUsIHN5bmMpIHtcbiAgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiKytcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhcbiAgICAgICAgICAoc3RyZWFtLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgICAgICAgICAgIGZpbmlzaChzdHJlYW0sIHN0YXRlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUucGVuZGluZ2NiLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYisrXG4gICAgICAgIGZpbmlzaChzdHJlYW0sIHN0YXRlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucGVuZGluZ2NiLS1cbiAgc3RhdGUuZmluaXNoZWQgPSB0cnVlXG4gIGNvbnN0IG9uZmluaXNoQ2FsbGJhY2tzID0gc3RhdGVba09uRmluaXNoZWRdLnNwbGljZSgwKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZmluaXNoQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgb25maW5pc2hDYWxsYmFja3NbaV0oKVxuICB9XG4gIHN0cmVhbS5lbWl0KCdmaW5pc2gnKVxuICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGwuXG4gICAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gICAgY29uc3QgYXV0b0Rlc3Ryb3kgPVxuICAgICAgIXJTdGF0ZSB8fFxuICAgICAgKHJTdGF0ZS5hdXRvRGVzdHJveSAmJlxuICAgICAgICAvLyBXZSBkb24ndCBleHBlY3QgdGhlIHJlYWRhYmxlIHRvIGV2ZXIgJ2VuZCdcbiAgICAgICAgLy8gaWYgcmVhZGFibGUgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAgICAgIChyU3RhdGUuZW5kRW1pdHRlZCB8fCByU3RhdGUucmVhZGFibGUgPT09IGZhbHNlKSlcbiAgICBpZiAoYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICB9XG4gIH1cbn1cbk9iamVjdERlZmluZVByb3BlcnRpZXMoV3JpdGFibGUucHJvdG90eXBlLCB7XG4gIGNsb3NlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuY2xvc2VkIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3llZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkIDogZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseSBtYW5hZ2luZyBkZXN0cm95ZWQuXG4gICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3cml0YWJsZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCB3ID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICAgICAgLy8gdy53cml0YWJsZSA9PT0gZmFsc2UgbWVhbnMgdGhhdCB0aGlzIGlzIHBhcnQgb2YgYSBEdXBsZXggc3RyZWFtXG4gICAgICAvLyB3aGVyZSB0aGUgd3JpdGFibGUgc2lkZSB3YXMgZGlzYWJsZWQgdXBvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICAvLyBDb21wYXQuIFRoZSB1c2VyIG1pZ2h0IG1hbnVhbGx5IGRpc2FibGUgd3JpdGFibGUgc2lkZSB0aHJvdWdoXG4gICAgICAvLyBkZXByZWNhdGVkIHNldHRlci5cbiAgICAgIHJldHVybiAhIXcgJiYgdy53cml0YWJsZSAhPT0gZmFsc2UgJiYgIXcuZGVzdHJveWVkICYmICF3LmVycm9yZWQgJiYgIXcuZW5kaW5nICYmICF3LmVuZGVkXG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJsZS5cbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUud3JpdGFibGUgPSAhIXZhbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVGaW5pc2hlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVPYmplY3RNb2RlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5vYmplY3RNb2RlIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlQnVmZmVyOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKClcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlRW5kZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA6IGZhbHNlXG4gICAgfVxuICB9LFxuICB3cml0YWJsZU5lZWREcmFpbjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCB3U3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gICAgICBpZiAoIXdTdGF0ZSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gIXdTdGF0ZS5kZXN0cm95ZWQgJiYgIXdTdGF0ZS5lbmRpbmcgJiYgd1N0YXRlLm5lZWREcmFpblxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya1xuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVDb3JrZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCA6IDBcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoXG4gICAgfVxuICB9LFxuICBlcnJvcmVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvcmVkIDogbnVsbFxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVBYm9ydGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlICE9PSBmYWxzZSAmJlxuICAgICAgICAodGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvcmVkKSAmJlxuICAgICAgICAhdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZFxuICAgICAgKVxuICAgIH1cbiAgfVxufSlcbmNvbnN0IGRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuXG4gIC8vIEludm9rZSBwZW5kaW5nIGNhbGxiYWNrcy5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmJ1ZmZlcmVkSW5kZXggPCBzdGF0ZS5idWZmZXJlZC5sZW5ndGggfHwgc3RhdGVba09uRmluaXNoZWRdLmxlbmd0aCkpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVycm9yQnVmZmVyLCBzdGF0ZSlcbiAgfVxuICBkZXN0cm95LmNhbGwodGhpcywgZXJyLCBjYilcbiAgcmV0dXJuIHRoaXNcbn1cbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpXG59XG5Xcml0YWJsZS5wcm90b3R5cGVbRUUuY2FwdHVyZVJlamVjdGlvblN5bWJvbF0gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZGVzdHJveShlcnIpXG59XG5sZXQgd2ViU3RyZWFtc0FkYXB0ZXJzXG5cbi8vIExhenkgdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuZnVuY3Rpb24gbGF6eVdlYlN0cmVhbXMoKSB7XG4gIGlmICh3ZWJTdHJlYW1zQWRhcHRlcnMgPT09IHVuZGVmaW5lZCkgd2ViU3RyZWFtc0FkYXB0ZXJzID0ge31cbiAgcmV0dXJuIHdlYlN0cmVhbXNBZGFwdGVyc1xufVxuV3JpdGFibGUuZnJvbVdlYiA9IGZ1bmN0aW9uICh3cml0YWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdTdHJlYW1Xcml0YWJsZUZyb21Xcml0YWJsZVN0cmVhbSh3cml0YWJsZVN0cmVhbSwgb3B0aW9ucylcbn1cbldyaXRhYmxlLnRvV2ViID0gZnVuY3Rpb24gKHN0cmVhbVdyaXRhYmxlKSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1dyaXRhYmxlU3RyZWFtRnJvbVN0cmVhbVdyaXRhYmxlKHN0cmVhbVdyaXRhYmxlKVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJyZXF1aXJlIiwiQXJyYXlQcm90b3R5cGVTbGljZSIsIkVycm9yIiwiRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZSIsIk9iamVjdERlZmluZVByb3BlcnR5IiwiT2JqZWN0RGVmaW5lUHJvcGVydGllcyIsIk9iamVjdFNldFByb3RvdHlwZU9mIiwiU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2UiLCJTeW1ib2wiLCJTeW1ib2xIYXNJbnN0YW5jZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJXcml0YWJsZSIsIldyaXRhYmxlU3RhdGUiLCJFdmVudEVtaXR0ZXIiLCJFRSIsIlN0cmVhbSIsIkJ1ZmZlciIsImRlc3Ryb3lJbXBsIiwiYWRkQWJvcnRTaWduYWwiLCJnZXRIaWdoV2F0ZXJNYXJrIiwiZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIiwiRVJSX01VTFRJUExFX0NBTExCQUNLIiwiRVJSX1NUUkVBTV9DQU5OT1RfUElQRSIsIkVSUl9TVFJFQU1fREVTVFJPWUVEIiwiRVJSX1NUUkVBTV9BTFJFQURZX0ZJTklTSEVEIiwiRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyIsIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EIiwiRVJSX1VOS05PV05fRU5DT0RJTkciLCJjb2RlcyIsImVycm9yT3JEZXN0cm95IiwicHJvdG90eXBlIiwibm9wIiwia09uRmluaXNoZWQiLCJvcHRpb25zIiwic3RyZWFtIiwiaXNEdXBsZXgiLCJvYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwiaGlnaFdhdGVyTWFyayIsImZpbmFsQ2FsbGVkIiwibmVlZERyYWluIiwiZW5kaW5nIiwiZW5kZWQiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsImRlZmF1bHRFbmNvZGluZyIsImxlbmd0aCIsIndyaXRpbmciLCJjb3JrZWQiLCJzeW5jIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJiaW5kIiwidW5kZWZpbmVkIiwid3JpdGVjYiIsIndyaXRlbGVuIiwiYWZ0ZXJXcml0ZVRpY2tJbmZvIiwicmVzZXRCdWZmZXIiLCJwZW5kaW5nY2IiLCJjb25zdHJ1Y3RlZCIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiZW1pdENsb3NlIiwiYXV0b0Rlc3Ryb3kiLCJlcnJvcmVkIiwiY2xvc2VkIiwiY2xvc2VFbWl0dGVkIiwic3RhdGUiLCJidWZmZXJlZCIsImJ1ZmZlcmVkSW5kZXgiLCJhbGxCdWZmZXJzIiwiYWxsTm9vcCIsImdldEJ1ZmZlciIsIl9fcHJvdG9fXyIsImdldCIsIl93cml0YWJsZVN0YXRlIiwid3JpdGUiLCJfd3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZGVzdHJveSIsIl9kZXN0cm95IiwiZmluYWwiLCJfZmluYWwiLCJjb25zdHJ1Y3QiLCJfY29uc3RydWN0Iiwic2lnbmFsIiwiY2FsbCIsImNsZWFyQnVmZmVyIiwiZmluaXNoTWF5YmUiLCJ2YWx1ZSIsIm9iamVjdCIsInBpcGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2IiLCJpc0VuY29kaW5nIiwiZnJvbSIsIl9pc1VpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiZXJyIiwibmV4dFRpY2siLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsInNldERlZmF1bHRFbmNvZGluZyIsImNhbGxiYWNrIiwibGVuIiwicmV0IiwicHVzaCIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJlciIsImVycm9yQnVmZmVyIiwic3RhY2siLCJfcmVhZGFibGVTdGF0ZSIsImNvdW50IiwiYWZ0ZXJXcml0ZVRpY2siLCJhZnRlcldyaXRlIiwiZW1pdCIsIm4iLCJfc3RhdGUkZXJyb3JlZCIsIm9uZmluaXNoQ2FsbGJhY2tzIiwic3BsaWNlIiwiaSIsIl9zdGF0ZSRlcnJvcmVkMiIsImJ1ZmZlcmVkTGVuZ3RoIiwiY2h1bmtzIiwiZW5kIiwibmVlZEZpbmlzaCIsImNhbGxGaW5hbCIsImNhbGxlZCIsIm9uRmluaXNoIiwiZmluaXNoIiwicHJlZmluaXNoIiwiclN0YXRlIiwiZW5kRW1pdHRlZCIsInJlYWRhYmxlIiwic2V0Iiwid3JpdGFibGUiLCJ3IiwidmFsIiwid3JpdGFibGVGaW5pc2hlZCIsIndyaXRhYmxlQnVmZmVyIiwid3JpdGFibGVFbmRlZCIsIndyaXRhYmxlTmVlZERyYWluIiwid1N0YXRlIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwid3JpdGFibGVDb3JrZWQiLCJ3cml0YWJsZUxlbmd0aCIsImVudW1lcmFibGUiLCJ3cml0YWJsZUFib3J0ZWQiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95IiwiY2FwdHVyZVJlamVjdGlvblN5bWJvbCIsIndlYlN0cmVhbXNBZGFwdGVycyIsImxhenlXZWJTdHJlYW1zIiwiZnJvbVdlYiIsIndyaXRhYmxlU3RyZWFtIiwibmV3U3RyZWFtV3JpdGFibGVGcm9tV3JpdGFibGVTdHJlYW0iLCJ0b1dlYiIsInN0cmVhbVdyaXRhYmxlIiwibmV3V3JpdGFibGVTdHJlYW1Gcm9tU3RyZWFtV3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/writable.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint jsdoc/require-jsdoc: \"error\" */ \nconst { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String, StringPrototypeToUpperCase, StringPrototypeTrim } = __webpack_require__(/*! ../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL } } = __webpack_require__(/*! ../ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst { normalizeEncoding } = __webpack_require__(/*! ../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nconst { isAsyncFunction, isArrayBufferView } = (__webpack_require__(/*! ../ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\").types);\nconst signals = {};\n/**\n * @param {*} value\n * @returns {boolean}\n */ function isInt32(value) {\n    return value === (value | 0);\n}\n/**\n * @param {*} value\n * @returns {boolean}\n */ function isUint32(value) {\n    return value === value >>> 0;\n}\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */ function parseFileMode(value, name, def) {\n    if (typeof value === \"undefined\") {\n        value = def;\n    }\n    if (typeof value === \"string\") {\n        if (RegExpPrototypeExec(octalReg, value) === null) {\n            throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n        }\n        value = NumberParseInt(value, 8);\n    }\n    validateUint32(value, name);\n    return value;\n}\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */ /** @type {validateInteger} */ const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER)=>{\n    if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n    if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n});\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */ /** @type {validateInt32} */ const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n    }\n    if (value < min || value > max) {\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }\n});\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */ /** @type {validateUint32} */ const validateUint32 = hideStackFrames((value, name, positive = false)=>{\n    if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    const max = 4294967295;\n    if (value < min || value > max) {\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }\n});\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */ /** @type {validateString} */ function validateString(value, name) {\n    if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */ /** @type {validateNumber} */ function validateNumber(value, name, min = undefined, max) {\n    if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {\n        throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : \"\"}${min != null && max != null ? \" && \" : \"\"}${max != null ? `<= ${max}` : \"\"}`, value);\n    }\n}\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */ /** @type {validateOneOf} */ const validateOneOf = hideStackFrames((value, name, oneOf)=>{\n    if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v)=>typeof v === \"string\" ? `'${v}'` : String(v)), \", \");\n        const reason = \"must be one of: \" + allowed;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n    }\n});\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */ /** @type {validateBoolean} */ function validateBoolean(value, name) {\n    if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */ function getOwnPropertyValueOrDefault(options, key, defaultValue) {\n    return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];\n}\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */ /** @type {validateObject} */ const validateObject = hideStackFrames((value, name, options = null)=>{\n    const allowArray = getOwnPropertyValueOrDefault(options, \"allowArray\", false);\n    const allowFunction = getOwnPropertyValueOrDefault(options, \"allowFunction\", false);\n    const nullable = getOwnPropertyValueOrDefault(options, \"nullable\", false);\n    if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\")) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n    }\n});\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */ /** @type {validateDictionary} */ const validateDictionary = hideStackFrames((value, name)=>{\n    if (value != null && typeof value !== \"object\" && typeof value !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"a dictionary\", value);\n    }\n});\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */ /** @type {validateArray} */ const validateArray = hideStackFrames((value, name, minLength = 0)=>{\n    if (!ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n    }\n    if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n    }\n});\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */ /** @type {validateStringArray} */ function validateStringArray(value, name) {\n    validateArray(value, name);\n    for(let i = 0; i < value.length; i++){\n        validateString(value[i], `${name}[${i}]`);\n    }\n}\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */ /** @type {validateBooleanArray} */ function validateBooleanArray(value, name) {\n    validateArray(value, name);\n    for(let i = 0; i < value.length; i++){\n        validateBoolean(value[i], `${name}[${i}]`);\n    }\n}\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */ /** @type {validateAbortSignalArray} */ function validateAbortSignalArray(value, name) {\n    validateArray(value, name);\n    for(let i = 0; i < value.length; i++){\n        const signal = value[i];\n        const indexedName = `${name}[${i}]`;\n        if (signal == null) {\n            throw new ERR_INVALID_ARG_TYPE(indexedName, \"AbortSignal\", signal);\n        }\n        validateAbortSignal(signal, indexedName);\n    }\n}\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */ function validateSignalName(signal, name = \"signal\") {\n    validateString(signal, name);\n    if (signals[signal] === undefined) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n            throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        }\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n    }\n}\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */ /** @type {validateBuffer} */ const validateBuffer = hideStackFrames((buffer, name = \"buffer\")=>{\n    if (!isArrayBufferView(buffer)) {\n        throw new ERR_INVALID_ARG_TYPE(name, [\n            \"Buffer\",\n            \"TypedArray\",\n            \"DataView\"\n        ], buffer);\n    }\n});\n/**\n * @param {string} data\n * @param {string} encoding\n */ function validateEncoding(data, encoding) {\n    const normalizedEncoding = normalizeEncoding(encoding);\n    const length = data.length;\n    if (normalizedEncoding === \"hex\" && length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"encoding\", encoding, `is invalid for data of length ${length}`);\n    }\n}\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */ function validatePort(port, name = \"Port\", allowZero = true) {\n    if (typeof port !== \"number\" && typeof port !== \"string\" || typeof port === \"string\" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 0xffff || port === 0 && !allowZero) {\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n    }\n    return port | 0;\n}\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */ /** @type {validateAbortSignal} */ const validateAbortSignal = hideStackFrames((signal, name)=>{\n    if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n    }\n});\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */ /** @type {validateFunction} */ const validateFunction = hideStackFrames((value, name)=>{\n    if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n});\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */ /** @type {validatePlainFunction} */ const validatePlainFunction = hideStackFrames((value, name)=>{\n    if (typeof value !== \"function\" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n});\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */ /** @type {validateUndefined} */ const validateUndefined = hideStackFrames((value, name)=>{\n    if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, \"undefined\", value);\n});\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */ function validateUnion(value, name, union) {\n    if (!ArrayPrototypeIncludes(union, value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, \"|\")}')`, value);\n    }\n}\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/ const linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/;\n/**\n * @param {any} value\n * @param {string} name\n */ function validateLinkHeaderFormat(value, name) {\n    if (typeof value === \"undefined\" || !RegExpPrototypeExec(linkValueRegExp, value)) {\n        throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format \"</styles.css>; rel=preload; as=style\"');\n    }\n}\n/**\n * @param {any} hints\n * @return {string}\n */ function validateLinkHeaderValue(hints) {\n    if (typeof hints === \"string\") {\n        validateLinkHeaderFormat(hints, \"hints\");\n        return hints;\n    } else if (ArrayIsArray(hints)) {\n        const hintsLength = hints.length;\n        let result = \"\";\n        if (hintsLength === 0) {\n            return result;\n        }\n        for(let i = 0; i < hintsLength; i++){\n            const link = hints[i];\n            validateLinkHeaderFormat(link, \"hints\");\n            result += link;\n            if (i !== hintsLength - 1) {\n                result += \", \";\n            }\n        }\n        return result;\n    }\n    throw new ERR_INVALID_ARG_VALUE(\"hints\", hints, 'must be an array or string of format \"</styles.css>; rel=preload; as=style\"');\n}\nmodule.exports = {\n    isInt32,\n    isUint32,\n    parseFileMode,\n    validateArray,\n    validateStringArray,\n    validateBooleanArray,\n    validateAbortSignalArray,\n    validateBoolean,\n    validateBuffer,\n    validateDictionary,\n    validateEncoding,\n    validateFunction,\n    validateInt32,\n    validateInteger,\n    validateNumber,\n    validateObject,\n    validateOneOf,\n    validatePlainFunction,\n    validatePort,\n    validateSignalName,\n    validateString,\n    validateUint32,\n    validateUndefined,\n    validateUnion,\n    validateAbortSignal,\n    validateLinkHeaderValue\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvdmFsaWRhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUMsR0FFdkM7QUFFQSxNQUFNLEVBQ0pBLFlBQVksRUFDWkMsc0JBQXNCLEVBQ3RCQyxrQkFBa0IsRUFDbEJDLGlCQUFpQixFQUNqQkMsZUFBZSxFQUNmQyxXQUFXLEVBQ1hDLHNCQUFzQixFQUN0QkMsc0JBQXNCLEVBQ3RCQyxjQUFjLEVBQ2RDLDZCQUE2QixFQUM3QkMsbUJBQW1CLEVBQ25CQyxNQUFNLEVBQ05DLDBCQUEwQixFQUMxQkMsbUJBQW1CLEVBQ3BCLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKQyxlQUFlLEVBQ2ZDLE9BQU8sRUFBRUMsbUJBQW1CLEVBQUVDLG9CQUFvQixFQUFFQyxxQkFBcUIsRUFBRUMsZ0JBQWdCLEVBQUVDLGtCQUFrQixFQUFFLEVBQ2xILEdBQUdQLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFUSxpQkFBaUIsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQUVTLGVBQWUsRUFBRUMsaUJBQWlCLEVBQUUsR0FBR1YsZ0pBQTZCO0FBQzVFLE1BQU1ZLFVBQVUsQ0FBQztBQUVqQjs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxLQUFLO0lBQ3BCLE9BQU9BLFVBQVdBLENBQUFBLFFBQVE7QUFDNUI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxTQUFTRCxLQUFLO0lBQ3JCLE9BQU9BLFVBQVVBLFVBQVU7QUFDN0I7QUFDQSxNQUFNRSxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFFakI7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNDLGNBQWNKLEtBQUssRUFBRUssSUFBSSxFQUFFQyxHQUFHO0lBQ3JDLElBQUksT0FBT04sVUFBVSxhQUFhO1FBQ2hDQSxRQUFRTTtJQUNWO0lBQ0EsSUFB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TTtZQUMvQkQsVUFBVUM7WUFDVixJQUFJM0IsTUFBTXlCLGNBQWMsR0FBRztnQkFDekJDLFVBQVU7WUFDWjtRQUNGO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE1BQU0sSUFBSXRFLHNCQUNSLFNBQ0FvRSxPQUNBO0FBRUo7QUFDQUksT0FBT0MsT0FBTyxHQUFHO0lBQ2ZqRTtJQUNBRTtJQUNBRztJQUNBMkI7SUFDQUc7SUFDQUU7SUFDQUM7SUFDQWhCO0lBQ0FxQjtJQUNBWjtJQUNBYztJQUNBTztJQUNBeEM7SUFDQUg7SUFDQU07SUFDQVk7SUFDQVY7SUFDQW9DO0lBQ0FKO0lBQ0FQO0lBQ0E1QjtJQUNBTjtJQUNBOEM7SUFDQUM7SUFDQWQ7SUFDQWtCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvdmFsaWRhdG9ycy5qcz85ZWJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBqc2RvYy9yZXF1aXJlLWpzZG9jOiBcImVycm9yXCIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQXJyYXlJc0FycmF5LFxuICBBcnJheVByb3RvdHlwZUluY2x1ZGVzLFxuICBBcnJheVByb3RvdHlwZUpvaW4sXG4gIEFycmF5UHJvdG90eXBlTWFwLFxuICBOdW1iZXJJc0ludGVnZXIsXG4gIE51bWJlcklzTmFOLFxuICBOdW1iZXJNQVhfU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJNSU5fU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJQYXJzZUludCxcbiAgT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHksXG4gIFJlZ0V4cFByb3RvdHlwZUV4ZWMsXG4gIFN0cmluZyxcbiAgU3RyaW5nUHJvdG90eXBlVG9VcHBlckNhc2UsXG4gIFN0cmluZ1Byb3RvdHlwZVRyaW1cbn0gPSByZXF1aXJlKCcuLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHtcbiAgaGlkZVN0YWNrRnJhbWVzLFxuICBjb2RlczogeyBFUlJfU09DS0VUX0JBRF9QT1JULCBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBFUlJfT1VUX09GX1JBTkdFLCBFUlJfVU5LTk9XTl9TSUdOQUwgfVxufSA9IHJlcXVpcmUoJy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgbm9ybWFsaXplRW5jb2RpbmcgfSA9IHJlcXVpcmUoJy4uL291cnMvdXRpbCcpXG5jb25zdCB7IGlzQXN5bmNGdW5jdGlvbiwgaXNBcnJheUJ1ZmZlclZpZXcgfSA9IHJlcXVpcmUoJy4uL291cnMvdXRpbCcpLnR5cGVzXG5jb25zdCBzaWduYWxzID0ge31cblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJbnQzMih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICh2YWx1ZSB8IDApXG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVWludDMyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPj4+IDBcbn1cbmNvbnN0IG9jdGFsUmVnID0gL15bMC03XSskL1xuY29uc3QgbW9kZURlc2MgPSAnbXVzdCBiZSBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIG9yIGFuIG9jdGFsIHN0cmluZydcblxuLyoqXG4gKiBQYXJzZSBhbmQgdmFsaWRhdGUgdmFsdWVzIHRoYXQgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBtb2RlX3QgKHRoZSBTXypcbiAqIGNvbnN0YW50cykuIE9ubHkgdmFsaWQgbnVtYmVycyBhbmQgb2N0YWwgc3RyaW5ncyBhcmUgYWxsb3dlZC4gVGhleSBjb3VsZCBiZVxuICogY29udmVydGVkIHRvIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBvciBub24tbmVnYXRpdmUgc2lnbmVkIGludGVnZXJzIGluIHRoZVxuICogQysrIGxhbmQsIGJ1dCBhbnkgdmFsdWUgaGlnaGVyIHRoYW4gMG83Nzcgd2lsbCByZXN1bHQgaW4gcGxhdGZvcm0tc3BlY2lmaWNcbiAqIGJlaGF2aW9ycy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWVzIHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmXSBJZiBzcGVjaWZpZWQsIHdpbGwgYmUgcmV0dXJuZWQgZm9yIGludmFsaWQgdmFsdWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGVNb2RlKHZhbHVlLCBuYW1lLCBkZWYpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YWx1ZSA9IGRlZlxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKFJlZ0V4cFByb3RvdHlwZUV4ZWMob2N0YWxSZWcsIHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShuYW1lLCB2YWx1ZSwgbW9kZURlc2MpXG4gICAgfVxuICAgIHZhbHVlID0gTnVtYmVyUGFyc2VJbnQodmFsdWUsIDgpXG4gIH1cbiAgdmFsaWRhdGVVaW50MzIodmFsdWUsIG5hbWUpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUludGVnZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgbnVtYmVyfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVJbnRlZ2VyfSAqL1xuY29uc3QgdmFsaWRhdGVJbnRlZ2VyID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgbWluID0gTnVtYmVyTUlOX1NBRkVfSU5URUdFUiwgbWF4ID0gTnVtYmVyTUFYX1NBRkVfSU5URUdFUikgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgaWYgKCFOdW1iZXJJc0ludGVnZXIodmFsdWUpKSB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsIGA+PSAke21pbn0gJiYgPD0gJHttYXh9YCwgdmFsdWUpXG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUludDMyXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5dXG4gKiBAcGFyYW0ge251bWJlcn0gW21heF1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIG51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlSW50MzJ9ICovXG5jb25zdCB2YWxpZGF0ZUludDMyID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgbWluID0gLTIxNDc0ODM2NDgsIG1heCA9IDIxNDc0ODM2NDcpID0+IHtcbiAgLy8gVGhlIGRlZmF1bHRzIGZvciBtaW4gYW5kIG1heCBjb3JyZXNwb25kIHRvIHRoZSBsaW1pdHMgb2YgMzItYml0IGludGVnZXJzLlxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbiAgaWYgKCFOdW1iZXJJc0ludGVnZXIodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCBgPj0gJHttaW59ICYmIDw9ICR7bWF4fWAsIHZhbHVlKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVVpbnQzMlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IFtwb3NpdGl2ZT1mYWxzZV1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIG51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlVWludDMyfSAqL1xuY29uc3QgdmFsaWRhdGVVaW50MzIgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBwb3NpdGl2ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxuICBpZiAoIU51bWJlcklzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG4gIGNvbnN0IG1pbiA9IHBvc2l0aXZlID8gMSA6IDBcbiAgLy8gMiAqKiAzMiA9PT0gNDI5NDk2NzI5NlxuICBjb25zdCBtYXggPSA0Mjk0OTY3Mjk1XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsIGA+PSAke21pbn0gJiYgPD0gJHttYXh9YCwgdmFsdWUpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgc3RyaW5nfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVTdHJpbmd9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdzdHJpbmcnLCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgbnVtYmVyfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVOdW1iZXJ9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSwgbWluID0gdW5kZWZpbmVkLCBtYXgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIGlmIChcbiAgICAobWluICE9IG51bGwgJiYgdmFsdWUgPCBtaW4pIHx8XG4gICAgKG1heCAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB8fFxuICAgICgobWluICE9IG51bGwgfHwgbWF4ICE9IG51bGwpICYmIE51bWJlcklzTmFOKHZhbHVlKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UoXG4gICAgICBuYW1lLFxuICAgICAgYCR7bWluICE9IG51bGwgPyBgPj0gJHttaW59YCA6ICcnfSR7bWluICE9IG51bGwgJiYgbWF4ICE9IG51bGwgPyAnICYmICcgOiAnJ30ke21heCAhPSBudWxsID8gYDw9ICR7bWF4fWAgOiAnJ31gLFxuICAgICAgdmFsdWVcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVPbmVPZlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1RbXX0gb25lT2ZcbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlT25lT2Z9ICovXG5jb25zdCB2YWxpZGF0ZU9uZU9mID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgb25lT2YpID0+IHtcbiAgaWYgKCFBcnJheVByb3RvdHlwZUluY2x1ZGVzKG9uZU9mLCB2YWx1ZSkpIHtcbiAgICBjb25zdCBhbGxvd2VkID0gQXJyYXlQcm90b3R5cGVKb2luKFxuICAgICAgQXJyYXlQcm90b3R5cGVNYXAob25lT2YsICh2KSA9PiAodHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYCcke3Z9J2AgOiBTdHJpbmcodikpKSxcbiAgICAgICcsICdcbiAgICApXG4gICAgY29uc3QgcmVhc29uID0gJ211c3QgYmUgb25lIG9mOiAnICsgYWxsb3dlZFxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgdmFsdWUsIHJlYXNvbilcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVCb29sZWFuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgYm9vbGVhbn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQm9vbGVhbn0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbih2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnYm9vbGVhbicsIHZhbHVlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRWYWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT0gbnVsbCB8fCAhT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkob3B0aW9ucywga2V5KSA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbnNba2V5XVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZU9iamVjdFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7e1xuICogICBhbGxvd0FycmF5PzogYm9vbGVhbixcbiAqICAgYWxsb3dGdW5jdGlvbj86IGJvb2xlYW4sXG4gKiAgIG51bGxhYmxlPzogYm9vbGVhblxuICogfX0gW29wdGlvbnNdXG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZU9iamVjdH0gKi9cbmNvbnN0IHZhbGlkYXRlT2JqZWN0ID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgb3B0aW9ucyA9IG51bGwpID0+IHtcbiAgY29uc3QgYWxsb3dBcnJheSA9IGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywgJ2FsbG93QXJyYXknLCBmYWxzZSlcbiAgY29uc3QgYWxsb3dGdW5jdGlvbiA9IGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywgJ2FsbG93RnVuY3Rpb24nLCBmYWxzZSlcbiAgY29uc3QgbnVsbGFibGUgPSBnZXRPd25Qcm9wZXJ0eVZhbHVlT3JEZWZhdWx0KG9wdGlvbnMsICdudWxsYWJsZScsIGZhbHNlKVxuICBpZiAoXG4gICAgKCFudWxsYWJsZSAmJiB2YWx1ZSA9PT0gbnVsbCkgfHxcbiAgICAoIWFsbG93QXJyYXkgJiYgQXJyYXlJc0FycmF5KHZhbHVlKSkgfHxcbiAgICAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiAoIWFsbG93RnVuY3Rpb24gfHwgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdPYmplY3QnLCB2YWx1ZSlcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVEaWN0aW9uYXJ5IC0gV2UgYXJlIHVzaW5nIHRoZSBXZWIgSURMIFN0YW5kYXJkIGRlZmluaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBcImRpY3Rpb25hcnlcIiBoZXJlLCB3aGljaCBtZWFucyBhbnkgdmFsdWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9zZSBUeXBlIGlzIGVpdGhlciBVbmRlZmluZWQsIE51bGwsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0ICh3aGljaCBpbmNsdWRlcyBmdW5jdGlvbnMpLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1kaWN0aW9uYXJ5XG4gKiBAc2VlIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyN0YWJsZS10eXBlb2Ytb3BlcmF0b3ItcmVzdWx0c1xuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVEaWN0aW9uYXJ5fSAqL1xuY29uc3QgdmFsaWRhdGVEaWN0aW9uYXJ5ID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnYSBkaWN0aW9uYXJ5JywgdmFsdWUpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbkxlbmd0aF1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIGFueVtdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVBcnJheX0gKi9cbmNvbnN0IHZhbGlkYXRlQXJyYXkgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBtaW5MZW5ndGggPSAwKSA9PiB7XG4gIGlmICghQXJyYXlJc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQXJyYXknLCB2YWx1ZSlcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgY29uc3QgcmVhc29uID0gYG11c3QgYmUgbG9uZ2VyIHRoYW4gJHttaW5MZW5ndGh9YFxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgdmFsdWUsIHJlYXNvbilcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVTdHJpbmdBcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIHN0cmluZ1tdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVTdHJpbmdBcnJheX0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nQXJyYXkodmFsdWUsIG5hbWUpIHtcbiAgdmFsaWRhdGVBcnJheSh2YWx1ZSwgbmFtZSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlU3RyaW5nKHZhbHVlW2ldLCBgJHtuYW1lfVske2l9XWApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVCb29sZWFuQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBib29sZWFuW119XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUJvb2xlYW5BcnJheX0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbkFycmF5KHZhbHVlLCBuYW1lKSB7XG4gIHZhbGlkYXRlQXJyYXkodmFsdWUsIG5hbWUpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUJvb2xlYW4odmFsdWVbaV0sIGAke25hbWV9WyR7aX1dYClcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUFib3J0U2lnbmFsQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBBYm9ydFNpZ25hbFtdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5fSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5KHZhbHVlLCBuYW1lKSB7XG4gIHZhbGlkYXRlQXJyYXkodmFsdWUsIG5hbWUpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaWduYWwgPSB2YWx1ZVtpXVxuICAgIGNvbnN0IGluZGV4ZWROYW1lID0gYCR7bmFtZX1bJHtpfV1gXG4gICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoaW5kZXhlZE5hbWUsICdBYm9ydFNpZ25hbCcsIHNpZ25hbClcbiAgICB9XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwsIGluZGV4ZWROYW1lKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBzaWduYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nc2lnbmFsJ11cbiAqIEByZXR1cm5zIHthc3NlcnRzIHNpZ25hbCBpcyBrZXlvZiBzaWduYWxzfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25hbE5hbWUoc2lnbmFsLCBuYW1lID0gJ3NpZ25hbCcpIHtcbiAgdmFsaWRhdGVTdHJpbmcoc2lnbmFsLCBuYW1lKVxuICBpZiAoc2lnbmFsc1tzaWduYWxdID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc2lnbmFsc1tTdHJpbmdQcm90b3R5cGVUb1VwcGVyQ2FzZShzaWduYWwpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX1VOS05PV05fU0lHTkFMKHNpZ25hbCArICcgKHNpZ25hbHMgbXVzdCB1c2UgYWxsIGNhcGl0YWwgbGV0dGVycyknKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRVJSX1VOS05PV05fU0lHTkFMKHNpZ25hbClcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUJ1ZmZlclxuICogQHBhcmFtIHsqfSBidWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nYnVmZmVyJ11cbiAqIEByZXR1cm5zIHthc3NlcnRzIGJ1ZmZlciBpcyBBcnJheUJ1ZmZlclZpZXd9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUJ1ZmZlcn0gKi9cbmNvbnN0IHZhbGlkYXRlQnVmZmVyID0gaGlkZVN0YWNrRnJhbWVzKChidWZmZXIsIG5hbWUgPSAnYnVmZmVyJykgPT4ge1xuICBpZiAoIWlzQXJyYXlCdWZmZXJWaWV3KGJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgWydCdWZmZXInLCAnVHlwZWRBcnJheScsICdEYXRhVmlldyddLCBidWZmZXIpXG4gIH1cbn0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUVuY29kaW5nKGRhdGEsIGVuY29kaW5nKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRFbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKVxuICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICBpZiAobm9ybWFsaXplZEVuY29kaW5nID09PSAnaGV4JyAmJiBsZW5ndGggJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZW5jb2RpbmcnLCBlbmNvZGluZywgYGlzIGludmFsaWQgZm9yIGRhdGEgb2YgbGVuZ3RoICR7bGVuZ3RofWApXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB0aGF0IHRoZSBwb3J0IG51bWJlciBpcyBub3QgTmFOIHdoZW4gY29lcmNlZCB0byBhIG51bWJlcixcbiAqIGlzIGFuIGludGVnZXIgYW5kIHRoYXQgaXQgZmFsbHMgd2l0aGluIHRoZSBsZWdhbCByYW5nZSBvZiBwb3J0IG51bWJlcnMuXG4gKiBAcGFyYW0geyp9IHBvcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nUG9ydCddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd1plcm89dHJ1ZV1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUG9ydChwb3J0LCBuYW1lID0gJ1BvcnQnLCBhbGxvd1plcm8gPSB0cnVlKSB7XG4gIGlmIChcbiAgICAodHlwZW9mIHBvcnQgIT09ICdudW1iZXInICYmIHR5cGVvZiBwb3J0ICE9PSAnc3RyaW5nJykgfHxcbiAgICAodHlwZW9mIHBvcnQgPT09ICdzdHJpbmcnICYmIFN0cmluZ1Byb3RvdHlwZVRyaW0ocG9ydCkubGVuZ3RoID09PSAwKSB8fFxuICAgICtwb3J0ICE9PSArcG9ydCA+Pj4gMCB8fFxuICAgIHBvcnQgPiAweGZmZmYgfHxcbiAgICAocG9ydCA9PT0gMCAmJiAhYWxsb3daZXJvKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRVJSX1NPQ0tFVF9CQURfUE9SVChuYW1lLCBwb3J0LCBhbGxvd1plcm8pXG4gIH1cbiAgcmV0dXJuIHBvcnQgfCAwXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQWJvcnRTaWduYWxcbiAqIEBwYXJhbSB7Kn0gc2lnbmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVBYm9ydFNpZ25hbH0gKi9cbmNvbnN0IHZhbGlkYXRlQWJvcnRTaWduYWwgPSBoaWRlU3RhY2tGcmFtZXMoKHNpZ25hbCwgbmFtZSkgPT4ge1xuICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQgJiYgKHNpZ25hbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlRnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBGdW5jdGlvbn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlRnVuY3Rpb259ICovXG5jb25zdCB2YWxpZGF0ZUZ1bmN0aW9uID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Z1bmN0aW9uJywgdmFsdWUpXG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVBsYWluRnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBGdW5jdGlvbn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlUGxhaW5GdW5jdGlvbn0gKi9cbmNvbnN0IHZhbGlkYXRlUGxhaW5GdW5jdGlvbiA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCBpc0FzeW5jRnVuY3Rpb24odmFsdWUpKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Z1bmN0aW9uJywgdmFsdWUpXG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIHVuZGVmaW5lZH1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlVW5kZWZpbmVkfSAqL1xuY29uc3QgdmFsaWRhdGVVbmRlZmluZWQgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lKSA9PiB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ3VuZGVmaW5lZCcsIHZhbHVlKVxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7VFtdfSB1bmlvblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVVuaW9uKHZhbHVlLCBuYW1lLCB1bmlvbikge1xuICBpZiAoIUFycmF5UHJvdG90eXBlSW5jbHVkZXModW5pb24sIHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCBgKCcke0FycmF5UHJvdG90eXBlSm9pbih1bmlvbiwgJ3wnKX0nKWAsIHZhbHVlKVxuICB9XG59XG5cbi8qXG4gIFRoZSBydWxlcyBmb3IgdGhlIExpbmsgaGVhZGVyIGZpZWxkIGFyZSBkZXNjcmliZWQgaGVyZTpcbiAgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzgyODguaHRtbCNzZWN0aW9uLTNcblxuICBUaGlzIHJlZ2V4IHZhbGlkYXRlcyBhbnkgc3RyaW5nIHN1cnJvdW5kZWQgYnkgYW5nbGUgYnJhY2tldHNcbiAgKG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIFVSSSByZWZlcmVuY2UpIGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZVxuICBsaW5rLXBhcmFtcyBzZXBhcmF0ZWQgYnkgc2VtaWNvbG9ucy5cbiovXG5jb25zdCBsaW5rVmFsdWVSZWdFeHAgPSAvXig/OjxbXj5dKj4pKD86XFxzKjtcXHMqW147XCJcXHNdKyg/Oj0oXCIpP1teO1wiXFxzXSpcXDEpPykqJC9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGlua0hlYWRlckZvcm1hdCh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCAhUmVnRXhwUHJvdG90eXBlRXhlYyhsaW5rVmFsdWVSZWdFeHAsIHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICAnbXVzdCBiZSBhbiBhcnJheSBvciBzdHJpbmcgb2YgZm9ybWF0IFwiPC9zdHlsZXMuY3NzPjsgcmVsPXByZWxvYWQ7IGFzPXN0eWxlXCInXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGhpbnRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGlua0hlYWRlclZhbHVlKGhpbnRzKSB7XG4gIGlmICh0eXBlb2YgaGludHMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsaWRhdGVMaW5rSGVhZGVyRm9ybWF0KGhpbnRzLCAnaGludHMnKVxuICAgIHJldHVybiBoaW50c1xuICB9IGVsc2UgaWYgKEFycmF5SXNBcnJheShoaW50cykpIHtcbiAgICBjb25zdCBoaW50c0xlbmd0aCA9IGhpbnRzLmxlbmd0aFxuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIGlmIChoaW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBoaW50c1tpXVxuICAgICAgdmFsaWRhdGVMaW5rSGVhZGVyRm9ybWF0KGxpbmssICdoaW50cycpXG4gICAgICByZXN1bHQgKz0gbGlua1xuICAgICAgaWYgKGkgIT09IGhpbnRzTGVuZ3RoIC0gMSkge1xuICAgICAgICByZXN1bHQgKz0gJywgJ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShcbiAgICAnaGludHMnLFxuICAgIGhpbnRzLFxuICAgICdtdXN0IGJlIGFuIGFycmF5IG9yIHN0cmluZyBvZiBmb3JtYXQgXCI8L3N0eWxlcy5jc3M+OyByZWw9cHJlbG9hZDsgYXM9c3R5bGVcIidcbiAgKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzSW50MzIsXG4gIGlzVWludDMyLFxuICBwYXJzZUZpbGVNb2RlLFxuICB2YWxpZGF0ZUFycmF5LFxuICB2YWxpZGF0ZVN0cmluZ0FycmF5LFxuICB2YWxpZGF0ZUJvb2xlYW5BcnJheSxcbiAgdmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5LFxuICB2YWxpZGF0ZUJvb2xlYW4sXG4gIHZhbGlkYXRlQnVmZmVyLFxuICB2YWxpZGF0ZURpY3Rpb25hcnksXG4gIHZhbGlkYXRlRW5jb2RpbmcsXG4gIHZhbGlkYXRlRnVuY3Rpb24sXG4gIHZhbGlkYXRlSW50MzIsXG4gIHZhbGlkYXRlSW50ZWdlcixcbiAgdmFsaWRhdGVOdW1iZXIsXG4gIHZhbGlkYXRlT2JqZWN0LFxuICB2YWxpZGF0ZU9uZU9mLFxuICB2YWxpZGF0ZVBsYWluRnVuY3Rpb24sXG4gIHZhbGlkYXRlUG9ydCxcbiAgdmFsaWRhdGVTaWduYWxOYW1lLFxuICB2YWxpZGF0ZVN0cmluZyxcbiAgdmFsaWRhdGVVaW50MzIsXG4gIHZhbGlkYXRlVW5kZWZpbmVkLFxuICB2YWxpZGF0ZVVuaW9uLFxuICB2YWxpZGF0ZUFib3J0U2lnbmFsLFxuICB2YWxpZGF0ZUxpbmtIZWFkZXJWYWx1ZVxufVxuIl0sIm5hbWVzIjpbIkFycmF5SXNBcnJheSIsIkFycmF5UHJvdG90eXBlSW5jbHVkZXMiLCJBcnJheVByb3RvdHlwZUpvaW4iLCJBcnJheVByb3RvdHlwZU1hcCIsIk51bWJlcklzSW50ZWdlciIsIk51bWJlcklzTmFOIiwiTnVtYmVyTUFYX1NBRkVfSU5URUdFUiIsIk51bWJlck1JTl9TQUZFX0lOVEVHRVIiLCJOdW1iZXJQYXJzZUludCIsIk9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5IiwiUmVnRXhwUHJvdG90eXBlRXhlYyIsIlN0cmluZyIsIlN0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlIiwiU3RyaW5nUHJvdG90eXBlVHJpbSIsInJlcXVpcmUiLCJoaWRlU3RhY2tGcmFtZXMiLCJjb2RlcyIsIkVSUl9TT0NLRVRfQkFEX1BPUlQiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9JTlZBTElEX0FSR19WQUxVRSIsIkVSUl9PVVRfT0ZfUkFOR0UiLCJFUlJfVU5LTk9XTl9TSUdOQUwiLCJub3JtYWxpemVFbmNvZGluZyIsImlzQXN5bmNGdW5jdGlvbiIsImlzQXJyYXlCdWZmZXJWaWV3IiwidHlwZXMiLCJzaWduYWxzIiwiaXNJbnQzMiIsInZhbHVlIiwiaXNVaW50MzIiLCJvY3RhbFJlZyIsIm1vZGVEZXNjIiwicGFyc2VGaWxlTW9kZSIsIm5hbWUiLCJkZWYiLCJ2YWxpZGF0ZVVpbnQzMiIsInZhbGlkYXRlSW50ZWdlciIsIm1pbiIsIm1heCIsInZhbGlkYXRlSW50MzIiLCJwb3NpdGl2ZSIsInZhbGlkYXRlU3RyaW5nIiwidmFsaWRhdGVOdW1iZXIiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0ZU9uZU9mIiwib25lT2YiLCJhbGxvd2VkIiwidiIsInJlYXNvbiIsInZhbGlkYXRlQm9vbGVhbiIsImdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQiLCJvcHRpb25zIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwidmFsaWRhdGVPYmplY3QiLCJhbGxvd0FycmF5IiwiYWxsb3dGdW5jdGlvbiIsIm51bGxhYmxlIiwidmFsaWRhdGVEaWN0aW9uYXJ5IiwidmFsaWRhdGVBcnJheSIsIm1pbkxlbmd0aCIsImxlbmd0aCIsInZhbGlkYXRlU3RyaW5nQXJyYXkiLCJpIiwidmFsaWRhdGVCb29sZWFuQXJyYXkiLCJ2YWxpZGF0ZUFib3J0U2lnbmFsQXJyYXkiLCJzaWduYWwiLCJpbmRleGVkTmFtZSIsInZhbGlkYXRlQWJvcnRTaWduYWwiLCJ2YWxpZGF0ZVNpZ25hbE5hbWUiLCJ2YWxpZGF0ZUJ1ZmZlciIsImJ1ZmZlciIsInZhbGlkYXRlRW5jb2RpbmciLCJkYXRhIiwiZW5jb2RpbmciLCJub3JtYWxpemVkRW5jb2RpbmciLCJ2YWxpZGF0ZVBvcnQiLCJwb3J0IiwiYWxsb3daZXJvIiwidmFsaWRhdGVGdW5jdGlvbiIsInZhbGlkYXRlUGxhaW5GdW5jdGlvbiIsInZhbGlkYXRlVW5kZWZpbmVkIiwidmFsaWRhdGVVbmlvbiIsInVuaW9uIiwibGlua1ZhbHVlUmVnRXhwIiwidmFsaWRhdGVMaW5rSGVhZGVyRm9ybWF0IiwidmFsaWRhdGVMaW5rSGVhZGVyVmFsdWUiLCJoaW50cyIsImhpbnRzTGVuZ3RoIiwicmVzdWx0IiwibGluayIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/validators.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { format, inspect, AggregateError: CustomAggregateError } = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/ const AggregateError = globalThis.AggregateError || CustomAggregateError;\nconst kIsNodeError = Symbol(\"kIsNodeError\");\nconst kTypes = [\n    \"string\",\n    \"function\",\n    \"number\",\n    \"object\",\n    // Accept 'Function' and 'Object' as alternative to the lower cased version.\n    \"Function\",\n    \"Object\",\n    \"boolean\",\n    \"bigint\",\n    \"symbol\"\n];\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\nconst nodeInternalPrefix = \"__node_internal_\";\nconst codes = {};\nfunction assert(value, message) {\n    if (!value) {\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n    }\n}\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n    let res = \"\";\n    let i = val.length;\n    const start = val[0] === \"-\" ? 1 : 0;\n    for(; i >= start + 4; i -= 3){\n        res = `_${val.slice(i - 3, i)}${res}`;\n    }\n    return `${val.slice(0, i)}${res}`;\n}\nfunction getMessage(key, msg, args) {\n    if (typeof msg === \"function\") {\n        assert(msg.length <= args.length, // Default options do not count.\n        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);\n        return msg(...args);\n    }\n    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n    assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);\n    if (args.length === 0) {\n        return msg;\n    }\n    return format(msg, ...args);\n}\nfunction E(code, message, Base) {\n    if (!Base) {\n        Base = Error;\n    }\n    class NodeError extends Base {\n        constructor(...args){\n            super(getMessage(code, message, args));\n        }\n        toString() {\n            return `${this.name} [${code}]: ${this.message}`;\n        }\n    }\n    Object.defineProperties(NodeError.prototype, {\n        name: {\n            value: Base.name,\n            writable: true,\n            enumerable: false,\n            configurable: true\n        },\n        toString: {\n            value () {\n                return `${this.name} [${code}]: ${this.message}`;\n            },\n            writable: true,\n            enumerable: false,\n            configurable: true\n        }\n    });\n    NodeError.prototype.code = code;\n    NodeError.prototype[kIsNodeError] = true;\n    codes[code] = NodeError;\n}\nfunction hideStackFrames(fn) {\n    // We rename the functions that will be hidden to cut off the stacktrace\n    // at the outermost one\n    const hidden = nodeInternalPrefix + fn.name;\n    Object.defineProperty(fn, \"name\", {\n        value: hidden\n    });\n    return fn;\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n    if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors)) {\n            // If `outerError` is already an `AggregateError`.\n            outerError.errors.push(innerError);\n            return outerError;\n        }\n        const err = new AggregateError([\n            outerError,\n            innerError\n        ], outerError.message);\n        err.code = outerError.code;\n        return err;\n    }\n    return innerError || outerError;\n}\nclass AbortError extends Error {\n    constructor(message = \"The operation was aborted\", options = undefined){\n        if (options !== undefined && typeof options !== \"object\") {\n            throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        }\n        super(message, options);\n        this.code = \"ABORT_ERR\";\n        this.name = \"AbortError\";\n    }\n}\nE(\"ERR_ASSERTION\", \"%s\", Error);\nE(\"ERR_INVALID_ARG_TYPE\", (name, expected, actual)=>{\n    assert(typeof name === \"string\", \"'name' must be a string\");\n    if (!Array.isArray(expected)) {\n        expected = [\n            expected\n        ];\n    }\n    let msg = \"The \";\n    if (name.endsWith(\" argument\")) {\n        // For cases like 'first argument'\n        msg += `${name} `;\n    } else {\n        msg += `\"${name}\" ${name.includes(\".\") ? \"property\" : \"argument\"} `;\n    }\n    msg += \"must be \";\n    const types = [];\n    const instances = [];\n    const other = [];\n    for (const value of expected){\n        assert(typeof value === \"string\", \"All expected entries have to be of type string\");\n        if (kTypes.includes(value)) {\n            types.push(value.toLowerCase());\n        } else if (classRegExp.test(value)) {\n            instances.push(value);\n        } else {\n            assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"');\n            other.push(value);\n        }\n    }\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n        const pos = types.indexOf(\"object\");\n        if (pos !== -1) {\n            types.splice(types, pos, 1);\n            instances.push(\"Object\");\n        }\n    }\n    if (types.length > 0) {\n        switch(types.length){\n            case 1:\n                msg += `of type ${types[0]}`;\n                break;\n            case 2:\n                msg += `one of type ${types[0]} or ${types[1]}`;\n                break;\n            default:\n                {\n                    const last = types.pop();\n                    msg += `one of type ${types.join(\", \")}, or ${last}`;\n                }\n        }\n        if (instances.length > 0 || other.length > 0) {\n            msg += \" or \";\n        }\n    }\n    if (instances.length > 0) {\n        switch(instances.length){\n            case 1:\n                msg += `an instance of ${instances[0]}`;\n                break;\n            case 2:\n                msg += `an instance of ${instances[0]} or ${instances[1]}`;\n                break;\n            default:\n                {\n                    const last = instances.pop();\n                    msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n                }\n        }\n        if (other.length > 0) {\n            msg += \" or \";\n        }\n    }\n    switch(other.length){\n        case 0:\n            break;\n        case 1:\n            if (other[0].toLowerCase() !== other[0]) {\n                msg += \"an \";\n            }\n            msg += `${other[0]}`;\n            break;\n        case 2:\n            msg += `one of ${other[0]} or ${other[1]}`;\n            break;\n        default:\n            {\n                const last = other.pop();\n                msg += `one of ${other.join(\", \")}, or ${last}`;\n            }\n    }\n    if (actual == null) {\n        msg += `. Received ${actual}`;\n    } else if (typeof actual === \"function\" && actual.name) {\n        msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === \"object\") {\n        var _actual$constructor;\n        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) {\n            msg += `. Received an instance of ${actual.constructor.name}`;\n        } else {\n            const inspected = inspect(actual, {\n                depth: -1\n            });\n            msg += `. Received ${inspected}`;\n        }\n    } else {\n        let inspected = inspect(actual, {\n            colors: false\n        });\n        if (inspected.length > 25) {\n            inspected = `${inspected.slice(0, 25)}...`;\n        }\n        msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n}, TypeError);\nE(\"ERR_INVALID_ARG_VALUE\", (name, value, reason = \"is invalid\")=>{\n    let inspected = inspect(value);\n    if (inspected.length > 128) {\n        inspected = inspected.slice(0, 128) + \"...\";\n    }\n    const type = name.includes(\".\") ? \"property\" : \"argument\";\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}, TypeError);\nE(\"ERR_INVALID_RETURN_VALUE\", (input, name, value)=>{\n    var _value$constructor;\n    const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`;\n}, TypeError);\nE(\"ERR_MISSING_ARGS\", (...args)=>{\n    assert(args.length > 0, \"At least one arg needs to be specified\");\n    let msg;\n    const len = args.length;\n    args = (Array.isArray(args) ? args : [\n        args\n    ]).map((a)=>`\"${a}\"`).join(\" or \");\n    switch(len){\n        case 1:\n            msg += `The ${args[0]} argument`;\n            break;\n        case 2:\n            msg += `The ${args[0]} and ${args[1]} arguments`;\n            break;\n        default:\n            {\n                const last = args.pop();\n                msg += `The ${args.join(\", \")}, and ${last} arguments`;\n            }\n            break;\n    }\n    return `${msg} must be specified`;\n}, TypeError);\nE(\"ERR_OUT_OF_RANGE\", (str, range, input)=>{\n    assert(range, 'Missing \"range\" argument');\n    let received;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n        received = addNumericalSeparator(String(input));\n    } else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > 2n ** 32n || input < -(2n ** 32n)) {\n            received = addNumericalSeparator(received);\n        }\n        received += \"n\";\n    } else {\n        received = inspect(input);\n    }\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n}, RangeError);\nE(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error);\nE(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error);\nE(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error);\nE(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error);\nE(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error);\nE(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\nE(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error);\nE(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error);\nE(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error);\nE(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error);\nE(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError);\nmodule.exports = {\n    AbortError,\n    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n    hideStackFrames,\n    codes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxnQkFBZ0JDLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTFFOzs7Ozs7O0FBT0EsR0FFQSxNQUFNRixpQkFBaUJHLFdBQVdILGNBQWMsSUFBSUM7QUFDcEQsTUFBTUcsZUFBZUMsT0FBTztBQUM1QixNQUFNQyxTQUFTO0lBQ2I7SUFDQTtJQUNBO0lBQ0E7SUFDQSw0RUFBNEU7SUFDNUU7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsUUFBUSxDQUFDO0FBQ2YsU0FBU0MsT0FBT0MsS0FBSyxFQUFFQyxPQUFPO0lBQzVCLElBQUksQ0FBQ0QsT0FBTztRQUNWLE1BQU0sSUFBSUYsTUFBTUksc0JBQXNCLENBQUNEO0lBQ3pDO0FBQ0Y7QUFFQSw4RUFBOEU7QUFDOUUsU0FBU0Usc0JBQXNCQyxHQUFHO0lBQ2hDLElBQUlDLE1BQU07SUFDVixJQUFJQyxJQUFJRixJQUFJRyxNQUFNO0lBQ2xCLE1BQU1DLFFBQVFKLEdBQUcsQ0FBQyxFQUFFLEtBQUssTUFBTSxJQUFJO0lBQ25DLE1BQU9FLEtBQUtFLFFBQVEsR0FBR0YsS0FBSyxFQUFHO1FBQzdCRCxNQUFNLENBQUMsQ0FBQyxFQUFFRCxJQUFJSyxLQUFLLENBQUNILElBQUksR0FBR0EsR0FBRyxFQUFFRCxJQUFJLENBQUM7SUFDdkM7SUFDQSxPQUFPLENBQUMsRUFBRUQsSUFBSUssS0FBSyxDQUFDLEdBQUdILEdBQUcsRUFBRUQsSUFBSSxDQUFDO0FBQ25DO0FBQ0EsU0FBU0ssV0FBV0MsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLElBQUk7SUFDaEMsSUFB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LElBQUksR0FBRyxHQUFHO1lBQzdDTyxXQUFXeEUsc0JBQXNCd0U7UUFDbkM7UUFDQUEsWUFBWTtJQUNkLE9BQU87UUFDTEEsV0FBV3ZGLFFBQVFnRjtJQUNyQjtJQUNBLE9BQU8sQ0FBQyxjQUFjLEVBQUVLLElBQUksOEJBQThCLEVBQUVDLE1BQU0sV0FBVyxFQUFFQyxTQUFTLENBQUM7QUFDM0YsR0FDQU07QUFFRmpFLEVBQUUseUJBQXlCLGtDQUFrQ0c7QUFDN0RILEVBQUUsOEJBQThCLG9DQUFvQ0c7QUFDcEVILEVBQUUsK0JBQStCLDhDQUE4Q0c7QUFDL0VILEVBQUUsMEJBQTBCLDZCQUE2Qkc7QUFDekRILEVBQUUsd0JBQXdCLCtDQUErQ0c7QUFDekVILEVBQUUsMEJBQTBCLHVDQUF1Q2lEO0FBQ25FakQsRUFBRSw4QkFBOEIsbUJBQW1CRztBQUNuREgsRUFBRSw2QkFBNkIsMkJBQTJCRztBQUMxREgsRUFBRSxzQ0FBc0Msb0NBQW9DRztBQUM1RUgsRUFBRSw4QkFBOEIsbUJBQW1CRztBQUNuREgsRUFBRSx3QkFBd0Isd0JBQXdCaUQ7QUFDbERpQixPQUFPQyxPQUFPLEdBQUc7SUFDZnpDO0lBQ0FSLG9CQUFvQkosZ0JBQWdCSTtJQUNwQ0o7SUFDQWhDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9lcnJvcnMuanM/ZjI0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBmb3JtYXQsIGluc3BlY3QsIEFnZ3JlZ2F0ZUVycm9yOiBDdXN0b21BZ2dyZWdhdGVFcnJvciB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLypcbiAgVGhpcyBmaWxlIGlzIGEgcmVkdWNlZCBhbmQgYWRhcHRlZCB2ZXJzaW9uIG9mIHRoZSBtYWluIGxpYi9pbnRlcm5hbC9lcnJvcnMuanMgZmlsZSBkZWZpbmVkIGF0XG5cbiAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuICBEb24ndCB0cnkgdG8gcmVwbGFjZSB3aXRoIHRoZSBvcmlnaW5hbCBmaWxlIGFuZCBrZWVwIGl0IHVwIHRvIGRhdGUgKHN0YXJ0aW5nIGZyb20gRSguLi4pIGRlZmluaXRpb25zKVxuICB3aXRoIHRoZSB1cHN0cmVhbSBmaWxlLlxuKi9cblxuY29uc3QgQWdncmVnYXRlRXJyb3IgPSBnbG9iYWxUaGlzLkFnZ3JlZ2F0ZUVycm9yIHx8IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yXG5jb25zdCBrSXNOb2RlRXJyb3IgPSBTeW1ib2woJ2tJc05vZGVFcnJvcicpXG5jb25zdCBrVHlwZXMgPSBbXG4gICdzdHJpbmcnLFxuICAnZnVuY3Rpb24nLFxuICAnbnVtYmVyJyxcbiAgJ29iamVjdCcsXG4gIC8vIEFjY2VwdCAnRnVuY3Rpb24nIGFuZCAnT2JqZWN0JyBhcyBhbHRlcm5hdGl2ZSB0byB0aGUgbG93ZXIgY2FzZWQgdmVyc2lvbi5cbiAgJ0Z1bmN0aW9uJyxcbiAgJ09iamVjdCcsXG4gICdib29sZWFuJyxcbiAgJ2JpZ2ludCcsXG4gICdzeW1ib2wnXG5dXG5jb25zdCBjbGFzc1JlZ0V4cCA9IC9eKFtBLVpdW2EtejAtOV0qKSskL1xuY29uc3Qgbm9kZUludGVybmFsUHJlZml4ID0gJ19fbm9kZV9pbnRlcm5hbF8nXG5jb25zdCBjb2RlcyA9IHt9XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfSU5URVJOQUxfQVNTRVJUSU9OKG1lc3NhZ2UpXG4gIH1cbn1cblxuLy8gT25seSB1c2UgdGhpcyBmb3IgaW50ZWdlcnMhIERlY2ltYWwgbnVtYmVycyBkbyBub3Qgd29yayB3aXRoIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShrZXksIG1zZywgYXJncykge1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2VydChcbiAgICAgIG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsXG4gICAgICAvLyBEZWZhdWx0IG9wdGlvbnMgZG8gbm90IGNvdW50LlxuICAgICAgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHttc2cubGVuZ3RofSkuYFxuICAgIClcbiAgICByZXR1cm4gbXNnKC4uLmFyZ3MpXG4gIH1cbiAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGhcbiAgYXNzZXJ0KFxuICAgIGV4cGVjdGVkTGVuZ3RoID09PSBhcmdzLmxlbmd0aCxcbiAgICBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke2V4cGVjdGVkTGVuZ3RofSkuYFxuICApXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtc2dcbiAgfVxuICByZXR1cm4gZm9ybWF0KG1zZywgLi4uYXJncylcbn1cbmZ1bmN0aW9uIEUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3JcbiAgfVxuICBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlcihnZXRNZXNzYWdlKGNvZGUsIG1lc3NhZ2UsIGFyZ3MpKVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2NvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhOb2RlRXJyb3IucHJvdG90eXBlLCB7XG4gICAgbmFtZToge1xuICAgICAgdmFsdWU6IEJhc2UubmFtZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuICAgIHRvU3RyaW5nOiB7XG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7Y29kZX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSlcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZVxuICBOb2RlRXJyb3IucHJvdG90eXBlW2tJc05vZGVFcnJvcl0gPSB0cnVlXG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yXG59XG5mdW5jdGlvbiBoaWRlU3RhY2tGcmFtZXMoZm4pIHtcbiAgLy8gV2UgcmVuYW1lIHRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGhpZGRlbiB0byBjdXQgb2ZmIHRoZSBzdGFja3RyYWNlXG4gIC8vIGF0IHRoZSBvdXRlcm1vc3Qgb25lXG4gIGNvbnN0IGhpZGRlbiA9IG5vZGVJbnRlcm5hbFByZWZpeCArIGZuLm5hbWVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogaGlkZGVuXG4gIH0pXG4gIHJldHVybiBmblxufVxuZnVuY3Rpb24gYWdncmVnYXRlVHdvRXJyb3JzKGlubmVyRXJyb3IsIG91dGVyRXJyb3IpIHtcbiAgaWYgKGlubmVyRXJyb3IgJiYgb3V0ZXJFcnJvciAmJiBpbm5lckVycm9yICE9PSBvdXRlckVycm9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3V0ZXJFcnJvci5lcnJvcnMpKSB7XG4gICAgICAvLyBJZiBgb3V0ZXJFcnJvcmAgaXMgYWxyZWFkeSBhbiBgQWdncmVnYXRlRXJyb3JgLlxuICAgICAgb3V0ZXJFcnJvci5lcnJvcnMucHVzaChpbm5lckVycm9yKVxuICAgICAgcmV0dXJuIG91dGVyRXJyb3JcbiAgICB9XG4gICAgY29uc3QgZXJyID0gbmV3IEFnZ3JlZ2F0ZUVycm9yKFtvdXRlckVycm9yLCBpbm5lckVycm9yXSwgb3V0ZXJFcnJvci5tZXNzYWdlKVxuICAgIGVyci5jb2RlID0gb3V0ZXJFcnJvci5jb2RlXG4gICAgcmV0dXJuIGVyclxuICB9XG4gIHJldHVybiBpbm5lckVycm9yIHx8IG91dGVyRXJyb3Jcbn1cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpXG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpXG4gICAgdGhpcy5jb2RlID0gJ0FCT1JUX0VSUidcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgfVxufVxuRSgnRVJSX0FTU0VSVElPTicsICclcycsIEVycm9yKVxuRShcbiAgJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpID0+IHtcbiAgICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgICAgZXhwZWN0ZWQgPSBbZXhwZWN0ZWRdXG4gICAgfVxuICAgIGxldCBtc2cgPSAnVGhlICdcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICAgIG1zZyArPSBgJHtuYW1lfSBgXG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyArPSBgXCIke25hbWV9XCIgJHtuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50J30gYFxuICAgIH1cbiAgICBtc2cgKz0gJ211c3QgYmUgJ1xuICAgIGNvbnN0IHR5cGVzID0gW11cbiAgICBjb25zdCBpbnN0YW5jZXMgPSBbXVxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGV4cGVjdGVkKSB7XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ0FsbCBleHBlY3RlZCBlbnRyaWVzIGhhdmUgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKVxuICAgICAgaWYgKGtUeXBlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgdHlwZXMucHVzaCh2YWx1ZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgfSBlbHNlIGlmIChjbGFzc1JlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgICBpbnN0YW5jZXMucHVzaCh2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gJ29iamVjdCcsICdUaGUgdmFsdWUgXCJvYmplY3RcIiBzaG91bGQgYmUgd3JpdHRlbiBhcyBcIk9iamVjdFwiJylcbiAgICAgICAgb3RoZXIucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGhhbmRsZSBgb2JqZWN0YCBpbiBjYXNlIG90aGVyIGluc3RhbmNlcyBhcmUgYWxsb3dlZCB0byBvdXRsaW5lXG4gICAgLy8gdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gZWFjaCBvdGhlci5cbiAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBvcyA9IHR5cGVzLmluZGV4T2YoJ29iamVjdCcpXG4gICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UodHlwZXMsIHBvcywgMSlcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goJ09iamVjdCcpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbXNnICs9IGBvZiB0eXBlICR7dHlwZXNbMF19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtc2cgKz0gYG9uZSBvZiB0eXBlICR7dHlwZXNbMF19IG9yICR7dHlwZXNbMV19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gdHlwZXMucG9wKClcbiAgICAgICAgICBtc2cgKz0gYG9uZSBvZiB0eXBlICR7dHlwZXMuam9pbignLCAnKX0sIG9yICR7bGFzdH1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID4gMCB8fCBvdGhlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1zZyArPSAnIG9yICdcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzd2l0Y2ggKGluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1zZyArPSBgYW4gaW5zdGFuY2Ugb2YgJHtpbnN0YW5jZXNbMF19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtc2cgKz0gYGFuIGluc3RhbmNlIG9mICR7aW5zdGFuY2VzWzBdfSBvciAke2luc3RhbmNlc1sxXX1gXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBpbnN0YW5jZXMucG9wKClcbiAgICAgICAgICBtc2cgKz0gYGFuIGluc3RhbmNlIG9mICR7aW5zdGFuY2VzLmpvaW4oJywgJyl9LCBvciAke2xhc3R9YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3RoZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gJyBvciAnXG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAob3RoZXIubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChvdGhlclswXS50b0xvd2VyQ2FzZSgpICE9PSBvdGhlclswXSkge1xuICAgICAgICAgIG1zZyArPSAnYW4gJ1xuICAgICAgICB9XG4gICAgICAgIG1zZyArPSBgJHtvdGhlclswXX1gXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIG1zZyArPSBgb25lIG9mICR7b3RoZXJbMF19IG9yICR7b3RoZXJbMV19YFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBsYXN0ID0gb3RoZXIucG9wKClcbiAgICAgICAgbXNnICs9IGBvbmUgb2YgJHtvdGhlci5qb2luKCcsICcpfSwgb3IgJHtsYXN0fWBcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjdHVhbCA9PSBudWxsKSB7XG4gICAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgJHthY3R1YWx9YFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhY3R1YWwubmFtZSkge1xuICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIGZ1bmN0aW9uICR7YWN0dWFsLm5hbWV9YFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBfYWN0dWFsJGNvbnN0cnVjdG9yXG4gICAgICBpZiAoXG4gICAgICAgIChfYWN0dWFsJGNvbnN0cnVjdG9yID0gYWN0dWFsLmNvbnN0cnVjdG9yKSAhPT0gbnVsbCAmJlxuICAgICAgICBfYWN0dWFsJGNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX2FjdHVhbCRjb25zdHJ1Y3Rvci5uYW1lXG4gICAgICApIHtcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIGFuIGluc3RhbmNlIG9mICR7YWN0dWFsLmNvbnN0cnVjdG9yLm5hbWV9YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zcGVjdGVkID0gaW5zcGVjdChhY3R1YWwsIHtcbiAgICAgICAgICBkZXB0aDogLTFcbiAgICAgICAgfSlcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkICR7aW5zcGVjdGVkfWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGluc3BlY3RlZCA9IGluc3BlY3QoYWN0dWFsLCB7XG4gICAgICAgIGNvbG9yczogZmFsc2VcbiAgICAgIH0pXG4gICAgICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDI1KSB7XG4gICAgICAgIGluc3BlY3RlZCA9IGAke2luc3BlY3RlZC5zbGljZSgwLCAyNSl9Li4uYFxuICAgICAgfVxuICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfSAoJHtpbnNwZWN0ZWR9KWBcbiAgICB9XG4gICAgcmV0dXJuIG1zZ1xuICB9LFxuICBUeXBlRXJyb3JcbilcbkUoXG4gICdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLFxuICAobmFtZSwgdmFsdWUsIHJlYXNvbiA9ICdpcyBpbnZhbGlkJykgPT4ge1xuICAgIGxldCBpbnNwZWN0ZWQgPSBpbnNwZWN0KHZhbHVlKVxuICAgIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgICBpbnNwZWN0ZWQgPSBpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSArICcuLi4nXG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50J1xuICAgIHJldHVybiBgVGhlICR7dHlwZX0gJyR7bmFtZX0nICR7cmVhc29ufS4gUmVjZWl2ZWQgJHtpbnNwZWN0ZWR9YFxuICB9LFxuICBUeXBlRXJyb3JcbilcbkUoXG4gICdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLFxuICAoaW5wdXQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgdmFyIF92YWx1ZSRjb25zdHJ1Y3RvclxuICAgIGNvbnN0IHR5cGUgPVxuICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChfdmFsdWUkY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgIT09IG51bGwgJiZcbiAgICAgIF92YWx1ZSRjb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBfdmFsdWUkY29uc3RydWN0b3IubmFtZVxuICAgICAgICA/IGBpbnN0YW5jZSBvZiAke3ZhbHVlLmNvbnN0cnVjdG9yLm5hbWV9YFxuICAgICAgICA6IGB0eXBlICR7dHlwZW9mIHZhbHVlfWBcbiAgICByZXR1cm4gYEV4cGVjdGVkICR7aW5wdXR9IHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFwiJHtuYW1lfVwiYCArIGAgZnVuY3Rpb24gYnV0IGdvdCAke3R5cGV9LmBcbiAgfSxcbiAgVHlwZUVycm9yXG4pXG5FKFxuICAnRVJSX01JU1NJTkdfQVJHUycsXG4gICguLi5hcmdzKSA9PiB7XG4gICAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJylcbiAgICBsZXQgbXNnXG4gICAgY29uc3QgbGVuID0gYXJncy5sZW5ndGhcbiAgICBhcmdzID0gKEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdKS5tYXAoKGEpID0+IGBcIiR7YX1cImApLmpvaW4oJyBvciAnKVxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1zZyArPSBgVGhlICR7YXJnc1swXX0gYXJndW1lbnRgXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIG1zZyArPSBgVGhlICR7YXJnc1swXX0gYW5kICR7YXJnc1sxXX0gYXJndW1lbnRzYFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBhcmdzLnBvcCgpXG4gICAgICAgICAgbXNnICs9IGBUaGUgJHthcmdzLmpvaW4oJywgJyl9LCBhbmQgJHtsYXN0fSBhcmd1bWVudHNgXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0dXJuIGAke21zZ30gbXVzdCBiZSBzcGVjaWZpZWRgXG4gIH0sXG4gIFR5cGVFcnJvclxuKVxuRShcbiAgJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICAoc3RyLCByYW5nZSwgaW5wdXQpID0+IHtcbiAgICBhc3NlcnQocmFuZ2UsICdNaXNzaW5nIFwicmFuZ2VcIiBhcmd1bWVudCcpXG4gICAgbGV0IHJlY2VpdmVkXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IDJuICoqIDMybiB8fCBpbnB1dCA8IC0oMm4gKiogMzJuKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlaXZlZCA9IGluc3BlY3QoaW5wdXQpXG4gICAgfVxuICAgIHJldHVybiBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgfSxcbiAgUmFuZ2VFcnJvclxuKVxuRSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycsIEVycm9yKVxuRSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCAnVGhlICVzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fQUxSRUFEWV9GSU5JU0hFRCcsICdDYW5ub3QgY2FsbCAlcyBhZnRlciBhIHN0cmVhbSB3YXMgZmluaXNoZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCAnQ2Fubm90IGNhbGwgJXMgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCcsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcilcbkUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJywgRXJyb3IpXG5FKCdFUlJfVU5LTk9XTl9FTkNPRElORycsICdVbmtub3duIGVuY29kaW5nOiAlcycsIFR5cGVFcnJvcilcbm1vZHVsZS5leHBvcnRzID0ge1xuICBBYm9ydEVycm9yLFxuICBhZ2dyZWdhdGVUd29FcnJvcnM6IGhpZGVTdGFja0ZyYW1lcyhhZ2dyZWdhdGVUd29FcnJvcnMpLFxuICBoaWRlU3RhY2tGcmFtZXMsXG4gIGNvZGVzXG59XG4iXSwibmFtZXMiOlsiZm9ybWF0IiwiaW5zcGVjdCIsIkFnZ3JlZ2F0ZUVycm9yIiwiQ3VzdG9tQWdncmVnYXRlRXJyb3IiLCJyZXF1aXJlIiwiZ2xvYmFsVGhpcyIsImtJc05vZGVFcnJvciIsIlN5bWJvbCIsImtUeXBlcyIsImNsYXNzUmVnRXhwIiwibm9kZUludGVybmFsUHJlZml4IiwiY29kZXMiLCJhc3NlcnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFUlJfSU5URVJOQUxfQVNTRVJUSU9OIiwiYWRkTnVtZXJpY2FsU2VwYXJhdG9yIiwidmFsIiwicmVzIiwiaSIsImxlbmd0aCIsInN0YXJ0Iiwic2xpY2UiLCJnZXRNZXNzYWdlIiwia2V5IiwibXNnIiwiYXJncyIsImV4cGVjdGVkTGVuZ3RoIiwibWF0Y2giLCJFIiwiY29kZSIsIkJhc2UiLCJFcnJvciIsIk5vZGVFcnJvciIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJuYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImhpZGVTdGFja0ZyYW1lcyIsImZuIiwiaGlkZGVuIiwiZGVmaW5lUHJvcGVydHkiLCJhZ2dyZWdhdGVUd29FcnJvcnMiLCJpbm5lckVycm9yIiwib3V0ZXJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImVycm9ycyIsInB1c2giLCJlcnIiLCJBYm9ydEVycm9yIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJlbmRzV2l0aCIsImluY2x1ZGVzIiwidHlwZXMiLCJpbnN0YW5jZXMiLCJvdGhlciIsInRvTG93ZXJDYXNlIiwidGVzdCIsInBvcyIsImluZGV4T2YiLCJzcGxpY2UiLCJsYXN0IiwicG9wIiwiam9pbiIsIl9hY3R1YWwkY29uc3RydWN0b3IiLCJpbnNwZWN0ZWQiLCJkZXB0aCIsImNvbG9ycyIsIlR5cGVFcnJvciIsInJlYXNvbiIsInR5cGUiLCJpbnB1dCIsIl92YWx1ZSRjb25zdHJ1Y3RvciIsImxlbiIsIm1hcCIsImEiLCJzdHIiLCJyYW5nZSIsInJlY2VpdmVkIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiTWF0aCIsImFicyIsIlN0cmluZyIsIlJhbmdlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/index.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/index.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nif (Stream && process.env.READABLE_STREAM === \"disable\") {\n    const promises = Stream.promises;\n    // Explicit export naming is needed for ESM\n    module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;\n    module.exports._isUint8Array = Stream._isUint8Array;\n    module.exports.isDisturbed = Stream.isDisturbed;\n    module.exports.isErrored = Stream.isErrored;\n    module.exports.isReadable = Stream.isReadable;\n    module.exports.Readable = Stream.Readable;\n    module.exports.Writable = Stream.Writable;\n    module.exports.Duplex = Stream.Duplex;\n    module.exports.Transform = Stream.Transform;\n    module.exports.PassThrough = Stream.PassThrough;\n    module.exports.addAbortSignal = Stream.addAbortSignal;\n    module.exports.finished = Stream.finished;\n    module.exports.destroy = Stream.destroy;\n    module.exports.pipeline = Stream.pipeline;\n    module.exports.compose = Stream.compose;\n    Object.defineProperty(Stream, \"promises\", {\n        configurable: true,\n        enumerable: true,\n        get () {\n            return promises;\n        }\n    });\n    module.exports.Stream = Stream.Stream;\n} else {\n    const CustomStream = __webpack_require__(/*! ../stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream.js\");\n    const promises = __webpack_require__(/*! ../stream/promises */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream/promises.js\");\n    const originalDestroy = CustomStream.Readable.destroy;\n    module.exports = CustomStream.Readable;\n    // Explicit export naming is needed for ESM\n    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;\n    module.exports._isUint8Array = CustomStream._isUint8Array;\n    module.exports.isDisturbed = CustomStream.isDisturbed;\n    module.exports.isErrored = CustomStream.isErrored;\n    module.exports.isReadable = CustomStream.isReadable;\n    module.exports.Readable = CustomStream.Readable;\n    module.exports.Writable = CustomStream.Writable;\n    module.exports.Duplex = CustomStream.Duplex;\n    module.exports.Transform = CustomStream.Transform;\n    module.exports.PassThrough = CustomStream.PassThrough;\n    module.exports.addAbortSignal = CustomStream.addAbortSignal;\n    module.exports.finished = CustomStream.finished;\n    module.exports.destroy = CustomStream.destroy;\n    module.exports.destroy = originalDestroy;\n    module.exports.pipeline = CustomStream.pipeline;\n    module.exports.compose = CustomStream.compose;\n    Object.defineProperty(CustomStream, \"promises\", {\n        configurable: true,\n        enumerable: true,\n        get () {\n            return promises;\n        }\n    });\n    module.exports.Stream = CustomStream.Stream;\n}\n// Allow default importing\nmodule.exports[\"default\"] = module.exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlELFVBQVVFLFFBQVFDLEdBQUcsQ0FBQ0MsZUFBZSxLQUFLLFdBQVc7SUFDdkQsTUFBTUMsV0FBV0wsT0FBT0ssUUFBUTtJQUVoQywyQ0FBMkM7SUFDM0NDLGtDQUFrQyxHQUFHTixPQUFPUSxtQkFBbUI7SUFDL0RGLDRCQUE0QixHQUFHTixPQUFPUyxhQUFhO0lBQ25ESCwwQkFBMEIsR0FBR04sT0FBT1UsV0FBVztJQUMvQ0osd0JBQXdCLEdBQUdOLE9BQU9XLFNBQVM7SUFDM0NMLHlCQUF5QixHQUFHTixPQUFPWSxVQUFVO0lBQzdDTix1QkFBdUIsR0FBR04sT0FBT2EsUUFBUTtJQUN6Q1AsdUJBQXVCLEdBQUdOLE9BQU9jLFFBQVE7SUFDekNSLHFCQUFxQixHQUFHTixPQUFPZSxNQUFNO0lBQ3JDVCx3QkFBd0IsR0FBR04sT0FBT2dCLFNBQVM7SUFDM0NWLDBCQUEwQixHQUFHTixPQUFPaUIsV0FBVztJQUMvQ1gsNkJBQTZCLEdBQUdOLE9BQU9rQixjQUFjO0lBQ3JEWix1QkFBdUIsR0FBR04sT0FBT21CLFFBQVE7SUFDekNiLHNCQUFzQixHQUFHTixPQUFPb0IsT0FBTztJQUN2Q2QsdUJBQXVCLEdBQUdOLE9BQU9xQixRQUFRO0lBQ3pDZixzQkFBc0IsR0FBR04sT0FBT3NCLE9BQU87SUFDdkNDLE9BQU9DLGNBQWMsQ0FBQ3hCLFFBQVEsWUFBWTtRQUN4Q3lCLGNBQWM7UUFDZEMsWUFBWTtRQUNaQztZQUNFLE9BQU90QjtRQUNUO0lBQ0Y7SUFDQUMscUJBQXFCLEdBQUdOLE9BQU9BLE1BQU07QUFDdkMsT0FBTztJQUNMLE1BQU00QixlQUFlM0IsbUJBQU9BLENBQUM7SUFDN0IsTUFBTUksV0FBV0osbUJBQU9BLENBQUM7SUFDekIsTUFBTTRCLGtCQUFrQkQsYUFBYWYsUUFBUSxDQUFDTyxPQUFPO0lBQ3JEZCxPQUFPQyxPQUFPLEdBQUdxQixhQUFhZixRQUFRO0lBRXRDLDJDQUEyQztJQUMzQ1Asa0NBQWtDLEdBQUdzQixhQUFhcEIsbUJBQW1CO0lBQ3JFRiw0QkFBNEIsR0FBR3NCLGFBQWFuQixhQUFhO0lBQ3pESCwwQkFBMEIsR0FBR3NCLGFBQWFsQixXQUFXO0lBQ3JESix3QkFBd0IsR0FBR3NCLGFBQWFqQixTQUFTO0lBQ2pETCx5QkFBeUIsR0FBR3NCLGFBQWFoQixVQUFVO0lBQ25ETix1QkFBdUIsR0FBR3NCLGFBQWFmLFFBQVE7SUFDL0NQLHVCQUF1QixHQUFHc0IsYUFBYWQsUUFBUTtJQUMvQ1IscUJBQXFCLEdBQUdzQixhQUFhYixNQUFNO0lBQzNDVCx3QkFBd0IsR0FBR3NCLGFBQWFaLFNBQVM7SUFDakRWLDBCQUEwQixHQUFHc0IsYUFBYVgsV0FBVztJQUNyRFgsNkJBQTZCLEdBQUdzQixhQUFhVixjQUFjO0lBQzNEWix1QkFBdUIsR0FBR3NCLGFBQWFULFFBQVE7SUFDL0NiLHNCQUFzQixHQUFHc0IsYUFBYVIsT0FBTztJQUM3Q2Qsc0JBQXNCLEdBQUd1QjtJQUN6QnZCLHVCQUF1QixHQUFHc0IsYUFBYVAsUUFBUTtJQUMvQ2Ysc0JBQXNCLEdBQUdzQixhQUFhTixPQUFPO0lBQzdDQyxPQUFPQyxjQUFjLENBQUNJLGNBQWMsWUFBWTtRQUM5Q0gsY0FBYztRQUNkQyxZQUFZO1FBQ1pDO1lBQ0UsT0FBT3RCO1FBQ1Q7SUFDRjtJQUNBQyxxQkFBcUIsR0FBR3NCLGFBQWE1QixNQUFNO0FBQzdDO0FBRUEsMEJBQTBCO0FBQzFCTSx5QkFBc0IsR0FBR0EsT0FBT0MsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL2luZGV4LmpzPzhhMzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5pZiAoU3RyZWFtICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnKSB7XG4gIGNvbnN0IHByb21pc2VzID0gU3RyZWFtLnByb21pc2VzXG5cbiAgLy8gRXhwbGljaXQgZXhwb3J0IG5hbWluZyBpcyBuZWVkZWQgZm9yIEVTTVxuICBtb2R1bGUuZXhwb3J0cy5fdWludDhBcnJheVRvQnVmZmVyID0gU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXJcbiAgbW9kdWxlLmV4cG9ydHMuX2lzVWludDhBcnJheSA9IFN0cmVhbS5faXNVaW50OEFycmF5XG4gIG1vZHVsZS5leHBvcnRzLmlzRGlzdHVyYmVkID0gU3RyZWFtLmlzRGlzdHVyYmVkXG4gIG1vZHVsZS5leHBvcnRzLmlzRXJyb3JlZCA9IFN0cmVhbS5pc0Vycm9yZWRcbiAgbW9kdWxlLmV4cG9ydHMuaXNSZWFkYWJsZSA9IFN0cmVhbS5pc1JlYWRhYmxlXG4gIG1vZHVsZS5leHBvcnRzLlJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlXG4gIG1vZHVsZS5leHBvcnRzLldyaXRhYmxlID0gU3RyZWFtLldyaXRhYmxlXG4gIG1vZHVsZS5leHBvcnRzLkR1cGxleCA9IFN0cmVhbS5EdXBsZXhcbiAgbW9kdWxlLmV4cG9ydHMuVHJhbnNmb3JtID0gU3RyZWFtLlRyYW5zZm9ybVxuICBtb2R1bGUuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaFxuICBtb2R1bGUuZXhwb3J0cy5hZGRBYm9ydFNpZ25hbCA9IFN0cmVhbS5hZGRBYm9ydFNpZ25hbFxuICBtb2R1bGUuZXhwb3J0cy5maW5pc2hlZCA9IFN0cmVhbS5maW5pc2hlZFxuICBtb2R1bGUuZXhwb3J0cy5kZXN0cm95ID0gU3RyZWFtLmRlc3Ryb3lcbiAgbW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSBTdHJlYW0ucGlwZWxpbmVcbiAgbW9kdWxlLmV4cG9ydHMuY29tcG9zZSA9IFN0cmVhbS5jb21wb3NlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW0sICdwcm9taXNlcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZXNcbiAgICB9XG4gIH0pXG4gIG1vZHVsZS5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbS5TdHJlYW1cbn0gZWxzZSB7XG4gIGNvbnN0IEN1c3RvbVN0cmVhbSA9IHJlcXVpcmUoJy4uL3N0cmVhbScpXG4gIGNvbnN0IHByb21pc2VzID0gcmVxdWlyZSgnLi4vc3RyZWFtL3Byb21pc2VzJylcbiAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gQ3VzdG9tU3RyZWFtLlJlYWRhYmxlLmRlc3Ryb3lcbiAgbW9kdWxlLmV4cG9ydHMgPSBDdXN0b21TdHJlYW0uUmVhZGFibGVcblxuICAvLyBFeHBsaWNpdCBleHBvcnQgbmFtaW5nIGlzIG5lZWRlZCBmb3IgRVNNXG4gIG1vZHVsZS5leHBvcnRzLl91aW50OEFycmF5VG9CdWZmZXIgPSBDdXN0b21TdHJlYW0uX3VpbnQ4QXJyYXlUb0J1ZmZlclxuICBtb2R1bGUuZXhwb3J0cy5faXNVaW50OEFycmF5ID0gQ3VzdG9tU3RyZWFtLl9pc1VpbnQ4QXJyYXlcbiAgbW9kdWxlLmV4cG9ydHMuaXNEaXN0dXJiZWQgPSBDdXN0b21TdHJlYW0uaXNEaXN0dXJiZWRcbiAgbW9kdWxlLmV4cG9ydHMuaXNFcnJvcmVkID0gQ3VzdG9tU3RyZWFtLmlzRXJyb3JlZFxuICBtb2R1bGUuZXhwb3J0cy5pc1JlYWRhYmxlID0gQ3VzdG9tU3RyZWFtLmlzUmVhZGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuUmVhZGFibGUgPSBDdXN0b21TdHJlYW0uUmVhZGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuV3JpdGFibGUgPSBDdXN0b21TdHJlYW0uV3JpdGFibGVcbiAgbW9kdWxlLmV4cG9ydHMuRHVwbGV4ID0gQ3VzdG9tU3RyZWFtLkR1cGxleFxuICBtb2R1bGUuZXhwb3J0cy5UcmFuc2Zvcm0gPSBDdXN0b21TdHJlYW0uVHJhbnNmb3JtXG4gIG1vZHVsZS5leHBvcnRzLlBhc3NUaHJvdWdoID0gQ3VzdG9tU3RyZWFtLlBhc3NUaHJvdWdoXG4gIG1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsID0gQ3VzdG9tU3RyZWFtLmFkZEFib3J0U2lnbmFsXG4gIG1vZHVsZS5leHBvcnRzLmZpbmlzaGVkID0gQ3VzdG9tU3RyZWFtLmZpbmlzaGVkXG4gIG1vZHVsZS5leHBvcnRzLmRlc3Ryb3kgPSBDdXN0b21TdHJlYW0uZGVzdHJveVxuICBtb2R1bGUuZXhwb3J0cy5kZXN0cm95ID0gb3JpZ2luYWxEZXN0cm95XG4gIG1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gQ3VzdG9tU3RyZWFtLnBpcGVsaW5lXG4gIG1vZHVsZS5leHBvcnRzLmNvbXBvc2UgPSBDdXN0b21TdHJlYW0uY29tcG9zZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tU3RyZWFtLCAncHJvbWlzZXMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHByb21pc2VzXG4gICAgfVxuICB9KVxuICBtb2R1bGUuZXhwb3J0cy5TdHJlYW0gPSBDdXN0b21TdHJlYW0uU3RyZWFtXG59XG5cbi8vIEFsbG93IGRlZmF1bHQgaW1wb3J0aW5nXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHNcbiJdLCJuYW1lcyI6WyJTdHJlYW0iLCJyZXF1aXJlIiwicHJvY2VzcyIsImVudiIsIlJFQURBQkxFX1NUUkVBTSIsInByb21pc2VzIiwibW9kdWxlIiwiZXhwb3J0cyIsIl91aW50OEFycmF5VG9CdWZmZXIiLCJfaXNVaW50OEFycmF5IiwiaXNEaXN0dXJiZWQiLCJpc0Vycm9yZWQiLCJpc1JlYWRhYmxlIiwiUmVhZGFibGUiLCJXcml0YWJsZSIsIkR1cGxleCIsIlRyYW5zZm9ybSIsIlBhc3NUaHJvdWdoIiwiYWRkQWJvcnRTaWduYWwiLCJmaW5pc2hlZCIsImRlc3Ryb3kiLCJwaXBlbGluZSIsImNvbXBvc2UiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJDdXN0b21TdHJlYW0iLCJvcmlnaW5hbERlc3Ryb3kiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js ***!
  \******************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/ module.exports = {\n    ArrayIsArray (self) {\n        return Array.isArray(self);\n    },\n    ArrayPrototypeIncludes (self, el) {\n        return self.includes(el);\n    },\n    ArrayPrototypeIndexOf (self, el) {\n        return self.indexOf(el);\n    },\n    ArrayPrototypeJoin (self, sep) {\n        return self.join(sep);\n    },\n    ArrayPrototypeMap (self, fn) {\n        return self.map(fn);\n    },\n    ArrayPrototypePop (self, el) {\n        return self.pop(el);\n    },\n    ArrayPrototypePush (self, el) {\n        return self.push(el);\n    },\n    ArrayPrototypeSlice (self, start, end) {\n        return self.slice(start, end);\n    },\n    Error,\n    FunctionPrototypeCall (fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n    },\n    FunctionPrototypeSymbolHasInstance (self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n    },\n    MathFloor: Math.floor,\n    Number,\n    NumberIsInteger: Number.isInteger,\n    NumberIsNaN: Number.isNaN,\n    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n    NumberParseInt: Number.parseInt,\n    ObjectDefineProperties (self, props) {\n        return Object.defineProperties(self, props);\n    },\n    ObjectDefineProperty (self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n    },\n    ObjectGetOwnPropertyDescriptor (self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n    },\n    ObjectKeys (obj) {\n        return Object.keys(obj);\n    },\n    ObjectSetPrototypeOf (target, proto) {\n        return Object.setPrototypeOf(target, proto);\n    },\n    Promise,\n    PromisePrototypeCatch (self, fn) {\n        return self.catch(fn);\n    },\n    PromisePrototypeThen (self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n    },\n    PromiseReject (err) {\n        return Promise.reject(err);\n    },\n    PromiseResolve (val) {\n        return Promise.resolve(val);\n    },\n    ReflectApply: Reflect.apply,\n    RegExpPrototypeTest (self, value) {\n        return self.test(value);\n    },\n    SafeSet: Set,\n    String,\n    StringPrototypeSlice (self, start, end) {\n        return self.slice(start, end);\n    },\n    StringPrototypeToLowerCase (self) {\n        return self.toLowerCase();\n    },\n    StringPrototypeToUpperCase (self) {\n        return self.toUpperCase();\n    },\n    StringPrototypeTrim (self) {\n        return self.trim();\n    },\n    Symbol,\n    SymbolFor: Symbol.for,\n    SymbolAsyncIterator: Symbol.asyncIterator,\n    SymbolHasInstance: Symbol.hasInstance,\n    SymbolIterator: Symbol.iterator,\n    SymbolDispose: Symbol.dispose || Symbol(\"Symbol.dispose\"),\n    SymbolAsyncDispose: Symbol.asyncDispose || Symbol(\"Symbol.asyncDispose\"),\n    TypedArrayPrototypeSet (self, buf, len) {\n        return self.set(buf, len);\n    },\n    Boolean: Boolean,\n    Uint8Array\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9wcmltb3JkaWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7QUFNQSxHQUNBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsY0FBYUMsSUFBSTtRQUNmLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0Y7SUFDdkI7SUFDQUcsd0JBQXVCSCxJQUFJLEVBQUVJLEVBQUU7UUFDN0IsT0FBT0osS0FBS0ssUUFBUSxDQUFDRDtJQUN2QjtJQUNBRSx1QkFBc0JOLElBQUksRUFBRUksRUFBRTtRQUM1QixPQUFPSixLQUFLTyxPQUFPLENBQUNIO0lBQ3RCO0lBQ0FJLG9CQUFtQlIsSUFBSSxFQUFFUyxHQUFHO1FBQzFCLE9BQU9ULEtBQUtVLElBQUksQ0FBQ0Q7SUFDbkI7SUFDQUUsbUJBQWtCWCxJQUFJLEVBQUVZLEVBQUU7UUFDeEIsT0FBT1osS0FBS2EsR0FBRyxDQUFDRDtJQUNsQjtJQUNBRSxtQkFBa0JkLElBQUksRUFBRUksRUFBRTtRQUN4QixPQUFPSixLQUFLZSxHQUFHLENBQUNYO0lBQ2xCO0lBQ0FZLG9CQUFtQmhCLElBQUksRUFBRUksRUFBRTtRQUN6QixPQUFPSixLQUFLaUIsSUFBSSxDQUFDYjtJQUNuQjtJQUNBYyxxQkFBb0JsQixJQUFJLEVBQUVtQixLQUFLLEVBQUVDLEdBQUc7UUFDbEMsT0FBT3BCLEtBQUtxQixLQUFLLENBQUNGLE9BQU9DO0lBQzNCO0lBQ0FFO0lBQ0FDLHVCQUFzQlgsRUFBRSxFQUFFWSxRQUFRLEVBQUUsR0FBR0MsSUFBSTtRQUN6QyxPQUFPYixHQUFHYyxJQUFJLENBQUNGLGFBQWFDO0lBQzlCO0lBQ0FFLG9DQUFtQzNCLElBQUksRUFBRTRCLFFBQVE7UUFDL0MsT0FBT0MsU0FBU0MsU0FBUyxDQUFDQyxPQUFPQyxXQUFXLENBQUMsQ0FBQ04sSUFBSSxDQUFDMUIsTUFBTTRCO0lBQzNEO0lBQ0FLLFdBQVdDLEtBQUtDLEtBQUs7SUFDckJDO0lBQ0FDLGlCQUFpQkQsT0FBT0UsU0FBUztJQUNqQ0MsYUFBYUgsT0FBT0ksS0FBSztJQUN6QkMsd0JBQXdCTCxPQUFPTSxnQkFBZ0I7SUFDL0NDLHdCQUF3QlAsT0FBT1EsZ0JBQWdCO0lBQy9DQyxnQkFBZ0JULE9BQU9VLFFBQVE7SUFDL0JDLHdCQUF1Qi9DLElBQUksRUFBRWdELEtBQUs7UUFDaEMsT0FBT0MsT0FBT0MsZ0JBQWdCLENBQUNsRCxNQUFNZ0Q7SUFDdkM7SUFDQUcsc0JBQXFCbkQsSUFBSSxFQUFFb0QsSUFBSSxFQUFFQyxJQUFJO1FBQ25DLE9BQU9KLE9BQU9LLGNBQWMsQ0FBQ3RELE1BQU1vRCxNQUFNQztJQUMzQztJQUNBRSxnQ0FBK0J2RCxJQUFJLEVBQUVvRCxJQUFJO1FBQ3ZDLE9BQU9ILE9BQU9PLHdCQUF3QixDQUFDeEQsTUFBTW9EO0lBQy9DO0lBQ0FLLFlBQVdDLEdBQUc7UUFDWixPQUFPVCxPQUFPVSxJQUFJLENBQUNEO0lBQ3JCO0lBQ0FFLHNCQUFxQkMsTUFBTSxFQUFFQyxLQUFLO1FBQ2hDLE9BQU9iLE9BQU9jLGNBQWMsQ0FBQ0YsUUFBUUM7SUFDdkM7SUFDQUU7SUFDQUMsdUJBQXNCakUsSUFBSSxFQUFFWSxFQUFFO1FBQzVCLE9BQU9aLEtBQUtrRSxLQUFLLENBQUN0RDtJQUNwQjtJQUNBdUQsc0JBQXFCbkUsSUFBSSxFQUFFb0UsTUFBTSxFQUFFQyxPQUFPO1FBQ3hDLE9BQU9yRSxLQUFLc0UsSUFBSSxDQUFDRixRQUFRQztJQUMzQjtJQUNBRSxlQUFjQyxHQUFHO1FBQ2YsT0FBT1IsUUFBUVMsTUFBTSxDQUFDRDtJQUN4QjtJQUNBRSxnQkFBZUMsR0FBRztRQUNoQixPQUFPWCxRQUFRWSxPQUFPLENBQUNEO0lBQ3pCO0lBQ0FFLGNBQWNDLFFBQVFDLEtBQUs7SUFDM0JDLHFCQUFvQmhGLElBQUksRUFBRWlGLEtBQUs7UUFDN0IsT0FBT2pGLEtBQUtrRixJQUFJLENBQUNEO0lBQ25CO0lBQ0FFLFNBQVNDO0lBQ1RDO0lBQ0FDLHNCQUFxQnRGLElBQUksRUFBRW1CLEtBQUssRUFBRUMsR0FBRztRQUNuQyxPQUFPcEIsS0FBS3FCLEtBQUssQ0FBQ0YsT0FBT0M7SUFDM0I7SUFDQW1FLDRCQUEyQnZGLElBQUk7UUFDN0IsT0FBT0EsS0FBS3dGLFdBQVc7SUFDekI7SUFDQUMsNEJBQTJCekYsSUFBSTtRQUM3QixPQUFPQSxLQUFLMEYsV0FBVztJQUN6QjtJQUNBQyxxQkFBb0IzRixJQUFJO1FBQ3RCLE9BQU9BLEtBQUs0RixJQUFJO0lBQ2xCO0lBQ0E3RDtJQUNBOEQsV0FBVzlELE9BQU8rRCxHQUFHO0lBQ3JCQyxxQkFBcUJoRSxPQUFPaUUsYUFBYTtJQUN6Q0MsbUJBQW1CbEUsT0FBT0MsV0FBVztJQUNyQ2tFLGdCQUFnQm5FLE9BQU9vRSxRQUFRO0lBQy9CQyxlQUFlckUsT0FBT3NFLE9BQU8sSUFBSXRFLE9BQU87SUFDeEN1RSxvQkFBb0J2RSxPQUFPd0UsWUFBWSxJQUFJeEUsT0FBTztJQUNsRHlFLHdCQUF1QnhHLElBQUksRUFBRXlHLEdBQUcsRUFBRUMsR0FBRztRQUNuQyxPQUFPMUcsS0FBSzJHLEdBQUcsQ0FBQ0YsS0FBS0M7SUFDdkI7SUFDQUUsU0FBU0E7SUFDVEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL3ByaW1vcmRpYWxzLmpzP2I2NjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qXG4gIFRoaXMgZmlsZSBpcyBhIHJlZHVjZWQgYW5kIGFkYXB0ZWQgdmVyc2lvbiBvZiB0aGUgbWFpbiBsaWIvaW50ZXJuYWwvcGVyX2NvbnRleHQvcHJpbW9yZGlhbHMuanMgZmlsZSBkZWZpbmVkIGF0XG5cbiAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9wZXJfY29udGV4dC9wcmltb3JkaWFscy5qc1xuXG4gIERvbid0IHRyeSB0byByZXBsYWNlIHdpdGggdGhlIG9yaWdpbmFsIGZpbGUgYW5kIGtlZXAgaXQgdXAgdG8gZGF0ZSB3aXRoIHRoZSB1cHN0cmVhbSBmaWxlLlxuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBcnJheUlzQXJyYXkoc2VsZikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNlbGYpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlSW5jbHVkZXMoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5pbmNsdWRlcyhlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVJbmRleE9mKHNlbGYsIGVsKSB7XG4gICAgcmV0dXJuIHNlbGYuaW5kZXhPZihlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVKb2luKHNlbGYsIHNlcCkge1xuICAgIHJldHVybiBzZWxmLmpvaW4oc2VwKVxuICB9LFxuICBBcnJheVByb3RvdHlwZU1hcChzZWxmLCBmbikge1xuICAgIHJldHVybiBzZWxmLm1hcChmbilcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVQb3Aoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5wb3AoZWwpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlUHVzaChzZWxmLCBlbCkge1xuICAgIHJldHVybiBzZWxmLnB1c2goZWwpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzZWxmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH0sXG4gIEVycm9yLFxuICBGdW5jdGlvblByb3RvdHlwZUNhbGwoZm4sIHRoaXNBcmdzLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpc0FyZ3MsIC4uLmFyZ3MpXG4gIH0sXG4gIEZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2Uoc2VsZiwgaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0uY2FsbChzZWxmLCBpbnN0YW5jZSlcbiAgfSxcbiAgTWF0aEZsb29yOiBNYXRoLmZsb29yLFxuICBOdW1iZXIsXG4gIE51bWJlcklzSW50ZWdlcjogTnVtYmVyLmlzSW50ZWdlcixcbiAgTnVtYmVySXNOYU46IE51bWJlci5pc05hTixcbiAgTnVtYmVyTUFYX1NBRkVfSU5URUdFUjogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIE51bWJlck1JTl9TQUZFX0lOVEVHRVI6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJQYXJzZUludDogTnVtYmVyLnBhcnNlSW50LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BzKVxuICB9LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShzZWxmLCBuYW1lLCBwcm9wKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBuYW1lLCBwcm9wKVxuICB9LFxuICBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZiwgbmFtZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlbGYsIG5hbWUpXG4gIH0sXG4gIE9iamVjdEtleXMob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgfSxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbiAgfSxcbiAgUHJvbWlzZSxcbiAgUHJvbWlzZVByb3RvdHlwZUNhdGNoKHNlbGYsIGZuKSB7XG4gICAgcmV0dXJuIHNlbGYuY2F0Y2goZm4pXG4gIH0sXG4gIFByb21pc2VQcm90b3R5cGVUaGVuKHNlbGYsIHRoZW5GbiwgY2F0Y2hGbikge1xuICAgIHJldHVybiBzZWxmLnRoZW4odGhlbkZuLCBjYXRjaEZuKVxuICB9LFxuICBQcm9taXNlUmVqZWN0KGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gIH0sXG4gIFByb21pc2VSZXNvbHZlKHZhbCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsKVxuICB9LFxuICBSZWZsZWN0QXBwbHk6IFJlZmxlY3QuYXBwbHksXG4gIFJlZ0V4cFByb3RvdHlwZVRlc3Qoc2VsZiwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2VsZi50ZXN0KHZhbHVlKVxuICB9LFxuICBTYWZlU2V0OiBTZXQsXG4gIFN0cmluZyxcbiAgU3RyaW5nUHJvdG90eXBlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzZWxmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi50b0xvd2VyQ2FzZSgpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi50b1VwcGVyQ2FzZSgpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRyaW0oc2VsZikge1xuICAgIHJldHVybiBzZWxmLnRyaW0oKVxuICB9LFxuICBTeW1ib2wsXG4gIFN5bWJvbEZvcjogU3ltYm9sLmZvcixcbiAgU3ltYm9sQXN5bmNJdGVyYXRvcjogU3ltYm9sLmFzeW5jSXRlcmF0b3IsXG4gIFN5bWJvbEhhc0luc3RhbmNlOiBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gIFN5bWJvbEl0ZXJhdG9yOiBTeW1ib2wuaXRlcmF0b3IsXG4gIFN5bWJvbERpc3Bvc2U6IFN5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbCgnU3ltYm9sLmRpc3Bvc2UnKSxcbiAgU3ltYm9sQXN5bmNEaXNwb3NlOiBTeW1ib2wuYXN5bmNEaXNwb3NlIHx8IFN5bWJvbCgnU3ltYm9sLmFzeW5jRGlzcG9zZScpLFxuICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHNlbGYsIGJ1ZiwgbGVuKSB7XG4gICAgcmV0dXJuIHNlbGYuc2V0KGJ1ZiwgbGVuKVxuICB9LFxuICBCb29sZWFuOiBCb29sZWFuLFxuICBVaW50OEFycmF5XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkFycmF5SXNBcnJheSIsInNlbGYiLCJBcnJheSIsImlzQXJyYXkiLCJBcnJheVByb3RvdHlwZUluY2x1ZGVzIiwiZWwiLCJpbmNsdWRlcyIsIkFycmF5UHJvdG90eXBlSW5kZXhPZiIsImluZGV4T2YiLCJBcnJheVByb3RvdHlwZUpvaW4iLCJzZXAiLCJqb2luIiwiQXJyYXlQcm90b3R5cGVNYXAiLCJmbiIsIm1hcCIsIkFycmF5UHJvdG90eXBlUG9wIiwicG9wIiwiQXJyYXlQcm90b3R5cGVQdXNoIiwicHVzaCIsIkFycmF5UHJvdG90eXBlU2xpY2UiLCJzdGFydCIsImVuZCIsInNsaWNlIiwiRXJyb3IiLCJGdW5jdGlvblByb3RvdHlwZUNhbGwiLCJ0aGlzQXJncyIsImFyZ3MiLCJjYWxsIiwiRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZSIsImluc3RhbmNlIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJoYXNJbnN0YW5jZSIsIk1hdGhGbG9vciIsIk1hdGgiLCJmbG9vciIsIk51bWJlciIsIk51bWJlcklzSW50ZWdlciIsImlzSW50ZWdlciIsIk51bWJlcklzTmFOIiwiaXNOYU4iLCJOdW1iZXJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX1NBRkVfSU5URUdFUiIsIk51bWJlck1JTl9TQUZFX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiTnVtYmVyUGFyc2VJbnQiLCJwYXJzZUludCIsIk9iamVjdERlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJPYmplY3REZWZpbmVQcm9wZXJ0eSIsIm5hbWUiLCJwcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJPYmplY3RLZXlzIiwib2JqIiwia2V5cyIsIk9iamVjdFNldFByb3RvdHlwZU9mIiwidGFyZ2V0IiwicHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsIlByb21pc2UiLCJQcm9taXNlUHJvdG90eXBlQ2F0Y2giLCJjYXRjaCIsIlByb21pc2VQcm90b3R5cGVUaGVuIiwidGhlbkZuIiwiY2F0Y2hGbiIsInRoZW4iLCJQcm9taXNlUmVqZWN0IiwiZXJyIiwicmVqZWN0IiwiUHJvbWlzZVJlc29sdmUiLCJ2YWwiLCJyZXNvbHZlIiwiUmVmbGVjdEFwcGx5IiwiUmVmbGVjdCIsImFwcGx5IiwiUmVnRXhwUHJvdG90eXBlVGVzdCIsInZhbHVlIiwidGVzdCIsIlNhZmVTZXQiLCJTZXQiLCJTdHJpbmciLCJTdHJpbmdQcm90b3R5cGVTbGljZSIsIlN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJTdHJpbmdQcm90b3R5cGVUb1VwcGVyQ2FzZSIsInRvVXBwZXJDYXNlIiwiU3RyaW5nUHJvdG90eXBlVHJpbSIsInRyaW0iLCJTeW1ib2xGb3IiLCJmb3IiLCJTeW1ib2xBc3luY0l0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsIlN5bWJvbEhhc0luc3RhbmNlIiwiU3ltYm9sSXRlcmF0b3IiLCJpdGVyYXRvciIsIlN5bWJvbERpc3Bvc2UiLCJkaXNwb3NlIiwiU3ltYm9sQXN5bmNEaXNwb3NlIiwiYXN5bmNEaXNwb3NlIiwiVHlwZWRBcnJheVByb3RvdHlwZVNldCIsImJ1ZiIsImxlbiIsInNldCIsIkJvb2xlYW4iLCJVaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst bufferModule = __webpack_require__(/*! buffer */ \"buffer\");\nconst { kResistStopPropagation, SymbolDispose } = __webpack_require__(/*! ./primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst AbortSignal = globalThis.AbortSignal || (__webpack_require__(/*! abort-controller */ \"(ssr)/../node_modules/abort-controller/dist/abort-controller.js\").AbortSignal);\nconst AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ \"(ssr)/../node_modules/abort-controller/dist/abort-controller.js\").AbortController);\nconst AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;\nconst Blob = globalThis.Blob || bufferModule.Blob;\n/* eslint-disable indent */ const isBlob = typeof Blob !== \"undefined\" ? function isBlob(b) {\n    // eslint-disable-next-line indent\n    return b instanceof Blob;\n} : function isBlob(b) {\n    return false;\n};\n/* eslint-enable indent */ const validateAbortSignal = (signal, name)=>{\n    if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n    }\n};\nconst validateFunction = (value, name)=>{\n    if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n};\n// This is a simplified version of AggregateError\nclass AggregateError extends Error {\n    constructor(errors){\n        if (!Array.isArray(errors)) {\n            throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        }\n        let message = \"\";\n        for(let i = 0; i < errors.length; i++){\n            message += `    ${errors[i].stack}\\n`;\n        }\n        super(message);\n        this.name = \"AggregateError\";\n        this.errors = errors;\n    }\n}\nmodule.exports = {\n    AggregateError,\n    kEmptyObject: Object.freeze({}),\n    once (callback) {\n        let called = false;\n        return function(...args) {\n            if (called) {\n                return;\n            }\n            called = true;\n            callback.apply(this, args);\n        };\n    },\n    createDeferredPromise: function() {\n        let resolve;\n        let reject;\n        // eslint-disable-next-line promise/param-names\n        const promise = new Promise((res, rej)=>{\n            resolve = res;\n            reject = rej;\n        });\n        return {\n            promise,\n            resolve,\n            reject\n        };\n    },\n    promisify (fn) {\n        return new Promise((resolve, reject)=>{\n            fn((err, ...args)=>{\n                if (err) {\n                    return reject(err);\n                }\n                return resolve(...args);\n            });\n        });\n    },\n    debuglog () {\n        return function() {};\n    },\n    format (format, ...args) {\n        // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {\n            const replacement = args.shift();\n            if (type === \"f\") {\n                return replacement.toFixed(6);\n            } else if (type === \"j\") {\n                return JSON.stringify(replacement);\n            } else if (type === \"s\" && typeof replacement === \"object\") {\n                const ctor = replacement.constructor !== Object ? replacement.constructor.name : \"\";\n                return `${ctor} {}`.trim();\n            } else {\n                return replacement.toString();\n            }\n        });\n    },\n    inspect (value) {\n        // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n        switch(typeof value){\n            case \"string\":\n                if (value.includes(\"'\")) {\n                    if (!value.includes('\"')) {\n                        return `\"${value}\"`;\n                    } else if (!value.includes(\"`\") && !value.includes(\"${\")) {\n                        return `\\`${value}\\``;\n                    }\n                }\n                return `'${value}'`;\n            case \"number\":\n                if (isNaN(value)) {\n                    return \"NaN\";\n                } else if (Object.is(value, -0)) {\n                    return String(value);\n                }\n                return value;\n            case \"bigint\":\n                return `${String(value)}n`;\n            case \"boolean\":\n            case \"undefined\":\n                return String(value);\n            case \"object\":\n                return \"{}\";\n        }\n    },\n    types: {\n        isAsyncFunction (fn) {\n            return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView (arr) {\n            return ArrayBuffer.isView(arr);\n        }\n    },\n    isBlob,\n    deprecate (fn, message) {\n        return fn;\n    },\n    addAbortListener: (__webpack_require__(/*! events */ \"events\").addAbortListener) || function addAbortListener(signal, listener) {\n        if (signal === undefined) {\n            throw new ERR_INVALID_ARG_TYPE(\"signal\", \"AbortSignal\", signal);\n        }\n        validateAbortSignal(signal, \"signal\");\n        validateFunction(listener, \"listener\");\n        let removeEventListener;\n        if (signal.aborted) {\n            queueMicrotask(()=>listener());\n        } else {\n            signal.addEventListener(\"abort\", listener, {\n                __proto__: null,\n                once: true,\n                [kResistStopPropagation]: true\n            });\n            removeEventListener = ()=>{\n                signal.removeEventListener(\"abort\", listener);\n            };\n        }\n        return {\n            __proto__: null,\n            [SymbolDispose] () {\n                var _removeEventListener;\n                (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined ? undefined : _removeEventListener();\n            }\n        };\n    },\n    AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {\n        // Fast path if there is only one signal.\n        if (signals.length === 1) {\n            return signals[0];\n        }\n        const ac = new AbortController();\n        const abort = ()=>ac.abort();\n        signals.forEach((signal)=>{\n            validateAbortSignal(signal, \"signals\");\n            signal.addEventListener(\"abort\", abort, {\n                once: true\n            });\n        });\n        ac.signal.addEventListener(\"abort\", ()=>{\n            signals.forEach((signal)=>signal.removeEventListener(\"abort\", abort));\n        }, {\n            once: true\n        });\n        return ac.signal;\n    }\n};\nmodule.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsZUFBZUMsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFQyxzQkFBc0IsRUFBRUMsYUFBYSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzFELE1BQU1HLGNBQWNDLFdBQVdELFdBQVcsSUFBSUgsNEhBQXVDO0FBQ3JGLE1BQU1LLGtCQUFrQkQsV0FBV0MsZUFBZSxJQUFJTCxnSUFBMkM7QUFDakcsTUFBTU0sZ0JBQWdCQyxPQUFPQyxjQUFjLENBQUMsa0JBQW1CLEdBQUdDLFdBQVc7QUFDN0UsTUFBTUMsT0FBT04sV0FBV00sSUFBSSxJQUFJWCxhQUFhVyxJQUFJO0FBQ2pELHlCQUF5QixHQUN6QixNQUFNQyxTQUNKLE9BQU9ELFNBQVMsY0FDWixTQUFTQyxPQUFPQyxDQUFDO0lBQ2Ysa0NBQWtDO0lBQ2xDLE9BQU9BLGFBQWFGO0FBQ3RCLElBQ0EsU0FBU0MsT0FBT0MsQ0FBQztJQUNmLE9BQU87QUFDVDtBQUNOLHdCQUF3QixHQUV4QixNQUFNQyxzQkFBc0IsQ0FBQ0MsUUFBUUM7SUFDbkMsSUFBSUQsV0FBV0UsYUFBY0YsQ0FBQUEsV0FBVyxRQUFRLE9BQU9BLFdBQVcsWUFBWSxDQUFFLGNBQWFBLE1BQUssQ0FBQyxHQUFJO1FBQ3JHLE1BQU0sSUFBSUcscUJBQXFCRixNQUFNLGVBQWVEO0lBQ3REO0FBQ0Y7QUFDQSxNQUFNSSxtQkFBbUIsQ0FBQ0MsT0FBT0o7SUFDL0IsSUFBSSxPQUFPSSxVQUFVLFlBQVksTUFBTSxJQUFJRixxQkFBcUJGLE1BQU0sWUFBWUk7QUFDcEY7QUFFQSxpREFBaUQ7QUFDakQsTUFBTUMsdUJBQXVCQztJQUMzQlosWUFBWWEsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixTQUFT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QixPQUFPd0QsT0FBTyxDQUFDLEVBQUU7UUFDbkI7UUFDQSxNQUFNQyxLQUFLLElBQUloRjtRQUNmLE1BQU1pRixRQUFRLElBQU1ELEdBQUdDLEtBQUs7UUFDNUJGLFFBQVFHLE9BQU8sQ0FBQyxDQUFDekU7WUFDZkQsb0JBQW9CQyxRQUFRO1lBQzVCQSxPQUFPaUUsZ0JBQWdCLENBQUMsU0FBU08sT0FBTztnQkFDdENwRCxNQUFNO1lBQ1I7UUFDRjtRQUNBbUQsR0FBR3ZFLE1BQU0sQ0FBQ2lFLGdCQUFnQixDQUN4QixTQUNBO1lBQ0VLLFFBQVFHLE9BQU8sQ0FBQyxDQUFDekUsU0FBV0EsT0FBTzhELG1CQUFtQixDQUFDLFNBQVNVO1FBQ2xFLEdBQ0E7WUFDRXBELE1BQU07UUFDUjtRQUVGLE9BQU9tRCxHQUFHdkUsTUFBTTtJQUNsQjtBQUNKO0FBQ0FnQiwrQkFBK0IsR0FBRzJELE9BQU9DLEdBQUcsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9vdXJzL3V0aWwuanM/MDFhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYnVmZmVyTW9kdWxlID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsga1Jlc2lzdFN0b3BQcm9wYWdhdGlvbiwgU3ltYm9sRGlzcG9zZSB9ID0gcmVxdWlyZSgnLi9wcmltb3JkaWFscycpXG5jb25zdCBBYm9ydFNpZ25hbCA9IGdsb2JhbFRoaXMuQWJvcnRTaWduYWwgfHwgcmVxdWlyZSgnYWJvcnQtY29udHJvbGxlcicpLkFib3J0U2lnbmFsXG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCByZXF1aXJlKCdhYm9ydC1jb250cm9sbGVyJykuQWJvcnRDb250cm9sbGVyXG5jb25zdCBBc3luY0Z1bmN0aW9uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uICgpIHt9KS5jb25zdHJ1Y3RvclxuY29uc3QgQmxvYiA9IGdsb2JhbFRoaXMuQmxvYiB8fCBidWZmZXJNb2R1bGUuQmxvYlxuLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5jb25zdCBpc0Jsb2IgPVxuICB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGZ1bmN0aW9uIGlzQmxvYihiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbmRlbnRcbiAgICAgICAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCbG9iXG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiBpc0Jsb2IoYikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbi8qIGVzbGludC1lbmFibGUgaW5kZW50ICovXG5cbmNvbnN0IHZhbGlkYXRlQWJvcnRTaWduYWwgPSAoc2lnbmFsLCBuYW1lKSA9PiB7XG4gIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCAmJiAoc2lnbmFsID09PSBudWxsIHx8IHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdBYm9ydFNpZ25hbCcsIHNpZ25hbClcbiAgfVxufVxuY29uc3QgdmFsaWRhdGVGdW5jdGlvbiA9ICh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Z1bmN0aW9uJywgdmFsdWUpXG59XG5cbi8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgQWdncmVnYXRlRXJyb3JcbmNsYXNzIEFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXJyb3JzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYW4gQXJyYXksIGdvdCAke3R5cGVvZiBlcnJvcnN9YClcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSAnJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtZXNzYWdlICs9IGAgICAgJHtlcnJvcnNbaV0uc3RhY2t9XFxuYFxuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBZ2dyZWdhdGVFcnJvcidcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yc1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWdncmVnYXRlRXJyb3IsXG4gIGtFbXB0eU9iamVjdDogT2JqZWN0LmZyZWV6ZSh7fSksXG4gIG9uY2UoY2FsbGJhY2spIHtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2VcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYWxsZWQgPSB0cnVlXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc29sdmVcbiAgICBsZXQgcmVqZWN0XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wYXJhbS1uYW1lc1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHJlc29sdmUgPSByZXNcbiAgICAgIHJlamVjdCA9IHJlalxuICAgIH0pXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb21pc2UsXG4gICAgICByZXNvbHZlLFxuICAgICAgcmVqZWN0XG4gICAgfVxuICB9LFxuICBwcm9taXNpZnkoZm4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZm4oKGVyciwgLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoLi4uYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgZGVidWdsb2coKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9XG4gIH0sXG4gIGZvcm1hdChmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgICAvLyBTaW1wbGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91dGlsLmh0bWwjdXRpbGZvcm1hdGZvcm1hdC1hcmdzXG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lKFtzZGlmal0pL2csIGZ1bmN0aW9uICguLi5bX3VudXNlZCwgdHlwZV0pIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gYXJncy5zaGlmdCgpXG4gICAgICBpZiAodHlwZSA9PT0gJ2YnKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudC50b0ZpeGVkKDYpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdqJykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVwbGFjZW1lbnQpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzJyAmJiB0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGN0b3IgPSByZXBsYWNlbWVudC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ID8gcmVwbGFjZW1lbnQuY29uc3RydWN0b3IubmFtZSA6ICcnXG4gICAgICAgIHJldHVybiBgJHtjdG9yfSB7fWAudHJpbSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGluc3BlY3QodmFsdWUpIHtcbiAgICAvLyBWYXN0bHkgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdXRpbC5odG1sI3V0aWxpbnNwZWN0b2JqZWN0LW9wdGlvbnNcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiJ1wiKSkge1xuICAgICAgICAgIGlmICghdmFsdWUuaW5jbHVkZXMoJ1wiJykpIHtcbiAgICAgICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYFxuICAgICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlLmluY2x1ZGVzKCdgJykgJiYgIXZhbHVlLmluY2x1ZGVzKCckeycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxcYCR7dmFsdWV9XFxgYFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdOYU4nXG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgcmV0dXJuIGAke1N0cmluZyh2YWx1ZSl9bmBcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAne30nXG4gICAgfVxuICB9LFxuICB0eXBlczoge1xuICAgIGlzQXN5bmNGdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZuIGluc3RhbmNlb2YgQXN5bmNGdW5jdGlvblxuICAgIH0sXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcoYXJyKSB7XG4gICAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycilcbiAgICB9XG4gIH0sXG4gIGlzQmxvYixcbiAgZGVwcmVjYXRlKGZuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZuXG4gIH0sXG4gIGFkZEFib3J0TGlzdGVuZXI6XG4gICAgcmVxdWlyZSgnZXZlbnRzJykuYWRkQWJvcnRMaXN0ZW5lciB8fFxuICAgIGZ1bmN0aW9uIGFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHNpZ25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnc2lnbmFsJywgJ0Fib3J0U2lnbmFsJywgc2lnbmFsKVxuICAgICAgfVxuICAgICAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwsICdzaWduYWwnKVxuICAgICAgdmFsaWRhdGVGdW5jdGlvbihsaXN0ZW5lciwgJ2xpc3RlbmVyJylcbiAgICAgIGxldCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gbGlzdGVuZXIoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyLCB7XG4gICAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgW2tSZXNpc3RTdG9wUHJvcGFnYXRpb25dOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1N5bWJvbERpc3Bvc2VdKCkge1xuICAgICAgICAgIHZhciBfcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICAgIDsoX3JlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfcmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICBBYm9ydFNpZ25hbEFueTpcbiAgICBBYm9ydFNpZ25hbC5hbnkgfHxcbiAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbEFueShzaWduYWxzKSB7XG4gICAgICAvLyBGYXN0IHBhdGggaWYgdGhlcmUgaXMgb25seSBvbmUgc2lnbmFsLlxuICAgICAgaWYgKHNpZ25hbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzaWduYWxzWzBdXG4gICAgICB9XG4gICAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgY29uc3QgYWJvcnQgPSAoKSA9PiBhYy5hYm9ydCgpXG4gICAgICBzaWduYWxzLmZvckVhY2goKHNpZ25hbCkgPT4ge1xuICAgICAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKHNpZ25hbCwgJ3NpZ25hbHMnKVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ2Fib3J0JyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHNpZ25hbHMuZm9yRWFjaCgoc2lnbmFsKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCkpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiBhYy5zaWduYWxcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwucHJvbWlzaWZ5LmN1c3RvbScpXG4iXSwibmFtZXMiOlsiYnVmZmVyTW9kdWxlIiwicmVxdWlyZSIsImtSZXNpc3RTdG9wUHJvcGFnYXRpb24iLCJTeW1ib2xEaXNwb3NlIiwiQWJvcnRTaWduYWwiLCJnbG9iYWxUaGlzIiwiQWJvcnRDb250cm9sbGVyIiwiQXN5bmNGdW5jdGlvbiIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJCbG9iIiwiaXNCbG9iIiwiYiIsInZhbGlkYXRlQWJvcnRTaWduYWwiLCJzaWduYWwiLCJuYW1lIiwidW5kZWZpbmVkIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJ2YWxpZGF0ZUZ1bmN0aW9uIiwidmFsdWUiLCJBZ2dyZWdhdGVFcnJvciIsIkVycm9yIiwiZXJyb3JzIiwiQXJyYXkiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwibWVzc2FnZSIsImkiLCJsZW5ndGgiLCJzdGFjayIsIm1vZHVsZSIsImV4cG9ydHMiLCJrRW1wdHlPYmplY3QiLCJmcmVlemUiLCJvbmNlIiwiY2FsbGJhY2siLCJjYWxsZWQiLCJhcmdzIiwiYXBwbHkiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJwcm9taXNpZnkiLCJmbiIsImVyciIsImRlYnVnbG9nIiwiZm9ybWF0IiwicmVwbGFjZSIsIl91bnVzZWQiLCJ0eXBlIiwicmVwbGFjZW1lbnQiLCJzaGlmdCIsInRvRml4ZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiY3RvciIsInRyaW0iLCJ0b1N0cmluZyIsImluc3BlY3QiLCJpbmNsdWRlcyIsImlzTmFOIiwiaXMiLCJTdHJpbmciLCJ0eXBlcyIsImlzQXN5bmNGdW5jdGlvbiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYXJyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJkZXByZWNhdGUiLCJhZGRBYm9ydExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWJvcnRlZCIsInF1ZXVlTWljcm90YXNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9fcHJvdG9fXyIsIl9yZW1vdmVFdmVudExpc3RlbmVyIiwiQWJvcnRTaWduYWxBbnkiLCJhbnkiLCJzaWduYWxzIiwiYWMiLCJhYm9ydCIsImZvckVhY2giLCJjdXN0b20iLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* replacement start */ const { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\"use strict\";\nconst { ObjectDefineProperty, ObjectKeys, ReflectApply } = __webpack_require__(/*! ./ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { promisify: { custom: customPromisify } } = __webpack_require__(/*! ./ours/util */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/util.js\");\nconst { streamReturningOperators, promiseReturningOperators } = __webpack_require__(/*! ./internal/streams/operators */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/operators.js\");\nconst { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = __webpack_require__(/*! ./ours/errors */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/errors.js\");\nconst compose = __webpack_require__(/*! ./internal/streams/compose */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/compose.js\");\nconst { setDefaultHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./internal/streams/state */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/state.js\");\nconst { pipeline } = __webpack_require__(/*! ./internal/streams/pipeline */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\nconst { destroyer } = __webpack_require__(/*! ./internal/streams/destroy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nconst eos = __webpack_require__(/*! ./internal/streams/end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nconst internalBuffer = {};\nconst promises = __webpack_require__(/*! ./stream/promises */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream/promises.js\");\nconst utils = __webpack_require__(/*! ./internal/streams/utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst Stream = module.exports = __webpack_require__(/*! ./internal/streams/legacy */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/legacy.js\").Stream;\nStream.isDestroyed = utils.isDestroyed;\nStream.isDisturbed = utils.isDisturbed;\nStream.isErrored = utils.isErrored;\nStream.isReadable = utils.isReadable;\nStream.isWritable = utils.isWritable;\nStream.Readable = __webpack_require__(/*! ./internal/streams/readable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/readable.js\");\nfor (const key of ObjectKeys(streamReturningOperators)){\n    const op = streamReturningOperators[key];\n    function fn(...args) {\n        if (new.target) {\n            throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return Stream.Readable.from(ReflectApply(op, this, args));\n    }\n    ObjectDefineProperty(fn, \"name\", {\n        __proto__: null,\n        value: op.name\n    });\n    ObjectDefineProperty(fn, \"length\", {\n        __proto__: null,\n        value: op.length\n    });\n    ObjectDefineProperty(Stream.Readable.prototype, key, {\n        __proto__: null,\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true\n    });\n}\nfor (const key of ObjectKeys(promiseReturningOperators)){\n    const op = promiseReturningOperators[key];\n    function fn1(...args) {\n        if (new.target) {\n            throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return ReflectApply(op, this, args);\n    }\n    ObjectDefineProperty(fn1, \"name\", {\n        __proto__: null,\n        value: op.name\n    });\n    ObjectDefineProperty(fn1, \"length\", {\n        __proto__: null,\n        value: op.length\n    });\n    ObjectDefineProperty(Stream.Readable.prototype, key, {\n        __proto__: null,\n        value: fn1,\n        enumerable: false,\n        configurable: true,\n        writable: true\n    });\n}\nStream.Writable = __webpack_require__(/*! ./internal/streams/writable */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/writable.js\");\nStream.Duplex = __webpack_require__(/*! ./internal/streams/duplex */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/duplex.js\");\nStream.Transform = __webpack_require__(/*! ./internal/streams/transform */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/transform.js\");\nStream.PassThrough = __webpack_require__(/*! ./internal/streams/passthrough */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/passthrough.js\");\nStream.pipeline = pipeline;\nconst { addAbortSignal } = __webpack_require__(/*! ./internal/streams/add-abort-signal */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\");\nStream.addAbortSignal = addAbortSignal;\nStream.finished = eos;\nStream.destroy = destroyer;\nStream.compose = compose;\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark;\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark;\nObjectDefineProperty(Stream, \"promises\", {\n    __proto__: null,\n    configurable: true,\n    enumerable: true,\n    get () {\n        return promises;\n    }\n});\nObjectDefineProperty(pipeline, customPromisify, {\n    __proto__: null,\n    enumerable: true,\n    get () {\n        return promises.pipeline;\n    }\n});\nObjectDefineProperty(eos, customPromisify, {\n    __proto__: null,\n    enumerable: true,\n    get () {\n        return promises.finished;\n    }\n});\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\nStream._isUint8Array = function isUint8Array(value) {\n    return value instanceof Uint8Array;\n};\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n    return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixHQUVyQixNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQXdCekI7QUFDRixNQUFNLEVBQUVDLG9CQUFvQixFQUFFQyxVQUFVLEVBQUVDLFlBQVksRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUNuRSxNQUFNLEVBQ0pJLFdBQVcsRUFBRUMsUUFBUUMsZUFBZSxFQUFFLEVBQ3ZDLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTyx3QkFBd0IsRUFBRUMseUJBQXlCLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDeEUsTUFBTSxFQUNKUyxPQUFPLEVBQUVDLHVCQUF1QixFQUFFLEVBQ25DLEdBQUdWLG1CQUFPQSxDQUFDO0FBQ1osTUFBTVcsVUFBVVgsbUJBQU9BLENBQUM7QUFDeEIsTUFBTSxFQUFFWSx1QkFBdUIsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR2IsbUJBQU9BLENBQUM7QUFDckUsTUFBTSxFQUFFYyxRQUFRLEVBQUUsR0FBR2QsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFZSxTQUFTLEVBQUUsR0FBR2YsbUJBQU9BLENBQUM7QUFDOUIsTUFBTWdCLE1BQU1oQixtQkFBT0EsQ0FBQztBQUNwQixNQUFNaUIsaUJBQWlCLENBQUM7QUFDeEIsTUFBTUMsV0FBV2xCLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1tQixRQUFRbkIsbUJBQU9BLENBQUM7QUFDdEIsTUFBTW9CLFNBQVVDLDJMQUE0RDtBQUM1RUQsT0FBT0csV0FBVyxHQUFHSixNQUFNSSxXQUFXO0FBQ3RDSCxPQUFPSSxXQUFXLEdBQUdMLE1BQU1LLFdBQVc7QUFDdENKLE9BQU9LLFNBQVMsR0FBR04sTUFBTU0sU0FBUztBQUNsQ0wsT0FBT00sVUFBVSxHQUFH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QUNxQixNQUFNQyxNQUFNLEVBQUVELE1BQU1FLFVBQVUsRUFBRUYsTUFBTUcsVUFBVTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9zdHJlYW0uanM/YzU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCB7IE9iamVjdERlZmluZVByb3BlcnR5LCBPYmplY3RLZXlzLCBSZWZsZWN0QXBwbHkgfSA9IHJlcXVpcmUoJy4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7XG4gIHByb21pc2lmeTogeyBjdXN0b206IGN1c3RvbVByb21pc2lmeSB9XG59ID0gcmVxdWlyZSgnLi9vdXJzL3V0aWwnKVxuY29uc3QgeyBzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMsIHByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnMgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9vcGVyYXRvcnMnKVxuY29uc3Qge1xuICBjb2RlczogeyBFUlJfSUxMRUdBTF9DT05TVFJVQ1RPUiB9XG59ID0gcmVxdWlyZSgnLi9vdXJzL2Vycm9ycycpXG5jb25zdCBjb21wb3NlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UnKVxuY29uc3QgeyBzZXREZWZhdWx0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUnKVxuY29uc3QgeyBkZXN0cm95ZXIgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95JylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IGludGVybmFsQnVmZmVyID0ge31cbmNvbnN0IHByb21pc2VzID0gcmVxdWlyZSgnLi9zdHJlYW0vcHJvbWlzZXMnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvdXRpbHMnKVxuY29uc3QgU3RyZWFtID0gKG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeScpLlN0cmVhbSlcblN0cmVhbS5pc0Rlc3Ryb3llZCA9IHV0aWxzLmlzRGVzdHJveWVkXG5TdHJlYW0uaXNEaXN0dXJiZWQgPSB1dGlscy5pc0Rpc3R1cmJlZFxuU3RyZWFtLmlzRXJyb3JlZCA9IHV0aWxzLmlzRXJyb3JlZFxuU3RyZWFtLmlzUmVhZGFibGUgPSB1dGlscy5pc1JlYWRhYmxlXG5TdHJlYW0uaXNXcml0YWJsZSA9IHV0aWxzLmlzV3JpdGFibGVcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZScpXG5mb3IgKGNvbnN0IGtleSBvZiBPYmplY3RLZXlzKHN0cmVhbVJldHVybmluZ09wZXJhdG9ycykpIHtcbiAgY29uc3Qgb3AgPSBzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnNba2V5XVxuICBmdW5jdGlvbiBmbiguLi5hcmdzKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IEVSUl9JTExFR0FMX0NPTlNUUlVDVE9SKClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmVhbS5SZWFkYWJsZS5mcm9tKFJlZmxlY3RBcHBseShvcCwgdGhpcywgYXJncykpXG4gIH1cbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubmFtZVxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ2xlbmd0aCcsIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IG9wLmxlbmd0aFxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShTdHJlYW0uUmVhZGFibGUucHJvdG90eXBlLCBrZXksIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IGZuLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KVxufVxuZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0S2V5cyhwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzKSkge1xuICBjb25zdCBvcCA9IHByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnNba2V5XVxuICBmdW5jdGlvbiBmbiguLi5hcmdzKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IEVSUl9JTExFR0FMX0NPTlNUUlVDVE9SKClcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3RBcHBseShvcCwgdGhpcywgYXJncylcbiAgfVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHZhbHVlOiBvcC5uYW1lXG4gIH0pXG4gIE9iamVjdERlZmluZVByb3BlcnR5KGZuLCAnbGVuZ3RoJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubGVuZ3RoXG4gIH0pXG4gIE9iamVjdERlZmluZVByb3BlcnR5KFN0cmVhbS5SZWFkYWJsZS5wcm90b3R5cGUsIGtleSwge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogZm4sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pXG59XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvd3JpdGFibGUnKVxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXgnKVxuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0nKVxuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoJylcblN0cmVhbS5waXBlbGluZSA9IHBpcGVsaW5lXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbCcpXG5TdHJlYW0uYWRkQWJvcnRTaWduYWwgPSBhZGRBYm9ydFNpZ25hbFxuU3RyZWFtLmZpbmlzaGVkID0gZW9zXG5TdHJlYW0uZGVzdHJveSA9IGRlc3Ryb3llclxuU3RyZWFtLmNvbXBvc2UgPSBjb21wb3NlXG5TdHJlYW0uc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgPSBzZXREZWZhdWx0SGlnaFdhdGVyTWFya1xuU3RyZWFtLmdldERlZmF1bHRIaWdoV2F0ZXJNYXJrID0gZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmtcbk9iamVjdERlZmluZVByb3BlcnR5KFN0cmVhbSwgJ3Byb21pc2VzJywge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiBwcm9taXNlc1xuICB9XG59KVxuT2JqZWN0RGVmaW5lUHJvcGVydHkocGlwZWxpbmUsIGN1c3RvbVByb21pc2lmeSwge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcHJvbWlzZXMucGlwZWxpbmVcbiAgfVxufSlcbk9iamVjdERlZmluZVByb3BlcnR5KGVvcywgY3VzdG9tUHJvbWlzaWZ5LCB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiBwcm9taXNlcy5maW5pc2hlZFxuICB9XG59KVxuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbVxuU3RyZWFtLl9pc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheVxufVxuU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXIgPSBmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG59XG4iXSwibmFtZXMiOlsiQnVmZmVyIiwicmVxdWlyZSIsIk9iamVjdERlZmluZVByb3BlcnR5IiwiT2JqZWN0S2V5cyIsIlJlZmxlY3RBcHBseSIsInByb21pc2lmeSIsImN1c3RvbSIsImN1c3RvbVByb21pc2lmeSIsInN0cmVhbVJldHVybmluZ09wZXJhdG9ycyIsInByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnMiLCJjb2RlcyIsIkVSUl9JTExFR0FMX0NPTlNUUlVDVE9SIiwiY29tcG9zZSIsInNldERlZmF1bHRIaWdoV2F0ZXJNYXJrIiwiZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsiLCJwaXBlbGluZSIsImRlc3Ryb3llciIsImVvcyIsImludGVybmFsQnVmZmVyIiwicHJvbWlzZXMiLCJ1dGlscyIsIlN0cmVhbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc0Rlc3Ryb3llZCIsImlzRGlzdHVyYmVkIiwiaXNFcnJvcmVkIiwiaXNSZWFkYWJsZSIsImlzV3JpdGFibGUiLCJSZWFkYWJsZSIsImtleSIsIm9wIiwiZm4iLCJhcmdzIiwiZnJvbSIsIl9fcHJvdG9fXyIsInZhbHVlIiwibmFtZSIsImxlbmd0aCIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIldyaXRhYmxlIiwiRHVwbGV4IiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJhZGRBYm9ydFNpZ25hbCIsImZpbmlzaGVkIiwiZGVzdHJveSIsImdldCIsIl9pc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsImNodW5rIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream/promises.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream/promises.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { ArrayPrototypePop, Promise } = __webpack_require__(/*! ../ours/primordials */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/ours/primordials.js\");\nconst { isIterable, isNodeStream, isWebStream } = __webpack_require__(/*! ../internal/streams/utils */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/utils.js\");\nconst { pipelineImpl: pl } = __webpack_require__(/*! ../internal/streams/pipeline */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\nconst { finished } = __webpack_require__(/*! ../internal/streams/end-of-stream */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n__webpack_require__(/*! ../../lib/stream.js */ \"(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream.js\");\nfunction pipeline(...streams) {\n    return new Promise((resolve, reject)=>{\n        let signal;\n        let end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {\n            const options = ArrayPrototypePop(streams);\n            signal = options.signal;\n            end = options.end;\n        }\n        pl(streams, (err, value)=>{\n            if (err) {\n                reject(err);\n            } else {\n                resolve(value);\n            }\n        }, {\n            signal,\n            end\n        });\n    });\n}\nmodule.exports = {\n    finished,\n    pipeline\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvc3RyZWFtL3Byb21pc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxpQkFBaUIsRUFBRUMsT0FBTyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9DLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLFdBQVcsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMxRCxNQUFNLEVBQUVJLGNBQWNDLEVBQUUsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVNLFFBQVEsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUM3QkEsbUJBQU9BLENBQUM7QUFDUixTQUFTTyxTQUFTLEdBQUdDLE9BQU87SUFDMUIsT0FBTyxJQUFJVCxRQUFRLENBQUNVLFNBQVNDO1FBQzNCLElBQUlDO1FBQ0osSUFBSUM7UUFDSixNQUFNQyxVQUFVTCxPQUFPLENBQUNBLFFBQVFNLE1BQU0sR0FBRyxFQUFFO1FBQzNDLElBQ0VELFdBQ0EsT0FBT0EsWUFBWSxZQUNuQixDQUFDWCxhQUFhVyxZQUNkLENBQUNaLFdBQVdZLFlBQ1osQ0FBQ1YsWUFBWVUsVUFDYjtZQUNBLE1BQU1FLFVBQVVqQixrQkFBa0JVO1lBQ2xDRyxTQUFTSSxRQUFRSixNQUFNO1lBQ3ZCQyxNQUFNRyxRQUFRSCxHQUFHO1FBQ25CO1FBQ0FQLEdBQ0VHLFNBQ0EsQ0FBQ1EsS0FBS0M7WUFDSixJQUFJRCxLQUFLO2dCQUNQTixPQUFPTTtZQUNULE9BQU87Z0JBQ0xQLFFBQVFRO1lBQ1Y7UUFDRixHQUNBO1lBQ0VOO1lBQ0FDO1FBQ0Y7SUFFSjtBQUNGO0FBQ0FNLE9BQU9DLE9BQU8sR0FBRztJQUNmYjtJQUNBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL3N0cmVhbS9wcm9taXNlcy5qcz8zMDNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEFycmF5UHJvdG90eXBlUG9wLCBQcm9taXNlIH0gPSByZXF1aXJlKCcuLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgaXNJdGVyYWJsZSwgaXNOb2RlU3RyZWFtLCBpc1dlYlN0cmVhbSB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc3RyZWFtcy91dGlscycpXG5jb25zdCB7IHBpcGVsaW5lSW1wbDogcGwgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUnKVxuY29uc3QgeyBmaW5pc2hlZCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtJylcbnJlcXVpcmUoJy4uLy4uL2xpYi9zdHJlYW0uanMnKVxuZnVuY3Rpb24gcGlwZWxpbmUoLi4uc3RyZWFtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBzaWduYWxcbiAgICBsZXQgZW5kXG4gICAgY29uc3QgbGFzdEFyZyA9IHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXVxuICAgIGlmIChcbiAgICAgIGxhc3RBcmcgJiZcbiAgICAgIHR5cGVvZiBsYXN0QXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgIWlzTm9kZVN0cmVhbShsYXN0QXJnKSAmJlxuICAgICAgIWlzSXRlcmFibGUobGFzdEFyZykgJiZcbiAgICAgICFpc1dlYlN0cmVhbShsYXN0QXJnKVxuICAgICkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IEFycmF5UHJvdG90eXBlUG9wKHN0cmVhbXMpXG4gICAgICBzaWduYWwgPSBvcHRpb25zLnNpZ25hbFxuICAgICAgZW5kID0gb3B0aW9ucy5lbmRcbiAgICB9XG4gICAgcGwoXG4gICAgICBzdHJlYW1zLFxuICAgICAgKGVyciwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICApXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmluaXNoZWQsXG4gIHBpcGVsaW5lXG59XG4iXSwibmFtZXMiOlsiQXJyYXlQcm90b3R5cGVQb3AiLCJQcm9taXNlIiwicmVxdWlyZSIsImlzSXRlcmFibGUiLCJpc05vZGVTdHJlYW0iLCJpc1dlYlN0cmVhbSIsInBpcGVsaW5lSW1wbCIsInBsIiwiZmluaXNoZWQiLCJwaXBlbGluZSIsInN0cmVhbXMiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2lnbmFsIiwiZW5kIiwibGFzdEFyZyIsImxlbmd0aCIsIm9wdGlvbnMiLCJlcnIiLCJ2YWx1ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/openlogin-jrpc/node_modules/readable-stream/lib/stream/promises.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   TORUS_BUILD_ENV: () => (/* binding */ TORUS_BUILD_ENV),\n/* harmony export */   TorusInPageProvider: () => (/* binding */ TorusInPageProvider),\n/* harmony export */   \"default\": () => (/* binding */ Torus)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/base-controllers */ \"(ssr)/../node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/../node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eth-rpc-errors */ \"(ssr)/../node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var is_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! is-stream */ \"(ssr)/../node_modules/is-stream/index.js\");\n/* harmony import */ var is_stream__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(is_stream__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/../node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! loglevel */ \"(ssr)/../node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/../node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\nvar version = \"0.3.4\";\nvar messages = {\n    errors: {\n        disconnected: ()=>\"Torus: Lost connection to Torus.\",\n        permanentlyDisconnected: ()=>\"Torus: Disconnected from iframe. Page reload required.\",\n        unsupportedSync: (method)=>`Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n        invalidDuplexStream: ()=>\"Must provide a Node.js-style duplex stream.\",\n        invalidOptions: (maxEventListeners)=>`Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,\n        invalidRequestArgs: ()=>`Expected a single, non-array, object argument.`,\n        invalidRequestMethod: ()=>`'args.method' must be a non-empty string.`,\n        invalidRequestParams: ()=>`'args.params' must be an object or array if provided.`,\n        invalidLoggerObject: ()=>`'args.logger' must be an object if provided.`,\n        invalidLoggerMethod: (method)=>`'args.logger' must include required method '${method}'.`\n    },\n    info: {\n        connected: (chainId)=>`Torus: Connected to chain with ID \"${chainId}\".`\n    },\n    warnings: {}\n};\nconst PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nconst TORUS_BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst translations = {\n    en: {\n        embed: {\n            continue: \"Continue\",\n            actionRequired: \"Authorization required\",\n            pendingAction: \"Click continue to proceed with your request in a popup\",\n            cookiesRequired: \"Cookies Required\",\n            enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n            clickHere: \"More Info\"\n        }\n    },\n    de: {\n        embed: {\n            continue: \"Fortsetzen\",\n            actionRequired: \"Autorisierung erforderlich\",\n            pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n            cookiesRequired: \"Cookies ben\\xf6tigt\",\n            enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n            clickHere: \"Mehr Info\"\n        }\n    },\n    ja: {\n        embed: {\n            continue: \"継続する\",\n            actionRequired: \"認証が必要です\",\n            pendingAction: \"続行をクリックして、ポップアップでリクエストを続行します\",\n            cookiesRequired: \"必要なクッキー\",\n            enableCookies: \"Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。\",\n            clickHere: \"詳しくは\"\n        }\n    },\n    ko: {\n        embed: {\n            continue: \"계속하다\",\n            actionRequired: \"승인 필요\",\n            pendingAction: \"팝업에서 요청을 진행하려면 계속을 클릭하십시오.\",\n            cookiesRequired: \"쿠키 필요\",\n            enableCookies: \"브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.\",\n            clickHere: \"더 많은 정보\"\n        }\n    },\n    zh: {\n        embed: {\n            continue: \"继续\",\n            actionRequired: \"需要授权\",\n            pendingAction: \"单击继续以在弹出窗口中继续您的请求\",\n            cookiesRequired: \"必填Cookie\",\n            enableCookies: \"请在您的浏览器首选项中启用cookie以访问Torus。\",\n            clickHere: \"更多信息\"\n        }\n    }\n};\nvar configuration = {\n    supportedVerifierList: [\n        LOGIN_PROVIDER.GOOGLE,\n        LOGIN_PROVIDER.REDDIT,\n        LOGIN_PROVIDER.DISCORD\n    ],\n    api: \"https://api.tor.us\",\n    translations,\n    prodTorusUrl: \"\",\n    localStorageKeyPrefix: `torus-`\n};\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_8___default().getLogger(\"solana-embed\");\n// utility functions\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */ function createErrorMiddleware() {\n    return (req, res, next)=>{\n        // json-rpc-engine will terminate the request when it notices this error\n        if (typeof req.method !== \"string\" || !req.method) {\n            res.error = eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\n                message: `The request 'method' must be a non-empty string.`,\n                data: req\n            });\n        }\n        next((done)=>{\n            const { error } = res;\n            if (!error) {\n                return done();\n            }\n            log.error(`Torus - RPC Error: ${error.message}`, error);\n            return done();\n        });\n    };\n}\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */ function logStreamDisconnectWarning(remoteLabel, error, emitter) {\n    let warningMsg = `Torus: Lost connection to \"${remoteLabel}\".`;\n    if (error?.stack) {\n        warningMsg += `\\n${error.stack}`;\n    }\n    log.warn(warningMsg);\n    if (emitter && emitter.listenerCount(\"error\") > 0) {\n        emitter.emit(\"error\", warningMsg);\n    }\n}\nconst getWindowId = ()=>Math.random().toString(36).slice(2);\nconst getTorusUrl = async (buildEnv)=>{\n    let torusUrl;\n    let logLevel;\n    // const versionUsed = version;\n    // log.info(\"solana embed version used: \", versionUsed);\n    switch(buildEnv){\n        case \"testing\":\n            torusUrl = \"https://solana-testing.tor.us\";\n            logLevel = \"debug\";\n            break;\n        case \"development\":\n            torusUrl = \"http://localhost:8080\";\n            logLevel = \"debug\";\n            break;\n        default:\n            torusUrl = `https://solana.tor.us`;\n            logLevel = \"error\";\n            break;\n    }\n    return {\n        torusUrl,\n        logLevel\n    };\n};\nconst getUserLanguage = ()=>{\n    let userLanguage = window.navigator.language || \"en-US\";\n    const userLanguages = userLanguage.split(\"-\");\n    userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n    return userLanguage;\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 600,\n    width: 400\n};\nfunction storageAvailable(type) {\n    let storage;\n    try {\n        storage = window[type];\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (e) {\n        return e && // everything except Firefox\n        (e.code === 22 || // Firefox\n        e.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === \"QuotaExceededError\" || // Firefox\n        e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storage && storage.length !== 0;\n    }\n}\n/**\n * popup handler utils\n */ function getPopupFeatures(_ref) {\n    let { width: w, height: h } = _ref;\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nclass BaseProvider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.SafeEventEmitter {\n    /**\n   * Indicating that this provider is a Torus provider.\n   */ constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"isTorus\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_rpcEngine\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"jsonRpcConnectionEvents\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_state\", void 0);\n        if (!(0,is_stream__WEBPACK_IMPORTED_MODULE_6__.duplex)(connectionStream)) {\n            throw new Error(messages.errors.invalidDuplexStream());\n        }\n        this.isTorus = true;\n        this.setMaxListeners(maxEventListeners);\n        this._handleConnect = this._handleConnect.bind(this);\n        this._handleDisconnect = this._handleDisconnect.bind(this);\n        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n        this._rpcRequest = this._rpcRequest.bind(this);\n        this._initializeState = this._initializeState.bind(this);\n        this.request = this.request.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        // this.enable = this.enable.bind(this);\n        // setup connectionStream multiplexing\n        const mux = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.ObjectMultiplex();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\"));\n        // ignore phishing warning message (handled elsewhere)\n        mux.ignoreStream(\"phishing\");\n        // setup own event listeners\n        // connect to async provider\n        const jsonRpcConnection = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.createStreamMiddleware)();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\"));\n        // handle RPC requests via dapp-side rpc engine\n        const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.JRPCEngine();\n        rpcEngine.push((0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.createIdRemapMiddleware)());\n        rpcEngine.push(createErrorMiddleware());\n        rpcEngine.push((0,_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.createLoggerMiddleware)({\n            origin: location.origin\n        }));\n        rpcEngine.push(jsonRpcConnection.middleware);\n        this._rpcEngine = rpcEngine;\n        this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n    }\n    /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   */ async request(args) {\n        if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestArgs(),\n                data: args\n            });\n        }\n        const { method, params } = args;\n        if (typeof method !== \"string\" || method.length === 0) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestMethod(),\n                data: args\n            });\n        }\n        if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestParams(),\n                data: args\n            });\n        }\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest({\n                method,\n                params\n            }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ send(payload, callback) {\n        this._rpcRequest(payload, callback);\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ sendAsync(payload) {\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest(payload, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits TorusInpageProvider#disconnect\n   */ _handleStreamDisconnect(streamName, error) {\n        logStreamDisconnectWarning(streamName, error, this);\n        this._handleDisconnect(false, error ? error.message : undefined);\n    }\n}\nconst handleEvent = function(handle, eventName, handler) {\n    for(var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){\n        handlerArgs[_key - 3] = arguments[_key];\n    }\n    const handlerWrapper = ()=>{\n        handler(...handlerArgs);\n        handle.removeEventListener(eventName, handlerWrapper);\n    };\n    handle.addEventListener(eventName, handlerWrapper);\n};\nasync function documentReady() {\n    return new Promise((resolve)=>{\n        if (document.readyState !== \"loading\") {\n            resolve();\n        } else {\n            handleEvent(document, \"DOMContentLoaded\", resolve);\n        }\n    });\n}\nconst htmlToElement = (html)=>{\n    const template = window.document.createElement(\"template\");\n    const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n    template.innerHTML = trimmedHtml;\n    return template.content.firstChild;\n};\nfunction isLegacyTransactionInstance(transaction) {\n    return transaction.version === undefined;\n}\nclass PopupHandler extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.SafeEventEmitter {\n    constructor(_ref){\n        let { url, target, features } = _ref;\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"url\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"features\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"window\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"windowTimer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"iClosedWindow\", void 0);\n        this.url = url;\n        this.target = target || \"_blank\";\n        this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n        this.window = undefined;\n        this.windowTimer = undefined;\n        this.iClosedWindow = false;\n        this._setupTimer();\n    }\n    _setupTimer() {\n        this.windowTimer = Number(setInterval(()=>{\n            if (this.window && this.window.closed) {\n                clearInterval(this.windowTimer);\n                if (!this.iClosedWindow) {\n                    this.emit(\"close\");\n                }\n                this.iClosedWindow = false;\n                this.window = undefined;\n            }\n            if (this.window === undefined) clearInterval(this.windowTimer);\n        }, 500));\n    }\n    open() {\n        this.window = window.open(this.url.href, this.target, this.features);\n        if (this.window?.focus) this.window.focus();\n        return Promise.resolve();\n    }\n    close() {\n        this.iClosedWindow = true;\n        if (this.window) this.window.close();\n    }\n    redirect(locationReplaceOnRedirect) {\n        if (locationReplaceOnRedirect) {\n            window.location.replace(this.url.href);\n        } else {\n            window.location.href = this.url.href;\n        }\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$2(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nclass TorusCommunicationProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"embedTranslations\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"windowRefs\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"tryWindowHandle\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusIframe\", void 0);\n        this._state = _objectSpread$2({}, TorusCommunicationProvider._defaultState);\n        // public state\n        this.torusUrl = \"\";\n        this.dappStorageKey = \"\";\n        const languageTranslations = configuration.translations[getUserLanguage()];\n        this.embedTranslations = languageTranslations.embed;\n        this.windowRefs = {};\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const notificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n                const { isFullScreen, rid } = params;\n                this._displayIframe({\n                    isFull: isFullScreen,\n                    rid: rid\n                });\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW) {\n                const { windowId, url } = params;\n                this._createPopupBlockAlert(windowId, url);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n                this._handleCloseWindow(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n                const { currentLoginProvider } = params;\n                this._state.isLoggedIn = true;\n                this._state.currentLoginProvider = currentLoginProvider;\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n                this._state.isLoggedIn = false;\n                this._state.currentLoginProvider = null;\n                this._displayIframe();\n            }\n        };\n        this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n    }\n    get isLoggedIn() {\n        return this._state.isLoggedIn;\n    }\n    get isIFrameFullScreen() {\n        return this._state.isIFrameFullScreen;\n    }\n    /**\n   * Returns whether the inPage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    async _initializeState(params) {\n        try {\n            const { torusUrl, dappStorageKey, torusAlertContainer, torusIframe } = params;\n            this.torusUrl = torusUrl;\n            this.dappStorageKey = dappStorageKey;\n            this.torusAlertContainer = torusAlertContainer;\n            this.torusIframe = torusIframe;\n            this.torusIframe.addEventListener(\"load\", ()=>{\n                // only do this if iframe is not full screen\n                if (!this._state.isIFrameFullScreen) this._displayIframe();\n            });\n            const { currentLoginProvider, isLoggedIn } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this._handleConnect(currentLoginProvider, isLoggedIn);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized communication state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    _handleWindow(windowId) {\n        let { url, target, features } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const finalUrl = new URL(url || `${this.torusUrl}/redirect?windowId=${windowId}`);\n        if (this.dappStorageKey) {\n            // If multiple instances, it returns the first one\n            if (finalUrl.hash) finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;\n            else finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        const handledWindow = new PopupHandler({\n            url: finalUrl,\n            target,\n            features\n        });\n        handledWindow.open();\n        if (!handledWindow.window) {\n            this._createPopupBlockAlert(windowId, finalUrl.href);\n            return;\n        }\n        // Add to collection only if window is opened\n        this.windowRefs[windowId] = handledWindow;\n        // We tell the iframe that the window has been successfully opened\n        this.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,\n            params: {\n                windowId\n            }\n        });\n        handledWindow.once(\"close\", ()=>{\n            // user closed the window\n            delete this.windowRefs[windowId];\n            this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n                params: {\n                    windowId\n                }\n            });\n        });\n    }\n    _displayIframe() {\n        let { isFull = false, rid = \"\" } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const style = {};\n        // set phase\n        if (!isFull) {\n            style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\n            style.height = \"70px\";\n            style.width = \"70px\";\n            switch(this._state.buttonPosition){\n                case BUTTON_POSITION.TOP_LEFT:\n                    style.top = \"0px\";\n                    style.left = \"0px\";\n                    style.right = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.TOP_RIGHT:\n                    style.top = \"0px\";\n                    style.right = \"0px\";\n                    style.left = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_RIGHT:\n                    style.bottom = \"0px\";\n                    style.right = \"0px\";\n                    style.top = \"auto\";\n                    style.left = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_LEFT:\n                default:\n                    style.bottom = \"0px\";\n                    style.left = \"0px\";\n                    style.top = \"auto\";\n                    style.right = \"auto\";\n                    break;\n            }\n        } else {\n            style.display = \"block\";\n            style.width = \"100%\";\n            style.height = \"100%\";\n            style.top = \"0px\";\n            style.right = \"0px\";\n            style.left = \"0px\";\n            style.bottom = \"0px\";\n        }\n        Object.assign(this.torusIframe.style, style);\n        this._state.isIFrameFullScreen = isFull;\n        this.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n            params: {\n                isIFrameFullScreen: isFull,\n                rid\n            }\n        });\n    }\n    hideTorusButton() {\n        this._state.torusWidgetVisibility = false;\n        this._displayIframe();\n    }\n    showTorusButton() {\n        this._state.torusWidgetVisibility = true;\n        this._displayIframe();\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        const cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(currentLoginProvider, isLoggedIn) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                currentLoginProvider,\n                isLoggedIn\n            });\n            log.debug(messages.info.connected(currentLoginProvider));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this._state.currentLoginProvider = null;\n                this._state.isLoggedIn = false;\n                this._state.torusWidgetVisibility = false;\n                this._state.isIFrameFullScreen = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    // Called if the iframe wants to close the window cause it is done processing the request\n    _handleCloseWindow(params) {\n        const { windowId } = params;\n        if (this.windowRefs[windowId]) {\n            this.windowRefs[windowId].close();\n            delete this.windowRefs[windowId];\n        }\n    }\n    async _createPopupBlockAlert(windowId, url) {\n        const logoUrl = this.getLogoUrl();\n        const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + `<div id=\"torusAlert__logo\"><img src=\"${logoUrl}\" /></div>` + \"<div>\" + `<h1 id=\"torusAlert__title\">${this.embedTranslations.actionRequired}</h1>` + `<p id=\"torusAlert__desc\">${this.embedTranslations.pendingAction}</p>` + \"</div>\" + \"</div>\");\n        const successAlert = htmlToElement(`<div><a id=\"torusAlert__btn\">${this.embedTranslations.continue}</a></div>`);\n        const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n        btnContainer.appendChild(successAlert);\n        torusAlert.appendChild(btnContainer);\n        const bindOnLoad = ()=>{\n            successAlert.addEventListener(\"click\", ()=>{\n                this._handleWindow(windowId, {\n                    url,\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                torusAlert.remove();\n                if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n            });\n        };\n        const attachOnLoad = ()=>{\n            this.torusAlertContainer.appendChild(torusAlert);\n        };\n        await documentReady();\n        attachOnLoad();\n        bindOnLoad();\n        this.torusAlertContainer.style.display = \"block\";\n    }\n    getLogoUrl() {\n        const logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;\n        return logoUrl;\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(TorusCommunicationProvider, \"_defaultState\", {\n    buttonPosition: \"bottom-left\",\n    currentLoginProvider: null,\n    isIFrameFullScreen: false,\n    hasEmittedConnection: false,\n    torusWidgetVisibility: false,\n    initialized: false,\n    isLoggedIn: false,\n    isPermanentlyDisconnected: false,\n    isConnected: false\n});\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nclass TorusInPageProvider extends BaseProvider {\n    /**\n   * The chain ID of the currently connected Solana chain.\n   * See [chainId.network]{@link https://chainid.network} for more information.\n   */ /**\n   * The user's currently selected Solana address.\n   * If null, Torus is either locked or the user has not permitted any\n   * addresses to be viewed.\n   */ constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"chainId\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"selectedAddress\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"tryWindowHandle\", void 0);\n        this._state = _objectSpread$1({}, TorusInPageProvider._defaultState);\n        // public state\n        this.selectedAddress = null;\n        this.chainId = null;\n        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n        this._handleChainChanged = this._handleChainChanged.bind(this);\n        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const jsonRpcNotificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n                this._handleAccountsChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n                this._handleUnlockStateChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n                this._handleChainChanged(params);\n            }\n        };\n        // json rpc notification listener\n        this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n    }\n    /**\n   * Returns whether the inpage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    // Private Methods\n    //= ===================\n    /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */ async _initializeState() {\n        try {\n            const { accounts, chainId, isUnlocked } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this.emit(\"connect\", {\n                chainId\n            });\n            this._handleChainChanged({\n                chainId\n            });\n            this._handleUnlockStateChanged({\n                accounts,\n                isUnlocked\n            });\n            this._handleAccountsChanged(accounts);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized provider state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        let cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n            if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\n                // handle accounts changing\n                cb = (err, res)=>{\n                    this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\n                    callback(err, res);\n                };\n            } else if (_payload.method === \"wallet_getProviderState\") {\n                this._rpcEngine.handle(payload, cb);\n                return;\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(chainId) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                chainId\n            });\n            log.debug(messages.info.connected(chainId));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this.chainId = null;\n                this._state.accounts = null;\n                this.selectedAddress = null;\n                this._state.isUnlocked = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    /**\n   * Called when accounts may have changed.\n   */ _handleAccountsChanged(accounts) {\n        let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        // defensive programming\n        let finalAccounts = accounts;\n        if (!Array.isArray(finalAccounts)) {\n            log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n            finalAccounts = [];\n        }\n        for (const account of accounts){\n            if (typeof account !== \"string\") {\n                log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\n                finalAccounts = [];\n                break;\n            }\n        }\n        // emit accountsChanged if anything about the accounts array has changed\n        if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default()(this._state.accounts, finalAccounts)) {\n            // we should always have the correct accounts even before solana_accounts\n            // returns, except in cases where isInternal is true\n            if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n                log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n            }\n            this._state.accounts = finalAccounts;\n            this.emit(\"accountsChanged\", finalAccounts);\n        }\n        // handle selectedAddress\n        if (this.selectedAddress !== finalAccounts[0]) {\n            this.selectedAddress = finalAccounts[0] || null;\n        }\n    }\n    /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */ _handleChainChanged() {\n        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!chainId) {\n            log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\n                chainId\n            });\n            return;\n        }\n        if (chainId === \"loading\") {\n            this._handleDisconnect(true);\n        } else {\n            this._handleConnect(chainId);\n            if (chainId !== this.chainId) {\n                this.chainId = chainId;\n                if (this._state.initialized) {\n                    this.emit(\"chainChanged\", this.chainId);\n                }\n            }\n        }\n    }\n    /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */ _handleUnlockStateChanged() {\n        let { accounts, isUnlocked } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (typeof isUnlocked !== \"boolean\") {\n            log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\n                isUnlocked\n            });\n            return;\n        }\n        if (isUnlocked !== this._state.isUnlocked) {\n            this._state.isUnlocked = isUnlocked;\n            this._handleAccountsChanged(accounts || []);\n        }\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(TorusInPageProvider, \"_defaultState\", {\n    accounts: null,\n    isConnected: false,\n    isUnlocked: false,\n    initialized: false,\n    isPermanentlyDisconnected: false,\n    hasEmittedConnection: false\n});\n/**\n * Returns whether the given image URL exists\n */ function imgExists(url) {\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = document.createElement(\"img\");\n            img.onload = ()=>resolve(true);\n            img.onerror = ()=>resolve(false);\n            img.src = url;\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n/**\n * Extracts a name for the site from the DOM\n */ const getSiteName = (window1)=>{\n    const { document: document1 } = window1;\n    const siteName = document1.querySelector('head > meta[property=\"og:site_name\"]');\n    if (siteName) {\n        return siteName.content;\n    }\n    const metaTitle = document1.querySelector('head > meta[name=\"title\"]');\n    if (metaTitle) {\n        return metaTitle.content;\n    }\n    if (document1.title && document1.title.length > 0) {\n        return document1.title;\n    }\n    return window1.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */ async function getSiteIcon(window1) {\n    try {\n        const { document: document1 } = window1;\n        // Use the site's favicon if it exists\n        let icon = document1.querySelector('head > link[rel=\"shortcut icon\"]');\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        // Search through available icons in no particular order\n        icon = Array.from(document1.querySelectorAll('head > link[rel=\"icon\"]')).find((_icon)=>Boolean(_icon.href));\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        return \"\";\n    } catch (error) {\n        return \"\";\n    }\n}\n/**\n * Gets site metadata and returns it\n *\n */ const getSiteMetadata = async ()=>({\n        name: getSiteName(window),\n        icon: await getSiteIcon(window)\n    });\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nconst PROVIDER_UNSAFE_METHODS = [\n    \"send_transaction\",\n    \"sign_transaction\",\n    \"sign_all_transactions\",\n    \"sign_message\",\n    \"connect\"\n];\nconst COMMUNICATION_UNSAFE_METHODS = [\n    _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER\n];\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\");\n// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n(async function preLoadIframe() {\n    try {\n        if (typeof document === \"undefined\") return;\n        const torusIframeHtml = document.createElement(\"link\");\n        const { torusUrl } = await getTorusUrl(\"production\");\n        torusIframeHtml.href = `${torusUrl}/frame`;\n        torusIframeHtml.crossOrigin = \"anonymous\";\n        torusIframeHtml.type = \"text/html\";\n        torusIframeHtml.rel = \"prefetch\";\n        if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n            if (torusIframeHtml.relList.supports(\"prefetch\")) {\n                document.head.appendChild(torusIframeHtml);\n            }\n        }\n    } catch (error) {\n        log.warn(error);\n    }\n})();\nclass Torus {\n    constructor(){\n        let { modalZIndex = 99999 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"isInitialized\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusAlert\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"modalZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"alertZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"requestedLoginProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"provider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"communicationProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"isTopupHidden\", false);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"torusIframe\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"styleLink\", void 0);\n        this.torusUrl = \"\";\n        this.isInitialized = false; // init done\n        this.requestedLoginProvider = null;\n        this.modalZIndex = modalZIndex;\n        this.alertZIndex = modalZIndex + 1000;\n        this.dappStorageKey = \"\";\n    }\n    get isLoggedIn() {\n        if (!this.communicationProvider) return false;\n        return this.communicationProvider.isLoggedIn;\n    }\n    async init() {\n        let { buildEnv = TORUS_BUILD_ENV.PRODUCTION, enableLogging = false, network, showTorusButton = false, useLocalStorage = false, buttonPosition = BUTTON_POSITION.BOTTOM_LEFT, apiKey = \"torus-default\", extraParams = {}, whiteLabel } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (this.isInitialized) throw new Error(\"Already initialized\");\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.setAPIKey)(apiKey);\n        const { torusUrl, logLevel } = await getTorusUrl(buildEnv);\n        log.enableAll();\n        log.info(torusUrl, \"url loaded\");\n        log.info(`Solana Embed Version :${version}`);\n        this.torusUrl = torusUrl;\n        log.setDefaultLevel(logLevel);\n        if (enableLogging) log.enableAll();\n        else log.disableAll();\n        const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\n        const torusIframeUrl = new URL(torusUrl);\n        if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";\n        else torusIframeUrl.pathname += \"/frame\";\n        const hashParams = new URLSearchParams();\n        if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\n        hashParams.append(\"origin\", window.location.origin);\n        torusIframeUrl.hash = hashParams.toString();\n        // Iframe code\n        this.torusIframe = htmlToElement(`<iframe\n        id=\"torusIframe\"\n        class=\"torusIframe\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}\"\n      ></iframe>`);\n        this.torusAlertContainer = htmlToElement(`<div id=\"torusAlertContainer\" style=\"display:none; z-index: ${this.alertZIndex.toString()}\"></div>`);\n        this.styleLink = htmlToElement(`<link href=\"${torusUrl}/css/widget.css\" rel=\"stylesheet\" type=\"text/css\">`);\n        const handleSetup = async ()=>{\n            return new Promise((resolve, reject)=>{\n                try {\n                    window.document.head.appendChild(this.styleLink);\n                    window.document.body.appendChild(this.torusIframe);\n                    window.document.body.appendChild(this.torusAlertContainer);\n                    this.torusIframe.addEventListener(\"load\", async ()=>{\n                        const dappMetadata = await getSiteMetadata();\n                        // send init params here\n                        this.torusIframe.contentWindow.postMessage({\n                            buttonPosition,\n                            apiKey,\n                            network,\n                            dappMetadata,\n                            extraParams,\n                            whiteLabel\n                        }, torusIframeUrl.origin);\n                        await this._setupWeb3({\n                            torusUrl\n                        });\n                        if (showTorusButton) this.showTorusButton();\n                        if (whiteLabel?.topupHide) this.isTopupHidden = whiteLabel.topupHide;\n                        else this.hideTorusButton();\n                        this.isInitialized = true;\n                        window.torus = this;\n                        resolve();\n                    });\n                } catch (error) {\n                    reject(error);\n                }\n            });\n        };\n        await documentReady();\n        await handleSetup();\n    }\n    async login() {\n        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        try {\n            this.requestedLoginProvider = params.loginProvider || null;\n            if (!this.requestedLoginProvider) {\n                this.communicationProvider._displayIframe({\n                    isFull: true\n                });\n            }\n            // If user is already logged in, we assume they have given access to the website\n            const res = await new Promise((resolve, reject)=>{\n                // We use this method because we want to update inPage provider state with account info\n                this.provider._rpcRequest({\n                    method: \"solana_requestAccounts\",\n                    params: [\n                        this.requestedLoginProvider,\n                        params.login_hint\n                    ]\n                }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.getRpcPromiseCallback)(resolve, reject));\n            });\n            if (Array.isArray(res) && res.length > 0) {\n                return res;\n            }\n            // This would never happen, but just in case\n            throw new Error(\"Login failed\");\n        } catch (error) {\n            log.error(\"login failed\", error);\n            throw error;\n        } finally{\n            if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\n        }\n    }\n    async loginWithPrivateKey(loginParams) {\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        const { privateKey, userInfo } = loginParams;\n        const { success } = await this.communicationProvider.request({\n            method: \"login_with_private_key\",\n            params: {\n                privateKey,\n                userInfo\n            }\n        });\n        if (!success) throw new Error(\"Login Failed\");\n    }\n    async logout() {\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.LOGOUT,\n            params: []\n        });\n        this.requestedLoginProvider = null;\n    }\n    async cleanUp() {\n        if (this.communicationProvider.isLoggedIn) {\n            await this.logout();\n        }\n        this.clearInit();\n    }\n    clearInit() {\n        function isElement(element) {\n            return element instanceof Element || element instanceof Document;\n        }\n        if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n            this.styleLink.remove();\n            this.styleLink = undefined;\n        }\n        if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n            this.torusIframe.remove();\n            this.torusIframe = undefined;\n        }\n        if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n            this.torusAlert = undefined;\n            this.torusAlertContainer.remove();\n            this.torusAlertContainer = undefined;\n        }\n        this.isInitialized = false;\n    }\n    hideTorusButton() {\n        this.communicationProvider.hideTorusButton();\n    }\n    showTorusButton() {\n        this.communicationProvider.showTorusButton();\n    }\n    async setProvider(params) {\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\n            params: _objectSpread({}, params)\n        });\n    }\n    async showWallet(path) {\n        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const instanceId = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\n            params: []\n        });\n        const finalPath = path ? `/${path}` : \"\";\n        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);\n        // Using URL constructor to prevent js injection and allow parameter validation.!\n        finalUrl.searchParams.append(\"instanceId\", instanceId);\n        Object.keys(params).forEach((x)=>{\n            finalUrl.searchParams.append(x, params[x]);\n        });\n        if (this.dappStorageKey) {\n            finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        // No need to track this window state. Hence, no _handleWindow call.\n        const walletWindow = new PopupHandler({\n            url: finalUrl,\n            features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\n        });\n        walletWindow.open();\n    }\n    async getUserInfo() {\n        const userInfoResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.USER_INFO,\n            params: []\n        });\n        return userInfoResponse;\n    }\n    async initiateTopup(provider, params) {\n        if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\n        const windowId = getWindowId();\n        this.communicationProvider._handleWindow(windowId);\n        const topupResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.TOPUP,\n            params: {\n                provider,\n                params,\n                windowId\n            }\n        });\n        return topupResponse;\n    }\n    // Solana specific API\n    async getAccounts() {\n        const response = await this.provider.request({\n            method: \"getAccounts\",\n            params: []\n        });\n        return response;\n    }\n    async sendTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                isLegacyTransaction\n            }\n        });\n        return response;\n    }\n    // support sendOptions\n    async signAndSendTransaction(transaction, options) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                options,\n                isLegacyTransaction\n            }\n        });\n        return {\n            signature: response\n        };\n    }\n    async signTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serializeMessage().toString(\"hex\") : Buffer.from(transaction.message.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"sign_transaction\",\n            params: {\n                message,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pair\n        const parsed = JSON.parse(response);\n        const signature = {\n            publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(parsed.publicKey),\n            signature: Buffer.from(parsed.signature, \"hex\")\n        };\n        transaction.addSignature(signature.publicKey, signature.signature);\n        return transaction;\n    }\n    async signAllTransactions(transactions) {\n        let isLegacyTransaction;\n        const encodedMessage = transactions.map((tx)=>{\n            isLegacyTransaction = isLegacyTransactionInstance(tx);\n            return isLegacyTransaction ? tx.serializeMessage().toString(\"hex\") : Buffer.from(tx.message.serialize()).toString(\"hex\");\n        });\n        const responses = await this.provider.request({\n            method: \"sign_all_transactions\",\n            params: {\n                message: encodedMessage,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pairs\n        const signatures = responses.map((item)=>{\n            const parsed = JSON.parse(item);\n            return {\n                publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey(parsed.publicKey),\n                signature: Buffer.from(parsed.signature, \"hex\")\n            };\n        });\n        transactions.forEach((tx, idx)=>{\n            tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);\n            return tx;\n        });\n        return transactions;\n    }\n    async signMessage(data) {\n        const response = await this.provider.request({\n            method: \"sign_message\",\n            params: {\n                data\n            }\n        });\n        return response;\n    }\n    async getGaslessPublicKey() {\n        const response = await this.provider.request({\n            method: \"get_gasless_public_key\",\n            params: []\n        });\n        return response;\n    }\n    // async connect(): Promise<boolean> {\n    //   const response = (await this.provider.request({\n    //     method: \"connect\",\n    //     params: {},\n    //   })) as boolean;\n    //   return response;\n    // }\n    handleDappStorageKey(useLocalStorage) {\n        const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;\n        let dappStorageKey = \"\";\n        if (isLocalStorageAvailable && useLocalStorage) {\n            const storedKey = window.localStorage.getItem(localStorageKey);\n            if (storedKey) dappStorageKey = storedKey;\n            else {\n                const generatedKey = `torus-app-${getWindowId()}`;\n                window.localStorage.setItem(localStorageKey, generatedKey);\n                dappStorageKey = generatedKey;\n            }\n        }\n        this.dappStorageKey = dappStorageKey;\n        return dappStorageKey;\n    }\n    async _setupWeb3(providerParams) {\n        log.info(\"setupWeb3 running\");\n        // setup background connection\n        const providerStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.BasePostMessageStream({\n            name: \"embed_torus\",\n            target: \"iframe_torus\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n        const communicationStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.BasePostMessageStream({\n            name: \"embed_communication\",\n            target: \"iframe_communication\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // compose the inPage provider\n        const inPageProvider = new TorusInPageProvider(providerStream, {});\n        const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\n        inPageProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\n                if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                // for inPageProvider methods sending windowId in request instead of params\n                // as params might be positional.\n                _payload.windowId = windowId;\n            }\n            inPageProvider._rpcEngine.handle(_payload, cb);\n        };\n        communicationProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\n                });\n                // for communication methods sending window id in jrpc req params\n                _payload.params.windowId = windowId;\n            }\n            communicationProvider._rpcEngine.handle(_payload, cb);\n        };\n        // detect solana_requestAccounts and pipe to enable for now\n        const detectAccountRequestPrototypeModifier = (m)=>{\n            const originalMethod = inPageProvider[m];\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const self = this;\n            inPageProvider[m] = function providerFunc(request, cb) {\n                const { method, params = [] } = request;\n                if (method === \"solana_requestAccounts\") {\n                    if (!cb) return self.login({\n                        loginProvider: params[0]\n                    });\n                    self.login({\n                        loginProvider: params[0]\n                    })// eslint-disable-next-line promise/no-callback-in-promise\n                    .then((res)=>cb(null, res))// eslint-disable-next-line promise/no-callback-in-promise\n                    .catch((err)=>cb(err));\n                }\n                return originalMethod.apply(this, [\n                    request,\n                    cb\n                ]);\n            };\n        };\n        // Detects call to solana_requestAccounts in request & sendAsync and passes to login\n        detectAccountRequestPrototypeModifier(\"request\");\n        detectAccountRequestPrototypeModifier(\"sendAsync\");\n        detectAccountRequestPrototypeModifier(\"send\");\n        const proxiedInPageProvider = new Proxy(inPageProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        this.provider = proxiedInPageProvider;\n        this.communicationProvider = proxiedCommunicationProvider;\n        await Promise.all([\n            inPageProvider._initializeState(),\n            communicationProvider._initializeState(_objectSpread(_objectSpread({}, providerParams), {}, {\n                dappStorageKey: this.dappStorageKey,\n                torusAlertContainer: this.torusAlertContainer,\n                torusIframe: this.torusIframe\n            }))\n        ]);\n        log.debug(\"Torus - injected provider\");\n    }\n}\n //# sourceMappingURL=solanaEmbed.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL2Rpc3Qvc29sYW5hRW1iZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUN4QjtBQUNpSTtBQUN6SDtBQUNxSTtBQUM1SDtBQUMxQjtBQUNYO0FBQ1E7QUFDSztBQUVyQyxJQUFJcUIsVUFBVTtBQUVkLElBQUlDLFdBQVc7SUFDYkMsUUFBUTtRQUNOQyxjQUFjLElBQU07UUFDcEJDLHlCQUF5QixJQUFNO1FBQy9CQyxpQkFBaUJDLENBQUFBLFNBQVUsQ0FBQyw2RUFBNkUsRUFBRUEsT0FBTyw4QkFBOEIsQ0FBQztRQUNqSkMscUJBQXFCLElBQU07UUFDM0JDLGdCQUFnQkMsQ0FBQUEsb0JBQXFCLENBQUMsZ0RBQWdELEVBQUVBLGtCQUFrQixDQUFDLENBQUM7UUFDNUdDLG9CQUFvQixJQUFNLENBQUMsOENBQThDLENBQUM7UUFDMUVDLHNCQUFzQixJQUFNLENBQUMseUNBQXlDLENBQUM7UUFDdkVDLHNCQUFzQixJQUFNLENBQUMscURBQXFELENBQUM7UUFDbkZDLHFCQUFxQixJQUFNLENBQUMsNENBQTRDLENBQUM7UUFDekVDLHFCQUFxQlIsQ0FBQUEsU0FBVSxDQUFDLDRDQUE0QyxFQUFFQSxPQUFPLEVBQUUsQ0FBQztJQUMxRjtJQUNBUyxNQUFNO1FBQ0pDLFdBQVdDLENBQUFBLFVBQVcsQ0FBQyxtQ0FBbUMsRUFBRUEsUUFBUSxFQUFFLENBQUM7SUFDekU7SUFDQUMsVUFBVSxDQUFDO0FBQ2I7QUFFQSxNQUFNQyxtQkFBbUI7SUFDdkJDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxhQUFhO0lBQ2JDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxTQUFTO0FBQ1g7QUFDQSxNQUFNQyxrQkFBa0I7SUFDdEJDLFlBQVk7SUFDWkMsYUFBYTtJQUNiQyxTQUFTO0FBQ1g7QUFDQSxNQUFNQyxrQkFBa0I7SUFDdEJDLGFBQWE7SUFDYkMsVUFBVTtJ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QUFDN0U7b0JBQVNvSTtpQkFBRztZQUNqRDtRQUNGO1FBQ0Esb0ZBQW9GO1FBQ3BGK0ssc0NBQXNDO1FBQ3RDQSxzQ0FBc0M7UUFDdENBLHNDQUFzQztRQUN0QyxNQUFNTyx3QkFBd0IsSUFBSUMsTUFBTVYsZ0JBQWdCO1lBQ3RELGtFQUFrRTtZQUNsRSxnQ0FBZ0M7WUFDaENXLGdCQUFnQixJQUFNO1FBQ3hCO1FBQ0EsTUFBTUMsK0JBQStCLElBQUlGLE1BQU01Ryx1QkFBdUI7WUFDcEUsa0VBQWtFO1lBQ2xFLGdDQUFnQztZQUNoQzZHLGdCQUFnQixJQUFNO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDL0UsUUFBUSxHQUFHNkU7UUFDaEIsSUFBSSxDQUFDM0cscUJBQXFCLEdBQUc4RztRQUM3QixNQUFNMVMsUUFBUTJTLEdBQUcsQ0FBQztZQUFDYixlQUFlbFQsZ0JBQWdCO1lBQUlnTixzQkFBc0JoTixnQkFBZ0IsQ0FBQytMLGNBQWNBLGNBQWMsQ0FBQyxHQUFHK0csaUJBQWlCLENBQUMsR0FBRztnQkFDaEpwTixnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO2dCQUNuQ3NCLHFCQUFxQixJQUFJLENBQUNBLG1CQUFtQjtnQkFDN0NDLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQy9CO1NBQUk7UUFDSjVNLElBQUlvTyxLQUFLLENBQUM7SUFDWjtBQUNGO0FBRXFILENBQ3JILDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvZGlzdC9zb2xhbmFFbWJlZC5lc20uanM/ODRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMsIFBST1ZJREVSX0pSUENfTUVUSE9EUywgUFJPVklERVJfTk9USUZJQ0FUSU9OUyB9IGZyb20gJ0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycyc7XG5pbXBvcnQgeyBzZXRBUElLZXkgfSBmcm9tICdAdG9ydXNsYWJzL2h0dHAtaGVscGVycyc7XG5pbXBvcnQgeyBTYWZlRXZlbnRFbWl0dGVyLCBPYmplY3RNdWx0aXBsZXgsIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUsIEpSUENFbmdpbmUsIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlLCBnZXRScGNQcm9taXNlQ2FsbGJhY2ssIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMnO1xuaW1wb3J0IHsgZXRoRXJyb3JzLCBFdGhlcmV1bVJwY0Vycm9yIH0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IHsgZHVwbGV4IH0gZnJvbSAnaXMtc3RyZWFtJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuaW1wb3J0IGxvZ2xldmVsIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBkZXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcblxudmFyIHZlcnNpb24gPSBcIjAuMy40XCI7XG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgZXJyb3JzOiB7XG4gICAgZGlzY29ubmVjdGVkOiAoKSA9PiBcIlRvcnVzOiBMb3N0IGNvbm5lY3Rpb24gdG8gVG9ydXMuXCIsXG4gICAgcGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6ICgpID0+IFwiVG9ydXM6IERpc2Nvbm5lY3RlZCBmcm9tIGlmcmFtZS4gUGFnZSByZWxvYWQgcmVxdWlyZWQuXCIsXG4gICAgdW5zdXBwb3J0ZWRTeW5jOiBtZXRob2QgPT4gYFRvcnVzOiBUaGUgVG9ydXMgRXRoZXJldW0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzeW5jaHJvbm91cyBtZXRob2RzIGxpa2UgJHttZXRob2R9IHdpdGhvdXQgYSBjYWxsYmFjayBwYXJhbWV0ZXIuYCxcbiAgICBpbnZhbGlkRHVwbGV4U3RyZWFtOiAoKSA9PiBcIk11c3QgcHJvdmlkZSBhIE5vZGUuanMtc3R5bGUgZHVwbGV4IHN0cmVhbS5cIixcbiAgICBpbnZhbGlkT3B0aW9uczogbWF4RXZlbnRMaXN0ZW5lcnMgPT4gYEludmFsaWQgb3B0aW9ucy4gUmVjZWl2ZWQ6IHsgbWF4RXZlbnRMaXN0ZW5lcnM6ICR7bWF4RXZlbnRMaXN0ZW5lcnN9fWAsXG4gICAgaW52YWxpZFJlcXVlc3RBcmdzOiAoKSA9PiBgRXhwZWN0ZWQgYSBzaW5nbGUsIG5vbi1hcnJheSwgb2JqZWN0IGFyZ3VtZW50LmAsXG4gICAgaW52YWxpZFJlcXVlc3RNZXRob2Q6ICgpID0+IGAnYXJncy5tZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLmAsXG4gICAgaW52YWxpZFJlcXVlc3RQYXJhbXM6ICgpID0+IGAnYXJncy5wYXJhbXMnIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5IGlmIHByb3ZpZGVkLmAsXG4gICAgaW52YWxpZExvZ2dlck9iamVjdDogKCkgPT4gYCdhcmdzLmxvZ2dlcicgbXVzdCBiZSBhbiBvYmplY3QgaWYgcHJvdmlkZWQuYCxcbiAgICBpbnZhbGlkTG9nZ2VyTWV0aG9kOiBtZXRob2QgPT4gYCdhcmdzLmxvZ2dlcicgbXVzdCBpbmNsdWRlIHJlcXVpcmVkIG1ldGhvZCAnJHttZXRob2R9Jy5gXG4gIH0sXG4gIGluZm86IHtcbiAgICBjb25uZWN0ZWQ6IGNoYWluSWQgPT4gYFRvcnVzOiBDb25uZWN0ZWQgdG8gY2hhaW4gd2l0aCBJRCBcIiR7Y2hhaW5JZH1cIi5gXG4gIH0sXG4gIHdhcm5pbmdzOiB7fVxufTtcblxuY29uc3QgUEFZTUVOVF9QUk9WSURFUiA9IHtcbiAgTU9PTlBBWTogXCJtb29ucGF5XCIsXG4gIFdZUkU6IFwid3lyZVwiLFxuICBSQU1QTkVUV09SSzogXCJyYW1wbmV0d29ya1wiLFxuICBYQU5QT09MOiBcInhhbnBvb2xcIixcbiAgTUVSQ1VSWU86IFwibWVyY3VyeW9cIixcbiAgVFJBTlNBSzogXCJ0cmFuc2FrXCJcbn07XG5jb25zdCBUT1JVU19CVUlMRF9FTlYgPSB7XG4gIFBST0RVQ1RJT046IFwicHJvZHVjdGlvblwiLFxuICBERVZFTE9QTUVOVDogXCJkZXZlbG9wbWVudFwiLFxuICBURVNUSU5HOiBcInRlc3RpbmdcIlxufTtcbmNvbnN0IEJVVFRPTl9QT1NJVElPTiA9IHtcbiAgQk9UVE9NX0xFRlQ6IFwiYm90dG9tLWxlZnRcIixcbiAgVE9QX0xFRlQ6IFwidG9wLWxlZnRcIixcbiAgQk9UVE9NX1JJR0hUOiBcImJvdHRvbS1yaWdodFwiLFxuICBUT1BfUklHSFQ6IFwidG9wLXJpZ2h0XCJcbn07XG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcbiAgR09PR0xFOiBcImdvb2dsZVwiLFxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXG4gIEFQUExFOiBcImFwcGxlXCIsXG4gIExJTkU6IFwibGluZVwiLFxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXG4gIEtBS0FPOiBcImtha2FvXCIsXG4gIExJTktFRElOOiBcImxpbmtlZGluXCIsXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxuICBXRUlCTzogXCJ3ZWlib1wiLFxuICBXRUNIQVQ6IFwid2VjaGF0XCIsXG4gIEVNQUlMX1BBU1NXT1JETEVTUzogXCJlbWFpbF9wYXNzd29yZGxlc3NcIlxufTtcblxuY29uc3QgdHJhbnNsYXRpb25zID0ge1xuICBlbjoge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCJDb250aW51ZVwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwiQXV0aG9yaXphdGlvbiByZXF1aXJlZFwiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCJDbGljayBjb250aW51ZSB0byBwcm9jZWVkIHdpdGggeW91ciByZXF1ZXN0IGluIGEgcG9wdXBcIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCJDb29raWVzIFJlcXVpcmVkXCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIlBsZWFzZSBlbmFibGUgY29va2llcyBpbiB5b3VyIGJyb3dzZXIgcHJlZmVyZW5jZXMgdG8gYWNjZXNzIFRvcnVzXCIsXG4gICAgICBjbGlja0hlcmU6IFwiTW9yZSBJbmZvXCJcbiAgICB9XG4gIH0sXG4gIGRlOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIkZvcnRzZXR6ZW5cIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIkF1dG9yaXNpZXJ1bmcgZXJmb3JkZXJsaWNoXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIktsaWNrZW4gU2llIGluIGVpbmVtIFBvcHVwIGF1ZiBXZWl0ZXIsIHVtIG1pdCBJaHJlciBBbmZyYWdlIGZvcnR6dWZhaHJlblwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIkNvb2tpZXMgYmVuw7Z0aWd0XCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIkJpdHRlIGFrdGl2aWVyZW4gU2llIENvb2tpZXMgaW4gSWhyZW4gQnJvd3NlcmVpbnN0ZWxsdW5nZW4sIHVtIGF1ZiBUb3J1cyB6dXp1Z3JlaWZlblwiLFxuICAgICAgY2xpY2tIZXJlOiBcIk1laHIgSW5mb1wiXG4gICAgfVxuICB9LFxuICBqYToge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCLntpnntprjgZnjgotcIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIuiqjeiovOOBjOW/heimgeOBp+OBmVwiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCLntprooYzjgpLjgq/jg6rjg4Pjgq/jgZfjgabjgIHjg53jg4Pjg5fjgqLjg4Pjg5fjgafjg6rjgq/jgqjjgrnjg4jjgpLntprooYzjgZfjgb7jgZlcIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLlv4XopoHjgarjgq/jg4Pjgq3jg7xcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiVG9ydXPjgavjgqLjgq/jgrvjgrnjgZnjgovjgavjga/jgIHjg5bjg6njgqbjgrbjga7oqK3lrprjgadDb29raWXjgpLmnInlirnjgavjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcbiAgICAgIGNsaWNrSGVyZTogXCLoqbPjgZfjgY/jga9cIlxuICAgIH1cbiAgfSxcbiAga286IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwi6rOE7IaN7ZWY64ukXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCLsirnsnbgg7ZWE7JqUXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIu2MneyXheyXkOyEnCDsmpTssq3snYQg7KeE7ZaJ7ZWY66Ck66m0IOqzhOyGjeydhCDtgbTrpq3tlZjsi63si5zsmKQuXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwi7L+g7YKkIO2VhOyalFwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCLruIzrnbzsmrDsoIAg7ZmY6rK9IOyEpOygleyXkOyEnCDsv6DtgqTrpbwg7Zmc7ISx7ZmU7ZWY7JesIFRvcnVz7JeQIOyVoeyEuOyKpO2VmOyLreyLnOyYpC5cIixcbiAgICAgIGNsaWNrSGVyZTogXCLrjZQg66eO7J2AIOygleuztFwiXG4gICAgfVxuICB9LFxuICB6aDoge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCLnu6fnu61cIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIumcgOimgeaOiOadg1wiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCLljZXlh7vnu6fnu63ku6XlnKjlvLnlh7rnqpflj6PkuK3nu6fnu63mgqjnmoTor7fmsYJcIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLlv4XloatDb29raWVcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwi6K+35Zyo5oKo55qE5rWP6KeI5Zmo6aaW6YCJ6aG55Lit5ZCv55SoY29va2ll5Lul6K6/6ZeuVG9ydXPjgIJcIixcbiAgICAgIGNsaWNrSGVyZTogXCLmm7TlpJrkv6Hmga9cIlxuICAgIH1cbiAgfVxufTtcbnZhciBjb25maWd1cmF0aW9uID0ge1xuICBzdXBwb3J0ZWRWZXJpZmllckxpc3Q6IFtMT0dJTl9QUk9WSURFUi5HT09HTEUsIExPR0lOX1BST1ZJREVSLlJFRERJVCwgTE9HSU5fUFJPVklERVIuRElTQ09SRF0sXG4gIGFwaTogXCJodHRwczovL2FwaS50b3IudXNcIixcbiAgdHJhbnNsYXRpb25zLFxuICBwcm9kVG9ydXNVcmw6IFwiXCIsXG4gIGxvY2FsU3RvcmFnZUtleVByZWZpeDogYHRvcnVzLWBcbn07XG5cbnZhciBsb2cgPSBsb2dsZXZlbC5nZXRMb2dnZXIoXCJzb2xhbmEtZW1iZWRcIik7XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG4vKipcbiAqIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIHRoYXQgbG9ncyBSUEMgZXJyb3JzIGFuZCBhbmQgdmFsaWRhdGVzIHJlcS5tZXRob2QuXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKiBAcmV0dXJucyAganNvbi1ycGMtZW5naW5lIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JNaWRkbGV3YXJlKCkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgLy8ganNvbi1ycGMtZW5naW5lIHdpbGwgdGVybWluYXRlIHRoZSByZXF1ZXN0IHdoZW4gaXQgbm90aWNlcyB0aGlzIGVycm9yXG4gICAgaWYgKHR5cGVvZiByZXEubWV0aG9kICE9PSBcInN0cmluZ1wiIHx8ICFyZXEubWV0aG9kKSB7XG4gICAgICByZXMuZXJyb3IgPSBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogYFRoZSByZXF1ZXN0ICdtZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLmAsXG4gICAgICAgIGRhdGE6IHJlcVxuICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQoZG9uZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gcmVzO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgICAgbG9nLmVycm9yKGBUb3J1cyAtIFJQQyBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfSk7XG4gIH07XG59XG4vKipcbiAqIExvZ3MgYSBzdHJlYW0gZGlzY29ubmVjdGlvbiBlcnJvci4gRW1pdHMgYW4gJ2Vycm9yJyBpZiBnaXZlbiBhblxuICogRXZlbnRFbWl0dGVyIHRoYXQgaGFzIGxpc3RlbmVycyBmb3IgdGhlICdlcnJvcicgZXZlbnQuXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKiBAcGFyYW0gcmVtb3RlTGFiZWwgLSBUaGUgbGFiZWwgb2YgdGhlIGRpc2Nvbm5lY3RlZCBzdHJlYW0uXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgYXNzb2NpYXRlZCBlcnJvciB0byBsb2cuXG4gKiBAcGFyYW0gZW1pdHRlciAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHJlbW90ZUxhYmVsLCBlcnJvciwgZW1pdHRlcikge1xuICBsZXQgd2FybmluZ01zZyA9IGBUb3J1czogTG9zdCBjb25uZWN0aW9uIHRvIFwiJHtyZW1vdGVMYWJlbH1cIi5gO1xuICBpZiAoZXJyb3I/LnN0YWNrKSB7XG4gICAgd2FybmluZ01zZyArPSBgXFxuJHtlcnJvci5zdGFja31gO1xuICB9XG4gIGxvZy53YXJuKHdhcm5pbmdNc2cpO1xuICBpZiAoZW1pdHRlciAmJiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoXCJlcnJvclwiKSA+IDApIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJlcnJvclwiLCB3YXJuaW5nTXNnKTtcbiAgfVxufVxuY29uc3QgZ2V0V2luZG93SWQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmNvbnN0IGdldFRvcnVzVXJsID0gYXN5bmMgYnVpbGRFbnYgPT4ge1xuICBsZXQgdG9ydXNVcmw7XG4gIGxldCBsb2dMZXZlbDtcbiAgLy8gY29uc3QgdmVyc2lvblVzZWQgPSB2ZXJzaW9uO1xuICAvLyBsb2cuaW5mbyhcInNvbGFuYSBlbWJlZCB2ZXJzaW9uIHVzZWQ6IFwiLCB2ZXJzaW9uVXNlZCk7XG4gIHN3aXRjaCAoYnVpbGRFbnYpIHtcbiAgICBjYXNlIFwidGVzdGluZ1wiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHBzOi8vc29sYW5hLXRlc3RpbmcudG9yLnVzXCI7XG4gICAgICBsb2dMZXZlbCA9IFwiZGVidWdcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkZXZlbG9wbWVudFwiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MFwiO1xuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdG9ydXNVcmwgPSBgaHR0cHM6Ly9zb2xhbmEudG9yLnVzYDtcbiAgICAgIGxvZ0xldmVsID0gXCJlcnJvclwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3J1c1VybCxcbiAgICBsb2dMZXZlbFxuICB9O1xufTtcbmNvbnN0IGdldFVzZXJMYW5ndWFnZSA9ICgpID0+IHtcbiAgbGV0IHVzZXJMYW5ndWFnZSA9IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgXCJlbi1VU1wiO1xuICBjb25zdCB1c2VyTGFuZ3VhZ2VzID0gdXNlckxhbmd1YWdlLnNwbGl0KFwiLVwiKTtcbiAgdXNlckxhbmd1YWdlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ3VyYXRpb24udHJhbnNsYXRpb25zLCB1c2VyTGFuZ3VhZ2VzWzBdKSA/IHVzZXJMYW5ndWFnZXNbMF0gOiBcImVuXCI7XG4gIHJldHVybiB1c2VyTGFuZ3VhZ2U7XG59O1xuY29uc3QgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA2NjAsXG4gIHdpZHRoOiAzNzVcbn07XG5jb25zdCBGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzQwLFxuICB3aWR0aDogMTMxNVxufTtcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XID0ge1xuICBoZWlnaHQ6IDcwMCxcbiAgd2lkdGg6IDEyMDBcbn07XG5jb25zdCBGRUFUVVJFU19DT05GSVJNX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA2MDAsXG4gIHdpZHRoOiA0MDBcbn07XG5mdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHtcbiAgbGV0IHN0b3JhZ2U7XG4gIHRyeSB7XG4gICAgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICBjb25zdCB4ID0gXCJfX3N0b3JhZ2VfdGVzdF9fXCI7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSh4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlICYmIChcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZS5jb2RlID09PSAyMiB8fFxuICAgIC8vIEZpcmVmb3hcbiAgICBlLmNvZGUgPT09IDEwMTQgfHxcbiAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZS5uYW1lID09PSBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHx8XG4gICAgLy8gRmlyZWZveFxuICAgIGUubmFtZSA9PT0gXCJOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRFwiKSAmJlxuICAgIC8vIGFja25vd2xlZGdlIFF1b3RhRXhjZWVkZWRFcnJvciBvbmx5IGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGFscmVhZHkgc3RvcmVkXG4gICAgc3RvcmFnZSAmJiBzdG9yYWdlLmxlbmd0aCAhPT0gMDtcbiAgfVxufVxuLyoqXG4gKiBwb3B1cCBoYW5kbGVyIHV0aWxzXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHVwRmVhdHVyZXMoX3JlZikge1xuICBsZXQge1xuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaFxuICB9ID0gX3JlZjtcbiAgLy8gRml4ZXMgZHVhbC1zY3JlZW4gcG9zaXRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vc3QgYnJvd3NlcnMgICAgICBGaXJlZm94XG4gIGNvbnN0IGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogd2luZG93LnNjcmVlblg7XG4gIGNvbnN0IGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuVG9wIDogd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPyB3aW5kb3cuaW5uZXJXaWR0aCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA6IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IDogd2luZG93LnNjcmVlbi5oZWlnaHQ7XG4gIGNvbnN0IHN5c3RlbVpvb20gPSAxOyAvLyBObyByZWxpYWJsZSBlc3RpbWF0ZVxuICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMoKHdpZHRoIC0gdykgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5MZWZ0KTtcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMoKGhlaWdodCAtIGgpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuVG9wKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBgdGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PSR7aCAvIHN5c3RlbVpvb219LHdpZHRoPSR7dyAvIHN5c3RlbVpvb219LHRvcD0ke3RvcH0sbGVmdD0ke2xlZnR9YDtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5jbGFzcyBCYXNlUHJvdmlkZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEluZGljYXRpbmcgdGhhdCB0aGlzIHByb3ZpZGVyIGlzIGEgVG9ydXMgcHJvdmlkZXIuXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSA9IFwicHJvdmlkZXJcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUb3J1c1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ycGNFbmdpbmVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJqc29uUnBjQ29ubmVjdGlvbkV2ZW50c1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGF0ZVwiLCB2b2lkIDApO1xuICAgIGlmICghZHVwbGV4KGNvbm5lY3Rpb25TdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuZXJyb3JzLmludmFsaWREdXBsZXhTdHJlYW0oKSk7XG4gICAgfVxuICAgIHRoaXMuaXNUb3J1cyA9IHRydWU7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMobWF4RXZlbnRMaXN0ZW5lcnMpO1xuICAgIHRoaXMuX2hhbmRsZUNvbm5lY3QgPSB0aGlzLl9oYW5kbGVDb25uZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCA9IHRoaXMuX2hhbmRsZURpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB0aGlzLl9ycGNSZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVN0YXRlID0gdGhpcy5faW5pdGlhbGl6ZVN0YXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZW5kQXN5bmMgPSB0aGlzLnNlbmRBc3luYy5iaW5kKHRoaXMpO1xuICAgIC8vIHRoaXMuZW5hYmxlID0gdGhpcy5lbmFibGUuYmluZCh0aGlzKTtcbiAgICAvLyBzZXR1cCBjb25uZWN0aW9uU3RyZWFtIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IG5ldyBPYmplY3RNdWx0aXBsZXgoKTtcbiAgICBwdW1wKGNvbm5lY3Rpb25TdHJlYW0sIG11eCwgY29ubmVjdGlvblN0cmVhbSwgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMsIFwiVG9ydXNcIikpO1xuICAgIC8vIGlnbm9yZSBwaGlzaGluZyB3YXJuaW5nIG1lc3NhZ2UgKGhhbmRsZWQgZWxzZXdoZXJlKVxuICAgIG11eC5pZ25vcmVTdHJlYW0oXCJwaGlzaGluZ1wiKTtcbiAgICAvLyBzZXR1cCBvd24gZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlclxuICAgIGNvbnN0IGpzb25ScGNDb25uZWN0aW9uID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpO1xuICAgIHB1bXAoanNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtLCBtdXguY3JlYXRlU3RyZWFtKGpzb25ScGNTdHJlYW1OYW1lKSwganNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtLCB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcywgXCJUb3J1cyBScGNQcm92aWRlclwiKSk7XG4gICAgLy8gaGFuZGxlIFJQQyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmVcbiAgICBjb25zdCBycGNFbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUVycm9yTWlkZGxld2FyZSgpKTtcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKHtcbiAgICAgIG9yaWdpbjogbG9jYXRpb24ub3JpZ2luXG4gICAgfSkpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGpzb25ScGNDb25uZWN0aW9uLm1pZGRsZXdhcmUpO1xuICAgIHRoaXMuX3JwY0VuZ2luZSA9IHJwY0VuZ2luZTtcbiAgICB0aGlzLmpzb25ScGNDb25uZWN0aW9uRXZlbnRzID0ganNvblJwY0Nvbm5lY3Rpb24uZXZlbnRzO1xuICB9XG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAqIFJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwsIG9yIHJlamVjdHMgb24gZXJyb3IuXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdEFyZ3MoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBhcmdzO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInN0cmluZ1wiIHx8IG1ldGhvZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuaW52YWxpZFJlcXVlc3RNZXRob2QoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuaW52YWxpZFJlcXVlc3RQYXJhbXMoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9ycGNSZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0sIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgc2VuZChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JwY1JlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICBzZW5kQXN5bmMocGF5bG9hZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9ycGNSZXF1ZXN0KHBheWxvYWQsIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBsb3N0IHRvIGNyaXRpY2FsIHN0cmVhbXMuXG4gICAqXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3Qoc3RyZWFtTmFtZSwgZXJyb3IpIHtcbiAgICBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhzdHJlYW1OYW1lLCBlcnJvciwgdGhpcyk7XG4gICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdChmYWxzZSwgZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5jb25zdCBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChoYW5kbGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaGFuZGxlckFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGhhbmRsZXJBcmdzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBjb25zdCBoYW5kbGVyV3JhcHBlciA9ICgpID0+IHtcbiAgICBoYW5kbGVyKC4uLmhhbmRsZXJBcmdzKTtcbiAgICBoYW5kbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyKTtcbiAgfTtcbiAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG59O1xuYXN5bmMgZnVuY3Rpb24gZG9jdW1lbnRSZWFkeSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVFdmVudChkb2N1bWVudCwgXCJET01Db250ZW50TG9hZGVkXCIsIHJlc29sdmUpO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBodG1sVG9FbGVtZW50ID0gaHRtbCA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgY29uc3QgdHJpbW1lZEh0bWwgPSBodG1sLnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0cmltbWVkSHRtbDtcbiAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbn07XG5mdW5jdGlvbiBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIHRyYW5zYWN0aW9uLnZlcnNpb24gPT09IHVuZGVmaW5lZDtcbn1cblxuY2xhc3MgUG9wdXBIYW5kbGVyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXNcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcmdldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93VGltZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpQ2xvc2VkV2luZG93XCIsIHZvaWQgMCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQgfHwgXCJfYmxhbmtcIjtcbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXMgfHwgZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyk7XG4gICAgdGhpcy53aW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aW5kb3dUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlDbG9zZWRXaW5kb3cgPSBmYWxzZTtcbiAgICB0aGlzLl9zZXR1cFRpbWVyKCk7XG4gIH1cbiAgX3NldHVwVGltZXIoKSB7XG4gICAgdGhpcy53aW5kb3dUaW1lciA9IE51bWJlcihzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy53aW5kb3cgJiYgdGhpcy53aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG4gICAgICAgIGlmICghdGhpcy5pQ2xvc2VkV2luZG93KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pQ2xvc2VkV2luZG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2luZG93ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud2luZG93ID09PSB1bmRlZmluZWQpIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG4gICAgfSwgNTAwKSk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdy5vcGVuKHRoaXMudXJsLmhyZWYsIHRoaXMudGFyZ2V0LCB0aGlzLmZlYXR1cmVzKTtcbiAgICBpZiAodGhpcy53aW5kb3c/LmZvY3VzKSB0aGlzLndpbmRvdy5mb2N1cygpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmlDbG9zZWRXaW5kb3cgPSB0cnVlO1xuICAgIGlmICh0aGlzLndpbmRvdykgdGhpcy53aW5kb3cuY2xvc2UoKTtcbiAgfVxuICByZWRpcmVjdChsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0KSB7XG4gICAgaWYgKGxvY2F0aW9uUmVwbGFjZU9uUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMudXJsLmhyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMudXJsLmhyZWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jbGFzcyBUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSA9IFwicHJvdmlkZXJcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKGNvbm5lY3Rpb25TdHJlYW0sIHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzLFxuICAgICAganNvblJwY1N0cmVhbU5hbWVcbiAgICB9KTtcbiAgICAvLyBwcml2YXRlIHN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW1iZWRUcmFuc2xhdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c1VybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhcHBTdG9yYWdlS2V5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93UmVmc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyeVdpbmRvd0hhbmRsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzQWxlcnRDb250YWluZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0lmcmFtZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3N0YXRlID0gX29iamVjdFNwcmVhZCQyKHt9LCBUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlci5fZGVmYXVsdFN0YXRlKTtcbiAgICAvLyBwdWJsaWMgc3RhdGVcbiAgICB0aGlzLnRvcnVzVXJsID0gXCJcIjtcbiAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gXCJcIjtcbiAgICBjb25zdCBsYW5ndWFnZVRyYW5zbGF0aW9ucyA9IGNvbmZpZ3VyYXRpb24udHJhbnNsYXRpb25zW2dldFVzZXJMYW5ndWFnZSgpXTtcbiAgICB0aGlzLmVtYmVkVHJhbnNsYXRpb25zID0gbGFuZ3VhZ2VUcmFuc2xhdGlvbnMuZW1iZWQ7XG4gICAgdGhpcy53aW5kb3dSZWZzID0ge307XG4gICAgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIEVJUC0xMTkzIGNvbm5lY3RcbiAgICB0aGlzLm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlciA9IHBheWxvYWQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHBheWxvYWQ7XG4gICAgICBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuSUZSQU1FX1NUQVRVUykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaXNGdWxsU2NyZWVuLFxuICAgICAgICAgIHJpZFxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKHtcbiAgICAgICAgICBpc0Z1bGw6IGlzRnVsbFNjcmVlbixcbiAgICAgICAgICByaWQ6IHJpZFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuQ1JFQVRFX1dJTkRPVykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgdXJsXG4gICAgICAgIH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwQmxvY2tBbGVydCh3aW5kb3dJZCwgdXJsKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuQ0xPU0VfV0lORE9XKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNsb3NlV2luZG93KHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLlVTRVJfTE9HR0VEX0lOKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlclxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBjdXJyZW50TG9naW5Qcm92aWRlcjtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuVVNFUl9MT0dHRURfT1VUKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmpzb25ScGNDb25uZWN0aW9uRXZlbnRzLm9uKFwibm90aWZpY2F0aW9uXCIsIG5vdGlmaWNhdGlvbkhhbmRsZXIpO1xuICB9XG4gIGdldCBpc0xvZ2dlZEluKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluO1xuICB9XG4gIGdldCBpc0lGcmFtZUZ1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpblBhZ2UgcHJvdmlkZXIgaXMgY29ubmVjdGVkIHRvIFRvcnVzLlxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkO1xuICB9XG4gIGFzeW5jIF9pbml0aWFsaXplU3RhdGUocGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9ydXNVcmwsXG4gICAgICAgIGRhcHBTdG9yYWdlS2V5LFxuICAgICAgICB0b3J1c0FsZXJ0Q29udGFpbmVyLFxuICAgICAgICB0b3J1c0lmcmFtZVxuICAgICAgfSA9IHBhcmFtcztcbiAgICAgIHRoaXMudG9ydXNVcmwgPSB0b3J1c1VybDtcbiAgICAgIHRoaXMuZGFwcFN0b3JhZ2VLZXkgPSBkYXBwU3RvcmFnZUtleTtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lciA9IHRvcnVzQWxlcnRDb250YWluZXI7XG4gICAgICB0aGlzLnRvcnVzSWZyYW1lID0gdG9ydXNJZnJhbWU7XG4gICAgICB0aGlzLnRvcnVzSWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgLy8gb25seSBkbyB0aGlzIGlmIGlmcmFtZSBpcyBub3QgZnVsbCBzY3JlZW5cbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0lGcmFtZUZ1bGxTY3JlZW4pIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlcixcbiAgICAgICAgaXNMb2dnZWRJblxuICAgICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuR0VUX1BST1ZJREVSX1NUQVRFLFxuICAgICAgICBwYXJhbXM6IFtdXG4gICAgICB9KTtcbiAgICAgIC8vIGluZGljYXRlIHRoYXQgd2UndmUgY29ubmVjdGVkLCBmb3IgRUlQLTExOTMgY29tcGxpYW5jZVxuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdChjdXJyZW50TG9naW5Qcm92aWRlciwgaXNMb2dnZWRJbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBGYWlsZWQgdG8gZ2V0IGluaXRpYWwgc3RhdGUuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbG9nLmluZm8oXCJpbml0aWFsaXplZCBjb21tdW5pY2F0aW9uIHN0YXRlXCIpO1xuICAgICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiX2luaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlV2luZG93KHdpbmRvd0lkKSB7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybCB8fCBgJHt0aGlzLnRvcnVzVXJsfS9yZWRpcmVjdD93aW5kb3dJZD0ke3dpbmRvd0lkfWApO1xuICAgIGlmICh0aGlzLmRhcHBTdG9yYWdlS2V5KSB7XG4gICAgICAvLyBJZiBtdWx0aXBsZSBpbnN0YW5jZXMsIGl0IHJldHVybnMgdGhlIGZpcnN0IG9uZVxuICAgICAgaWYgKGZpbmFsVXJsLmhhc2gpIGZpbmFsVXJsLmhhc2ggKz0gYCZkYXBwU3RvcmFnZUtleT0ke3RoaXMuZGFwcFN0b3JhZ2VLZXl9YDtlbHNlIGZpbmFsVXJsLmhhc2ggPSBgI2RhcHBTdG9yYWdlS2V5PSR7dGhpcy5kYXBwU3RvcmFnZUtleX1gO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVkV2luZG93ID0gbmV3IFBvcHVwSGFuZGxlcih7XG4gICAgICB1cmw6IGZpbmFsVXJsLFxuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXNcbiAgICB9KTtcbiAgICBoYW5kbGVkV2luZG93Lm9wZW4oKTtcbiAgICBpZiAoIWhhbmRsZWRXaW5kb3cud2luZG93KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cEJsb2NrQWxlcnQod2luZG93SWQsIGZpbmFsVXJsLmhyZWYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZGQgdG8gY29sbGVjdGlvbiBvbmx5IGlmIHdpbmRvdyBpcyBvcGVuZWRcbiAgICB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdID0gaGFuZGxlZFdpbmRvdztcbiAgICAvLyBXZSB0ZWxsIHRoZSBpZnJhbWUgdGhhdCB0aGUgd2luZG93IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBvcGVuZWRcbiAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5PUEVORURfV0lORE9XLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHdpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gICAgaGFuZGxlZFdpbmRvdy5vbmNlKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgLy8gdXNlciBjbG9zZWQgdGhlIHdpbmRvd1xuICAgICAgZGVsZXRlIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF07XG4gICAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1csXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9kaXNwbGF5SWZyYW1lKCkge1xuICAgIGxldCB7XG4gICAgICBpc0Z1bGwgPSBmYWxzZSxcbiAgICAgIHJpZCA9IFwiXCJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgIC8vIHNldCBwaGFzZVxuICAgIGlmICghaXNGdWxsKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gdGhpcy5fc3RhdGUudG9ydXNXaWRnZXRWaXNpYmlsaXR5ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBcIjcwcHhcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gXCI3MHB4XCI7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlLmJ1dHRvblBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLlRPUF9MRUZUOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uVE9QX1JJR0hUOlxuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX1JJR0hUOlxuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX0xFRlQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS50b3AgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgIHN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRvcnVzSWZyYW1lLnN0eWxlLCBzdHlsZSk7XG4gICAgdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuID0gaXNGdWxsO1xuICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLklGUkFNRV9TVEFUVVMsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgaXNJRnJhbWVGdWxsU2NyZWVuOiBpc0Z1bGwsXG4gICAgICAgIHJpZFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhpZGVUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gIH1cbiAgc2hvd1RvcnVzQnV0dG9uKCkge1xuICAgIHRoaXMuX3N0YXRlLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IHRydWU7XG4gICAgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSUEMgbWV0aG9kLiBGb3J3YXJkcyByZXF1ZXN0cyB0byBiYWNrZ3JvdW5kIHZpYSB0aGUgUlBDIGVuZ2luZS5cbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgICovXG4gIF9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSkge1xuICAgICAgaWYgKCFfcGF5bG9hZC5qc29ucnBjKSB7XG4gICAgICAgIF9wYXlsb2FkLmpzb25ycGMgPSBcIjIuMFwiO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyeVdpbmRvd0hhbmRsZShfcGF5bG9hZCwgY2IpO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGNvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudExvZ2luUHJvdmlkZXIgLSBUaGUgbG9naW4gUHJvdmlkZXJcbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlQ29ubmVjdChjdXJyZW50TG9naW5Qcm92aWRlciwgaXNMb2dnZWRJbikge1xuICAgIGlmICghdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlcixcbiAgICAgICAgaXNMb2dnZWRJblxuICAgICAgfSk7XG4gICAgICBsb2cuZGVidWcobWVzc2FnZXMuaW5mby5jb25uZWN0ZWQoY3VycmVudExvZ2luUHJvdmlkZXIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgZGlzY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQgd2l0aCByZXNwZWN0IHRvIHRoZSBpc1JlY292ZXJhYmxlIHBhcmFtZXRlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgcGVyIHRoZSBDbG9zZUV2ZW50IHN0YXR1cyBjb2RlcyBhcyByZXF1aXJlZCBieSBFSVAtMTE5MzpcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAqXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZURpc2Nvbm5lY3QoaXNSZWNvdmVyYWJsZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkIHx8ICF0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkICYmICFpc1JlY292ZXJhYmxlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKGlzUmVjb3ZlcmFibGUpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDEzLFxuICAgICAgICAvLyBUcnkgYWdhaW4gbGF0ZXJcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTEsXG4gICAgICAgIC8vIEludGVybmFsIGVycm9yXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMucGVybWFuZW50bHlEaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnRMb2dpblByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNMb2dnZWRJbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIC8vIENhbGxlZCBpZiB0aGUgaWZyYW1lIHdhbnRzIHRvIGNsb3NlIHRoZSB3aW5kb3cgY2F1c2UgaXQgaXMgZG9uZSBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0XG4gIF9oYW5kbGVDbG9zZVdpbmRvdyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aW5kb3dJZFxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF0pIHtcbiAgICAgIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF0uY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdO1xuICAgIH1cbiAgfVxuICBhc3luYyBfY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KHdpbmRvd0lkLCB1cmwpIHtcbiAgICBjb25zdCBsb2dvVXJsID0gdGhpcy5nZXRMb2dvVXJsKCk7XG4gICAgY29uc3QgdG9ydXNBbGVydCA9IGh0bWxUb0VsZW1lbnQoJzxkaXYgaWQ9XCJ0b3J1c0FsZXJ0XCIgY2xhc3M9XCJ0b3J1cy1hbGVydC0tdjJcIj4nICsgYDxkaXYgaWQ9XCJ0b3J1c0FsZXJ0X19sb2dvXCI+PGltZyBzcmM9XCIke2xvZ29Vcmx9XCIgLz48L2Rpdj5gICsgXCI8ZGl2PlwiICsgYDxoMSBpZD1cInRvcnVzQWxlcnRfX3RpdGxlXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmFjdGlvblJlcXVpcmVkfTwvaDE+YCArIGA8cCBpZD1cInRvcnVzQWxlcnRfX2Rlc2NcIj4ke3RoaXMuZW1iZWRUcmFuc2xhdGlvbnMucGVuZGluZ0FjdGlvbn08L3A+YCArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiKTtcbiAgICBjb25zdCBzdWNjZXNzQWxlcnQgPSBodG1sVG9FbGVtZW50KGA8ZGl2PjxhIGlkPVwidG9ydXNBbGVydF9fYnRuXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmNvbnRpbnVlfTwvYT48L2Rpdj5gKTtcbiAgICBjb25zdCBidG5Db250YWluZXIgPSBodG1sVG9FbGVtZW50KCc8ZGl2IGlkPVwidG9ydXNBbGVydF9fYnRuLWNvbnRhaW5lclwiPjwvZGl2PicpO1xuICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWNjZXNzQWxlcnQpO1xuICAgIHRvcnVzQWxlcnQuYXBwZW5kQ2hpbGQoYnRuQ29udGFpbmVyKTtcbiAgICBjb25zdCBiaW5kT25Mb2FkID0gKCkgPT4ge1xuICAgICAgc3VjY2Vzc0FsZXJ0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cpXG4gICAgICAgIH0pO1xuICAgICAgICB0b3J1c0FsZXJ0LnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXR0YWNoT25Mb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRvcnVzQWxlcnQpO1xuICAgIH07XG4gICAgYXdhaXQgZG9jdW1lbnRSZWFkeSgpO1xuICAgIGF0dGFjaE9uTG9hZCgpO1xuICAgIGJpbmRPbkxvYWQoKTtcbiAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuICBnZXRMb2dvVXJsKCkge1xuICAgIGNvbnN0IGxvZ29VcmwgPSBgJHt0aGlzLnRvcnVzVXJsfS9pbWFnZXMvdG9ydXNfaWNvbi1ibHVlLnN2Z2A7XG4gICAgcmV0dXJuIGxvZ29Vcmw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlciwgXCJfZGVmYXVsdFN0YXRlXCIsIHtcbiAgYnV0dG9uUG9zaXRpb246IFwiYm90dG9tLWxlZnRcIixcbiAgY3VycmVudExvZ2luUHJvdmlkZXI6IG51bGwsXG4gIGlzSUZyYW1lRnVsbFNjcmVlbjogZmFsc2UsXG4gIGhhc0VtaXR0ZWRDb25uZWN0aW9uOiBmYWxzZSxcbiAgdG9ydXNXaWRnZXRWaXNpYmlsaXR5OiBmYWxzZSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBpc0xvZ2dlZEluOiBmYWxzZSxcbiAgaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZDogZmFsc2UsXG4gIGlzQ29ubmVjdGVkOiBmYWxzZVxufSk7XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jbGFzcyBUb3J1c0luUGFnZVByb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIFRoZSBjaGFpbiBJRCBvZiB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTb2xhbmEgY2hhaW4uXG4gICAqIFNlZSBbY2hhaW5JZC5uZXR3b3JrXXtAbGluayBodHRwczovL2NoYWluaWQubmV0d29ya30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgdXNlcidzIGN1cnJlbnRseSBzZWxlY3RlZCBTb2xhbmEgYWRkcmVzcy5cbiAgICogSWYgbnVsbCwgVG9ydXMgaXMgZWl0aGVyIGxvY2tlZCBvciB0aGUgdXNlciBoYXMgbm90IHBlcm1pdHRlZCBhbnlcbiAgICogYWRkcmVzc2VzIHRvIGJlIHZpZXdlZC5cbiAgICovXG5cbiAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0cmVhbSwgX3JlZikge1xuICAgIGxldCB7XG4gICAgICBtYXhFdmVudExpc3RlbmVycyA9IDEwMCxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lID0gXCJwcm92aWRlclwiXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoY29ubmVjdGlvblN0cmVhbSwge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZVxuICAgIH0pO1xuICAgIC8vIHByaXZhdGUgc3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFpbklkXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2VsZWN0ZWRBZGRyZXNzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJ5V2luZG93SGFuZGxlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fc3RhdGUgPSBfb2JqZWN0U3ByZWFkJDEoe30sIFRvcnVzSW5QYWdlUHJvdmlkZXIuX2RlZmF1bHRTdGF0ZSk7XG4gICAgLy8gcHVibGljIHN0YXRlXG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgIHRoaXMuY2hhaW5JZCA9IG51bGw7XG4gICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkID0gdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkID0gdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkID0gdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIEVJUC0xMTkzIGNvbm5lY3RcbiAgICB0aGlzLm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QganNvblJwY05vdGlmaWNhdGlvbkhhbmRsZXIgPSBwYXlsb2FkID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBwYXlsb2FkO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gUFJPVklERVJfTk9USUZJQ0FUSU9OUy5BQ0NPVU5UU19DSEFOR0VEKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFBST1ZJREVSX05PVElGSUNBVElPTlMuVU5MT0NLX1NUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gUFJPVklERVJfTk9USUZJQ0FUSU9OUy5DSEFJTl9DSEFOR0VEKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZChwYXJhbXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8ganNvbiBycGMgbm90aWZpY2F0aW9uIGxpc3RlbmVyXG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCBqc29uUnBjTm90aWZpY2F0aW9uSGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5wYWdlIHByb3ZpZGVyIGlzIGNvbm5lY3RlZCB0byBUb3J1cy5cbiAgICovXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZDtcbiAgfVxuICAvLyBQcml2YXRlIE1ldGhvZHNcbiAgLy89ID09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGhlbHBlci5cbiAgICogUG9wdWxhdGVzIGluaXRpYWwgc3RhdGUgYnkgY2FsbGluZyAnd2FsbGV0X2dldFByb3ZpZGVyU3RhdGUnIGFuZCBlbWl0c1xuICAgKiBuZWNlc3NhcnkgZXZlbnRzLlxuICAgKi9cbiAgYXN5bmMgX2luaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgaXNVbmxvY2tlZFxuICAgICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogUFJPVklERVJfSlJQQ19NRVRIT0RTLkdFVF9QUk9WSURFUl9TVEFURSxcbiAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgfSk7XG4gICAgICAvLyBpbmRpY2F0ZSB0aGF0IHdlJ3ZlIGNvbm5lY3RlZCwgZm9yIEVJUC0xMTkzIGNvbXBsaWFuY2VcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZCh7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGlzVW5sb2NrZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IEZhaWxlZCB0byBnZXQgaW5pdGlhbCBzdGF0ZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsb2cuaW5mbyhcImluaXRpYWxpemVkIHByb3ZpZGVyIHN0YXRlXCIpO1xuICAgICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiX2luaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWwgUlBDIG1ldGhvZC4gRm9yd2FyZHMgcmVxdWVzdHMgdG8gYmFja2dyb3VuZCB2aWEgdGhlIFJQQyBlbmdpbmUuXG4gICAqIEFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kXG4gICAqL1xuICBfcnBjUmVxdWVzdChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGxldCBpc0ludGVybmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICBsZXQgY2IgPSBjYWxsYmFjaztcbiAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSkge1xuICAgICAgaWYgKCFfcGF5bG9hZC5qc29ucnBjKSB7XG4gICAgICAgIF9wYXlsb2FkLmpzb25ycGMgPSBcIjIuMFwiO1xuICAgICAgfVxuICAgICAgaWYgKF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJzb2xhbmFfYWNjb3VudHNcIiB8fCBfcGF5bG9hZC5tZXRob2QgPT09IFwic29sYW5hX3JlcXVlc3RBY2NvdW50c1wiKSB7XG4gICAgICAgIC8vIGhhbmRsZSBhY2NvdW50cyBjaGFuZ2luZ1xuICAgICAgICBjYiA9IChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChyZXMucmVzdWx0IHx8IFtdLCBfcGF5bG9hZC5tZXRob2QgPT09IFwic29sYW5hX2FjY291bnRzXCIsIGlzSW50ZXJuYWwpO1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoX3BheWxvYWQubWV0aG9kID09PSBcIndhbGxldF9nZXRQcm92aWRlclN0YXRlXCIpIHtcbiAgICAgICAgdGhpcy5fcnBjRW5naW5lLmhhbmRsZShwYXlsb2FkLCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cnlXaW5kb3dIYW5kbGUoX3BheWxvYWQsIGNiKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgSUQgb2YgdGhlIG5ld2x5IGNvbm5lY3RlZCBjaGFpbi5cbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlQ29ubmVjdChjaGFpbklkKSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgICAgbG9nLmRlYnVnKG1lc3NhZ2VzLmluZm8uY29ubmVjdGVkKGNoYWluSWQpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgZGlzY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQgd2l0aCByZXNwZWN0IHRvIHRoZSBpc1JlY292ZXJhYmxlIHBhcmFtZXRlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgcGVyIHRoZSBDbG9zZUV2ZW50IHN0YXR1cyBjb2RlcyBhcyByZXF1aXJlZCBieSBFSVAtMTE5MzpcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAqXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZURpc2Nvbm5lY3QoaXNSZWNvdmVyYWJsZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkIHx8ICF0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkICYmICFpc1JlY292ZXJhYmxlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKGlzUmVjb3ZlcmFibGUpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDEzLFxuICAgICAgICAvLyBUcnkgYWdhaW4gbGF0ZXJcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTEsXG4gICAgICAgIC8vIEludGVybmFsIGVycm9yXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMucGVybWFuZW50bHlEaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhY2NvdW50cyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xuICAgIGxldCBpc0V0aEFjY291bnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBsZXQgaXNJbnRlcm5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgLy8gZGVmZW5zaXZlIHByb2dyYW1taW5nXG4gICAgbGV0IGZpbmFsQWNjb3VudHMgPSBhY2NvdW50cztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmluYWxBY2NvdW50cykpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBSZWNlaXZlZCBub24tYXJyYXkgYWNjb3VudHMgcGFyYW1ldGVyLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBmaW5hbEFjY291bnRzKTtcbiAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGFjY291bnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIG5vbi1zdHJpbmcgYWNjb3VudC4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgYWNjb3VudHMpO1xuICAgICAgICBmaW5hbEFjY291bnRzID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBlbWl0IGFjY291bnRzQ2hhbmdlZCBpZiBhbnl0aGluZyBhYm91dCB0aGUgYWNjb3VudHMgYXJyYXkgaGFzIGNoYW5nZWRcbiAgICBpZiAoIWRlcXVhbCh0aGlzLl9zdGF0ZS5hY2NvdW50cywgZmluYWxBY2NvdW50cykpIHtcbiAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgaGF2ZSB0aGUgY29ycmVjdCBhY2NvdW50cyBldmVuIGJlZm9yZSBzb2xhbmFfYWNjb3VudHNcbiAgICAgIC8vIHJldHVybnMsIGV4Y2VwdCBpbiBjYXNlcyB3aGVyZSBpc0ludGVybmFsIGlzIHRydWVcbiAgICAgIGlmIChpc0V0aEFjY291bnRzICYmIEFycmF5LmlzQXJyYXkodGhpcy5fc3RhdGUuYWNjb3VudHMpICYmIHRoaXMuX3N0YXRlLmFjY291bnRzLmxlbmd0aCA+IDAgJiYgIWlzSW50ZXJuYWwpIHtcbiAgICAgICAgbG9nLmVycm9yKCdUb3J1czogXCJzb2xhbmFfYWNjb3VudHNcIiB1bmV4cGVjdGVkbHkgdXBkYXRlZCBhY2NvdW50cy4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy4nLCBmaW5hbEFjY291bnRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gZmluYWxBY2NvdW50cztcbiAgICAgIHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBmaW5hbEFjY291bnRzKTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHNlbGVjdGVkQWRkcmVzc1xuICAgIGlmICh0aGlzLnNlbGVjdGVkQWRkcmVzcyAhPT0gZmluYWxBY2NvdW50c1swXSkge1xuICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBmaW5hbEFjY291bnRzWzBdIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgY2hhaW5JZCBhbmQgbmV0d29ya1ZlcnNpb24sIGVtaXRzIGNvcnJlc3BvbmRpbmdcbiAgICogZXZlbnRzIGFuZCBzZXRzIHJlbGV2YW50IHB1YmxpYyBzdGF0ZS5cbiAgICogRG9lcyBub3RoaW5nIGlmIG5laXRoZXIgdGhlIGNoYWluSWQgbm9yIHRoZSBuZXR3b3JrVmVyc2lvbiBhcmUgZGlmZmVyZW50XG4gICAqIGZyb20gZXhpc3RpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2NoYWluQ2hhbmdlZFxuICAgKiBAcGFyYW0gbmV0d29ya0luZm8gLSBBbiBvYmplY3Qgd2l0aCBuZXR3b3JrIGluZm8uXG4gICAqL1xuICBfaGFuZGxlQ2hhaW5DaGFuZ2VkKCkge1xuICAgIGxldCB7XG4gICAgICBjaGFpbklkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgaW52YWxpZCBuZXR3b3JrIHBhcmFtZXRlcnMuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIHtcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGFpbklkID09PSBcImxvYWRpbmdcIikge1xuICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdChjaGFpbklkKTtcbiAgICAgIGlmIChjaGFpbklkICE9PSB0aGlzLmNoYWluSWQpIHtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwb24gcmVjZWlwdCBvZiBhIG5ldyBpc1VubG9ja2VkIHN0YXRlLCBzZXRzIHJlbGV2YW50IHB1YmxpYyBzdGF0ZS5cbiAgICogQ2FsbHMgdGhlIGFjY291bnRzIGNoYW5nZWQgaGFuZGxlciB3aXRoIHRoZSByZWNlaXZlZCBhY2NvdW50cywgb3IgYW4gZW1wdHlcbiAgICogYXJyYXkuXG4gICAqXG4gICAqIERvZXMgbm90aGluZyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIGV4aXN0aW5nIHZhbHVlLlxuICAgKiBUaGVyZSBhcmUgbm8gbG9jay91bmxvY2sgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgKi9cbiAgX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCgpIHtcbiAgICBsZXQge1xuICAgICAgYWNjb3VudHMsXG4gICAgICBpc1VubG9ja2VkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKHR5cGVvZiBpc1VubG9ja2VkICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIGludmFsaWQgaXNVbmxvY2tlZCBwYXJhbWV0ZXIuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIHtcbiAgICAgICAgaXNVbmxvY2tlZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1VubG9ja2VkICE9PSB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gaXNVbmxvY2tlZDtcbiAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cyB8fCBbXSk7XG4gICAgfVxuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoVG9ydXNJblBhZ2VQcm92aWRlciwgXCJfZGVmYXVsdFN0YXRlXCIsIHtcbiAgYWNjb3VudHM6IG51bGwsXG4gIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgaXNVbmxvY2tlZDogZmFsc2UsXG4gIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZDogZmFsc2UsXG4gIGhhc0VtaXR0ZWRDb25uZWN0aW9uOiBmYWxzZVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBpbWFnZSBVUkwgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGltZ0V4aXN0cyh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHRydWUpO1xuICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZXNvbHZlKGZhbHNlKTtcbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEV4dHJhY3RzIGEgbmFtZSBmb3IgdGhlIHNpdGUgZnJvbSB0aGUgRE9NXG4gKi9cbmNvbnN0IGdldFNpdGVOYW1lID0gd2luZG93ID0+IHtcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50XG4gIH0gPSB3aW5kb3c7XG4gIGNvbnN0IHNpdGVOYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IG1ldGFbcHJvcGVydHk9XCJvZzpzaXRlX25hbWVcIl0nKTtcbiAgaWYgKHNpdGVOYW1lKSB7XG4gICAgcmV0dXJuIHNpdGVOYW1lLmNvbnRlbnQ7XG4gIH1cbiAgY29uc3QgbWV0YVRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IG1ldGFbbmFtZT1cInRpdGxlXCJdJyk7XG4gIGlmIChtZXRhVGl0bGUpIHtcbiAgICByZXR1cm4gbWV0YVRpdGxlLmNvbnRlbnQ7XG4gIH1cbiAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQudGl0bGU7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIGFuIGljb24gZm9yIHRoZSBzaXRlIGZyb20gdGhlIERPTVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTaXRlSWNvbih3aW5kb3cpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB3aW5kb3c7XG4gICAgLy8gVXNlIHRoZSBzaXRlJ3MgZmF2aWNvbiBpZiBpdCBleGlzdHNcbiAgICBsZXQgaWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQgPiBsaW5rW3JlbD1cInNob3J0Y3V0IGljb25cIl0nKTtcbiAgICBpZiAoaWNvbiAmJiAoYXdhaXQgaW1nRXhpc3RzKGljb24uaHJlZikpKSB7XG4gICAgICByZXR1cm4gaWNvbi5ocmVmO1xuICAgIH1cbiAgICAvLyBTZWFyY2ggdGhyb3VnaCBhdmFpbGFibGUgaWNvbnMgaW4gbm8gcGFydGljdWxhciBvcmRlclxuICAgIGljb24gPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2hlYWQgPiBsaW5rW3JlbD1cImljb25cIl0nKSkuZmluZChfaWNvbiA9PiBCb29sZWFuKF9pY29uLmhyZWYpKTtcbiAgICBpZiAoaWNvbiAmJiAoYXdhaXQgaW1nRXhpc3RzKGljb24uaHJlZikpKSB7XG4gICAgICByZXR1cm4gaWNvbi5ocmVmO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuLyoqXG4gKiBHZXRzIHNpdGUgbWV0YWRhdGEgYW5kIHJldHVybnMgaXRcbiAqXG4gKi9cbmNvbnN0IGdldFNpdGVNZXRhZGF0YSA9IGFzeW5jICgpID0+ICh7XG4gIG5hbWU6IGdldFNpdGVOYW1lKHdpbmRvdyksXG4gIGljb246IGF3YWl0IGdldFNpdGVJY29uKHdpbmRvdylcbn0pO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmNvbnN0IFBST1ZJREVSX1VOU0FGRV9NRVRIT0RTID0gW1wic2VuZF90cmFuc2FjdGlvblwiLCBcInNpZ25fdHJhbnNhY3Rpb25cIiwgXCJzaWduX2FsbF90cmFuc2FjdGlvbnNcIiwgXCJzaWduX21lc3NhZ2VcIiwgXCJjb25uZWN0XCJdO1xuY29uc3QgQ09NTVVOSUNBVElPTl9VTlNBRkVfTUVUSE9EUyA9IFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TRVRfUFJPVklERVJdO1xuY29uc3QgaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUgPSBzdG9yYWdlQXZhaWxhYmxlKFwibG9jYWxTdG9yYWdlXCIpO1xuLy8gcHJlbG9hZCBmb3IgaWZyYW1lIGRvZXNuJ3Qgd29yayBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01OTMyNjdcbihhc3luYyBmdW5jdGlvbiBwcmVMb2FkSWZyYW1lKCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBjb25zdCB0b3J1c0lmcmFtZUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBjb25zdCB7XG4gICAgICB0b3J1c1VybFxuICAgIH0gPSBhd2FpdCBnZXRUb3J1c1VybChcInByb2R1Y3Rpb25cIik7XG4gICAgdG9ydXNJZnJhbWVIdG1sLmhyZWYgPSBgJHt0b3J1c1VybH0vZnJhbWVgO1xuICAgIHRvcnVzSWZyYW1lSHRtbC5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgdG9ydXNJZnJhbWVIdG1sLnR5cGUgPSBcInRleHQvaHRtbFwiO1xuICAgIHRvcnVzSWZyYW1lSHRtbC5yZWwgPSBcInByZWZldGNoXCI7XG4gICAgaWYgKHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0ICYmIHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0LnN1cHBvcnRzKSB7XG4gICAgICBpZiAodG9ydXNJZnJhbWVIdG1sLnJlbExpc3Quc3VwcG9ydHMoXCJwcmVmZXRjaFwiKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRvcnVzSWZyYW1lSHRtbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy53YXJuKGVycm9yKTtcbiAgfVxufSkoKTtcbmNsYXNzIFRvcnVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHtcbiAgICAgIG1vZGFsWkluZGV4ID0gOTk5OTlcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0luaXRpYWxpemVkXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGFsWkluZGV4XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxlcnRaSW5kZXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0ZWRMb2dpblByb3ZpZGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21tdW5pY2F0aW9uUHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXBwU3RvcmFnZUtleVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVG9wdXBIaWRkZW5cIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzQWxlcnRDb250YWluZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c1VybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzSWZyYW1lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3R5bGVMaW5rXCIsIHZvaWQgMCk7XG4gICAgdGhpcy50b3J1c1VybCA9IFwiXCI7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7IC8vIGluaXQgZG9uZVxuICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IG51bGw7XG4gICAgdGhpcy5tb2RhbFpJbmRleCA9IG1vZGFsWkluZGV4O1xuICAgIHRoaXMuYWxlcnRaSW5kZXggPSBtb2RhbFpJbmRleCArIDEwMDA7XG4gICAgdGhpcy5kYXBwU3RvcmFnZUtleSA9IFwiXCI7XG4gIH1cbiAgZ2V0IGlzTG9nZ2VkSW4oKSB7XG4gICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlcikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgbGV0IHtcbiAgICAgIGJ1aWxkRW52ID0gVE9SVVNfQlVJTERfRU5WLlBST0RVQ1RJT04sXG4gICAgICBlbmFibGVMb2dnaW5nID0gZmFsc2UsXG4gICAgICBuZXR3b3JrLFxuICAgICAgc2hvd1RvcnVzQnV0dG9uID0gZmFsc2UsXG4gICAgICB1c2VMb2NhbFN0b3JhZ2UgPSBmYWxzZSxcbiAgICAgIGJ1dHRvblBvc2l0aW9uID0gQlVUVE9OX1BPU0lUSU9OLkJPVFRPTV9MRUZULFxuICAgICAgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCIsXG4gICAgICBleHRyYVBhcmFtcyA9IHt9LFxuICAgICAgd2hpdGVMYWJlbFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgaW5pdGlhbGl6ZWRcIik7XG4gICAgc2V0QVBJS2V5KGFwaUtleSk7XG4gICAgY29uc3Qge1xuICAgICAgdG9ydXNVcmwsXG4gICAgICBsb2dMZXZlbFxuICAgIH0gPSBhd2FpdCBnZXRUb3J1c1VybChidWlsZEVudik7XG4gICAgbG9nLmVuYWJsZUFsbCgpO1xuICAgIGxvZy5pbmZvKHRvcnVzVXJsLCBcInVybCBsb2FkZWRcIik7XG4gICAgbG9nLmluZm8oYFNvbGFuYSBFbWJlZCBWZXJzaW9uIDoke3ZlcnNpb259YCk7XG4gICAgdGhpcy50b3J1c1VybCA9IHRvcnVzVXJsO1xuICAgIGxvZy5zZXREZWZhdWx0TGV2ZWwobG9nTGV2ZWwpO1xuICAgIGlmIChlbmFibGVMb2dnaW5nKSBsb2cuZW5hYmxlQWxsKCk7ZWxzZSBsb2cuZGlzYWJsZUFsbCgpO1xuICAgIGNvbnN0IGRhcHBTdG9yYWdlS2V5ID0gdGhpcy5oYW5kbGVEYXBwU3RvcmFnZUtleSh1c2VMb2NhbFN0b3JhZ2UpO1xuICAgIGNvbnN0IHRvcnVzSWZyYW1lVXJsID0gbmV3IFVSTCh0b3J1c1VybCk7XG4gICAgaWYgKHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSkgdG9ydXNJZnJhbWVVcmwucGF0aG5hbWUgKz0gXCJmcmFtZVwiO2Vsc2UgdG9ydXNJZnJhbWVVcmwucGF0aG5hbWUgKz0gXCIvZnJhbWVcIjtcbiAgICBjb25zdCBoYXNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChkYXBwU3RvcmFnZUtleSkgaGFzaFBhcmFtcy5hcHBlbmQoXCJkYXBwU3RvcmFnZUtleVwiLCBkYXBwU3RvcmFnZUtleSk7XG4gICAgaGFzaFBhcmFtcy5hcHBlbmQoXCJvcmlnaW5cIiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgdG9ydXNJZnJhbWVVcmwuaGFzaCA9IGhhc2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAvLyBJZnJhbWUgY29kZVxuICAgIHRoaXMudG9ydXNJZnJhbWUgPSBodG1sVG9FbGVtZW50KGA8aWZyYW1lXG4gICAgICAgIGlkPVwidG9ydXNJZnJhbWVcIlxuICAgICAgICBjbGFzcz1cInRvcnVzSWZyYW1lXCJcbiAgICAgICAgc3JjPVwiJHt0b3J1c0lmcmFtZVVybC5ocmVmfVwiXG4gICAgICAgIHN0eWxlPVwiZGlzcGxheTogbm9uZTsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IHJpZ2h0OiAwOyB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlOyBib3JkZXI6IG5vbmU7IGJvcmRlci1yYWRpdXM6IDA7IHotaW5kZXg6ICR7dGhpcy5tb2RhbFpJbmRleC50b1N0cmluZygpfVwiXG4gICAgICA+PC9pZnJhbWU+YCk7XG4gICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyID0gaHRtbFRvRWxlbWVudChgPGRpdiBpZD1cInRvcnVzQWxlcnRDb250YWluZXJcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTsgei1pbmRleDogJHt0aGlzLmFsZXJ0WkluZGV4LnRvU3RyaW5nKCl9XCI+PC9kaXY+YCk7XG4gICAgdGhpcy5zdHlsZUxpbmsgPSBodG1sVG9FbGVtZW50KGA8bGluayBocmVmPVwiJHt0b3J1c1VybH0vY3NzL3dpZGdldC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+YCk7XG4gICAgY29uc3QgaGFuZGxlU2V0dXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuc3R5bGVMaW5rKTtcbiAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvcnVzSWZyYW1lKTtcbiAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIpO1xuICAgICAgICAgIHRoaXMudG9ydXNJZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGFwcE1ldGFkYXRhID0gYXdhaXQgZ2V0U2l0ZU1ldGFkYXRhKCk7XG4gICAgICAgICAgICAvLyBzZW5kIGluaXQgcGFyYW1zIGhlcmVcbiAgICAgICAgICAgIHRoaXMudG9ydXNJZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGJ1dHRvblBvc2l0aW9uLFxuICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgICAgIGRhcHBNZXRhZGF0YSxcbiAgICAgICAgICAgICAgZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICAgIHdoaXRlTGFiZWxcbiAgICAgICAgICAgIH0sIHRvcnVzSWZyYW1lVXJsLm9yaWdpbik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFdlYjMoe1xuICAgICAgICAgICAgICB0b3J1c1VybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2hvd1RvcnVzQnV0dG9uKSB0aGlzLnNob3dUb3J1c0J1dHRvbigpO1xuICAgICAgICAgICAgaWYgKHdoaXRlTGFiZWw/LnRvcHVwSGlkZSkgdGhpcy5pc1RvcHVwSGlkZGVuID0gd2hpdGVMYWJlbC50b3B1cEhpZGU7ZWxzZSB0aGlzLmhpZGVUb3J1c0J1dHRvbigpO1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdpbmRvdy50b3J1cyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBhd2FpdCBkb2N1bWVudFJlYWR5KCk7XG4gICAgYXdhaXQgaGFuZGxlU2V0dXAoKTtcbiAgfVxuICBhc3luYyBsb2dpbigpIHtcbiAgICBsZXQgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpbml0KCkgZmlyc3RcIik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IHBhcmFtcy5sb2dpblByb3ZpZGVyIHx8IG51bGw7XG4gICAgICBpZiAoIXRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlcikge1xuICAgICAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5fZGlzcGxheUlmcmFtZSh7XG4gICAgICAgICAgaXNGdWxsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXNlciBpcyBhbHJlYWR5IGxvZ2dlZCBpbiwgd2UgYXNzdW1lIHRoZXkgaGF2ZSBnaXZlbiBhY2Nlc3MgdG8gdGhlIHdlYnNpdGVcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgbWV0aG9kIGJlY2F1c2Ugd2Ugd2FudCB0byB1cGRhdGUgaW5QYWdlIHByb3ZpZGVyIHN0YXRlIHdpdGggYWNjb3VudCBpbmZvXG4gICAgICAgIHRoaXMucHJvdmlkZXIuX3JwY1JlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogXCJzb2xhbmFfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICAgICAgcGFyYW1zOiBbdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyLCBwYXJhbXMubG9naW5faGludF1cbiAgICAgICAgfSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9naW4gZmFpbGVkXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJsb2dpbiBmYWlsZWRcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0lGcmFtZUZ1bGxTY3JlZW4pIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLl9kaXNwbGF5SWZyYW1lKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvZ2luV2l0aFByaXZhdGVLZXkobG9naW5QYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpbml0KCkgZmlyc3RcIik7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleSxcbiAgICAgIHVzZXJJbmZvXG4gICAgfSA9IGxvZ2luUGFyYW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN1Y2Nlc3NcbiAgICB9ID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwibG9naW5fd2l0aF9wcml2YXRlX2tleVwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgIHVzZXJJbmZvXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFzdWNjZXNzKSB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpbiBGYWlsZWRcIik7XG4gIH1cbiAgYXN5bmMgbG9nb3V0KCkge1xuICAgIGlmICghdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNMb2dnZWRJbikgdGhyb3cgbmV3IEVycm9yKFwiTm90IGxvZ2dlZCBpblwiKTtcbiAgICBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HT1VULFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IG51bGw7XG4gIH1cbiAgYXN5bmMgY2xlYW5VcCgpIHtcbiAgICBpZiAodGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNMb2dnZWRJbikge1xuICAgICAgYXdhaXQgdGhpcy5sb2dvdXQoKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhckluaXQoKTtcbiAgfVxuICBjbGVhckluaXQoKSB7XG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQodGhpcy5zdHlsZUxpbmspICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuc3R5bGVMaW5rKSkge1xuICAgICAgdGhpcy5zdHlsZUxpbmsucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlTGluayA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudCh0aGlzLnRvcnVzSWZyYW1lKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnRvcnVzSWZyYW1lKSkge1xuICAgICAgdGhpcy50b3J1c0lmcmFtZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQodGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIpKSB7XG4gICAgICB0aGlzLnRvcnVzQWxlcnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG4gIGhpZGVUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5oaWRlVG9ydXNCdXR0b24oKTtcbiAgfVxuICBzaG93VG9ydXNCdXR0b24oKSB7XG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuc2hvd1RvcnVzQnV0dG9uKCk7XG4gIH1cbiAgYXN5bmMgc2V0UHJvdmlkZXIocGFyYW1zKSB7XG4gICAgYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNFVF9QUk9WSURFUixcbiAgICAgIHBhcmFtczogX29iamVjdFNwcmVhZCh7fSwgcGFyYW1zKVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNob3dXYWxsZXQocGF0aCkge1xuICAgIGxldCBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuV0FMTEVUX0lOU1RBTkNFX0lELFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIGNvbnN0IGZpbmFsUGF0aCA9IHBhdGggPyBgLyR7cGF0aH1gIDogXCJcIjtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwoYCR7dGhpcy50b3J1c1VybH0vd2FsbGV0JHtmaW5hbFBhdGh9YCk7XG4gICAgLy8gVXNpbmcgVVJMIGNvbnN0cnVjdG9yIHRvIHByZXZlbnQganMgaW5qZWN0aW9uIGFuZCBhbGxvdyBwYXJhbWV0ZXIgdmFsaWRhdGlvbi4hXG4gICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluc3RhbmNlSWRcIiwgaW5zdGFuY2VJZCk7XG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKHggPT4ge1xuICAgICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZCh4LCBwYXJhbXNbeF0pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmRhcHBTdG9yYWdlS2V5KSB7XG4gICAgICBmaW5hbFVybC5oYXNoID0gYCNkYXBwU3RvcmFnZUtleT0ke3RoaXMuZGFwcFN0b3JhZ2VLZXl9YDtcbiAgICB9XG4gICAgLy8gTm8gbmVlZCB0byB0cmFjayB0aGlzIHdpbmRvdyBzdGF0ZS4gSGVuY2UsIG5vIF9oYW5kbGVXaW5kb3cgY2FsbC5cbiAgICBjb25zdCB3YWxsZXRXaW5kb3cgPSBuZXcgUG9wdXBIYW5kbGVyKHtcbiAgICAgIHVybDogZmluYWxVcmwsXG4gICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cpXG4gICAgfSk7XG4gICAgd2FsbGV0V2luZG93Lm9wZW4oKTtcbiAgfVxuICBhc3luYyBnZXRVc2VySW5mbygpIHtcbiAgICBjb25zdCB1c2VySW5mb1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlVTRVJfSU5GTyxcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gdXNlckluZm9SZXNwb25zZTtcbiAgfVxuICBhc3luYyBpbml0aWF0ZVRvcHVwKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiVG9ydXMgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIGNvbnN0IHdpbmRvd0lkID0gZ2V0V2luZG93SWQoKTtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5faGFuZGxlV2luZG93KHdpbmRvd0lkKTtcbiAgICBjb25zdCB0b3B1cFJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlRPUFVQLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHdpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvcHVwUmVzcG9uc2U7XG4gIH1cbiAgLy8gU29sYW5hIHNwZWNpZmljIEFQSVxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZ2V0QWNjb3VudHNcIixcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgaXNMZWdhY3lUcmFuc2FjdGlvbiA9IGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzTGVnYWN5VHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlXG4gICAgfSkudG9TdHJpbmcoXCJoZXhcIikgOiBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi5zZXJpYWxpemUoKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNlbmRfdHJhbnNhY3Rpb25cIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8vIHN1cHBvcnQgc2VuZE9wdGlvbnNcbiAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlzTGVnYWN5VHJhbnNhY3Rpb24gPSBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0xlZ2FjeVRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZVxuICAgIH0pLnRvU3RyaW5nKFwiaGV4XCIpIDogQnVmZmVyLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzZW5kX3RyYW5zYWN0aW9uXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmU6IHJlc3BvbnNlXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBpc0xlZ2FjeVRyYW5zYWN0aW9uID0gaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlKHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNMZWdhY3lUcmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZyhcImhleFwiKSA6IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLm1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzaWduX3RyYW5zYWN0aW9uXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZU9ubHk6IHRydWUsXG4gICAgICAgIGlzTGVnYWN5VHJhbnNhY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyByZWNvbnN0cnVjdCBzaWduYXR1cmUgcGFpclxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHtcbiAgICAgIHB1YmxpY0tleTogbmV3IFB1YmxpY0tleShwYXJzZWQucHVibGljS2V5KSxcbiAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20ocGFyc2VkLnNpZ25hdHVyZSwgXCJoZXhcIilcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZFNpZ25hdHVyZShzaWduYXR1cmUucHVibGljS2V5LCBzaWduYXR1cmUuc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cbiAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICBsZXQgaXNMZWdhY3lUcmFuc2FjdGlvbjtcbiAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IHRyYW5zYWN0aW9ucy5tYXAodHggPT4ge1xuICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvbiA9IGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0eCk7XG4gICAgICByZXR1cm4gaXNMZWdhY3lUcmFuc2FjdGlvbiA/IHR4LnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZyhcImhleFwiKSA6IEJ1ZmZlci5mcm9tKHR4Lm1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwic2lnbl9hbGxfdHJhbnNhY3Rpb25zXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZTogZW5jb2RlZE1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VPbmx5OiB0cnVlLFxuICAgICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gcmVjb25zdHJ1Y3Qgc2lnbmF0dXJlIHBhaXJzXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IHJlc3BvbnNlcy5tYXAoaXRlbSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGl0ZW0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljS2V5OiBuZXcgUHVibGljS2V5KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHBhcnNlZC5zaWduYXR1cmUsIFwiaGV4XCIpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0eCwgaWR4KSA9PiB7XG4gICAgICB0eC5hZGRTaWduYXR1cmUoc2lnbmF0dXJlc1tpZHhdLnB1YmxpY0tleSwgc2lnbmF0dXJlc1tpZHhdLnNpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gdHg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9ucztcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInNpZ25fbWVzc2FnZVwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgZ2V0R2FzbGVzc1B1YmxpY0tleSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZ2V0X2dhc2xlc3NfcHVibGljX2tleVwiLFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvLyBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAvLyAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gIC8vICAgICBtZXRob2Q6IFwiY29ubmVjdFwiLFxuICAvLyAgICAgcGFyYW1zOiB7fSxcbiAgLy8gICB9KSkgYXMgYm9vbGVhbjtcbiAgLy8gICByZXR1cm4gcmVzcG9uc2U7XG4gIC8vIH1cbiAgaGFuZGxlRGFwcFN0b3JhZ2VLZXkodXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlS2V5ID0gYCR7Y29uZmlndXJhdGlvbi5sb2NhbFN0b3JhZ2VLZXlQcmVmaXh9JHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9YDtcbiAgICBsZXQgZGFwcFN0b3JhZ2VLZXkgPSBcIlwiO1xuICAgIGlmIChpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSAmJiB1c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHN0b3JlZEtleSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZEtleSkgZGFwcFN0b3JhZ2VLZXkgPSBzdG9yZWRLZXk7ZWxzZSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZEtleSA9IGB0b3J1cy1hcHAtJHtnZXRXaW5kb3dJZCgpfWA7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VLZXksIGdlbmVyYXRlZEtleSk7XG4gICAgICAgIGRhcHBTdG9yYWdlS2V5ID0gZ2VuZXJhdGVkS2V5O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gZGFwcFN0b3JhZ2VLZXk7XG4gICAgcmV0dXJuIGRhcHBTdG9yYWdlS2V5O1xuICB9XG4gIGFzeW5jIF9zZXR1cFdlYjMocHJvdmlkZXJQYXJhbXMpIHtcbiAgICBsb2cuaW5mbyhcInNldHVwV2ViMyBydW5uaW5nXCIpO1xuICAgIC8vIHNldHVwIGJhY2tncm91bmQgY29ubmVjdGlvblxuICAgIGNvbnN0IHByb3ZpZGVyU3RyZWFtID0gbmV3IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSh7XG4gICAgICBuYW1lOiBcImVtYmVkX3RvcnVzXCIsXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX3RvcnVzXCIsXG4gICAgICB0YXJnZXRXaW5kb3c6IHRoaXMudG9ydXNJZnJhbWUuY29udGVudFdpbmRvd1xuICAgIH0pO1xuICAgIC8vIFdlIGNyZWF0ZSBhbm90aGVyIExvY2FsTWVzc2FnZUR1cGxleFN0cmVhbSBmb3IgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGRhcHAgPD4gaWZyYW1lXG4gICAgY29uc3QgY29tbXVuaWNhdGlvblN0cmVhbSA9IG5ldyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0oe1xuICAgICAgbmFtZTogXCJlbWJlZF9jb21tdW5pY2F0aW9uXCIsXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX2NvbW11bmljYXRpb25cIixcbiAgICAgIHRhcmdldFdpbmRvdzogdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93XG4gICAgfSk7XG4gICAgLy8gY29tcG9zZSB0aGUgaW5QYWdlIHByb3ZpZGVyXG4gICAgY29uc3QgaW5QYWdlUHJvdmlkZXIgPSBuZXcgVG9ydXNJblBhZ2VQcm92aWRlcihwcm92aWRlclN0cmVhbSwge30pO1xuICAgIGNvbnN0IGNvbW11bmljYXRpb25Qcm92aWRlciA9IG5ldyBUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlcihjb21tdW5pY2F0aW9uU3RyZWFtLCB7fSk7XG4gICAgaW5QYWdlUHJvdmlkZXIudHJ5V2luZG93SGFuZGxlID0gKHBheWxvYWQsIGNiKSA9PiB7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpICYmIFBST1ZJREVSX1VOU0FGRV9NRVRIT0RTLmluY2x1ZGVzKF9wYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIE5vdCBMb2dnZWQgSW5cIik7XG4gICAgICAgIGNvbnN0IHdpbmRvd0lkID0gZ2V0V2luZG93SWQoKTtcbiAgICAgICAgY29tbXVuaWNhdGlvblByb3ZpZGVyLl9oYW5kbGVXaW5kb3cod2luZG93SWQsIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmb3IgaW5QYWdlUHJvdmlkZXIgbWV0aG9kcyBzZW5kaW5nIHdpbmRvd0lkIGluIHJlcXVlc3QgaW5zdGVhZCBvZiBwYXJhbXNcbiAgICAgICAgLy8gYXMgcGFyYW1zIG1pZ2h0IGJlIHBvc2l0aW9uYWwuXG4gICAgICAgIF9wYXlsb2FkLndpbmRvd0lkID0gd2luZG93SWQ7XG4gICAgICB9XG4gICAgICBpblBhZ2VQcm92aWRlci5fcnBjRW5naW5lLmhhbmRsZShfcGF5bG9hZCwgY2IpO1xuICAgIH07XG4gICAgY29tbXVuaWNhdGlvblByb3ZpZGVyLnRyeVdpbmRvd0hhbmRsZSA9IChwYXlsb2FkLCBjYikgPT4ge1xuICAgICAgY29uc3QgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSAmJiBDT01NVU5JQ0FUSU9OX1VOU0FGRV9NRVRIT0RTLmluY2x1ZGVzKF9wYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgY29uc3Qgd2luZG93SWQgPSBnZXRXaW5kb3dJZCgpO1xuICAgICAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XKSAvLyB0b2RvOiBhcmUgdGhlc2UgZmVhdHVyZXMgZ2VuZXJpYyBmb3IgYWxsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmb3IgY29tbXVuaWNhdGlvbiBtZXRob2RzIHNlbmRpbmcgd2luZG93IGlkIGluIGpycGMgcmVxIHBhcmFtc1xuICAgICAgICBfcGF5bG9hZC5wYXJhbXMud2luZG93SWQgPSB3aW5kb3dJZDtcbiAgICAgIH1cbiAgICAgIGNvbW11bmljYXRpb25Qcm92aWRlci5fcnBjRW5naW5lLmhhbmRsZShfcGF5bG9hZCwgY2IpO1xuICAgIH07XG4gICAgLy8gZGV0ZWN0IHNvbGFuYV9yZXF1ZXN0QWNjb3VudHMgYW5kIHBpcGUgdG8gZW5hYmxlIGZvciBub3dcbiAgICBjb25zdCBkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyID0gbSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGluUGFnZVByb3ZpZGVyW21dO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGluUGFnZVByb3ZpZGVyW21dID0gZnVuY3Rpb24gcHJvdmlkZXJGdW5jKHJlcXVlc3QsIGNiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgcGFyYW1zID0gW11cbiAgICAgICAgfSA9IHJlcXVlc3Q7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwic29sYW5hX3JlcXVlc3RBY2NvdW50c1wiKSB7XG4gICAgICAgICAgaWYgKCFjYikgcmV0dXJuIHNlbGYubG9naW4oe1xuICAgICAgICAgICAgbG9naW5Qcm92aWRlcjogcGFyYW1zWzBdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5sb2dpbih7XG4gICAgICAgICAgICBsb2dpblByb3ZpZGVyOiBwYXJhbXNbMF1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICAgICAgICAudGhlbihyZXMgPT4gY2IobnVsbCwgcmVzKSlcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9uby1jYWxsYmFjay1pbi1wcm9taXNlXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiBjYihlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgW3JlcXVlc3QsIGNiXSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgLy8gRGV0ZWN0cyBjYWxsIHRvIHNvbGFuYV9yZXF1ZXN0QWNjb3VudHMgaW4gcmVxdWVzdCAmIHNlbmRBc3luYyBhbmQgcGFzc2VzIHRvIGxvZ2luXG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInJlcXVlc3RcIik7XG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInNlbmRBc3luY1wiKTtcbiAgICBkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyKFwic2VuZFwiKTtcbiAgICBjb25zdCBwcm94aWVkSW5QYWdlUHJvdmlkZXIgPSBuZXcgUHJveHkoaW5QYWdlUHJvdmlkZXIsIHtcbiAgICAgIC8vIHN0cmFpZ2h0IHVwIGxpZSB0aGF0IHdlIGRlbGV0ZWQgdGhlIHByb3BlcnR5IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaW4gc3RyaWN0IG1vZGVcbiAgICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZENvbW11bmljYXRpb25Qcm92aWRlciA9IG5ldyBQcm94eShjb21tdW5pY2F0aW9uUHJvdmlkZXIsIHtcbiAgICAgIC8vIHN0cmFpZ2h0IHVwIGxpZSB0aGF0IHdlIGRlbGV0ZWQgdGhlIHByb3BlcnR5IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaW4gc3RyaWN0IG1vZGVcbiAgICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3hpZWRJblBhZ2VQcm92aWRlcjtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlciA9IHByb3hpZWRDb21tdW5pY2F0aW9uUHJvdmlkZXI7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW2luUGFnZVByb3ZpZGVyLl9pbml0aWFsaXplU3RhdGUoKSwgY29tbXVuaWNhdGlvblByb3ZpZGVyLl9pbml0aWFsaXplU3RhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm92aWRlclBhcmFtcyksIHt9LCB7XG4gICAgICBkYXBwU3RvcmFnZUtleTogdGhpcy5kYXBwU3RvcmFnZUtleSxcbiAgICAgIHRvcnVzQWxlcnRDb250YWluZXI6IHRoaXMudG9ydXNBbGVydENvbnRhaW5lcixcbiAgICAgIHRvcnVzSWZyYW1lOiB0aGlzLnRvcnVzSWZyYW1lXG4gICAgfSkpXSk7XG4gICAgbG9nLmRlYnVnKFwiVG9ydXMgLSBpbmplY3RlZCBwcm92aWRlclwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCVVRUT05fUE9TSVRJT04sIExPR0lOX1BST1ZJREVSLCBQQVlNRU5UX1BST1ZJREVSLCBUT1JVU19CVUlMRF9FTlYsIFRvcnVzSW5QYWdlUHJvdmlkZXIsIFRvcnVzIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvbGFuYUVtYmVkLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJQdWJsaWNLZXkiLCJjcmVhdGVMb2dnZXJNaWRkbGV3YXJlIiwiQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMiLCJDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMiLCJQUk9WSURFUl9KUlBDX01FVEhPRFMiLCJQUk9WSURFUl9OT1RJRklDQVRJT05TIiwic2V0QVBJS2V5IiwiU2FmZUV2ZW50RW1pdHRlciIsIk9iamVjdE11bHRpcGxleCIsImNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUiLCJKUlBDRW5naW5lIiwiY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUiLCJnZXRScGNQcm9taXNlQ2FsbGJhY2siLCJCYXNlUG9zdE1lc3NhZ2VTdHJlYW0iLCJldGhFcnJvcnMiLCJFdGhlcmV1bVJwY0Vycm9yIiwiZHVwbGV4IiwicHVtcCIsImxvZ2xldmVsIiwiZGVxdWFsIiwidmVyc2lvbiIsIm1lc3NhZ2VzIiwiZXJyb3JzIiwiZGlzY29ubmVjdGVkIiwicGVybWFuZW50bHlEaXNjb25uZWN0ZWQiLCJ1bnN1cHBvcnRlZFN5bmMiLCJtZXRob2QiLCJpbnZhbGlkRHVwbGV4U3RyZWFtIiwiaW52YWxpZE9wdGlvbnMiLCJtYXhFdmVudExpc3RlbmVycyIsImludmFsaWRSZXF1ZXN0QXJncyIsImludmFsaWRSZXF1ZXN0TWV0aG9kIiwiaW52YWxpZFJlcXVlc3RQYXJhbXMiLCJpbnZhbGlkTG9nZ2VyT2JqZWN0IiwiaW52YWxpZExvZ2dlck1ldGhvZCIsImluZm8iLCJjb25uZWN0ZWQiLCJjaGFpbklkIiwid2FybmluZ3MiLCJQQVlNRU5UX1BST1ZJREVSIiwiTU9PTlBBWSIsIldZUkUiLCJSQU1QTkVUV09SSyIsIlhBTlBPT0wiLCJNRVJDVVJZTyIsIlRSQU5TQUsiLCJUT1JVU19CVUlMRF9FTlYiLCJQUk9EVUNUSU9OIiwiREVWRUxPUE1FTlQiLCJURVNUSU5HIiwiQlVUVE9OX1BPU0lUSU9OIiwiQk9UVE9NX0xFRlQiLCJUT1BfTEVGVCIsIkJPVFRPTV9SSUdIVCIsIlRPUF9SSUdIVCIsIkxPR0lOX1BST1ZJREVSIiwiR09PR0xFIiwiRkFDRUJPT0siLCJSRURESVQiLCJESVNDT1JEIiwiVFdJVENIIiwiQVBQTEUiLCJMSU5FIiwiR0lUSFVCIiwiS0FLQU8iLCJMSU5LRURJTiIsIlRXSVRURVIiLCJXRUlCTyIsIldFQ0hBVCIsIkVNQUlMX1BBU1NXT1JETEVTUyIsInRyYW5zbGF0aW9ucyIsImVuIiwiZW1iZWQiLCJjb250aW51ZSIsImFjdGlvblJlcXVpcmVkIiwicGVuZGluZ0FjdGlvbiIsImNvb2tpZXNSZXF1aXJlZCIsImVuYWJsZUNvb2tpZXMiLCJjbGlja0hlcmUiLCJkZSIsImphIiwia28iLCJ6aCIsImNvbmZpZ3VyYXRpb24iLCJzdXBwb3J0ZWRWZXJpZmllckxpc3QiLCJhcGkiLCJwcm9kVG9ydXNVcmwiLCJsb2NhbFN0b3JhZ2VLZXlQcmVmaXgiLCJsb2ciLCJnZXRMb2dnZXIiLCJjcmVhdGVFcnJvck1pZGRsZXdhcmUiLCJyZXEiLCJyZXMiLCJuZXh0IiwiZXJyb3IiLCJycGMiLCJpbnZhbGlkUmVxdWVzdCIsIm1lc3NhZ2UiLCJkYXRhIiwiZG9uZSIsImxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nIiwicmVtb3RlTGFiZWwiLCJlbWl0dGVyIiwid2FybmluZ01zZyIsInN0YWNrIiwid2FybiIsImxpc3RlbmVyQ291bnQiLCJlbWl0IiwiZ2V0V2luZG93SWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImdldFRvcnVzVXJsIiwiYnVpbGRFbnYiLCJ0b3J1c1VybCIsImxvZ0xldmVsIiwiZ2V0VXNlckxhbmd1YWdlIiwidXNlckxhbmd1YWdlIiwid2luZG93IiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJ1c2VyTGFuZ3VhZ2VzIiwic3BsaXQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XIiwiaGVpZ2h0Iiwid2lkdGgiLCJGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1ciLCJGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyIsIkZFQVRVUkVTX0NPTkZJUk1fV0lORE9XIiwic3RvcmFnZUF2YWlsYWJsZSIsInR5cGUiLCJzdG9yYWdlIiwieCIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZSIsImNvZGUiLCJuYW1lIiwibGVuZ3RoIiwiZ2V0UG9wdXBGZWF0dXJlcyIsIl9yZWYiLCJ3IiwiaCIsImR1YWxTY3JlZW5MZWZ0Iiwic2NyZWVuTGVmdCIsInVuZGVmaW5lZCIsInNjcmVlblgiLCJkdWFsU2NyZWVuVG9wIiwic2NyZWVuVG9wIiwic2NyZWVuWSIsImlubmVyV2lkdGgiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwic2NyZWVuIiwiaW5uZXJIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzeXN0ZW1ab29tIiwibGVmdCIsImFicyIsInRvcCIsImZlYXR1cmVzIiwiQmFzZVByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uU3RyZWFtIiwianNvblJwY1N0cmVhbU5hbWUiLCJFcnJvciIsImlzVG9ydXMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJfaGFuZGxlQ29ubmVjdCIsImJpbmQiLCJfaGFuZGxlRGlzY29ubmVjdCIsIl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0IiwiX3JwY1JlcXVlc3QiLCJfaW5pdGlhbGl6ZVN0YXRlIiwicmVxdWVzdCIsInNlbmRBc3luYyIsIm11eCIsImlnbm9yZVN0cmVhbSIsImpzb25ScGNDb25uZWN0aW9uIiwic3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwicnBjRW5naW5lIiwicHVzaCIsIm9yaWdpbiIsImxvY2F0aW9uIiwibWlkZGxld2FyZSIsIl9ycGNFbmdpbmUiLCJqc29uUnBjQ29ubmVjdGlvbkV2ZW50cyIsImV2ZW50cyIsImFyZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJhbXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNlbmQiLCJwYXlsb2FkIiwiY2FsbGJhY2siLCJzdHJlYW1OYW1lIiwiaGFuZGxlRXZlbnQiLCJoYW5kbGUiLCJldmVudE5hbWUiLCJoYW5kbGVyIiwiX2xlbiIsImFyZ3VtZW50cyIsImhhbmRsZXJBcmdzIiwiX2tleSIsImhhbmRsZXJXcmFwcGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJkb2N1bWVudFJlYWR5IiwicmVhZHlTdGF0ZSIsImh0bWxUb0VsZW1lbnQiLCJodG1sIiwidGVtcGxhdGUiLCJjcmVhdGVFbGVtZW50IiwidHJpbW1lZEh0bWwiLCJ0cmltIiwiaW5uZXJIVE1MIiwiY29udGVudCIsImZpcnN0Q2hpbGQiLCJpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UiLCJ0cmFuc2FjdGlvbiIsIlBvcHVwSGFuZGxlciIsInVybCIsInRhcmdldCIsIndpbmRvd1RpbWVyIiwiaUNsb3NlZFdpbmRvdyIsIl9zZXR1cFRpbWVyIiwiTnVtYmVyIiwic2V0SW50ZXJ2YWwiLCJjbG9zZWQiLCJjbGVhckludGVydmFsIiwib3BlbiIsImhyZWYiLCJmb2N1cyIsImNsb3NlIiwicmVkaXJlY3QiLCJsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0IiwicmVwbGFjZSIsIm93bktleXMkMiIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkJDIiLCJpIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlciIsIl9zdGF0ZSIsIl9kZWZhdWx0U3RhdGUiLCJkYXBwU3RvcmFnZUtleSIsImxhbmd1YWdlVHJhbnNsYXRpb25zIiwiZW1iZWRUcmFuc2xhdGlvbnMiLCJ3aW5kb3dSZWZzIiwib24iLCJpc0Nvbm5lY3RlZCIsIm5vdGlmaWNhdGlvbkhhbmRsZXIiLCJJRlJBTUVfU1RBVFVTIiwiaXNGdWxsU2NyZWVuIiwicmlkIiwiX2Rpc3BsYXlJZnJhbWUiLCJpc0Z1bGwiLCJDUkVBVEVfV0lORE9XIiwid2luZG93SWQiLCJfY3JlYXRlUG9wdXBCbG9ja0FsZXJ0IiwiQ0xPU0VfV0lORE9XIiwiX2hhbmRsZUNsb3NlV2luZG93IiwiVVNFUl9MT0dHRURfSU4iLCJjdXJyZW50TG9naW5Qcm92aWRlciIsImlzTG9nZ2VkSW4iLCJVU0VSX0xPR0dFRF9PVVQiLCJpc0lGcmFtZUZ1bGxTY3JlZW4iLCJ0b3J1c0FsZXJ0Q29udGFpbmVyIiwidG9ydXNJZnJhbWUiLCJHRVRfUFJPVklERVJfU1RBVEUiLCJpbml0aWFsaXplZCIsIl9oYW5kbGVXaW5kb3ciLCJmaW5hbFVybCIsIlVSTCIsImhhc2giLCJoYW5kbGVkV2luZG93IiwiT1BFTkVEX1dJTkRPVyIsIm9uY2UiLCJDTE9TRURfV0lORE9XIiwic3R5bGUiLCJkaXNwbGF5IiwidG9ydXNXaWRnZXRWaXNpYmlsaXR5IiwiYnV0dG9uUG9zaXRpb24iLCJyaWdodCIsImJvdHRvbSIsImFzc2lnbiIsImhpZGVUb3J1c0J1dHRvbiIsInNob3dUb3J1c0J1dHRvbiIsImNiIiwiX3BheWxvYWQiLCJqc29ucnBjIiwidHJ5V2luZG93SGFuZGxlIiwiZGVidWciLCJpc1JlY292ZXJhYmxlIiwiZXJyb3JNZXNzYWdlIiwiaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCIsImxvZ29VcmwiLCJnZXRMb2dvVXJsIiwidG9ydXNBbGVydCIsInN1Y2Nlc3NBbGVydCIsImJ0bkNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwiYmluZE9uTG9hZCIsInJlbW92ZSIsImNoaWxkcmVuIiwiYXR0YWNoT25Mb2FkIiwiaGFzRW1pdHRlZENvbm5lY3Rpb24iLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJUb3J1c0luUGFnZVByb3ZpZGVyIiwic2VsZWN0ZWRBZGRyZXNzIiwiX2hhbmRsZUFjY291bnRzQ2hhbmdlZCIsIl9oYW5kbGVDaGFpbkNoYW5nZWQiLCJfaGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkIiwianNvblJwY05vdGlmaWNhdGlvbkhhbmRsZXIiLCJBQ0NPVU5UU19DSEFOR0VEIiwiVU5MT0NLX1NUQVRFX0NIQU5HRUQiLCJDSEFJTl9DSEFOR0VEIiwiYWNjb3VudHMiLCJpc1VubG9ja2VkIiwiaXNJbnRlcm5hbCIsImVyciIsInJlc3VsdCIsImlzRXRoQWNjb3VudHMiLCJmaW5hbEFjY291bnRzIiwiYWNjb3VudCIsImltZ0V4aXN0cyIsImltZyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJnZXRTaXRlTmFtZSIsInNpdGVOYW1lIiwicXVlcnlTZWxlY3RvciIsIm1ldGFUaXRsZSIsInRpdGxlIiwiaG9zdG5hbWUiLCJnZXRTaXRlSWNvbiIsImljb24iLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbmQiLCJfaWNvbiIsIkJvb2xlYW4iLCJnZXRTaXRlTWV0YWRhdGEiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsIlBST1ZJREVSX1VOU0FGRV9NRVRIT0RTIiwiQ09NTVVOSUNBVElPTl9VTlNBRkVfTUVUSE9EUyIsIlNFVF9QUk9WSURFUiIsImlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwicHJlTG9hZElmcmFtZSIsInRvcnVzSWZyYW1lSHRtbCIsImNyb3NzT3JpZ2luIiwicmVsIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiaGVhZCIsIlRvcnVzIiwibW9kYWxaSW5kZXgiLCJpc0luaXRpYWxpemVkIiwicmVxdWVzdGVkTG9naW5Qcm92aWRlciIsImFsZXJ0WkluZGV4IiwiY29tbXVuaWNhdGlvblByb3ZpZGVyIiwiaW5pdCIsImVuYWJsZUxvZ2dpbmciLCJuZXR3b3JrIiwidXNlTG9jYWxTdG9yYWdlIiwiYXBpS2V5IiwiZXh0cmFQYXJhbXMiLCJ3aGl0ZUxhYmVsIiwiZW5hYmxlQWxsIiwic2V0RGVmYXVsdExldmVsIiwiZGlzYWJsZUFsbCIsImhhbmRsZURhcHBTdG9yYWdlS2V5IiwidG9ydXNJZnJhbWVVcmwiLCJwYXRobmFtZSIsImVuZHNXaXRoIiwiaGFzaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInN0eWxlTGluayIsImhhbmRsZVNldHVwIiwiYm9keSIsImRhcHBNZXRhZGF0YSIsImNvbnRlbnRXaW5kb3ciLCJwb3N0TWVzc2FnZSIsIl9zZXR1cFdlYjMiLCJ0b3B1cEhpZGUiLCJpc1RvcHVwSGlkZGVuIiwidG9ydXMiLCJsb2dpbiIsImxvZ2luUHJvdmlkZXIiLCJwcm92aWRlciIsImxvZ2luX2hpbnQiLCJsb2dpbldpdGhQcml2YXRlS2V5IiwibG9naW5QYXJhbXMiLCJwcml2YXRlS2V5IiwidXNlckluZm8iLCJzdWNjZXNzIiwibG9nb3V0IiwiTE9HT1VUIiwiY2xlYW5VcCIsImNsZWFySW5pdCIsImlzRWxlbWVudCIsImVsZW1lbnQiLCJFbGVtZW50IiwiRG9jdW1lbnQiLCJjb250YWlucyIsInNldFByb3ZpZGVyIiwic2hvd1dhbGxldCIsInBhdGgiLCJpbnN0YW5jZUlkIiwiV0FMTEVUX0lOU1RBTkNFX0lEIiwiZmluYWxQYXRoIiwic2VhcmNoUGFyYW1zIiwid2FsbGV0V2luZG93IiwiZ2V0VXNlckluZm8iLCJ1c2VySW5mb1Jlc3BvbnNlIiwiVVNFUl9JTkZPIiwiaW5pdGlhdGVUb3B1cCIsInRvcHVwUmVzcG9uc2UiLCJUT1BVUCIsImdldEFjY291bnRzIiwicmVzcG9uc2UiLCJzZW5kVHJhbnNhY3Rpb24iLCJpc0xlZ2FjeVRyYW5zYWN0aW9uIiwic2VyaWFsaXplIiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJCdWZmZXIiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwib3B0aW9ucyIsInNpZ25hdHVyZSIsInNpZ25UcmFuc2FjdGlvbiIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJtZXNzYWdlT25seSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsInB1YmxpY0tleSIsImFkZFNpZ25hdHVyZSIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJlbmNvZGVkTWVzc2FnZSIsIm1hcCIsInR4IiwicmVzcG9uc2VzIiwic2lnbmF0dXJlcyIsIml0ZW0iLCJpZHgiLCJzaWduTWVzc2FnZSIsImdldEdhc2xlc3NQdWJsaWNLZXkiLCJsb2NhbFN0b3JhZ2VLZXkiLCJzdG9yZWRLZXkiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZ2VuZXJhdGVkS2V5IiwicHJvdmlkZXJQYXJhbXMiLCJwcm92aWRlclN0cmVhbSIsInRhcmdldFdpbmRvdyIsImNvbW11bmljYXRpb25TdHJlYW0iLCJpblBhZ2VQcm92aWRlciIsImluY2x1ZGVzIiwiZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllciIsIm0iLCJvcmlnaW5hbE1ldGhvZCIsInNlbGYiLCJwcm92aWRlckZ1bmMiLCJ0aGVuIiwiY2F0Y2giLCJwcm94aWVkSW5QYWdlUHJvdmlkZXIiLCJQcm94eSIsImRlbGV0ZVByb3BlcnR5IiwicHJveGllZENvbW11bmljYXRpb25Qcm92aWRlciIsImFsbCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@solana/web3.js/lib/index.esm.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@toruslabs/solana-embed/node_modules/@solana/web3.js/lib/index.esm.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/../node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/../node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bigint-buffer */ \"(ssr)/../node_modules/bigint-buffer/dist/node.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! superstruct */ \"(ssr)/../node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/../node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node-fetch */ \"(ssr)/../node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rpc-websockets */ \"(ssr)/../node_modules/rpc-websockets/dist/index.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/../node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_12__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_13__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_13__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nconst encodeDecode = (layout)=>{\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return {\n        decode,\n        encode\n    };\n};\nconst bigInt = (length)=>(property)=>{\n        const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(length, property);\n        const { encode, decode } = encodeDecode(layout);\n        const bigIntLayout = layout;\n        bigIntLayout.decode = (buffer, offset)=>{\n            const src = decode(buffer, offset);\n            return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBigIntLE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));\n        };\n        bigIntLayout.encode = (bigInt, buffer, offset)=>{\n            const src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n        return bigIntLayout;\n    };\nconst u64 = bigInt(8);\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (params.basePubkey != params.fromPubkey) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ var ms$2 = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n            return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n    }\n    return ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ /**\n * Module dependencies.\n */ var util = (util__WEBPACK_IMPORTED_MODULE_6___default());\nvar ms$1 = ms$2;\nvar humanizeMs = function(t) {\n    if (typeof t === \"number\") return t;\n    var r = ms$1(t);\n    if (r === undefined) {\n        var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n        console.warn(err.stack);\n    }\n    return r;\n};\nvar constants = {\n    // agent\n    CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n    CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n    INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n    CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n    // socket\n    SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n    SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n    SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n    SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n};\nconst OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_7___default().Agent);\nconst ms = humanizeMs;\nconst debug = util__WEBPACK_IMPORTED_MODULE_6___default().debuglog(\"agentkeepalive\");\nconst { INIT_SOCKET: INIT_SOCKET$1, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = constants;\n// OriginalAgent come from\n// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n// node <= 10\nlet defaultTimeoutListenerCount = 1;\nconst majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\nif (majorVersion >= 11 && majorVersion <= 12) {\n    defaultTimeoutListenerCount = 2;\n} else if (majorVersion >= 13) {\n    defaultTimeoutListenerCount = 3;\n}\nfunction deprecate(message) {\n    console.log(\"[agentkeepalive:deprecated] %s\", message);\n}\nclass Agent extends OriginalAgent {\n    constructor(options){\n        options = options || {};\n        options.keepAlive = options.keepAlive !== false;\n        // default is keep-alive and 4s free socket timeout\n        // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n        if (options.freeSocketTimeout === undefined) {\n            options.freeSocketTimeout = 4000;\n        }\n        // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.keepAliveTimeout) {\n            deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.keepAliveTimeout;\n            delete options.keepAliveTimeout;\n        }\n        // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.freeSocketKeepAliveTimeout) {\n            deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n            delete options.freeSocketKeepAliveTimeout;\n        }\n        // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n        // By default is double free socket timeout.\n        if (options.timeout === undefined) {\n            // make sure socket default inactivity timeout >= 8s\n            options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n        }\n        // support humanize format\n        options.timeout = ms(options.timeout);\n        options.freeSocketTimeout = ms(options.freeSocketTimeout);\n        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n        super(options);\n        this[CURRENT_ID] = 0;\n        // create socket success counter\n        this.createSocketCount = 0;\n        this.createSocketCountLastCheck = 0;\n        this.createSocketErrorCount = 0;\n        this.createSocketErrorCountLastCheck = 0;\n        this.closeSocketCount = 0;\n        this.closeSocketCountLastCheck = 0;\n        // socket error event count\n        this.errorSocketCount = 0;\n        this.errorSocketCountLastCheck = 0;\n        // request finished counter\n        this.requestCount = 0;\n        this.requestCountLastCheck = 0;\n        // including free socket timeout counter\n        this.timeoutSocketCount = 0;\n        this.timeoutSocketCountLastCheck = 0;\n        this.on(\"free\", (socket)=>{\n            // https://github.com/nodejs/node/pull/32000\n            // Node.js native agent will check socket timeout eqs agent.options.timeout.\n            // Use the ttl or freeSocketTimeout to overwrite.\n            const timeout = this.calcSocketTimeout(socket);\n            if (timeout > 0 && socket.timeout !== timeout) {\n                socket.setTimeout(timeout);\n            }\n        });\n    }\n    get freeSocketKeepAliveTimeout() {\n        deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n        return this.options.freeSocketTimeout;\n    }\n    get timeout() {\n        deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n        return this.options.timeout;\n    }\n    get socketActiveTTL() {\n        deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n        return this.options.socketActiveTTL;\n    }\n    calcSocketTimeout(socket) {\n        /**\n     * return <= 0: should free socket\n     * return > 0: should update socket timeout\n     * return undefined: not find custom timeout\n     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n        const socketActiveTTL = this.options.socketActiveTTL;\n        if (socketActiveTTL) {\n            // check socketActiveTTL\n            const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n            const diff = socketActiveTTL - aliveTime;\n            if (diff <= 0) {\n                return diff;\n            }\n            if (freeSocketTimeout && diff < freeSocketTimeout) {\n                freeSocketTimeout = diff;\n            }\n        }\n        // set freeSocketTimeout\n        if (freeSocketTimeout) {\n            // set free keepalive timer\n            // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n            // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n            const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n            return customFreeSocketTimeout || freeSocketTimeout;\n        }\n    }\n    keepSocketAlive(socket) {\n        const result = super.keepSocketAlive(socket);\n        // should not keepAlive, do nothing\n        if (!result) return result;\n        const customTimeout = this.calcSocketTimeout(socket);\n        if (typeof customTimeout === \"undefined\") {\n            return true;\n        }\n        if (customTimeout <= 0) {\n            debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n            return false;\n        }\n        if (socket.timeout !== customTimeout) {\n            socket.setTimeout(customTimeout);\n        }\n        return true;\n    }\n    // only call on addRequest\n    reuseSocket(...args) {\n        // reuseSocket(socket, req)\n        super.reuseSocket(...args);\n        const socket = args[0];\n        const req = args[1];\n        req.reusedSocket = true;\n        const agentTimeout = this.options.timeout;\n        if (getSocketTimeout(socket) !== agentTimeout) {\n            // reset timeout before use\n            socket.setTimeout(agentTimeout);\n            debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n        }\n        socket[SOCKET_REQUEST_COUNT]++;\n        debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n    }\n    [CREATE_ID]() {\n        const id = this[CURRENT_ID]++;\n        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n        return id;\n    }\n    [INIT_SOCKET$1](socket, options) {\n        // bugfix here.\n        // https on node 8, 10 won't set agent.options.timeout by default\n        // TODO: need to fix on node itself\n        if (options.timeout) {\n            const timeout = getSocketTimeout(socket);\n            if (!timeout) {\n                socket.setTimeout(options.timeout);\n            }\n        }\n        if (this.options.keepAlive) {\n            // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n            // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n            socket.setNoDelay(true);\n        }\n        this.createSocketCount++;\n        if (this.options.socketActiveTTL) {\n            socket[SOCKET_CREATED_TIME] = Date.now();\n        }\n        // don't show the hole '-----BEGIN CERTIFICATE----' key string\n        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n        socket[SOCKET_REQUEST_COUNT] = 1;\n        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n        installListeners(this, socket, options);\n    }\n    createConnection(options, oncreate) {\n        let called = false;\n        const onNewCreate = (err, socket)=>{\n            if (called) return;\n            called = true;\n            if (err) {\n                this.createSocketErrorCount++;\n                return oncreate(err);\n            }\n            this[INIT_SOCKET$1](socket, options);\n            oncreate(err, socket);\n        };\n        const newSocket = super.createConnection(options, onNewCreate);\n        if (newSocket) onNewCreate(null, newSocket);\n        return newSocket;\n    }\n    get statusChanged() {\n        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n        if (changed) {\n            this.createSocketCountLastCheck = this.createSocketCount;\n            this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n            this.closeSocketCountLastCheck = this.closeSocketCount;\n            this.errorSocketCountLastCheck = this.errorSocketCount;\n            this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n            this.requestCountLastCheck = this.requestCount;\n        }\n        return changed;\n    }\n    getCurrentStatus() {\n        return {\n            createSocketCount: this.createSocketCount,\n            createSocketErrorCount: this.createSocketErrorCount,\n            closeSocketCount: this.closeSocketCount,\n            errorSocketCount: this.errorSocketCount,\n            timeoutSocketCount: this.timeoutSocketCount,\n            requestCount: this.requestCount,\n            freeSockets: inspect(this.freeSockets),\n            sockets: inspect(this.sockets),\n            requests: inspect(this.requests)\n        };\n    }\n}\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n    return socket.timeout || socket._idleTimeout;\n}\nfunction installListeners(agent, socket, options) {\n    debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n    // listener socket events: close, timeout, error, free\n    function onFree() {\n        // create and socket.emit('free') logic\n        // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n        // no req on the socket, it should be the new socket\n        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n        socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n        agent.requestCount++;\n        debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // should reuse on pedding requests?\n        const name = agent.getName(options);\n        if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n            // will be reuse on agent free listener\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        }\n    }\n    socket.on(\"free\", onFree);\n    function onClose(isError) {\n        debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n        agent.closeSocketCount++;\n    }\n    socket.on(\"close\", onClose);\n    // start socket timeout handler\n    function onTimeout() {\n        // onTimeout and emitRequestTimeout(_http_client.js)\n        // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n        const listenerCount = socket.listeners(\"timeout\").length;\n        // node <= 10, default listenerCount is 1, onTimeout\n        // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n        // node >= 13, default listenerCount is 3, onTimeout,\n        //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n        //   and emitRequestTimeout\n        const timeout = getSocketTimeout(socket);\n        const req = socket._httpMessage;\n        const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n        debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n        if (debug.enabled) {\n            debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n        }\n        agent.timeoutSocketCount++;\n        const name = agent.getName(options);\n        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n            // free socket timeout, destroy quietly\n            socket.destroy();\n            // Remove it from freeSockets list immediately to prevent new requests\n            // from being sent through this socket.\n            agent.removeSocket(socket, options);\n            debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n        } else {\n            // if there is no any request socket timeout handler,\n            // agent need to handle socket timeout itself.\n            //\n            // custom request socket timeout handle logic must follow these rules:\n            //  1. Destroy socket first\n            //  2. Must emit socket 'agentRemove' event tell agent remove socket\n            //     from freeSockets list immediately.\n            //     Otherise you may be get 'socket hang up' error when reuse\n            //     free socket and timeout happen in the same time.\n            if (reqTimeoutListenerCount === 0) {\n                const error = new Error(\"Socket timeout\");\n                error.code = \"ERR_SOCKET_TIMEOUT\";\n                error.timeout = timeout;\n                // must manually call socket.end() or socket.destroy() to end the connection.\n                // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                socket.destroy(error);\n                agent.removeSocket(socket, options);\n                debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n            }\n        }\n    }\n    socket.on(\"timeout\", onTimeout);\n    function onError(err) {\n        const listenerCount = socket.listeners(\"error\").length;\n        debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n        agent.errorSocketCount++;\n        if (listenerCount === 1) {\n            // if socket don't contain error event handler, don't catch it, emit it again\n            debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n            socket.removeListener(\"error\", onError);\n            socket.emit(\"error\", err);\n        }\n    }\n    socket.on(\"error\", onError);\n    function onRemove() {\n        debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // We need this function for cases like HTTP 'upgrade'\n        // (defined by WebSockets) where we need to remove a socket from the\n        // pool because it'll be locked up indefinitely\n        socket.removeListener(\"close\", onClose);\n        socket.removeListener(\"error\", onError);\n        socket.removeListener(\"free\", onFree);\n        socket.removeListener(\"timeout\", onTimeout);\n        socket.removeListener(\"agentRemove\", onRemove);\n    }\n    socket.on(\"agentRemove\", onRemove);\n}\nvar agent = Agent;\nfunction inspect(obj) {\n    const res = {};\n    for(const key in obj){\n        res[key] = obj[key].length;\n    }\n    return res;\n}\nconst OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_8___default().Agent);\nconst HttpAgent = agent;\nconst { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = constants;\nlet HttpsAgent$1 = class HttpsAgent extends HttpAgent {\n    constructor(options){\n        super(options);\n        this.defaultPort = 443;\n        this.protocol = \"https:\";\n        this.maxCachedSessions = this.options.maxCachedSessions;\n        /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n            this.maxCachedSessions = 100;\n        }\n        this._sessionCache = {\n            map: {},\n            list: []\n        };\n    }\n    createConnection(options, oncreate) {\n        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n        this[INIT_SOCKET](socket, options);\n        return socket;\n    }\n};\n// https://github.com/nodejs/node/blob/master/lib/https.js#L89\nHttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n[\n    \"getName\",\n    \"_getSession\",\n    \"_cacheSession\",\n    // https://github.com/nodejs/node/pull/4982\n    \"_evictSession\"\n].forEach(function(method) {\n    /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n        HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];\n    }\n});\nvar https_agent = HttpsAgent$1;\nagentkeepalive.exports = agent;\nvar HttpsAgent = agentkeepalive.exports.HttpsAgent = https_agent;\nagentkeepalive.exports.constants = constants;\nvar agentkeepaliveExports = agentkeepalive.exports;\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var name in obj){\n        keys.push(name);\n    }\n    return keys;\n};\nfunction stringify(val, isArrayProp) {\n    var i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return \"true\";\n    }\n    if (val === false) {\n        return \"false\";\n    }\n    switch(typeof val){\n        case \"object\":\n            if (val === null) {\n                return null;\n            } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === \"[object Array]\") {\n                    str = \"[\";\n                    max = val.length - 1;\n                    for(i = 0; i < max; i++){\n                        str += stringify(val[i], true) + \",\";\n                    }\n                    if (max > -1) {\n                        str += stringify(val[i], true);\n                    }\n                    return str + \"]\";\n                } else if (toStr === \"[object Object]\") {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = \"\";\n                    i = 0;\n                    while(i < max){\n                        key = keys[i];\n                        propVal = stringify(val[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += \",\";\n                            }\n                            str += JSON.stringify(key) + \":\" + propVal;\n                        }\n                        i++;\n                    }\n                    return \"{\" + str + \"}\";\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case \"function\":\n        case \"undefined\":\n            return isArrayProp ? null : undefined;\n        case \"string\":\n            return JSON.stringify(val);\n        default:\n            return isFinite(val) ? val : null;\n    }\n}\nvar fastStableStringify = function(val) {\n    var returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        return \"\" + returnVal;\n    }\n};\nvar fastStableStringify$1 = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringify);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_10__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets__WEBPACK_IMPORTED_MODULE_11__.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = (0,rpc_websockets__WEBPACK_IMPORTED_MODULE_11__.WebSocket)(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n        ])\n    })))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */ const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"0.0.0-development\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify$1(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", configWithoutEncoding);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getRecentBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getConfirmedTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            if (e instanceof Error) {\n                                console.error(`${method} error for argument`, args, e.message);\n                            }\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify$1([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @return subscription id\n   */ onAccountChange(publicKey, callback, commitment) {\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\");\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @param filters The program account filters to pass into the RPC method\n   * @return subscription id\n   */ onProgramAccountChange(programId, callback, commitment, filters) {\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , filters ? {\n            filters: filters\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(BigInt(params.recentSlot), 8)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNnQjtBQUN6QjtBQUNDO0FBQ3NCO0FBQ3VCO0FBQ2Y7QUFDVDtBQUNVO0FBQ3pCO0FBQ0U7QUFDdUI7QUFDMkg7QUFDaEk7QUFDVjtBQUNpQjtBQUNUO0FBQ0k7QUFFcEQ7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRUQsTUFBTXlDLHFCQUFxQnhDLDJEQUFPQSxDQUFDeUMsS0FBSyxDQUFDQyxnQkFBZ0I7QUFDekQsTUFBTUMsa0JBQWtCO0lBQ3RCLE1BQU1DLGdCQUFnQjVDLDJEQUFPQSxDQUFDeUMsS0FBSyxDQUFDQyxnQkFBZ0I7SUFDcEQsTUFBTUcsWUFBWUMsYUFBYUY7SUFDL0IsTUFBTUcsWUFBWSxJQUFJQyxXQUFXO0lBQ2pDRCxVQUFVRSxHQUFHLENBQUNMO0lBQ2RHLFVBQVVFLEdBQUcsQ0FBQ0osV0FBVztJQUN6QixPQUFPO1FBQ0xBO1FBQ0FFO0lBQ0Y7QUFDRjtBQUNBLE1BQU1ELGVBQWU5QywyREFBT0EsQ0FBQzhDLFlBQVk7QUFDekMsU0FBU0ksVUFBVUwsU0FBUztJQUMxQixJQUFJO1FBQ0Y3QywyREFBT0EsQ0FBQ21ELGFBQWEsQ0FBQ0MsT0FBTyxDQUFDUDtRQUM5QixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFDQSxNQUFNUSxPQUFPLENBQUNDLFNBQVNQLFlBQWMvQywyREFBT0EsQ0FBQ3FELElBQUksQ0FBQ0MsU0FBU1AsVUFBVVEsS0FBSyxDQUFDLEdBQUc7QUFDOUUsTUFBTUMsU0FBU3hELDJEQUFPQSxDQUFDd0QsTUFB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LFNBQVMsRUFBRTlGLEtBQUtDLFNBQVMsQ0FBQzBJLFFBQVEsQ0FBQyxDQUFDO1lBQzNEO1FBQ0Y7UUFDQSxNQUFNLElBQUl0YSxNQUFNLENBQUMsZ0JBQWdCLEVBQUU0RCxVQUFVLFNBQVMsRUFBRStOLEtBQUtDLFNBQVMsQ0FBQzBJLFFBQVEsQ0FBQyxDQUFDO0lBQ25GO0lBQ0EsT0FBTzFXO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELE1BQU1xMUMsbUJBQW1CO0FBRTZnRCxDQUN0aUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL3NvbGFuYS1lbWJlZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanM/YTI2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBkZXNlcmlhbGl6ZVVuY2hlY2tlZCB9IGZyb20gJ2JvcnNoJztcbmltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgYmxvYiB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyB0b0JpZ0ludExFLCB0b0J1ZmZlckxFIH0gZnJvbSAnYmlnaW50LWJ1ZmZlcic7XG5pbXBvcnQgcmVxdWlyZSQkMCBmcm9tICd1dGlsJztcbmltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSAnaHR0cCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQyLCB7IEFnZW50IGFzIEFnZW50JDEgfSBmcm9tICdodHRwcyc7XG5pbXBvcnQgeyBjb2VyY2UsIGluc3RhbmNlLCBzdHJpbmcsIHR1cGxlLCBsaXRlcmFsLCB1bmtub3duLCB0eXBlLCBudW1iZXIsIGFycmF5LCBudWxsYWJsZSwgb3B0aW9uYWwsIGJvb2xlYW4sIHJlY29yZCwgdW5pb24sIGNyZWF0ZSwgYW55LCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdzdXBlcnN0cnVjdCc7XG5pbXBvcnQgUnBjQ2xpZW50IGZyb20gJ2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXInO1xuaW1wb3J0ICogYXMgbm9kZUZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IHsgQ29tbW9uQ2xpZW50LCBXZWJTb2NrZXQgfSBmcm9tICdycGMtd2Vic29ja2V0cyc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcblxuLyoqXG4gKiBBIDY0IGJ5dGUgc2VjcmV0IGtleSwgdGhlIGZpcnN0IDMyIGJ5dGVzIG9mIHdoaWNoIGlzIHRoZVxuICogcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICovXG5cbi8qKlxuICogRWQyNTUxOSBLZXlwYWlyXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuY29uc3QgZ2VuZXJhdGVLZXlwYWlyID0gKCkgPT4ge1xuICBjb25zdCBwcml2YXRlU2NhbGFyID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICBzZWNyZXRLZXkuc2V0KHByaXZhdGVTY2FsYXIpO1xuICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleSxcbiAgICBzZWNyZXRLZXlcbiAgfTtcbn07XG5jb25zdCBnZXRQdWJsaWNLZXkgPSBlZDI1NTE5LmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzT25DdXJ2ZShwdWJsaWNLZXkpIHtcbiAgdHJ5IHtcbiAgICBlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNpZ24gPSAobWVzc2FnZSwgc2VjcmV0S2V5KSA9PiBlZDI1NTE5LnNpZ24obWVzc2FnZSwgc2VjcmV0S2V5LnNsaWNlKDAsIDMyKSk7XG5jb25zdCB2ZXJpZnkgPSBlZDI1NTE5LnZlcmlmeTtcblxuY29uc3QgdG9CdWZmZXIgPSBhcnIgPT4ge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbiAgfVxufTtcblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG4gIGVuY29kZSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZVVuY2hlY2tlZChkYXRhKSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplVW5jaGVja2VkKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyBhIFJ1c3QtY29tcGF0aWJsZSBlbnVtLCBzaW5jZSBlbnVtcyBhcmUgb25seSBzdHJpbmdzIG9yXG4vLyBudW1iZXJzIGluIHB1cmUgSlNcbmNsYXNzIEVudW0gZXh0ZW5kcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIocHJvcGVydGllcyk7XG4gICAgdGhpcy5lbnVtID0gJyc7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnVtIGNhbiBvbmx5IHRha2Ugc2luZ2xlIHZhbHVlJyk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLm1hcChrZXkgPT4ge1xuICAgICAgdGhpcy5lbnVtID0ga2V5O1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBTT0xBTkFfU0NIRU1BID0gbmV3IE1hcCgpO1xuXG52YXIgX1B1YmxpY0tleTtcblxuLyoqXG4gKiBNYXhpbXVtIGxlbmd0aCBvZiBkZXJpdmVkIHB1YmtleSBzZWVkXG4gKi9cbmNvbnN0IE1BWF9TRUVEX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFNpemUgb2YgcHVibGljIGtleSBpbiBieXRlc1xuICovXG5jb25zdCBQVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIFB1YmxpY0tleSBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIGlzUHVibGljS2V5RGF0YSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuX2JuICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGxvY2FsIGNvdW50ZXIgdXNlZCBieSBQdWJsaWNLZXkudW5pcXVlKClcbmxldCB1bmlxdWVQdWJsaWNLZXlDb3VudGVyID0gMTtcblxuLyoqXG4gKiBBIHB1YmxpYyBrZXlcbiAqL1xuY2xhc3MgUHVibGljS2V5IGV4dGVuZHMgU3RydWN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQdWJsaWNLZXkgb2JqZWN0XG4gICAqIEBwYXJhbSB2YWx1ZSBlZDI1NTE5IHB1YmxpYyBrZXkgYXMgYnVmZmVyIG9yIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibiA9IHZvaWQgMDtcbiAgICBpZiAoaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSkge1xuICAgICAgdGhpcy5fYm4gPSB2YWx1ZS5fYm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGFzc3VtZSBiYXNlIDU4IGVuY29kaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJzNTguZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTihkZWNvZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCkge1xuICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkodW5pcXVlUHVibGljS2V5Q291bnRlcik7XG4gICAgdW5pcXVlUHVibGljS2V5Q291bnRlciArPSAxO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGtleS50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHB1YmxpYyBrZXkgdmFsdWUuIFRoZSBiYXNlNTgtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYWxsIG9uZXMgKGFzIHNlZW4gYmVsb3cpXG4gICAqIFRoZSB1bmRlcmx5aW5nIEJOIG51bWJlciBpcyAzMiBieXRlcyB0aGF0IGFyZSBhbGwgemVyb3NcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYm4uZXEocHVibGljS2V5Ll9ibik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b0Jhc2U1OCgpIHtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUodGhpcy50b0J5dGVzKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J5dGVzKCkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBiID0gdGhpcy5fYm4udG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICBpZiAoYi5sZW5ndGggPT09IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgY29uc3QgemVyb1BhZCA9IEJ1ZmZlci5hbGxvYygzMik7XG4gICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgIHJldHVybiB6ZXJvUGFkO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gYFB1YmxpY0tleSgke3RoaXMudG9TdHJpbmcoKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChmcm9tUHVibGljS2V5LCBzZWVkLCBwcm9ncmFtSWQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtmcm9tUHVibGljS2V5LnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKHNlZWQpLCBwcm9ncmFtSWQudG9CdWZmZXIoKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHByb2dyYW0gYWRkcmVzcyBmcm9tIHNlZWRzIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgc2VlZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgaWYgKHNlZWQubGVuZ3RoID4gTUFYX1NFRURfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1heCBzZWVkIGxlbmd0aCBleGNlZWRlZGApO1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCB0b0J1ZmZlcihzZWVkKV0pO1xuICAgIH0pO1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgcHJvZ3JhbUlkLnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKCdQcm9ncmFtRGVyaXZlZEFkZHJlc3MnKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgaWYgKGlzT25DdXJ2ZShwdWJsaWNLZXlCeXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWVkcywgYWRkcmVzcyBtdXN0IGZhbGwgb2ZmIHRoZSBjdXJ2ZWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICpcbiAgICogVmFsaWQgcHJvZ3JhbSBhZGRyZXNzZXMgbXVzdCBmYWxsIG9mZiB0aGUgZWQyNTUxOSBjdXJ2ZS4gIFRoaXMgZnVuY3Rpb25cbiAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAqIHJlc3VsdHMgaW4gYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3MuXG4gICAqL1xuICBzdGF0aWMgZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IG5vbmNlID0gMjU1O1xuICAgIGxldCBhZGRyZXNzO1xuICAgIHdoaWxlIChub25jZSAhPSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWVkc1dpdGhOb25jZSA9IHNlZWRzLmNvbmNhdChCdWZmZXIuZnJvbShbbm9uY2VdKSk7XG4gICAgICAgIGFkZHJlc3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkc1dpdGhOb25jZSwgcHJvZ3JhbUlkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIG5vbmNlLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthZGRyZXNzLCBub25jZV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIG5vbmNlYCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhhdCBhIHB1YmtleSBpcyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZS5cbiAgICovXG4gIHN0YXRpYyBpc09uQ3VydmUocHVia2V5RGF0YSkge1xuICAgIGNvbnN0IHB1YmtleSA9IG5ldyBQdWJsaWNLZXkocHVia2V5RGF0YSk7XG4gICAgcmV0dXJuIGlzT25DdXJ2ZShwdWJrZXkudG9CeXRlcygpKTtcbiAgfVxufVxuX1B1YmxpY0tleSA9IFB1YmxpY0tleTtcblB1YmxpY0tleS5kZWZhdWx0ID0gbmV3IF9QdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5TT0xBTkFfU0NIRU1BLnNldChQdWJsaWNLZXksIHtcbiAga2luZDogJ3N0cnVjdCcsXG4gIGZpZWxkczogW1snX2JuJywgJ3UyNTYnXV1cbn0pO1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5IHBhaXIgKHB1YmxpYyBhbmQgc2VjcmV0IGtleXMpLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYxLjEwLjAsIHBsZWFzZSB1c2Uge0BsaW5rIEtleXBhaXJ9IGluc3RlYWQuXG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFjY291bnQgb2JqZWN0XG4gICAqXG4gICAqIElmIHRoZSBzZWNyZXRLZXkgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCBhIG5ldyBrZXkgcGFpciBpcyByYW5kb21seVxuICAgKiBjcmVhdGVkIGZvciB0aGUgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IFNlY3JldCBrZXkgZm9yIHRoZSBhY2NvdW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZWNyZXRLZXkpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHVibGljS2V5ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zZWNyZXRLZXkgPSB2b2lkIDA7XG4gICAgaWYgKHNlY3JldEtleSkge1xuICAgICAgY29uc3Qgc2VjcmV0S2V5QnVmZmVyID0gdG9CdWZmZXIoc2VjcmV0S2V5KTtcbiAgICAgIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgzMiwgNjQpO1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDAsIDMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gdG9CdWZmZXIoZ2VuZXJhdGVQcml2YXRlS2V5KCkpO1xuICAgICAgdGhpcy5fcHVibGljS2V5ID0gdG9CdWZmZXIoZ2V0UHVibGljS2V5KHRoaXMuX3NlY3JldEtleSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBhY2NvdW50XG4gICAqL1xuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHRoaXMuX3B1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlICoqdW5lbmNyeXB0ZWQqKiBzZWNyZXQga2V5IGZvciB0aGlzIGFjY291bnQuIFRoZSBmaXJzdCAzMiBieXRlc1xuICAgKiBpcyB0aGUgcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLl9zZWNyZXRLZXksIHRoaXMuX3B1YmxpY0tleV0sIDY0KTtcbiAgfVxufVxuXG5jb25zdCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBNYXhpbXVtIG92ZXItdGhlLXdpcmUgc2l6ZSBvZiBhIFRyYW5zYWN0aW9uXG4gKlxuICogMTI4MCBpcyBJUHY2IG1pbmltdW0gTVRVXG4gKiA0MCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgSVB2NiBoZWFkZXJcbiAqIDggYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIGZyYWdtZW50IGhlYWRlclxuICovXG5jb25zdCBQQUNLRVRfREFUQV9TSVpFID0gMTI4MCAtIDQwIC0gODtcbmNvbnN0IFZFUlNJT05fUFJFRklYX01BU0sgPSAweDdmO1xuY29uc3QgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyA9IDY0O1xuXG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiBibG9jayBoZWlnaHQgZXhjZWVkZWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCB0aW1lb3V0U2Vjb25kcykge1xuICAgIHN1cGVyKGBUcmFuc2FjdGlvbiB3YXMgbm90IGNvbmZpcm1lZCBpbiAke3RpbWVvdXRTZWNvbmRzLnRvRml4ZWQoMil9IHNlY29uZHMuIEl0IGlzIGAgKyAndW5rbm93biBpZiBpdCBzdWNjZWVkZWQgb3IgZmFpbGVkLiBDaGVjayBzaWduYXR1cmUgJyArIGAke3NpZ25hdHVyZX0gdXNpbmcgdGhlIFNvbGFuYSBFeHBsb3JlciBvciBDTEkgdG9vbHMuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogdGhlIG5vbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3InXG59KTtcblxuY2xhc3MgTWVzc2FnZUFjY291bnRLZXlzIHtcbiAgY29uc3RydWN0b3Ioc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBrZXlTZWdtZW50cygpIHtcbiAgICBjb25zdCBrZXlTZWdtZW50cyA9IFt0aGlzLnN0YXRpY0FjY291bnRLZXlzXTtcbiAgICBpZiAodGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZSk7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTZWdtZW50cztcbiAgfVxuICBnZXQoaW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGtleVNlZ21lbnQgb2YgdGhpcy5rZXlTZWdtZW50cygpKSB7XG4gICAgICBpZiAoaW5kZXggPCBrZXlTZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ga2V5U2VnbWVudFtpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCAtPSBrZXlTZWdtZW50Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkubGVuZ3RoO1xuICB9XG4gIGNvbXBpbGVJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgLy8gQmFpbCBlYXJseSBpZiBhbnkgYWNjb3VudCBpbmRleGVzIHdvdWxkIG92ZXJmbG93IGEgdThcbiAgICBjb25zdCBVOF9NQVggPSAyNTU7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gVThfTUFYICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBrZXlJbmRleE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgIGtleUluZGV4TWFwLnNldChrZXkudG9CYXNlNTgoKSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbmRLZXlJbmRleCA9IGtleSA9PiB7XG4gICAgICBjb25zdCBrZXlJbmRleCA9IGtleUluZGV4TWFwLmdldChrZXkudG9CYXNlNTgoKSk7XG4gICAgICBpZiAoa2V5SW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhbiB1bmtub3duIGluc3RydWN0aW9uIGFjY291bnQga2V5IGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgICAgcmV0dXJuIGtleUluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGZpbmRLZXlJbmRleChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBmaW5kS2V5SW5kZXgobWV0YS5wdWJrZXkpKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIExheW91dCBmb3IgYSBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IHB1YmxpY0tleSA9IChwcm9wZXJ0eSA9ICdwdWJsaWNLZXknKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYigzMiwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IHNpZ25hdHVyZSA9IChwcm9wZXJ0eSA9ICdzaWduYXR1cmUnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYig2NCwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIFJ1c3QgU3RyaW5nIHR5cGVcbiAqL1xuY29uc3QgcnVzdFN0cmluZyA9IChwcm9wZXJ0eSA9ICdzdHJpbmcnKSA9PiB7XG4gIGNvbnN0IHJzbCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5ibG9iKEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdjaGFycycpXSwgcHJvcGVydHkpO1xuICBjb25zdCBfZGVjb2RlID0gcnNsLmRlY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgcnNsU2hpbSA9IHJzbDtcbiAgcnNsU2hpbS5kZWNvZGUgPSAoYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuICByc2xTaGltLmVuY29kZSA9IChzdHIsIGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBjaGFyczogQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpXG4gICAgfTtcbiAgICByZXR1cm4gX2VuY29kZShkYXRhLCBiLCBvZmZzZXQpO1xuICB9O1xuICByc2xTaGltLmFsbG9jID0gc3RyID0+IHtcbiAgICByZXR1cm4gQnVmZmVyTGF5b3V0LnUzMigpLnNwYW4gKyBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS5sZW5ndGg7XG4gIH07XG4gIHJldHVybiByc2xTaGltO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGFuIEF1dGhvcml6ZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGF1dGhvcml6ZWQgPSAocHJvcGVydHkgPSAnYXV0aG9yaXplZCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnc3Rha2VyJyksIHB1YmxpY0tleSgnd2l0aGRyYXdlcicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgTG9ja3VwIG9iamVjdFxuICovXG5jb25zdCBsb2NrdXAgPSAocHJvcGVydHkgPSAnbG9ja3VwJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnY3VzdG9kaWFuJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUluaXQgb2JqZWN0XG4gKi9cbmNvbnN0IHZvdGVJbml0ID0gKHByb3BlcnR5ID0gJ3ZvdGVJbml0JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IChwcm9wZXJ0eSA9ICd2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyksIHB1YmxpY0tleSgnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleScpLCBydXN0U3RyaW5nKCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQnKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyldLCBwcm9wZXJ0eSk7XG59O1xuZnVuY3Rpb24gZ2V0QWxsb2ModHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGdldEl0ZW1BbGxvYyA9IGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLnNwYW4gPj0gMCkge1xuICAgICAgcmV0dXJuIGl0ZW0uc3BhbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlbS5hbGxvYyhmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH0gZWxzZSBpZiAoJ2NvdW50JyBpbiBpdGVtICYmICdlbGVtZW50TGF5b3V0JyBpbiBpdGVtKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpdGVtLnByb3BlcnR5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQubGVuZ3RoICogZ2V0SXRlbUFsbG9jKGl0ZW0uZWxlbWVudExheW91dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZmllbGRzJyBpbiBpdGVtKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgYFN0cnVjdHVyZWAgd2hvc2Ugc2l6ZSBuZWVkcyB0byBiZSByZWN1cnNpdmVseSBtZWFzdXJlZC5cbiAgICAgIHJldHVybiBnZXRBbGxvYyh7XG4gICAgICAgIGxheW91dDogaXRlbVxuICAgICAgfSwgZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9XG4gICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGFsbG9jYXRlZCBzaXplIG9mIGxheW91dFxuICAgIHJldHVybiAwO1xuICB9O1xuICBsZXQgYWxsb2MgPSAwO1xuICB0eXBlLmxheW91dC5maWVsZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBhbGxvYyArPSBnZXRJdGVtQWxsb2MoaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWxsb2M7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aChieXRlcykge1xuICBsZXQgbGVuID0gMDtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSBieXRlcy5zaGlmdCgpO1xuICAgIGxlbiB8PSAoZWxlbSAmIDB4N2YpIDw8IHNpemUgKiA3O1xuICAgIHNpemUgKz0gMTtcbiAgICBpZiAoKGVsZW0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgoYnl0ZXMsIGxlbikge1xuICBsZXQgcmVtX2xlbiA9IGxlbjtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gcmVtX2xlbiAmIDB4N2Y7XG4gICAgcmVtX2xlbiA+Pj0gNztcbiAgICBpZiAocmVtX2xlbiA9PSAwKSB7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0gfD0gMHg4MDtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5jbGFzcyBDb21waWxlZEtleXMge1xuICBjb25zdHJ1Y3RvcihwYXllciwga2V5TWV0YU1hcCkge1xuICAgIHRoaXMucGF5ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXIgPSBwYXllcjtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSBrZXlNZXRhTWFwO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGluc3RydWN0aW9ucywgcGF5ZXIpIHtcbiAgICBjb25zdCBrZXlNZXRhTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdldE9ySW5zZXJ0RGVmYXVsdCA9IHB1YmtleSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gcHVia2V5LnRvQmFzZTU4KCk7XG4gICAgICBsZXQga2V5TWV0YSA9IGtleU1ldGFNYXAuZ2V0KGFkZHJlc3MpO1xuICAgICAgaWYgKGtleU1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlNZXRhID0ge1xuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBpc0ludm9rZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGtleU1ldGFNYXAuc2V0KGFkZHJlc3MsIGtleU1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleU1ldGE7XG4gICAgfTtcbiAgICBjb25zdCBwYXllcktleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQocGF5ZXIpO1xuICAgIHBheWVyS2V5TWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgcGF5ZXJLZXlNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXggb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBnZXRPckluc2VydERlZmF1bHQoaXgucHJvZ3JhbUlkKS5pc0ludm9rZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBhY2NvdW50TWV0YSBvZiBpeC5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQoYWNjb3VudE1ldGEucHVia2V5KTtcbiAgICAgICAga2V5TWV0YS5pc1NpZ25lciB8fD0gYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICAgIGtleU1ldGEuaXNXcml0YWJsZSB8fD0gYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21waWxlZEtleXMocGF5ZXIsIGtleU1ldGFNYXApO1xuICB9XG4gIGdldE1lc3NhZ2VDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IG1hcEVudHJpZXMgPSBbLi4udGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKV07XG4gICAgYXNzZXJ0KG1hcEVudHJpZXMubGVuZ3RoIDw9IDI1NiwgJ01heCBzdGF0aWMgYWNjb3VudCBrZXlzIGxlbmd0aCBleGNlZWRlZCcpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5U2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCB3cml0YWJsZU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IHdyaXRhYmxlU2lnbmVycy5sZW5ndGggKyByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogcmVhZG9ubHlOb25TaWduZXJzLmxlbmd0aFxuICAgIH07XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAge1xuICAgICAgYXNzZXJ0KHdyaXRhYmxlU2lnbmVycy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHdyaXRhYmxlIHNpZ25lciBrZXknKTtcbiAgICAgIGNvbnN0IFtwYXllckFkZHJlc3NdID0gd3JpdGFibGVTaWduZXJzWzBdO1xuICAgICAgYXNzZXJ0KHBheWVyQWRkcmVzcyA9PT0gdGhpcy5wYXllci50b0Jhc2U1OCgpLCAnRXhwZWN0ZWQgZmlyc3Qgd3JpdGFibGUgc2lnbmVyIGtleSB0byBiZSB0aGUgZmVlIHBheWVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gWy4uLndyaXRhYmxlU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5U2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLndyaXRhYmxlTm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5Tm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSldO1xuICAgIHJldHVybiBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c107XG4gIH1cbiAgZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKSB7XG4gICAgY29uc3QgW3dyaXRhYmxlSW5kZXhlcywgZHJhaW5lZFdyaXRhYmxlS2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmIGtleU1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgW3JlYWRvbmx5SW5kZXhlcywgZHJhaW5lZFJlYWRvbmx5S2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmICFrZXlNZXRhLmlzV3JpdGFibGUpO1xuXG4gICAgLy8gRG9uJ3QgZXh0cmFjdCBsb29rdXAgaWYgbm8ga2V5cyB3ZXJlIGZvdW5kXG4gICAgaWYgKHdyaXRhYmxlSW5kZXhlcy5sZW5ndGggPT09IDAgJiYgcmVhZG9ubHlJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIGFjY291bnRLZXk6IGxvb2t1cFRhYmxlLmtleSxcbiAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgIHJlYWRvbmx5SW5kZXhlc1xuICAgIH0sIHtcbiAgICAgIHdyaXRhYmxlOiBkcmFpbmVkV3JpdGFibGVLZXlzLFxuICAgICAgcmVhZG9ubHk6IGRyYWluZWRSZWFkb25seUtleXNcbiAgICB9XTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlRW50cmllcywga2V5TWV0YUZpbHRlcikge1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXhlcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGRyYWluZWRLZXlzID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywga2V5TWV0YV0gb2YgdGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGtleU1ldGFGaWx0ZXIoa2V5TWV0YSkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleShhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbG9va3VwVGFibGVJbmRleCA9IGxvb2t1cFRhYmxlRW50cmllcy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkuZXF1YWxzKGtleSkpO1xuICAgICAgICBpZiAobG9va3VwVGFibGVJbmRleCA+PSAwKSB7XG4gICAgICAgICAgYXNzZXJ0KGxvb2t1cFRhYmxlSW5kZXggPCAyNTYsICdNYXggbG9va3VwIHRhYmxlIGluZGV4IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgbG9va3VwVGFibGVJbmRleGVzLnB1c2gobG9va3VwVGFibGVJbmRleCk7XG4gICAgICAgICAgZHJhaW5lZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIHRoaXMua2V5TWV0YU1hcC5kZWxldGUoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsb29rdXBUYWJsZUluZGV4ZXMsIGRyYWluZWRLZXlzXTtcbiAgfVxufVxuXG5jb25zdCBFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UgPSAnUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHVuZXhwZWN0ZWRseSc7XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzaGlmdGAsIGJ1dCB0aHJvd3MgaWYgdGhlIGFycmF5IGlzIHplcm8tbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSB7XG4gIGlmIChieXRlQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zaGlmdCgpO1xufVxuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc3BsaWNlYCwgYnV0IHRocm93cyBpZiB0aGUgc2VjdGlvbiBiZWluZyBzcGxpY2VkIG91dCBleHRlbmRzIHBhc3QgdGhlIGVuZCBvZlxuICogdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgLi4uYXJncykge1xuICBjb25zdCBbc3RhcnRdID0gYXJncztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyIC8vIEltcGxpZXMgdGhhdCBgZGVsZXRlQ291bnRgIHdhcyBzdXBwbGllZFxuICA/IHN0YXJ0ICsgKGFyZ3NbMV0gPz8gMCkgPiBieXRlQXJyYXkubGVuZ3RoIDogc3RhcnQgPj0gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc3BsaWNlKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIEFuIGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgYnkgYSBwcm9ncmFtXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2dyYW1JZEluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBhY2NvdW50c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGFcbiAqL1xuXG4vKipcbiAqIE1lc3NhZ2UgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGluc3RydWN0aW9ucyB0byBiZSBwcm9jZXNzZWQgYXRvbWljYWxseVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleFRvUHJvZ3JhbUlkcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSBhcmdzLmFjY291bnRLZXlzLm1hcChhY2NvdW50ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudCkpO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKGl4ID0+IHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuc2V0KGl4LnByb2dyYW1JZEluZGV4LCB0aGlzLmFjY291bnRLZXlzW2l4LnByb2dyYW1JZEluZGV4XSkpO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAnbGVnYWN5JztcbiAgfVxuICBnZXQgc3RhdGljQWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXM7XG4gIH1cbiAgZ2V0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICBkYXRhOiBiczU4LmVuY29kZShpeC5kYXRhKVxuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyLFxuICAgICAgYWNjb3VudEtleXM6IHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVVuc2lnbmVkQWNjb3VudHMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiB1bnNpZ25lZEFjY291bnRJbmRleCA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgfVxuICB9XG4gIGlzUHJvZ3JhbUlkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuaGFzKGluZGV4KTtcbiAgfVxuICBwcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5pbmRleFRvUHJvZ3JhbUlkcy52YWx1ZXMoKV07XG4gIH1cbiAgbm9uUHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cy5maWx0ZXIoKF8sIGluZGV4KSA9PiAhdGhpcy5pc1Byb2dyYW1JZChpbmRleCkpO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBudW1LZXlzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGtleUNvdW50LCBudW1LZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXhcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIGNvbnN0IGRhdGEgPSBBcnJheS5mcm9tKGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpKTtcbiAgICAgIGxldCBrZXlJbmRpY2VzQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChrZXlJbmRpY2VzQ291bnQsIGFjY291bnRzLmxlbmd0aCk7XG4gICAgICBsZXQgZGF0YUNvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoZGF0YUNvdW50LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAga2V5SW5kaWNlc0NvdW50OiBCdWZmZXIuZnJvbShrZXlJbmRpY2VzQ291bnQpLFxuICAgICAgICBrZXlJbmRpY2VzOiBhY2NvdW50cyxcbiAgICAgICAgZGF0YUxlbmd0aDogQnVmZmVyLmZyb20oZGF0YUNvdW50KSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChpbnN0cnVjdGlvbkNvdW50LCBpbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBCdWZmZXIuYWxsb2MoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgQnVmZmVyLmZyb20oaW5zdHJ1Y3Rpb25Db3VudCkuY29weShpbnN0cnVjdGlvbkJ1ZmZlcik7XG4gICAgbGV0IGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoID0gaW5zdHJ1Y3Rpb25Db3VudC5sZW5ndGg7XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmtleUluZGljZXNDb3VudC5sZW5ndGgsICdrZXlJbmRpY2VzQ291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhTGVuZ3RoLmxlbmd0aCwgJ2RhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKGtleUNvdW50Lmxlbmd0aCwgJ2tleUNvdW50JyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzXSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c10pLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogQnVmZmVyLmZyb20oa2V5Q291bnQpLFxuICAgICAga2V5czogdGhpcy5hY2NvdW50S2V5cy5tYXAoa2V5ID0+IHRvQnVmZmVyKGtleS50b0J5dGVzKCkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgc2lnbkRhdGEgPSBCdWZmZXIuYWxsb2MoMjA0OCk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2lnbkRhdGFMYXlvdXQuZW5jb2RlKHRyYW5zYWN0aW9uLCBzaWduRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIuY29weShzaWduRGF0YSwgbGVuZ3RoKTtcbiAgICByZXR1cm4gc2lnbkRhdGEuc2xpY2UoMCwgbGVuZ3RoICsgaW5zdHJ1Y3Rpb25CdWZmZXIubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBpZiAobnVtUmVxdWlyZWRTaWduYXR1cmVzICE9PSAobnVtUmVxdWlyZWRTaWduYXR1cmVzICYgVkVSU0lPTl9QUkVGSVhfTUFTSykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbmVkIG1lc3NhZ2VzIG11c3QgYmUgZGVzZXJpYWxpemVkIHdpdGggVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgYWNjb3VudEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY291bnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICAgIGFjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShCdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRDb3VudCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhU2xpY2UgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhID0gYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oZGF0YVNsaWNlKSk7XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VBcmdzID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmVuY29kZShCdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG5jbGFzcyBNZXNzYWdlVjAge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBhcmdzLnN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGFyZ3MuY29tcGlsZWRJbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gYXJncy5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb3VudCArPSBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIGlmIChhcmdzICYmICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnKTtcbiAgICAgIH1cbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChhcmdzICYmICdhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cycgaW4gYXJncyAmJiBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGNvbnN0IG51bVN0YXRpY0FjY291bnRLZXlzID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID49IG51bVN0YXRpY0FjY291bnRLZXlzKSB7XG4gICAgICBjb25zdCBsb29rdXBBY2NvdW50S2V5c0luZGV4ID0gaW5kZXggLSBudW1TdGF0aWNBY2NvdW50S2V5cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMgPSB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMucmVkdWNlKChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IG5ldyBBcnJheSgpLFxuICAgICAgcmVhZG9ubHk6IG5ldyBBcnJheSgpXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge1xuICAgICAgICAgIHdyaXRhYmxlLFxuICAgICAgICAgIHJlYWRvbmx5XG4gICAgICAgIH1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IHRoaXMuc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCk7XG4gICAgY29uc3QgZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpO1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3ByZWZpeCcpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEluc3RydWN0aW9ucy5sZW5ndGgsICdzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLmxlbmd0aCwgJ2FkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgcHJlZml4OiBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgsXG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoa2V5ID0+IGtleS50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaCksXG4gICAgICBpbnN0cnVjdGlvbnNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoKSxcbiAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSwgc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZS5zbGljZSgwLCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWREYXRhTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkRGF0YUxlbmd0aCwgaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoLCAnYWNjb3VudEtleUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZERhdGFMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZERhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgsICdkYXRhJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4LFxuICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZERhdGFMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhTGVuZ3RoKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfSwgc2VyaWFsaXplZEluc3RydWN0aW9ucywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLCBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dC5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBsb29rdXAuYWNjb3VudEtleS50b0J5dGVzKCksXG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGxvb2t1cC53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuICAgIGNvbnN0IHByZWZpeCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG4gICAgYXNzZXJ0KHByZWZpeCAhPT0gbWFza2VkUHJlZml4LCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2UgYnV0IHJlY2VpdmVkIGxlZ2FjeSBtZXNzYWdlYCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpXG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBiczU4LmVuY29kZShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGRhdGFMZW5ndGgpKTtcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWNjb3VudEtleSA9IG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgICBjb25zdCB3cml0YWJsZUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCB3cml0YWJsZUluZGV4ZXNMZW5ndGgpO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgcmVhZG9ubHlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaCh7XG4gICAgICAgIGFjY291bnRLZXksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5jb25zdCBWZXJzaW9uZWRNZXNzYWdlID0ge1xuICBkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgY29uc3QgcHJlZml4ID0gc2VyaWFsaXplZE1lc3NhZ2VbMF07XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcblxuICAgIC8vIGlmIHRoZSBoaWdoZXN0IGJpdCBvZiB0aGUgcHJlZml4IGlzIG5vdCBzZXQsIHRoZSBtZXNzYWdlIGlzIG5vdCB2ZXJzaW9uZWRcbiAgICBpZiAobWFza2VkUHJlZml4ID09PSBwcmVmaXgpIHtcbiAgICAgIHJldHVybiAnbGVnYWN5JztcbiAgICB9XG5cbiAgICAvLyB0aGUgbG93ZXIgNyBiaXRzIG9mIHRoZSBwcmVmaXggaW5kaWNhdGUgdGhlIG1lc3NhZ2UgdmVyc2lvblxuICAgIHJldHVybiBtYXNrZWRQcmVmaXg7XG4gIH0sXG4gIGRlc2VyaWFsaXplOiBzZXJpYWxpemVkTWVzc2FnZSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgaWYgKHZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZS5mcm9tKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBNZXNzYWdlVjAuZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIG1lc3NhZ2UgdmVyc2lvbiAke3ZlcnNpb259IGRlc2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG59O1xuXG4vKiogQGludGVybmFsICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIGFzIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAqL1xuXG5sZXQgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiQkxPQ0tIRUlHSFRfRVhDRUVERURcIl0gPSAwXSA9IFwiQkxPQ0tIRUlHSFRfRVhDRUVERURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJQUk9DRVNTRURcIl0gPSAxXSA9IFwiUFJPQ0VTU0VEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiVElNRURfT1VUXCJdID0gMl0gPSBcIlRJTUVEX09VVFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIk5PTkNFX0lOVkFMSURcIl0gPSAzXSA9IFwiTk9OQ0VfSU5WQUxJRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXM7XG59KHt9KTtcblxuLyoqXG4gKiBEZWZhdWx0IChlbXB0eSkgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IERFRkFVTFRfU0lHTkFUVVJFID0gQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB0aGlzLnByb2dyYW1JZCA9IG9wdHMucHJvZ3JhbUlkO1xuICAgIHRoaXMua2V5cyA9IG9wdHMua2V5cztcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBvcHRzLmRhdGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKCh7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIHB1YmtleTogcHVia2V5LnRvSlNPTigpLFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkpLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZC50b0pTT04oKSxcbiAgICAgIGRhdGE6IFsuLi50aGlzLmRhdGFdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhaXIgb2Ygc2lnbmF0dXJlIGFuZCBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTsgYW4gdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgYmVpbmdcbi8vIGZvcmNlZCB0byBvdmVyLWV4cG9ydCB0eXBlcyBieSB0aGUgZG9jdW1lbnRhdGlvbiBnZW5lcmF0b3IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI1ODIwXG5cbi8qKlxuICogQmxvY2toYXNoLWJhc2VkIHRyYW5zYWN0aW9ucyBoYXZlIGEgbGlmZXRpbWUgdGhhdCBhcmUgZGVmaW5lZCBieVxuICogdGhlIGJsb2NraGFzaCB0aGV5IGluY2x1ZGUuIEFueSB0cmFuc2FjdGlvbiB3aG9zZSBibG9ja2hhc2ggaXNcbiAqIHRvbyBvbGQgd2lsbCBiZSByZWplY3RlZC5cbiAqL1xuXG4vKipcbiAqIFVzZSB0aGVzZSBvcHRpb25zIHRvIGNvbnN0cnVjdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBOb25jZSBpbmZvcm1hdGlvbiB0byBiZSB1c2VkIHRvIGJ1aWxkIGFuIG9mZmxpbmUgVHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBmaXJzdCAocGF5ZXIpIFRyYW5zYWN0aW9uIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyIHwgbnVsbH0gQnVmZmVyIG9mIHBheWVyJ3Mgc2lnbmF0dXJlXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlKCkge1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlc1swXS5zaWduYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXJcbiAgICovXG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gd2l0aCBhIGJsb2NraGFzaCBhbmQgbGFzdFZhbGlkQmxvY2tIZWlnaHRcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB1c2luZyBhIGR1cmFibGUgbm9uY2VcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYFRyYW5zYWN0aW9uQ3RvckZpZWxkc2AgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqIFBsZWFzZSBzdXBwbHkgYSBgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yYCBpbnN0ZWFkLlxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGVtcHR5IFRyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlcyBmb3IgdGhlIHRyYW5zYWN0aW9uLiAgVHlwaWNhbGx5IGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlXG4gICAgICogYHNpZ24oKWAgbWV0aG9kXG4gICAgICovXG4gICAgdGhpcy5zaWduYXR1cmVzID0gW107XG4gICAgdGhpcy5mZWVQYXllciA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb25zIHRvIGF0b21pY2FsbHkgZXhlY3V0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgLyoqXG4gICAgICogQSByZWNlbnQgdHJhbnNhY3Rpb24gaWQuIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB0aGUgbGFzdCBibG9jayBjaGFpbiBjYW4gYWR2YW5jZSB0byBiZWZvcmUgdHggaXMgZGVjbGFyZWQgZXhwaXJlZFxuICAgICAqICovXG4gICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBOb25jZSBpbmZvcm1hdGlvbi4gSWYgcG9wdWxhdGVkLCB0cmFuc2FjdGlvbiB3aWxsIHVzZSBhIGR1cmFibGVcbiAgICAgKiBOb25jZSBoYXNoIGluc3RlYWQgb2YgYSByZWNlbnRCbG9ja2hhc2guIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLm5vbmNlSW5mbyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGEgbm9uY2UgdHJhbnNhY3Rpb24gdGhpcyByZXByZXNlbnRzIHRoZSBtaW5pbXVtIHNsb3QgZnJvbSB3aGljaFxuICAgICAqIHRvIGV2YWx1YXRlIGlmIHRoZSBub25jZSBoYXMgYWR2YW5jZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGNvbmZpcm0gdGhlXG4gICAgICogdHJhbnNhY3Rpb24uIFRoaXMgcHJvdGVjdHMgYWdhaW5zdCBhIGNhc2Ugd2hlcmUgdGhlIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvblxuICAgICAqIGxvZ2ljIGxvYWRzIHRoZSBub25jZSBhY2NvdW50IGZyb20gYW4gb2xkIHNsb3QgYW5kIGFzc3VtZXMgdGhlIG1pc21hdGNoIGluXG4gICAgICogbm9uY2UgdmFsdWUgaW1wbGllcyB0aGF0IHRoZSBub25jZSBoYXMgYmVlbiBhZHZhbmNlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9qc29uID0gdm9pZCAwO1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0cy5mZWVQYXllcikge1xuICAgICAgdGhpcy5mZWVQYXllciA9IG9wdHMuZmVlUGF5ZXI7XG4gICAgfVxuICAgIGlmIChvcHRzLnNpZ25hdHVyZXMpIHtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IG9wdHMuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbm9uY2VJbmZvJykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSBtaW5Db250ZXh0U2xvdDtcbiAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgaWYgKG5vbmNlSW5mbykge1xuICAgICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gcmVjZW50QmxvY2toYXNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgZmVlUGF5ZXI6IHRoaXMuZmVlUGF5ZXIgPyB0aGlzLmZlZVBheWVyLnRvSlNPTigpIDogbnVsbCxcbiAgICAgIG5vbmNlSW5mbzogdGhpcy5ub25jZUluZm8gPyB7XG4gICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlSW5mby5ub25jZSxcbiAgICAgICAgbm9uY2VJbnN0cnVjdGlvbjogdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbi50b0pTT04oKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi50b0pTT04oKSksXG4gICAgICBzaWduZXJzOiB0aGlzLnNpZ25hdHVyZXMubWFwKCh7XG4gICAgICAgIHB1YmxpY0tleVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvSlNPTigpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvbmUgb3IgbW9yZSBpbnN0cnVjdGlvbnMgdG8gdGhpcyBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PCBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcyA+fSBpdGVtcyAtIEluc3RydWN0aW9ucyB0byBhZGQgdG8gdGhlIFRyYW5zYWN0aW9uXG4gICAqL1xuICBhZGQoLi4uaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGluc3RydWN0aW9ucycpO1xuICAgIH1cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCdpbnN0cnVjdGlvbnMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5jb25jYXQoaXRlbS5pbnN0cnVjdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICgnZGF0YScgaW4gaXRlbSAmJiAncHJvZ3JhbUlkJyBpbiBpdGVtICYmICdrZXlzJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGl0ZW0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICovXG4gIGNvbXBpbGVNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9tZXNzYWdlICYmIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpID09PSBKU09OLnN0cmluZ2lmeSh0aGlzLl9qc29uKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgfVxuICAgIGxldCByZWNlbnRCbG9ja2hhc2g7XG4gICAgbGV0IGluc3RydWN0aW9ucztcbiAgICBpZiAodGhpcy5ub25jZUluZm8pIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMubm9uY2VJbmZvLm5vbmNlO1xuICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zWzBdICE9IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24sIC4uLnRoaXMuaW5zdHJ1Y3Rpb25zXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBpZiAoIXJlY2VudEJsb2NraGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWNlbnRCbG9ja2hhc2ggcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGluc3RydWN0aW9ucyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBsZXQgZmVlUGF5ZXI7XG4gICAgaWYgKHRoaXMuZmVlUGF5ZXIpIHtcbiAgICAgIGZlZVBheWVyID0gdGhpcy5mZWVQYXllcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpIHtcbiAgICAgIC8vIFVzZSBpbXBsaWNpdCBmZWUgcGF5ZXJcbiAgICAgIGZlZVBheWVyID0gdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmZWUgcGF5ZXIgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbnNbaV0ucHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBpbnN0cnVjdGlvbiBpbmRleCAke2l9IGhhcyB1bmRlZmluZWQgcHJvZ3JhbSBpZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtSWRzID0gW107XG4gICAgY29uc3QgYWNjb3VudE1ldGFzID0gW107XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgaW5zdHJ1Y3Rpb24ua2V5cy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICAgIC4uLmFjY291bnRNZXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghcHJvZ3JhbUlkcy5pbmNsdWRlcyhwcm9ncmFtSWQpKSB7XG4gICAgICAgIHByb2dyYW1JZHMucHVzaChwcm9ncmFtSWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQXBwZW5kIHByb2dyYW1JRCBhY2NvdW50IG1ldGFzXG4gICAgcHJvZ3JhbUlkcy5mb3JFYWNoKHByb2dyYW1JZCA9PiB7XG4gICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEN1bGwgZHVwbGljYXRlIGFjY291bnQgbWV0YXNcbiAgICBjb25zdCB1bmlxdWVNZXRhcyA9IFtdO1xuICAgIGFjY291bnRNZXRhcy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgIGNvbnN0IHB1YmtleVN0cmluZyA9IGFjY291bnRNZXRhLnB1YmtleS50b1N0cmluZygpO1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS50b1N0cmluZygpID09PSBwdWJrZXlTdHJpbmc7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgfHwgYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyIHx8IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pcXVlTWV0YXMucHVzaChhY2NvdW50TWV0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0LiBQcmlvcml0aXppbmcgZmlyc3QgYnkgc2lnbmVyLCB0aGVuIGJ5IHdyaXRhYmxlXG4gICAgdW5pcXVlTWV0YXMuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHguaXNTaWduZXIgIT09IHkuaXNTaWduZXIpIHtcbiAgICAgICAgLy8gU2lnbmVycyBhbHdheXMgY29tZSBiZWZvcmUgbm9uLXNpZ25lcnNcbiAgICAgICAgcmV0dXJuIHguaXNTaWduZXIgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoeC5pc1dyaXRhYmxlICE9PSB5LmlzV3JpdGFibGUpIHtcbiAgICAgICAgLy8gV3JpdGFibGUgYWNjb3VudHMgYWx3YXlzIGNvbWUgYmVmb3JlIHJlYWQtb25seSBhY2NvdW50c1xuICAgICAgICByZXR1cm4geC5pc1dyaXRhYmxlID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBzb3J0IGJ5IHB1YmtleSwgc3RyaW5nd2lzZS5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGxvY2FsZU1hdGNoZXI6ICdiZXN0IGZpdCcsXG4gICAgICAgIHVzYWdlOiAnc29ydCcsXG4gICAgICAgIHNlbnNpdGl2aXR5OiAndmFyaWFudCcsXG4gICAgICAgIGlnbm9yZVB1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICAgICAgbnVtZXJpYzogZmFsc2UsXG4gICAgICAgIGNhc2VGaXJzdDogJ2xvd2VyJ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4LnB1YmtleS50b0Jhc2U1OCgpLmxvY2FsZUNvbXBhcmUoeS5wdWJrZXkudG9CYXNlNTgoKSwgJ2VuJywgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBNb3ZlIGZlZSBwYXllciB0byB0aGUgZnJvbnRcbiAgICBjb25zdCBmZWVQYXllckluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhmZWVQYXllcik7XG4gICAgfSk7XG4gICAgaWYgKGZlZVBheWVySW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgW3BheWVyTWV0YV0gPSB1bmlxdWVNZXRhcy5zcGxpY2UoZmVlUGF5ZXJJbmRleCwgMSk7XG4gICAgICBwYXllck1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgICAgcGF5ZXJNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdChwYXllck1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHtcbiAgICAgICAgcHVia2V5OiBmZWVQYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpc2FsbG93IHVua25vd24gc2lnbmVyc1xuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoc2lnbmF0dXJlLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIGlmICghdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyKSB7XG4gICAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHJlZmVyZW5jZXMgYSBzaWduYXR1cmUgdGhhdCBpcyB1bm5lY2Vzc2FyeSwgJyArICdvbmx5IHRoZSBmZWUgcGF5ZXIgYW5kIGluc3RydWN0aW9uIHNpZ25lciBhY2NvdW50cyBzaG91bGQgc2lnbiBhIHRyYW5zYWN0aW9uLiAnICsgJ1RoaXMgYmVoYXZpb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7c2lnbmF0dXJlLnB1YmxpY0tleS50b1N0cmluZygpfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbnVtUmVxdWlyZWRTaWduYXR1cmVzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IDA7XG5cbiAgICAvLyBTcGxpdCBvdXQgc2lnbmluZyBmcm9tIG5vbi1zaWduaW5nIGtleXMgYW5kIGNvdW50IGhlYWRlciB2YWx1ZXNcbiAgICBjb25zdCBzaWduZWRLZXlzID0gW107XG4gICAgY29uc3QgdW5zaWduZWRLZXlzID0gW107XG4gICAgdW5pcXVlTWV0YXMuZm9yRWFjaCgoe1xuICAgICAgcHVia2V5LFxuICAgICAgaXNTaWduZXIsXG4gICAgICBpc1dyaXRhYmxlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgIHNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyArPSAxO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IHNpZ25lZEtleXMuY29uY2F0KHVuc2lnbmVkS2V5cyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvZ3JhbUlkXG4gICAgICB9ID0gaW5zdHJ1Y3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogYWNjb3VudEtleXMuaW5kZXhPZihwcm9ncmFtSWQudG9TdHJpbmcoKSksXG4gICAgICAgIGFjY291bnRzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGFjY291bnRLZXlzLmluZGV4T2YobWV0YS5wdWJrZXkudG9TdHJpbmcoKSkpLFxuICAgICAgICBkYXRhOiBiczU4LmVuY29kZShkYXRhKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb21waWxlZEluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgIGluc3RydWN0aW9uLmFjY291bnRzLmZvckVhY2goa2V5SW5kZXggPT4gYXNzZXJ0KGtleUluZGV4ID49IDApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPT09IHNpZ25lZEtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuc2lnbmF0dXJlcy5ldmVyeSgocGFpciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEtleXNbaW5kZXhdLmVxdWFscyhwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWxpZCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcHVibGljIGtleXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIFRyYW5zYWN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFNpZ25hdHVyZXMgY2FuIGJlIGFkZGVkIHdpdGggZWl0aGVyIGBwYXJ0aWFsU2lnbmAgb3IgYGFkZFNpZ25hdHVyZWBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MC44NC4wLiBPbmx5IHRoZSBmZWUgcGF5ZXIgbmVlZHMgdG8gYmVcbiAgICogc3BlY2lmaWVkIGFuZCBpdCBjYW4gYmUgc2V0IGluIHRoZSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvciBvciB3aXRoIHRoZVxuICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U2lnbmVycyguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZXJzLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoc2lnbmVyID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICogY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEFsbCB0aGUgY2F2ZWF0cyBmcm9tIHRoZSBgc2lnbmAgbWV0aG9kIGFwcGx5IHRvIGBwYXJ0aWFsU2lnbmBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwYXJ0aWFsU2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcGFydGlhbFNpZ24obWVzc2FnZSwgLi4uc2lnbmVycykge1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKHNpZ25lci5wdWJsaWNLZXksIHRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTsgLy8gRW5zdXJlIHNpZ25hdHVyZXMgYXJyYXkgaXMgcG9wdWxhdGVkXG4gICAgdGhpcy5fYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChzaWdwYWlyID0+IHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3B1YmtleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgb2YgYSBUcmFuc2FjdGlvblxuICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgKiBJZiBubyBib29sZWFuIGlzIHByb3ZpZGVkLCB3ZSBleHBlY3QgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlcyhyZXF1aXJlQWxsU2lnbmF0dXJlcyA9IHRydWUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyh0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgIHJldHVybiAhc2lnbmF0dXJlRXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKG1lc3NhZ2UsIHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9IG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAocmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAoZXJyb3JzLm1pc3NpbmcgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5LnRvQnl0ZXMoKSkpIHtcbiAgICAgICAgICAoZXJyb3JzLmludmFsaWQgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5pbnZhbGlkIHx8IGVycm9ycy5taXNzaW5nID8gZXJyb3JzIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgVHJhbnNhY3Rpb24gaW4gdGhlIHdpcmUgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW2NvbmZpZ10gQ29uZmlnIG9mIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBTaWduYXR1cmUgb2YgdHJhbnNhY3Rpb24gaW4gd2lyZSBmb3JtYXQuXG4gICAqL1xuICBzZXJpYWxpemUoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXMsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzXG4gICAgfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IHRydWUsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzOiB0cnVlXG4gICAgfSwgY29uZmlnKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpO1xuICAgIGlmICh2ZXJpZnlTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCBzaWdFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhzaWduRGF0YSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgICAgaWYgKHNpZ0Vycm9ycykge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkLic7XG4gICAgICAgIGlmIChzaWdFcnJvcnMuaW52YWxpZCkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuSW52YWxpZCBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5pbnZhbGlkLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5pbnZhbGlkLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnRXJyb3JzLm1pc3NpbmcpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbk1pc3Npbmcgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMubWlzc2luZy5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMubWlzc2luZy5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZShzaWduRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChzaWduYXR1cmVDb3VudCwgc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGVuZ3RoID0gc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCArIHNpZ25EYXRhLmxlbmd0aDtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSBCdWZmZXIuYWxsb2ModHJhbnNhY3Rpb25MZW5ndGgpO1xuICAgIGFzc2VydChzaWduYXR1cmVzLmxlbmd0aCA8IDI1Nik7XG4gICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlQ291bnQpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCAwKTtcbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgaW5kZXggKiA2NCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2lnbkRhdGEuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQpO1xuICAgIGFzc2VydCh3aXJlVHJhbnNhY3Rpb24ubGVuZ3RoIDw9IFBBQ0tFVF9EQVRBX1NJWkUsIGBUcmFuc2FjdGlvbiB0b28gbGFyZ2U6ICR7d2lyZVRyYW5zYWN0aW9uLmxlbmd0aH0gPiAke1BBQ0tFVF9EQVRBX1NJWkV9YCk7XG4gICAgcmV0dXJuIHdpcmVUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBrZXlzKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5rZXlzLm1hcChrZXlPYmogPT4ga2V5T2JqLnB1YmtleSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcHJvZ3JhbUlkKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5wcm9ncmFtSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0uZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHdpcmUgdHJhbnNhY3Rpb24gaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5IHwgQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFNpZ25hdHVyZSBvZiB3aXJlIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBzaWduYXR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgICBzaWduYXR1cmVzLnB1c2goYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucG9wdWxhdGUoTWVzc2FnZS5mcm9tKGJ5dGVBcnJheSksIHNpZ25hdHVyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlIFRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIG1lc3NhZ2UgYW5kIHNpZ25hdHVyZXNcbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2Ugb2YgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzaWduYXR1cmVzIExpc3Qgb2Ygc2lnbmF0dXJlcyB0byBhc3NpZ24gdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVGhlIHBvcHVsYXRlZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIHBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMgPSBbXSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbWVzc2FnZS5yZWNlbnRCbG9ja2hhc2g7XG4gICAgaWYgKG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICB9XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaWdQdWJrZXlQYWlyID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSA9PSBiczU4LmVuY29kZShERUZBVUxUX1NJR05BVFVSRSkgPyBudWxsIDogYnM1OC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUoa2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCkpIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0cmFuc2FjdGlvbi5fanNvbiA9IHRyYW5zYWN0aW9uLnRvSlNPTigpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2FjdGlvbk1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5wYXllcktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyS2V5ID0gYXJncy5wYXllcktleTtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gIH1cbiAgc3RhdGljIGRlY29tcGlsZShtZXNzYWdlLCBhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVhZGVyLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgfSA9IGhlYWRlcjtcbiAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIC0gbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA+IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA+PSAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbWVzc2FnZS5nZXRBY2NvdW50S2V5cyhhcmdzKTtcbiAgICBjb25zdCBwYXllcktleSA9IGFjY291bnRLZXlzLmdldCgwKTtcbiAgICBpZiAocGF5ZXJLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb21waWxlIG1lc3NhZ2UgYmVjYXVzZSBubyBhY2NvdW50IGtleXMgd2VyZSBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbXBpbGVkSXggb2YgY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5SW5kZXggb2YgY29tcGlsZWRJeC5hY2NvdW50S2V5SW5kZXhlcykge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBhY2NvdW50S2V5cy5nZXQoa2V5SW5kZXgpO1xuICAgICAgICBpZiAocHVia2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGtleSBmb3IgYWNjb3VudCBrZXkgaW5kZXggJHtrZXlJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1NpZ25lciA9IGtleUluZGV4IDwgbnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgICAgICBsZXQgaXNXcml0YWJsZTtcbiAgICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIGlmIChrZXlJbmRleCA8IGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggPFxuICAgICAgICAgIC8vIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgY2Fubm90IGJlIHVuZGVmaW5lZCBiZWNhdXNlIHdlIGFscmVhZHkgZm91bmQgYSBwdWJrZXkgZm9yIHRoaXMgaW5kZXggYWJvdmVcbiAgICAgICAgICBhY2NvdW50S2V5cy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjoga2V5SW5kZXggPCBoZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgIGlzV3JpdGFibGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBhY2NvdW50S2V5cy5nZXQoY29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleCk7XG4gICAgICBpZiAocHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBwcm9ncmFtIGlkIGZvciBwcm9ncmFtIGlkIGluZGV4ICR7Y29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleH1gKTtcbiAgICAgIH1cbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiB0b0J1ZmZlcihjb21waWxlZEl4LmRhdGEpLFxuICAgICAgICBrZXlzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25NZXNzYWdlKHtcbiAgICAgIHBheWVyS2V5LFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgcmVjZW50QmxvY2toYXNoXG4gICAgfSk7XG4gIH1cbiAgY29tcGlsZVRvTGVnYWN5TWVzc2FnZSgpIHtcbiAgICByZXR1cm4gTWVzc2FnZS5jb21waWxlKHtcbiAgICAgIHBheWVyS2V5OiB0aGlzLnBheWVyS2V5LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9WME1lc3NhZ2UoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICByZXR1cm4gTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJzaW9uZWQgdHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVmVyc2lvbmVkVHJhbnNhY3Rpb24ge1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLnZlcnNpb247XG4gIH1cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc2lnbmF0dXJlcykge1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgaWYgKHNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoID09PSBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsICdFeHBlY3RlZCBzaWduYXR1cmVzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMnKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTaWduYXR1cmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlczsgaSsrKSB7XG4gICAgICAgIGRlZmF1bHRTaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaWduYXR1cmVzID0gZGVmYXVsdFNpZ25hdHVyZXM7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgsIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShzaWduYXR1cmUoKSwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCwgJ3NpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZE1lc3NhZ2UubGVuZ3RoLCAnc2VyaWFsaXplZE1lc3NhZ2UnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCA9IHRyYW5zYWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgpLFxuICAgICAgc2lnbmF0dXJlczogdGhpcy5zaWduYXR1cmVzLFxuICAgICAgc2VyaWFsaXplZE1lc3NhZ2VcbiAgICB9LCBzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkVHJhbnNhY3Rpb25dO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBjb25zdCBzaWduYXR1cmVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSk7XG4gICAgcmV0dXJuIG5ldyBWZXJzaW9uZWRUcmFuc2FjdGlvbihtZXNzYWdlLCBzaWduYXR1cmVzKTtcbiAgfVxuICBzaWduKHNpZ25lcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHNpZ25lci5wdWJsaWNLZXkpKTtcbiAgICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2Fubm90IHNpZ24gd2l0aCBub24gc2lnbmVyIGtleSAke3NpZ25lci5wdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduKG1lc3NhZ2VEYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICB9XG4gIH1cbiAgYWRkU2lnbmF0dXJlKHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5ieXRlTGVuZ3RoID09PSA2NCwgJ1NpZ25hdHVyZSBtdXN0IGJlIDY0IGJ5dGVzIGxvbmcnKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHB1YmxpY0tleSkpO1xuICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2FuIG5vdCBhZGQgc2lnbmF0dXJlOyBcXGAke3B1YmxpY0tleS50b0Jhc2U1OCgpfVxcYCBpcyBub3QgcmVxdWlyZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uYCk7XG4gICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuXG4vLyBUT0RPOiBUaGVzZSBjb25zdGFudHMgc2hvdWxkIGJlIHJlbW92ZWQgaW4gZmF2b3Igb2YgcmVhZGluZyB0aGVtIG91dCBvZiBhXG4vLyBTeXNjYWxsIGFjY291bnRcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1RJQ0tTX1BFUl9TRUNPTkQgPSAxNjA7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfVElDS1NfUEVSX1NMT1QgPSA2NDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1NMT1RTX1BFUl9TRUNPTkQgPSBOVU1fVElDS1NfUEVSX1NFQ09ORCAvIERFRkFVTFRfVElDS1NfUEVSX1NMT1Q7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE1TX1BFUl9TTE9UID0gMTAwMCAvIE5VTV9TTE9UU19QRVJfU0VDT05EO1xuXG5jb25zdCBTWVNWQVJfQ0xPQ0tfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyQzFvY2sxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckVwb2NoU2NoZWR1MWUxMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZWNlbnRCMW9ja0hhc2hlczExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVOVF9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZW50MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVXQVJEU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhhc2hlczExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNsYXNzIFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYWN0aW9uLFxuICAgIHNpZ25hdHVyZSxcbiAgICB0cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgbG9nc1xuICB9KSB7XG4gICAgY29uc3QgbWF5YmVMb2dzT3V0cHV0ID0gbG9ncyA/IGBMb2dzOiBcXG4ke0pTT04uc3RyaW5naWZ5KGxvZ3Muc2xpY2UoLTEwKSwgbnVsbCwgMil9LiBgIDogJyc7XG4gICAgY29uc3QgZ3VpZGVUZXh0ID0gJ1xcbkNhdGNoIHRoZSBgU2VuZFRyYW5zYWN0aW9uRXJyb3JgIGFuZCBjYWxsIGBnZXRMb2dzKClgIG9uIGl0IGZvciBmdWxsIGRldGFpbHMuJztcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSAnc2VuZCc6XG4gICAgICAgIG1lc3NhZ2UgPSBgVHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IHJlc3VsdGVkIGluIGFuIGVycm9yLiBcXG5gICsgYCR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gYCArIG1heWJlTG9nc091dHB1dCArIGd1aWRlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaW11bGF0ZSc6XG4gICAgICAgIG1lc3NhZ2UgPSBgU2ltdWxhdGlvbiBmYWlsZWQuIFxcbk1lc3NhZ2U6ICR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gXFxuYCArIG1heWJlTG9nc091dHB1dCArIGd1aWRlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBVbmtub3duIGFjdGlvbiAnJHsoYSA9PiBhKShhY3Rpb24pfSdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlID0gdHJhbnNhY3Rpb25NZXNzYWdlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbG9ncyA/IGxvZ3MgOiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IHRyYW5zYWN0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgICAgbG9nczogQXJyYXkuaXNBcnJheSh0aGlzLnRyYW5zYWN0aW9uTG9ncykgPyB0aGlzLnRyYW5zYWN0aW9uTG9ncyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKiBAZGVwcmVjYXRlZCBVc2UgYGF3YWl0IGdldExvZ3MoKWAgaW5zdGVhZCAqL1xuICBnZXQgbG9ncygpIHtcbiAgICBjb25zdCBjYWNoZWRMb2dzID0gdGhpcy50cmFuc2FjdGlvbkxvZ3M7XG4gICAgaWYgKGNhY2hlZExvZ3MgIT0gbnVsbCAmJiB0eXBlb2YgY2FjaGVkTG9ncyA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGNhY2hlZExvZ3MpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRMb2dzO1xuICB9XG4gIGFzeW5jIGdldExvZ3MoY29ubmVjdGlvbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRyYW5zYWN0aW9uTG9ncykpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmdldFRyYW5zYWN0aW9uKHRoaXMuc2lnbmF0dXJlKS50aGVuKHR4ID0+IHtcbiAgICAgICAgICBpZiAodHggJiYgdHgubWV0YSAmJiB0eC5tZXRhLmxvZ01lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dzID0gdHgubWV0YS5sb2dNZXNzYWdlcztcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbG9ncztcbiAgICAgICAgICAgIHJlc29sdmUobG9ncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xvZyBtZXNzYWdlcyBub3QgZm91bmQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uTG9ncztcbiAgfVxufVxuXG4vLyBLZWVwIGluIHN5bmMgd2l0aCBjbGllbnQvc3JjL3JwY19jdXN0b21fZXJyb3JzLnJzXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlID0ge1xuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUDogLTMyMDAxLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRTogLTMyMDAyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFOiAtMzIwMDQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWTogLTMyMDA1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDA2LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEOiAtMzIwMDcsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVDogLTMyMDA4LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEOiAtMzIwMDksXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVg6IC0zMjAxMCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRTogLTMyMDExLFxuICBKU09OX1JQQ19TQ0FOX0VSUk9SOiAtMzIwMTIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIOiAtMzIwMTMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6IC0zMjAxNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT046IC0zMjAxNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQ6IC0zMjAxNlxufTtcbmNsYXNzIFNvbGFuYUpTT05SUENFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZSxcbiAgICBkYXRhXG4gIH0sIGN1c3RvbU1lc3NhZ2UpIHtcbiAgICBzdXBlcihjdXN0b21NZXNzYWdlICE9IG51bGwgPyBgJHtjdXN0b21NZXNzYWdlfTogJHttZXNzYWdlfWAgOiBtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm5hbWUgPSAnU29sYW5hSlNPTlJQQ0Vycm9yJztcbiAgfVxufVxuXG4vKipcbiAqIFNpZ24sIHNlbmQgYW5kIGNvbmZpcm0gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzXG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgc2lnbmVycywgb3B0aW9ucykge1xuICBjb25zdCBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICBwcmVmbGlnaHRDb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgb3B0aW9ucy5jb21taXRtZW50LFxuICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVycywgc2VuZE9wdGlvbnMpO1xuICBsZXQgc3RhdHVzO1xuICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgIT0gbnVsbCkge1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubm9uY2VJbmZvICE9IG51bGwpIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZUluc3RydWN0aW9uXG4gICAgfSA9IHRyYW5zYWN0aW9uLm5vbmNlSW5mbztcbiAgICBjb25zdCBub25jZUFjY291bnRQdWJrZXkgPSBub25jZUluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5O1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdDogdHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWU6IHRyYW5zYWN0aW9uLm5vbmNlSW5mby5ub25jZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnM/LmFib3J0U2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbigpOiBBIHRyYW5zYWN0aW9uIHdpdGggYSBkZXByZWNhdGVkIGNvbmZpcm1hdGlvbiBzdHJhdGVneSB3YXMgJyArICdzdXBwbGllZCBhbG9uZyB3aXRoIGFuIGBhYm9ydFNpZ25hbGAuIE9ubHkgdHJhbnNhY3Rpb25zIGhhdmluZyBgbGFzdFZhbGlkQmxvY2tIZWlnaHRgICcgKyAnb3IgYSBjb21iaW5hdGlvbiBvZiBgbm9uY2VJbmZvYCBhbmQgYG1pbk5vbmNlQ29udGV4dFNsb3RgIGFyZSBhYm9ydGFibGUuJyk7XG4gICAgfVxuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH1cbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NlbmQnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8vIHp6elxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogUG9wdWxhdGUgYSBidWZmZXIgb2YgaW5zdHJ1Y3Rpb24gZGF0YSB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBhbGxvY0xlbmd0aCA9IHR5cGUubGF5b3V0LnNwYW4gPj0gMCA/IHR5cGUubGF5b3V0LnNwYW4gOiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpO1xuICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGFsbG9jTGVuZ3RoKTtcbiAgY29uc3QgbGF5b3V0RmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgaW5zdHJ1Y3Rpb246IHR5cGUuaW5kZXhcbiAgfSwgZmllbGRzKTtcbiAgdHlwZS5sYXlvdXQuZW5jb2RlKGxheW91dEZpZWxkcywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBpbnN0cnVjdGlvbiBkYXRhIGJ1ZmZlciB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhJDEodHlwZSwgYnVmZmVyKSB7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSB0eXBlLmxheW91dC5kZWNvZGUoYnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgaW5zdHJ1Y3Rpb24gaW5kZXggbWlzbWF0Y2ggJHtkYXRhLmluc3RydWN0aW9ufSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzkwYmVkZDdlMDY3YjViOGYzZGRiYjQ1ZGEwMGE0ZTljYWJiMjJjNjIvc2RrL3NyYy9mZWVfY2FsY3VsYXRvci5ycyNMNy1MMTFcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRmVlQ2FsY3VsYXRvckxheW91dCA9IEJ1ZmZlckxheW91dC5udTY0KCdsYW1wb3J0c1BlclNpZ25hdHVyZScpO1xuXG4vKipcbiAqIENhbGN1bGF0b3IgZm9yIHRyYW5zYWN0aW9uIGZlZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi8wZWEyODQzZWM5Y2RjNTE3NTcyYjhlNjJjOTU5ZjQxYjU1Y2Y0NDUzL3Nkay9zcmMvbm9uY2Vfc3RhdGUucnMjTDI5LUwzMlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOb25jZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2ZXJzaW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YXRlJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBwdWJsaWNLZXkoJ25vbmNlJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0ZlZUNhbGN1bGF0b3JMYXlvdXRdLCAnZmVlQ2FsY3VsYXRvcicpXSk7XG5jb25zdCBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBOb25jZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgTm9uY2VBY2NvdW50IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5vbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSBhcmdzLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgdGhpcy5ub25jZSA9IGFyZ3Mubm9uY2U7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gYXJncy5mZWVDYWxjdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIE5vbmNlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gTm9uY2VBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudCA9IE5vbmNlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgMCk7XG4gICAgcmV0dXJuIG5ldyBOb25jZUFjY291bnQoe1xuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQuYXV0aG9yaXplZFB1YmtleSksXG4gICAgICBub25jZTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQubm9uY2UpLnRvU3RyaW5nKCksXG4gICAgICBmZWVDYWxjdWxhdG9yOiBub25jZUFjY291bnQuZmVlQ2FsY3VsYXRvclxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGVuY29kZURlY29kZSA9IGxheW91dCA9PiB7XG4gIGNvbnN0IGRlY29kZSA9IGxheW91dC5kZWNvZGUuYmluZChsYXlvdXQpO1xuICBjb25zdCBlbmNvZGUgPSBsYXlvdXQuZW5jb2RlLmJpbmQobGF5b3V0KTtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlXG4gIH07XG59O1xuY29uc3QgYmlnSW50ID0gbGVuZ3RoID0+IHByb3BlcnR5ID0+IHtcbiAgY29uc3QgbGF5b3V0ID0gYmxvYihsZW5ndGgsIHByb3BlcnR5KTtcbiAgY29uc3Qge1xuICAgIGVuY29kZSxcbiAgICBkZWNvZGVcbiAgfSA9IGVuY29kZURlY29kZShsYXlvdXQpO1xuICBjb25zdCBiaWdJbnRMYXlvdXQgPSBsYXlvdXQ7XG4gIGJpZ0ludExheW91dC5kZWNvZGUgPSAoYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgIHJldHVybiB0b0JpZ0ludExFKEJ1ZmZlci5mcm9tKHNyYykpO1xuICB9O1xuICBiaWdJbnRMYXlvdXQuZW5jb2RlID0gKGJpZ0ludCwgYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSB0b0J1ZmZlckxFKGJpZ0ludCwgbGVuZ3RoKTtcbiAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICB9O1xuICByZXR1cm4gYmlnSW50TGF5b3V0O1xufTtcbmNvbnN0IHU2NCA9IGJpZ0ludCg4KTtcblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWR2YW5jZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXJXaXRoU2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqXG4gKiBTeXN0ZW0gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3lzdGVtSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTeXN0ZW1JbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcihpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlciwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlVHJhbnNmZXJXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNwYWNlXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BhY2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhc3NpZ24gc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbihpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgaW5pdGlhbGl6ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VJbml0aWFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGFkdmFuY2Ugc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQWR2YW5jZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIHdpdGhkcmF3IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYXV0aG9yaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN5c3RlbVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN5c3RlbUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzeXN0ZW0gSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBDcmVhdGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbjoge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFRyYW5zZmVyOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBDcmVhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQWR2YW5jZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFdpdGhkcmF3Tm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIEluaXRpYWxpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQXV0aG9yaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEFsbG9jYXRlOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKV0pXG4gIH0sXG4gIEFsbG9jYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXJXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVXBncmFkZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiAxMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3lzdGVtIHByb2dyYW1cbiAqL1xuY2xhc3MgU3lzdGVtUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN5c3RlbSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHRyYW5zZmVycyBsYW1wb3J0cyBmcm9tIG9uZSBhY2NvdW50IHRvIGFub3RoZXJcbiAgICovXG4gIHN0YXRpYyB0cmFuc2ZlcihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cylcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFzc2lnbnMgYW4gYWNjb3VudCB0byBhIHByb2dyYW1cbiAgICovXG4gIHN0YXRpYyBhc3NpZ24ocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgcHJvZ3JhbUlkXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudFdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLmJhc2VQdWJrZXkgIT0gcGFyYW1zLmZyb21QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTm9uY2VBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMgJiYgJ3NlZWQnIGluIHBhcmFtcykge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudFdpdGhTZWVkKHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgYmFzZVB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgbm9uY2VQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5XG4gICAgfTtcbiAgICB0cmFuc2FjdGlvbi5hZGQodGhpcy5ub25jZUluaXRpYWxpemUoaW5pdFBhcmFtcykpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBpbml0aWFsaXplIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlSW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMuYXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gYWR2YW5jZSB0aGUgbm9uY2UgaW4gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VBZHZhbmNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCB3aXRoZHJhd3MgbGFtcG9ydHMgZnJvbSBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZVdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyB0aGUgYXV0aG9yaXR5XG4gICAqIG9uIGEgTm9uY2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBub25jZUF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5uZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFsbG9jYXRlcyBzcGFjZSBpbiBhbiBhY2NvdW50IHdpdGhvdXQgZnVuZGluZ1xuICAgKi9cbiAgc3RhdGljIGFsbG9jYXRlKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGU7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2VcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5TeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8vIEtlZXAgcHJvZ3JhbSBjaHVua3MgdW5kZXIgUEFDS0VUX0RBVEFfU0laRSwgbGVhdmluZyBlbm91Z2ggcm9vbSBmb3IgdGhlXG4vLyByZXN0IG9mIHRoZSBUcmFuc2FjdGlvbiBmaWVsZHNcbi8vXG4vLyBUT0RPOiByZXBsYWNlIDMwMCB3aXRoIGEgcHJvcGVyIGNvbnN0YW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgb3RoZXJcbi8vIFRyYW5zYWN0aW9uIGZpZWxkc1xuY29uc3QgQ0hVTktfU0laRSA9IFBBQ0tFVF9EQVRBX1NJWkUgLSAzMDA7XG5cbi8qKlxuICogUHJvZ3JhbSBsb2FkZXIgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIExvYWRlciB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogQW1vdW50IG9mIHByb2dyYW0gZGF0YSBwbGFjZWQgaW4gZWFjaCBsb2FkIFRyYW5zYWN0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiAyICogKFxuICAgIC8vIEV2ZXJ5IHRyYW5zYWN0aW9uIHJlcXVpcmVzIHR3byBzaWduYXR1cmVzIChwYXllciArIHByb2dyYW0pXG4gICAgTWF0aC5jZWlsKGRhdGFMZW5ndGggLyBMb2FkZXIuY2h1bmtTaXplKSArIDEgK1xuICAgIC8vIEFkZCBvbmUgZm9yIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgIDEpIC8vIEFkZCBvbmUgZm9yIEZpbmFsaXplIHRyYW5zYWN0aW9uXG4gICAgO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgZ2VuZXJpYyBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgU3lzdGVtIGFjY291bnQgdGhhdCBwYXlzIHRvIGxvYWQgdGhlIHByb2dyYW1cbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIHByb2dyYW1JZCBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgbG9hZGVyXG4gICAqIEBwYXJhbSBkYXRhIFByb2dyYW0gb2N0ZXRzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9ncmFtIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBwcm9ncmFtIHdhcyBhbHJlYWR5IGxvYWRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIHByb2dyYW1JZCwgZGF0YSkge1xuICAgIHtcbiAgICAgIGNvbnN0IGJhbGFuY2VOZWVkZWQgPSBhd2FpdCBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhLmxlbmd0aCk7XG5cbiAgICAgIC8vIEZldGNoIHByb2dyYW0gYWNjb3VudCBpbmZvIHRvIGNoZWNrIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHByb2dyYW0ucHVibGljS2V5LCAnY29uZmlybWVkJyk7XG4gICAgICBsZXQgdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgaWYgKHByb2dyYW1JbmZvICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsb2FkIGZhaWxlZCwgYWNjb3VudCBpcyBhbHJlYWR5IGV4ZWN1dGFibGUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYWxsb2NhdGUoe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGhcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9ncmFtSW5mby5vd25lci5lcXVhbHMocHJvZ3JhbUlkKSkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYXNzaWduKHtcbiAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgcHJvZ3JhbUlkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5sYW1wb3J0cyA8IGJhbGFuY2VOZWVkZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHRvUHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkIC0gcHJvZ3JhbUluZm8ubGFtcG9ydHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkID4gMCA/IGJhbGFuY2VOZWVkZWQgOiAxLFxuICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgYWNjb3VudCBpcyBhbHJlYWR5IGNyZWF0ZWQgY29ycmVjdGx5LCBza2lwIHRoaXMgc3RlcFxuICAgICAgLy8gYW5kIHByb2NlZWQgZGlyZWN0bHkgdG8gbG9hZGluZyBpbnN0cnVjdGlvbnNcbiAgICAgIGlmICh0cmFuc2FjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdvZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCdieXRlJyksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdieXRlcycpXSk7XG4gICAgY29uc3QgY2h1bmtTaXplID0gTG9hZGVyLmNodW5rU2l6ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgYXJyYXkgPSBkYXRhO1xuICAgIGxldCB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoYXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheS5zbGljZSgwLCBjaHVua1NpemUpO1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhjaHVua1NpemUgKyAxNik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAwLFxuICAgICAgICAvLyBMb2FkIGluc3RydWN0aW9uXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgICBieXRlc0xlbmd0aDogMCxcbiAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiAwXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbnMucHVzaChzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIERlbGF5IGJldHdlZW4gc2VuZHMgaW4gYW4gYXR0ZW1wdCB0byByZWR1Y2UgcmF0ZSBsaW1pdCBlcnJvcnNcbiAgICAgIGlmIChjb25uZWN0aW9uLl9ycGNFbmRwb2ludC5pbmNsdWRlcygnc29sYW5hLmNvbScpKSB7XG4gICAgICAgIGNvbnN0IFJFUVVFU1RTX1BFUl9TRUNPTkQgPSA0O1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwIC8gUkVRVUVTVFNfUEVSX1NFQ09ORCk7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgYXJyYXkgPSBhcnJheS5zbGljZShjaHVua1NpemUpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMpO1xuXG4gICAgLy8gRmluYWxpemUgdGhlIGFjY291bnQgbG9hZGVkIHdpdGggcHJvZ3JhbSBkYXRhIGZvciBleGVjdXRpb25cbiAgICB7XG4gICAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pO1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgICBpbnN0cnVjdGlvbjogMSAvLyBGaW5hbGl6ZSBpbnN0cnVjdGlvblxuICAgICAgfSwgZGF0YSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZXBsb3lDb21taXRtZW50ID0gJ3Byb2Nlc3NlZCc7XG4gICAgICBjb25zdCBmaW5hbGl6ZVNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiBmaW5hbGl6ZVNpZ25hdHVyZSxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgICBibG9ja2hhc2g6IHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaFxuICAgICAgfSwgZGVwbG95Q29tbWl0bWVudCk7XG4gICAgICBpZiAodmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtmaW5hbGl6ZVNpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYCk7XG4gICAgICB9XG4gICAgICAvLyBXZSBwcmV2ZW50IHByb2dyYW1zIGZyb20gYmVpbmcgdXNhYmxlIHVudGlsIHRoZSBzbG90IGFmdGVyIHRoZWlyIGRlcGxveW1lbnQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI5NjU0XG4gICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFNsb3QgPSBhd2FpdCBjb25uZWN0aW9uLmdldFNsb3Qoe1xuICAgICAgICAgICAgY29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjdXJyZW50U2xvdCA+IGNvbnRleHQuc2xvdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJvdW5kKE1TX1BFUl9TTE9UIC8gMikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdWNjZXNzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbkxvYWRlci5jaHVua1NpemUgPSBDSFVOS19TSVpFO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjE3LjIwLlxuICovXG5jb25zdCBCUEZfTE9BREVSX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdCUEZMb2FkZXIyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggYSBwcm9ncmFtIGxvYWRlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjE3LjIwLlxuICovXG5jbGFzcyBCcGZMb2FkZXIge1xuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gTG9hZGVyLmdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIFNCRiBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgQWNjb3VudCB0aGF0IHdpbGwgcGF5IHByb2dyYW0gbG9hZGluZyBmZWVzXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBlbGYgVGhlIGVudGlyZSBFTEYgY29udGFpbmluZyB0aGUgU0JGIHByb2dyYW1cbiAgICogQHBhcmFtIGxvYWRlclByb2dyYW1JZCBUaGUgcHJvZ3JhbSBpZCBvZiB0aGUgQlBGIGxvYWRlciB0byB1c2VcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgZWxmLCBsb2FkZXJQcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gTG9hZGVyLmxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGxvYWRlclByb2dyYW1JZCwgZWxmKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgYWdlbnRrZWVwYWxpdmUgPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIG1zJDIgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbi8qIVxuICogaHVtYW5pemUtbXMgLSBpbmRleC5qc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgZGVhZF9ob3JzZSA8ZGVhZF9ob3JzZUBxcS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlJCQwO1xudmFyIG1zJDEgPSBtcyQyO1xuXG52YXIgaHVtYW5pemVNcyA9IGZ1bmN0aW9uICh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicpIHJldHVybiB0O1xuICB2YXIgciA9IG1zJDEodCk7XG4gIGlmIChyID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdodW1hbml6ZS1tcyglaikgcmVzdWx0IHVuZGVmaW5lZCcsIHQpKTtcbiAgICBjb25zb2xlLndhcm4oZXJyLnN0YWNrKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbnZhciBjb25zdGFudHMgPSB7XG4gIC8vIGFnZW50XG4gIENVUlJFTlRfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3VycmVudElkJyksXG4gIENSRUFURV9JRDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVJZCcpLFxuICBJTklUX1NPQ0tFVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNpbml0U29ja2V0JyksXG4gIENSRUFURV9IVFRQU19DT05ORUNUSU9OOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUh0dHBzQ29ubmVjdGlvbicpLFxuICAvLyBzb2NrZXRcbiAgU09DS0VUX0NSRUFURURfVElNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRDcmVhdGVkVGltZScpLFxuICBTT0NLRVRfTkFNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXROYW1lJyksXG4gIFNPQ0tFVF9SRVFVRVNUX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RDb3VudCcpLFxuICBTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRSZXF1ZXN0RmluaXNoZWRDb3VudCcpLFxufTtcblxuY29uc3QgT3JpZ2luYWxBZ2VudCA9IHJlcXVpcmUkJDAkMS5BZ2VudDtcbmNvbnN0IG1zID0gaHVtYW5pemVNcztcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSQkMC5kZWJ1Z2xvZygnYWdlbnRrZWVwYWxpdmUnKTtcbmNvbnN0IHtcbiAgSU5JVF9TT0NLRVQ6IElOSVRfU09DS0VUJDEsXG4gIENVUlJFTlRfSUQsXG4gIENSRUFURV9JRCxcbiAgU09DS0VUX0NSRUFURURfVElNRSxcbiAgU09DS0VUX05BTUUsXG4gIFNPQ0tFVF9SRVFVRVNUX0NPVU5ULFxuICBTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVCxcbn0gPSBjb25zdGFudHM7XG5cbi8vIE9yaWdpbmFsQWdlbnQgY29tZSBmcm9tXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjEyLjAvbGliL19odHRwX2FnZW50LmpzXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXG4vLyBub2RlIDw9IDEwXG5sZXQgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMTtcbmNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicsIDEpWzBdLnN1YnN0cmluZygxKSk7XG5pZiAobWFqb3JWZXJzaW9uID49IDExICYmIG1ham9yVmVyc2lvbiA8PSAxMikge1xuICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAyO1xufSBlbHNlIGlmIChtYWpvclZlcnNpb24gPj0gMTMpIHtcbiAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMztcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coJ1thZ2VudGtlZXBhbGl2ZTpkZXByZWNhdGVkXSAlcycsIG1lc3NhZ2UpO1xufVxuXG5jbGFzcyBBZ2VudCBleHRlbmRzIE9yaWdpbmFsQWdlbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5rZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZSAhPT0gZmFsc2U7XG4gICAgLy8gZGVmYXVsdCBpcyBrZWVwLWFsaXZlIGFuZCA0cyBmcmVlIHNvY2tldCB0aW1lb3V0XG4gICAgLy8gc2VlIGh0dHBzOi8vbWVkaXVtLmNvbS9zc2Vuc2UtdGVjaC9yZWR1Y2UtbmV0d29ya2luZy1lcnJvcnMtaW4tbm9kZWpzLTIzYjRlYjlmMmQ4M1xuICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSA0MDAwO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgQVBJOiBrZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQpIHtcbiAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG4gICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuICAgICAgZGVsZXRlIG9wdGlvbnMua2VlcEFsaXZlVGltZW91dDtcbiAgICB9XG4gICAgLy8gTGVnYWN5IEFQSTogZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG4gICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQpIHtcbiAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICBkZWxldGUgb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuXG4gICAgLy8gQnkgZGVmYXVsdCBpcyBkb3VibGUgZnJlZSBzb2NrZXQgdGltZW91dC5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBzb2NrZXQgZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXQgPj0gOHNcbiAgICAgIG9wdGlvbnMudGltZW91dCA9IE1hdGgubWF4KG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgKiAyLCA4MDAwKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IGh1bWFuaXplIGZvcm1hdFxuICAgIG9wdGlvbnMudGltZW91dCA9IG1zKG9wdGlvbnMudGltZW91dCk7XG4gICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG1zKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQpO1xuICAgIG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID0gb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPyBtcyhvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkgOiAwO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzW0NVUlJFTlRfSURdID0gMDtcblxuICAgIC8vIGNyZWF0ZSBzb2NrZXQgc3VjY2VzcyBjb3VudGVyXG4gICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgPSAwO1xuICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICAvLyBzb2NrZXQgZXJyb3IgZXZlbnQgY291bnRcbiAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICAvLyByZXF1ZXN0IGZpbmlzaGVkIGNvdW50ZXJcbiAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG4gICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgLy8gaW5jbHVkaW5nIGZyZWUgc29ja2V0IHRpbWVvdXQgY291bnRlclxuICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ID0gMDtcbiAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICB0aGlzLm9uKCdmcmVlJywgc29ja2V0ID0+IHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwXG4gICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBhZ2VudCB3aWxsIGNoZWNrIHNvY2tldCB0aW1lb3V0IGVxcyBhZ2VudC5vcHRpb25zLnRpbWVvdXQuXG4gICAgICAvLyBVc2UgdGhlIHR0bCBvciBmcmVlU29ja2V0VGltZW91dCB0byBvdmVyd3JpdGUuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgICAgaWYgKHRpbWVvdXQgPiAwICYmIHNvY2tldC50aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG4gICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KCkge1xuICAgIGRlcHJlY2F0ZSgnYWdlbnQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0O1xuICB9XG5cbiAgZ2V0IHRpbWVvdXQoKSB7XG4gICAgZGVwcmVjYXRlKCdhZ2VudC50aW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy50aW1lb3V0IGluc3RlYWQnKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gIH1cblxuICBnZXQgc29ja2V0QWN0aXZlVFRMKCkge1xuICAgIGRlcHJlY2F0ZSgnYWdlbnQuc29ja2V0QWN0aXZlVFRMIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuICB9XG5cbiAgY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KSB7XG4gICAgLyoqXG4gICAgICogcmV0dXJuIDw9IDA6IHNob3VsZCBmcmVlIHNvY2tldFxuICAgICAqIHJldHVybiA+IDA6IHNob3VsZCB1cGRhdGUgc29ja2V0IHRpbWVvdXRcbiAgICAgKiByZXR1cm4gdW5kZWZpbmVkOiBub3QgZmluZCBjdXN0b20gdGltZW91dFxuICAgICAqL1xuICAgIGxldCBmcmVlU29ja2V0VGltZW91dCA9IHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcbiAgICBjb25zdCBzb2NrZXRBY3RpdmVUVEwgPSB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuICAgIGlmIChzb2NrZXRBY3RpdmVUVEwpIHtcbiAgICAgIC8vIGNoZWNrIHNvY2tldEFjdGl2ZVRUTFxuICAgICAgY29uc3QgYWxpdmVUaW1lID0gRGF0ZS5ub3coKSAtIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXTtcbiAgICAgIGNvbnN0IGRpZmYgPSBzb2NrZXRBY3RpdmVUVEwgLSBhbGl2ZVRpbWU7XG4gICAgICBpZiAoZGlmZiA8PSAwKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfVxuICAgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0ICYmIGRpZmYgPCBmcmVlU29ja2V0VGltZW91dCkge1xuICAgICAgICBmcmVlU29ja2V0VGltZW91dCA9IGRpZmY7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBmcmVlU29ja2V0VGltZW91dFxuICAgIGlmIChmcmVlU29ja2V0VGltZW91dCkge1xuICAgICAgLy8gc2V0IGZyZWUga2VlcGFsaXZlIHRpbWVyXG4gICAgICAvLyB0cnkgdG8gdXNlIHNvY2tldCBjdXN0b20gZnJlZVNvY2tldFRpbWVvdXQgZmlyc3QsIHN1cHBvcnQgaGVhZGVyc1sna2VlcC1hbGl2ZSddXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1tb2R1bGVzL3VybGxpYi9ibG9iL2I3NjA1MzAyMDkyM2Y0ZDk5YTFjOTNjZjJlMTZlMGM1YmExMGJhY2YvbGliL3VybGxpYi5qcyNMNDk4XG4gICAgICBjb25zdCBjdXN0b21GcmVlU29ja2V0VGltZW91dCA9IHNvY2tldC5mcmVlU29ja2V0VGltZW91dCB8fCBzb2NrZXQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICByZXR1cm4gY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgfHwgZnJlZVNvY2tldFRpbWVvdXQ7XG4gICAgfVxuICB9XG5cbiAga2VlcFNvY2tldEFsaXZlKHNvY2tldCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmtlZXBTb2NrZXRBbGl2ZShzb2NrZXQpO1xuICAgIC8vIHNob3VsZCBub3Qga2VlcEFsaXZlLCBkbyBub3RoaW5nXG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cbiAgICBjb25zdCBjdXN0b21UaW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tVGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tVGltZW91dCA8PSAwKSB7XG4gICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUgYnV0IG5lZWQgdG8gZGVzdHJveSBieSBUVEwsIHJlcXVlc3QgY291bnQgJXMsIGRpZmYgaXMgJXMnLFxuICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBjdXN0b21UaW1lb3V0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNvY2tldC50aW1lb3V0ICE9PSBjdXN0b21UaW1lb3V0KSB7XG4gICAgICBzb2NrZXQuc2V0VGltZW91dChjdXN0b21UaW1lb3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBvbmx5IGNhbGwgb24gYWRkUmVxdWVzdFxuICByZXVzZVNvY2tldCguLi5hcmdzKSB7XG4gICAgLy8gcmV1c2VTb2NrZXQoc29ja2V0LCByZXEpXG4gICAgc3VwZXIucmV1c2VTb2NrZXQoLi4uYXJncyk7XG4gICAgY29uc3Qgc29ja2V0ID0gYXJnc1swXTtcbiAgICBjb25zdCByZXEgPSBhcmdzWzFdO1xuICAgIHJlcS5yZXVzZWRTb2NrZXQgPSB0cnVlO1xuICAgIGNvbnN0IGFnZW50VGltZW91dCA9IHRoaXMub3B0aW9ucy50aW1lb3V0O1xuICAgIGlmIChnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkgIT09IGFnZW50VGltZW91dCkge1xuICAgICAgLy8gcmVzZXQgdGltZW91dCBiZWZvcmUgdXNlXG4gICAgICBzb2NrZXQuc2V0VGltZW91dChhZ2VudFRpbWVvdXQpO1xuICAgICAgZGVidWcoJyVzIHJlc2V0IHRpbWVvdXQgdG8gJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGFnZW50VGltZW91dCk7XG4gICAgfVxuICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0rKztcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHJldXNlIG9uIGFkZFJlcXVlc3QsIHRpbWVvdXQgJXNtcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuICAgICAgZ2V0U29ja2V0VGltZW91dChzb2NrZXQpKTtcbiAgfVxuXG4gIFtDUkVBVEVfSURdKCkge1xuICAgIGNvbnN0IGlkID0gdGhpc1tDVVJSRU5UX0lEXSsrO1xuICAgIGlmICh0aGlzW0NVUlJFTlRfSURdID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgW0lOSVRfU09DS0VUJDFdKHNvY2tldCwgb3B0aW9ucykge1xuICAgIC8vIGJ1Z2ZpeCBoZXJlLlxuICAgIC8vIGh0dHBzIG9uIG5vZGUgOCwgMTAgd29uJ3Qgc2V0IGFnZW50Lm9wdGlvbnMudGltZW91dCBieSBkZWZhdWx0XG4gICAgLy8gVE9ETzogbmVlZCB0byBmaXggb24gbm9kZSBpdHNlbGZcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIERpc2FibGUgTmFnbGUncyBhbGdvcml0aG06IGh0dHA6Ly9ibG9nLmNhdXN0aWsuY29tLzIwMTIvMDQvMDgvc2NhbGluZy1ub2RlLWpzLXRvLTEwMGstY29uY3VycmVudC1jb25uZWN0aW9ucy9cbiAgICAgIC8vIGh0dHBzOi8vZmVuZ21rMi5jb20vYmVuY2htYXJrL25hZ2xlLWFsZ29yaXRobS1kZWxheWVkLWFjay1tb2NrLmh0bWxcbiAgICAgIHNvY2tldC5zZXROb0RlbGF5KHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50Kys7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIHtcbiAgICAgIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIC8vIGRvbid0IHNob3cgdGhlIGhvbGUgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tJyBrZXkgc3RyaW5nXG4gICAgc29ja2V0W1NPQ0tFVF9OQU1FXSA9IGBzb2NrWyR7dGhpc1tDUkVBVEVfSURdKCl9IyR7b3B0aW9ucy5fYWdlbnRLZXl9XWAuc3BsaXQoJy0tLS0tQkVHSU4nLCAxKVswXTtcbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID0gMTtcbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdID0gMDtcbiAgICBpbnN0YWxsTGlzdGVuZXJzKHRoaXMsIHNvY2tldCwgb3B0aW9ucyk7XG4gIH1cblxuICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IG9uTmV3Q3JlYXRlID0gKGVyciwgc29ja2V0KSA9PiB7XG4gICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCsrO1xuICAgICAgICByZXR1cm4gb25jcmVhdGUoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbSU5JVF9TT0NLRVQkMV0oc29ja2V0LCBvcHRpb25zKTtcbiAgICAgIG9uY3JlYXRlKGVyciwgc29ja2V0KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbmV3U29ja2V0ID0gc3VwZXIuY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbk5ld0NyZWF0ZSk7XG4gICAgaWYgKG5ld1NvY2tldCkgb25OZXdDcmVhdGUobnVsbCwgbmV3U29ja2V0KTtcbiAgICByZXR1cm4gbmV3U29ja2V0O1xuICB9XG5cbiAgZ2V0IHN0YXR1c0NoYW5nZWQoKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCAhPT0gdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgIT09IHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50ICE9PSB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ICE9PSB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5yZXF1ZXN0Q291bnQgIT09IHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudDtcbiAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY2xvc2VTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuZXJyb3JTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy50aW1lb3V0U29ja2V0Q291bnQ7XG4gICAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IHRoaXMucmVxdWVzdENvdW50O1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIGdldEN1cnJlbnRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZVNvY2tldENvdW50OiB0aGlzLmNyZWF0ZVNvY2tldENvdW50LFxuICAgICAgY3JlYXRlU29ja2V0RXJyb3JDb3VudDogdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50LFxuICAgICAgY2xvc2VTb2NrZXRDb3VudDogdGhpcy5jbG9zZVNvY2tldENvdW50LFxuICAgICAgZXJyb3JTb2NrZXRDb3VudDogdGhpcy5lcnJvclNvY2tldENvdW50LFxuICAgICAgdGltZW91dFNvY2tldENvdW50OiB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCxcbiAgICAgIHJlcXVlc3RDb3VudDogdGhpcy5yZXF1ZXN0Q291bnQsXG4gICAgICBmcmVlU29ja2V0czogaW5zcGVjdCh0aGlzLmZyZWVTb2NrZXRzKSxcbiAgICAgIHNvY2tldHM6IGluc3BlY3QodGhpcy5zb2NrZXRzKSxcbiAgICAgIHJlcXVlc3RzOiBpbnNwZWN0KHRoaXMucmVxdWVzdHMpLFxuICAgIH07XG4gIH1cbn1cblxuLy8gbm9kZSA4IGRvbid0IGhhcyB0aW1lb3V0IGF0dHJpYnV0ZSBvbiBzb2NrZXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzIxMjA0L2ZpbGVzI2RpZmYtZTZlZjAyNGMzNzc1ZDc4N2MzODQ4N2E2MzA5ZTQ5MWRSNDA4XG5mdW5jdGlvbiBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuICByZXR1cm4gc29ja2V0LnRpbWVvdXQgfHwgc29ja2V0Ll9pZGxlVGltZW91dDtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbExpc3RlbmVycyhhZ2VudCwgc29ja2V0LCBvcHRpb25zKSB7XG4gIGRlYnVnKCclcyBjcmVhdGUsIHRpbWVvdXQgJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cbiAgLy8gbGlzdGVuZXIgc29ja2V0IGV2ZW50czogY2xvc2UsIHRpbWVvdXQsIGVycm9yLCBmcmVlXG4gIGZ1bmN0aW9uIG9uRnJlZSgpIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNvY2tldC5lbWl0KCdmcmVlJykgbG9naWNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL19odHRwX2FnZW50LmpzI0wzMTFcbiAgICAvLyBubyByZXEgb24gdGhlIHNvY2tldCwgaXQgc2hvdWxkIGJlIHRoZSBuZXcgc29ja2V0XG4gICAgaWYgKCFzb2NrZXQuX2h0dHBNZXNzYWdlICYmIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPT09IDEpIHJldHVybjtcblxuICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0rKztcbiAgICBhZ2VudC5yZXF1ZXN0Q291bnQrKztcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cbiAgICAvLyBzaG91bGQgcmV1c2Ugb24gcGVkZGluZyByZXF1ZXN0cz9cbiAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcbiAgICBpZiAoc29ja2V0LndyaXRhYmxlICYmIGFnZW50LnJlcXVlc3RzW25hbWVdICYmIGFnZW50LnJlcXVlc3RzW25hbWVdLmxlbmd0aCkge1xuICAgICAgLy8gd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGxpc3RlbmVyXG4gICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG4gICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBldmVudCcsXG4gICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuICAgIH1cbiAgfVxuICBzb2NrZXQub24oJ2ZyZWUnLCBvbkZyZWUpO1xuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UoaXNFcnJvcikge1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgY2xvc2UsIGlzRXJyb3I6ICVzJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGlzRXJyb3IpO1xuICAgIGFnZW50LmNsb3NlU29ja2V0Q291bnQrKztcbiAgfVxuICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZSk7XG5cbiAgLy8gc3RhcnQgc29ja2V0IHRpbWVvdXQgaGFuZGxlclxuICBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgLy8gb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXQoX2h0dHBfY2xpZW50LmpzKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMi54L2xpYi9faHR0cF9jbGllbnQuanMjTDcxMVxuICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSBzb2NrZXQubGlzdGVuZXJzKCd0aW1lb3V0JykubGVuZ3RoO1xuICAgIC8vIG5vZGUgPD0gMTAsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAxLCBvblRpbWVvdXRcbiAgICAvLyAxMSA8IG5vZGUgPD0gMTIsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAyLCBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuICAgIC8vIG5vZGUgPj0gMTMsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAzLCBvblRpbWVvdXQsXG4gICAgLy8gICBvblRpbWVvdXQoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDAvZmlsZXMjZGlmZi01ZjdmYjA4NTA0MTJjNmJlMTg5ZmFlZGRlYTZjNTM1OVIzMzMpXG4gICAgLy8gICBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG4gICAgY29uc3QgdGltZW91dCA9IGdldFNvY2tldFRpbWVvdXQoc29ja2V0KTtcbiAgICBjb25zdCByZXEgPSBzb2NrZXQuX2h0dHBNZXNzYWdlO1xuICAgIGNvbnN0IHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID0gcmVxICYmIHJlcS5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGggfHwgMDtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHRpbWVvdXQgYWZ0ZXIgJXNtcywgbGlzdGVuZXJzICVzLCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgJXMsIGhhc0h0dHBSZXF1ZXN0ICVzLCBIdHRwUmVxdWVzdCB0aW1lb3V0TGlzdGVuZXJDb3VudCAlcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuICAgICAgdGltZW91dCwgbGlzdGVuZXJDb3VudCwgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50LCAhIXJlcSwgcmVxVGltZW91dExpc3RlbmVyQ291bnQpO1xuICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICBkZWJ1ZygndGltZW91dCBsaXN0ZW5lcnM6ICVzJywgc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLm1hcChmID0+IGYubmFtZSkuam9pbignLCAnKSk7XG4gICAgfVxuICAgIGFnZW50LnRpbWVvdXRTb2NrZXRDb3VudCsrO1xuICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuICAgIGlmIChhZ2VudC5mcmVlU29ja2V0c1tuYW1lXSAmJiBhZ2VudC5mcmVlU29ja2V0c1tuYW1lXS5pbmRleE9mKHNvY2tldCkgIT09IC0xKSB7XG4gICAgICAvLyBmcmVlIHNvY2tldCB0aW1lb3V0LCBkZXN0cm95IHF1aWV0bHlcbiAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgbmV3IHJlcXVlc3RzXG4gICAgICAvLyBmcm9tIGJlaW5nIHNlbnQgdGhyb3VnaCB0aGlzIHNvY2tldC5cbiAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuICAgICAgZGVidWcoJyVzIGlzIGZyZWUsIGRlc3Ryb3kgcXVpZXRseScsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBhbnkgcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGVyLFxuICAgICAgLy8gYWdlbnQgbmVlZCB0byBoYW5kbGUgc29ja2V0IHRpbWVvdXQgaXRzZWxmLlxuICAgICAgLy9cbiAgICAgIC8vIGN1c3RvbSByZXF1ZXN0IHNvY2tldCB0aW1lb3V0IGhhbmRsZSBsb2dpYyBtdXN0IGZvbGxvdyB0aGVzZSBydWxlczpcbiAgICAgIC8vICAxLiBEZXN0cm95IHNvY2tldCBmaXJzdFxuICAgICAgLy8gIDIuIE11c3QgZW1pdCBzb2NrZXQgJ2FnZW50UmVtb3ZlJyBldmVudCB0ZWxsIGFnZW50IHJlbW92ZSBzb2NrZXRcbiAgICAgIC8vICAgICBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkuXG4gICAgICAvLyAgICAgT3RoZXJpc2UgeW91IG1heSBiZSBnZXQgJ3NvY2tldCBoYW5nIHVwJyBlcnJvciB3aGVuIHJldXNlXG4gICAgICAvLyAgICAgZnJlZSBzb2NrZXQgYW5kIHRpbWVvdXQgaGFwcGVuIGluIHRoZSBzYW1lIHRpbWUuXG4gICAgICBpZiAocmVxVGltZW91dExpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvY2tldCB0aW1lb3V0Jyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnRVJSX1NPQ0tFVF9USU1FT1VUJztcbiAgICAgICAgZXJyb3IudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIC8vIG11c3QgbWFudWFsbHkgY2FsbCBzb2NrZXQuZW5kKCkgb3Igc29ja2V0LmRlc3Ryb3koKSB0byBlbmQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12MTAueC9kb2NzL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFja1xuICAgICAgICBzb2NrZXQuZGVzdHJveShlcnJvcik7XG4gICAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuICAgICAgICBkZWJ1ZygnJXMgZGVzdHJveSB3aXRoIHRpbWVvdXQgZXJyb3InLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc29ja2V0Lm9uKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSBzb2NrZXQubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aDtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGVycm9yOiAlcywgbGlzdGVuZXJDb3VudDogJXMnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcbiAgICAgIGVyciwgbGlzdGVuZXJDb3VudCk7XG4gICAgYWdlbnQuZXJyb3JTb2NrZXRDb3VudCsrO1xuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAvLyBpZiBzb2NrZXQgZG9uJ3QgY29udGFpbiBlcnJvciBldmVudCBoYW5kbGVyLCBkb24ndCBjYXRjaCBpdCwgZW1pdCBpdCBhZ2FpblxuICAgICAgZGVidWcoJyVzIGVtaXQgdW5jYXVnaHQgZXJyb3IgZXZlbnQnLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICB9XG4gIHNvY2tldC5vbignZXJyb3InLCBvbkVycm9yKTtcblxuICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGFnZW50UmVtb3ZlJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sXG4gICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcbiAgICAvLyBXZSBuZWVkIHRoaXMgZnVuY3Rpb24gZm9yIGNhc2VzIGxpa2UgSFRUUCAndXBncmFkZSdcbiAgICAvLyAoZGVmaW5lZCBieSBXZWJTb2NrZXRzKSB3aGVyZSB3ZSBuZWVkIHRvIHJlbW92ZSBhIHNvY2tldCBmcm9tIHRoZVxuICAgIC8vIHBvb2wgYmVjYXVzZSBpdCdsbCBiZSBsb2NrZWQgdXAgaW5kZWZpbml0ZWx5XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2ZyZWUnLCBvbkZyZWUpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIG9uVGltZW91dCk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdhZ2VudFJlbW92ZScsIG9uUmVtb3ZlKTtcbiAgfVxuICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xufVxuXG52YXIgYWdlbnQgPSBBZ2VudDtcblxuZnVuY3Rpb24gaW5zcGVjdChvYmopIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc1trZXldID0gb2JqW2tleV0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmNvbnN0IE9yaWdpbmFsSHR0cHNBZ2VudCA9IHJlcXVpcmUkJDAkMi5BZ2VudDtcbmNvbnN0IEh0dHBBZ2VudCA9IGFnZW50O1xuY29uc3Qge1xuICBJTklUX1NPQ0tFVCxcbiAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04sXG59ID0gY29uc3RhbnRzO1xuXG5sZXQgSHR0cHNBZ2VudCQxID0gY2xhc3MgSHR0cHNBZ2VudCBleHRlbmRzIEh0dHBBZ2VudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuZGVmYXVsdFBvcnQgPSA0NDM7XG4gICAgdGhpcy5wcm90b2NvbCA9ICdodHRwczonO1xuICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSB0aGlzLm9wdGlvbnMubWF4Q2FjaGVkU2Vzc2lvbnM7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gMTAwO1xuICAgIH1cblxuICAgIHRoaXMuX3Nlc3Npb25DYWNoZSA9IHtcbiAgICAgIG1hcDoge30sXG4gICAgICBsaXN0OiBbXSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXNbQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT05dKG9wdGlvbnMsIG9uY3JlYXRlKTtcbiAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzb2NrZXQ7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaHR0cHMuanMjTDg5XG5IdHRwc0FnZW50JDEucHJvdG90eXBlW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbjtcblxuW1xuICAnZ2V0TmFtZScsXG4gICdfZ2V0U2Vzc2lvbicsXG4gICdfY2FjaGVTZXNzaW9uJyxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDk4MlxuICAnX2V2aWN0U2Vzc2lvbicsXG5dLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgSHR0cHNBZ2VudCQxLnByb3RvdHlwZVttZXRob2RdID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59KTtcblxudmFyIGh0dHBzX2FnZW50ID0gSHR0cHNBZ2VudCQxO1xuXG5hZ2VudGtlZXBhbGl2ZS5leHBvcnRzID0gYWdlbnQ7XG52YXIgSHR0cHNBZ2VudCA9IGFnZW50a2VlcGFsaXZlLmV4cG9ydHMuSHR0cHNBZ2VudCA9IGh0dHBzX2FnZW50O1xuYWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG5cbnZhciBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMgPSBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xudmFyIEh0dHBLZWVwQWxpdmVBZ2VudCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhhZ2VudGtlZXBhbGl2ZUV4cG9ydHMpO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIga2V5cyA9IFtdO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRrZXlzLnB1c2gobmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiBrZXlzO1xuXHR9O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsLCBpc0FycmF5UHJvcCkge1xuXHR2YXIgaSwgbWF4LCBzdHIsIGtleXMsIGtleSwgcHJvcFZhbCwgdG9TdHI7XG5cdGlmICh2YWwgPT09IHRydWUpIHtcblx0XHRyZXR1cm4gXCJ0cnVlXCI7XG5cdH1cblx0aWYgKHZhbCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gXCJmYWxzZVwiO1xuXHR9XG5cdHN3aXRjaCAodHlwZW9mIHZhbCkge1xuXHRcdGNhc2UgXCJvYmplY3RcIjpcblx0XHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbC50b0pTT04gJiYgdHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbC50b0pTT04oKSwgaXNBcnJheVByb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9TdHIgPSBvYmpUb1N0cmluZy5jYWxsKHZhbCk7XG5cdFx0XHRcdGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRcdFx0c3RyID0gJ1snO1xuXHRcdFx0XHRcdG1heCA9IHZhbC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSkgKyAnLCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXggPiAtMSkge1xuXHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RyICsgJ10nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRvU3RyID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRcdFx0Ly8gb25seSBvYmplY3QgaXMgbGVmdFxuXHRcdFx0XHRcdGtleXMgPSBvYmpLZXlzKHZhbCkuc29ydCgpO1xuXHRcdFx0XHRcdG1heCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRcdHN0ciA9IFwiXCI7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0XHRwcm9wVmFsID0gc3RyaW5naWZ5KHZhbFtrZXldLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRpZiAocHJvcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzdHIpIHtcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gJywnO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzonICsgcHJvcFZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICd7JyArIHN0ciArICd9Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdGNhc2UgXCJmdW5jdGlvblwiOlxuXHRcdGNhc2UgXCJ1bmRlZmluZWRcIjpcblx0XHRcdHJldHVybiBpc0FycmF5UHJvcCA/IG51bGwgOiB1bmRlZmluZWQ7XG5cdFx0Y2FzZSBcInN0cmluZ1wiOlxuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBpc0Zpbml0ZSh2YWwpID8gdmFsIDogbnVsbDtcblx0fVxufVxuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSA9IGZ1bmN0aW9uKHZhbCkge1xuXHR2YXIgcmV0dXJuVmFsID0gc3RyaW5naWZ5KHZhbCwgZmFsc2UpO1xuXHRpZiAocmV0dXJuVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gJycrIHJldHVyblZhbDtcblx0fVxufTtcblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmYXN0U3RhYmxlU3RyaW5naWZ5KTtcblxuY29uc3QgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCA9IDMyO1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBzZWxmLlxuZnVuY3Rpb24gdHJhaWxpbmdaZXJvcyhuKSB7XG4gIGxldCB0cmFpbGluZ1plcm9zID0gMDtcbiAgd2hpbGUgKG4gPiAxKSB7XG4gICAgbiAvPSAyO1xuICAgIHRyYWlsaW5nWmVyb3MrKztcbiAgfVxuICByZXR1cm4gdHJhaWxpbmdaZXJvcztcbn1cblxuLy8gUmV0dXJucyB0aGUgc21hbGxlc3QgcG93ZXIgb2YgdHdvIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBuXG5mdW5jdGlvbiBuZXh0UG93ZXJPZlR3byhuKSB7XG4gIGlmIChuID09PSAwKSByZXR1cm4gMTtcbiAgbi0tO1xuICBuIHw9IG4gPj4gMTtcbiAgbiB8PSBuID4+IDI7XG4gIG4gfD0gbiA+PiA0O1xuICBuIHw9IG4gPj4gODtcbiAgbiB8PSBuID4+IDE2O1xuICBuIHw9IG4gPj4gMzI7XG4gIHJldHVybiBuICsgMTtcbn1cblxuLyoqXG4gKiBFcG9jaCBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNlcG9jaClcbiAqIENhbiBiZSByZXRyaWV2ZWQgd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb24uZ2V0RXBvY2hTY2hlZHVsZX0gbWV0aG9kXG4gKi9cbmNsYXNzIEVwb2NoU2NoZWR1bGUge1xuICBjb25zdHJ1Y3RvcihzbG90c1BlckVwb2NoLCBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIHdhcm11cCwgZmlyc3ROb3JtYWxFcG9jaCwgZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzbG90cyBpbiBlYWNoIGVwb2NoICovXG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNsb3RzIGJlZm9yZSBiZWdpbm5pbmcgb2YgYW4gZXBvY2ggdG8gY2FsY3VsYXRlIGEgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGF0IGVwb2NoICovXG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSB2b2lkIDA7XG4gICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIGVwb2NocyBzdGFydCBzaG9ydCBhbmQgZ3JvdyAqL1xuICAgIHRoaXMud2FybXVwID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3QgZXBvY2ggd2l0aCBgc2xvdHNQZXJFcG9jaGAgc2xvdHMgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBzbG90IG9mIGBmaXJzdE5vcm1hbEVwb2NoYCAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHNsb3RzUGVyRXBvY2g7XG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ7XG4gICAgdGhpcy53YXJtdXAgPSB3YXJtdXA7XG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gZmlyc3ROb3JtYWxFcG9jaDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IGZpcnN0Tm9ybWFsU2xvdDtcbiAgfVxuICBnZXRFcG9jaChzbG90KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdClbMF07XG4gIH1cbiAgZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdCkge1xuICAgIGlmIChzbG90IDwgdGhpcy5maXJzdE5vcm1hbFNsb3QpIHtcbiAgICAgIGNvbnN0IGVwb2NoID0gdHJhaWxpbmdaZXJvcyhuZXh0UG93ZXJPZlR3byhzbG90ICsgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCArIDEpKSAtIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkgLSAxO1xuICAgICAgY29uc3QgZXBvY2hMZW4gPSB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCk7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBzbG90IC0gKGVwb2NoTGVuIC0gTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCk7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub3JtYWxTbG90SW5kZXggPSBzbG90IC0gdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgICBjb25zdCBub3JtYWxFcG9jaEluZGV4ID0gTWF0aC5mbG9vcihub3JtYWxTbG90SW5kZXggLyB0aGlzLnNsb3RzUGVyRXBvY2gpO1xuICAgICAgY29uc3QgZXBvY2ggPSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggKyBub3JtYWxFcG9jaEluZGV4O1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gbm9ybWFsU2xvdEluZGV4ICUgdGhpcy5zbG90c1BlckVwb2NoO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9XG4gIH1cbiAgZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8PSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3coMiwgZXBvY2gpIC0gMSkgKiBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGVwb2NoIC0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSAqIHRoaXMuc2xvdHNQZXJFcG9jaCArIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgIH1cbiAgfVxuICBnZXRMYXN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSArIHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSAtIDE7XG4gIH1cbiAgZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDwgdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgZXBvY2ggKyB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICB9XG4gIH1cbn1cblxudmFyIGZldGNoSW1wbCA9IHR5cGVvZiBnbG9iYWxUaGlzLmZldGNoID09PSAnZnVuY3Rpb24nID9cbi8vIFRoZSBGZXRjaCBBUEkgaXMgc3VwcG9ydGVkIGV4cGVyaW1lbnRhbGx5IGluIE5vZGUgMTcuNSsgYW5kIG5hdGl2ZWx5IGluIE5vZGUgMTgrLlxuZ2xvYmFsVGhpcy5mZXRjaCA6XG4vLyBPdGhlcndpc2UgdXNlIHRoZSBwb2x5ZmlsbC5cbmFzeW5jIGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICBjb25zdCBwcm9jZXNzZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQuc2xpY2UoMCwgMikgPT09ICcvLycgPyAnaHR0cHM6JyArIGlucHV0IDogaW5wdXQ7XG4gIHJldHVybiBhd2FpdCBub2RlRmV0Y2guZGVmYXVsdChwcm9jZXNzZWRJbnB1dCwgaW5pdCk7XG59O1xuXG5jbGFzcyBScGNXZWJTb2NrZXRDbGllbnQgZXh0ZW5kcyBDb21tb25DbGllbnQge1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgY29uc3Qgd2ViU29ja2V0RmFjdG9yeSA9IHVybCA9PiB7XG4gICAgICBjb25zdCBycGMgPSBXZWJTb2NrZXQodXJsLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0cnVlLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogNSxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCdzb2NrZXQnIGluIHJwYykge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMuc29ja2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJwYztcbiAgICB9O1xuICAgIHN1cGVyKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpO1xuICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHZvaWQgMDtcbiAgfVxuICBjYWxsKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FsbCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gY2FsbCBhIEpTT04tUlBDIG1ldGhvZCBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxuICBub3RpZnkoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIHNlbmQgYSBKU09OLVJQQyBub3RpZmljYXRpb24gYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIERlY29kZSBhY2NvdW50IGRhdGEgYnVmZmVyIHVzaW5nIGFuIEFjY291bnRUeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSh0eXBlLCBkYXRhKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSB0eXBlLmxheW91dC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRlY29kZWQudHlwZUluZGV4ICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFjY291bnQgZGF0YTsgYWNjb3VudCB0eXBlIG1pc21hdGNoICR7ZGVjb2RlZC50eXBlSW5kZXh9ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG5jb25zdCBMT09LVVBfVEFCTEVfTUVUQV9TSVpFID0gNTY7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBhcmdzLmtleTtcbiAgICB0aGlzLnN0YXRlID0gYXJncy5zdGF0ZTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICBjb25zdCBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kZWFjdGl2YXRpb25TbG90ID09PSBVNjRfTUFYO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShhY2NvdW50RGF0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBkZWNvZGVEYXRhKExvb2t1cFRhYmxlTWV0YUxheW91dCwgYWNjb3VudERhdGEpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPSBhY2NvdW50RGF0YS5sZW5ndGggLSBMT09LVVBfVEFCTEVfTUVUQV9TSVpFO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuID49IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuICUgMzIgPT09IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMgPSBzZXJpYWxpemVkQWRkcmVzc2VzTGVuIC8gMzI7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMsICdhZGRyZXNzZXMnKV0pLmRlY29kZShhY2NvdW50RGF0YS5zbGljZShMT09LVVBfVEFCTEVfTUVUQV9TSVpFKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWN0aXZhdGlvblNsb3Q6IG1ldGEuZGVhY3RpdmF0aW9uU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3Q6IG1ldGEubGFzdEV4dGVuZGVkU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4OiBtZXRhLmxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgsXG4gICAgICBhdXRob3JpdHk6IG1ldGEuYXV0aG9yaXR5Lmxlbmd0aCAhPT0gMCA/IG5ldyBQdWJsaWNLZXkobWV0YS5hdXRob3JpdHlbMF0pIDogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSlcbiAgICB9O1xuICB9XG59XG5jb25zdCBMb29rdXBUYWJsZU1ldGFMYXlvdXQgPSB7XG4gIGluZGV4OiAxLFxuICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3R5cGVJbmRleCcpLCB1NjQoJ2RlYWN0aXZhdGlvblNsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2xhc3RFeHRlbmRlZFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdsYXN0RXh0ZW5kZWRTdGFydEluZGV4JyksIEJ1ZmZlckxheW91dC51OCgpLFxuICAvLyBvcHRpb25cbiAgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTgoKSwgLTEpLCAnYXV0aG9yaXR5JyldKVxufTtcblxuY29uc3QgVVJMX1JFID0gL15bXjpdKzpcXC9cXC8oW146W10rfFxcW1teXFxdXStcXF0pKDpcXGQrKT8oLiopL2k7XG5mdW5jdGlvbiBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBlbmRwb2ludC5tYXRjaChVUkxfUkUpO1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBGYWlsZWQgdG8gdmFsaWRhdGUgZW5kcG9pbnQgVVJMIFxcYCR7ZW5kcG9pbnR9XFxgYCk7XG4gIH1cbiAgY29uc3QgW18sXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGhvc3Rpc2gsIHBvcnRXaXRoQ29sb24sIHJlc3RdID0gbWF0Y2hlcztcbiAgY29uc3QgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICBjb25zdCBzdGFydFBvcnQgPSBwb3J0V2l0aENvbG9uID09IG51bGwgPyBudWxsIDogcGFyc2VJbnQocG9ydFdpdGhDb2xvbi5zbGljZSgxKSwgMTApO1xuICBjb25zdCB3ZWJzb2NrZXRQb3J0ID1cbiAgLy8gT25seSBzaGlmdCB0aGUgcG9ydCBieSArMSBhcyBhIGNvbnZlbnRpb24gZm9yIHdzKHMpIG9ubHkgaWYgZ2l2ZW4gZW5kcG9pbnRcbiAgLy8gaXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBlbmRwb2ludCBwb3J0IChIVFRQLWJhc2VkIFJQQyksIGFzc3VtaW5nXG4gIC8vIHdlJ3JlIGRpcmVjdGx5IHRyeWluZyB0byBjb25uZWN0IHRvIGFnYXZlLXZhbGlkYXRvcidzIHdzIGxpc3RlbmluZyBwb3J0LlxuICAvLyBXaGVuIHRoZSBlbmRwb2ludCBvbWl0cyB0aGUgcG9ydCwgd2UncmUgY29ubmVjdGluZyB0byB0aGUgcHJvdG9jb2xcbiAgLy8gZGVmYXVsdCBwb3J0czogaHR0cCg4MCkgb3IgaHR0cHMoNDQzKSBhbmQgaXQncyBhc3N1bWVkIHdlJ3JlIGJlaGluZCBhIHJldmVyc2VcbiAgLy8gcHJveHkgd2hpY2ggbWFuYWdlcyBXZWJTb2NrZXQgdXBncmFkZSBhbmQgYmFja2VuZCBwb3J0IHJlZGlyZWN0aW9uLlxuICBzdGFydFBvcnQgPT0gbnVsbCA/ICcnIDogYDoke3N0YXJ0UG9ydCArIDF9YDtcbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0aXNofSR7d2Vic29ja2V0UG9ydH0ke3Jlc3R9YDtcbn1cblxuY29uc3QgUHVibGljS2V5RnJvbVN0cmluZyA9IGNvZXJjZShpbnN0YW5jZShQdWJsaWNLZXkpLCBzdHJpbmcoKSwgdmFsdWUgPT4gbmV3IFB1YmxpY0tleSh2YWx1ZSkpO1xuY29uc3QgUmF3QWNjb3VudERhdGFSZXN1bHQgPSB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSk7XG5jb25zdCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEgPSBjb2VyY2UoaW5zdGFuY2UoQnVmZmVyKSwgUmF3QWNjb3VudERhdGFSZXN1bHQsIHZhbHVlID0+IEJ1ZmZlci5mcm9tKHZhbHVlWzBdLCAnYmFzZTY0JykpO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gdXNlIGEgcmVjZW50IGJsb2NraGFzaCBmb3IgdXAgdG8gMzAgc2Vjb25kc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIEhBQ0suXG4gKiBDb3BpZWQgZnJvbSBycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuXG4gKiBPdGhlcndpc2UsIGB5YXJuIGJ1aWxkYCBmYWlscyB3aXRoOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2MwNTdlY2E4MWQ0NzllZjcwNWNkYjUzMTYyZjk5NzFkXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuXG4vKiogQGludGVybmFsICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRXZlcnkgc3Vic2NyaXB0aW9uIGNvbnRhaW5zIHRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGhcbiAqIHRoZSBzZXJ2ZXIsIGFuZCBhIGxpc3Qgb2YgY2FsbGVycyBpbnRlcmVzdGVkIGluIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEEgc3Vic2NyaXB0aW9uIG1heSBiZSBpbiB2YXJpb3VzIHN0YXRlcyBvZiBjb25uZWN0ZWRuZXNzLiBPbmx5IHdoZW4gaXQgaXNcbiAqIGZ1bGx5IGNvbm5lY3RlZCB3aWxsIGl0IGhhdmUgYSBzZXJ2ZXIgc3Vic2NyaXB0aW9uIGlkIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFRoaXMgaWQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBzZXJ2ZXIgdG8gdW5zdWJzY3JpYmUgdGhlIGNsaWVudCBlbnRpcmVseS5cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGVuY2Fwc3VsYXRlcyBhIHN1YnNjcmlwdGlvbidzIFJQQyBtZXRob2RcbiAqIG5hbWVzIGFuZCBub3RpZmljYXRpb24gKGNhbGxiYWNrKSBzaWduYXR1cmUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFV0aWxpdHkgdHlwZSB0aGF0IGtlZXBzIHRhZ2dlZCB1bmlvbnMgaW50YWN0IHdoaWxlIG9taXR0aW5nIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgc2luZ2xlIHN1YnNjcmliYWJsZSAndG9waWMuJyBJdCdzIG1hZGUgdXAgb2Y6XG4gKlxuICogLSBUaGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBzZXJ2ZXIsXG4gKiAtIFRoZSBzdGF0ZSBvZiB0aGUgc3Vic2NyaXB0aW9uLCBpbiB0ZXJtcyBvZiBpdHMgY29ubmVjdGVkbmVzcywgYW5kXG4gKiAtIFRoZSBzZXQgb2YgY2FsbGJhY2tzIHRvIGNhbGwgd2hlbiB0aGUgc2VydmVyIHB1Ymxpc2hlcyBub3RpZmljYXRpb25zXG4gKlxuICogVGhpcyByZWNvcmQgZ2V0cyBpbmRleGVkIGJ5IGBTdWJzY3JpcHRpb25Db25maWdIYXNoYCBhbmQgaXMgdXNlZCB0b1xuICogc2V0IHVwIHN1YnNjcmlwdGlvbnMsIGZhbiBvdXQgbm90aWZpY2F0aW9ucywgYW5kIHRyYWNrIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBmb3IgUlBDIHJlc3BvbnNlc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc2VuZGluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXG4gKi9cblxuLyoqXG4gKiBSUEMgUmVzcG9uc2Ugd2l0aCBleHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHVzZXMgdGhlIGxhc3QgdmFsaWRcbiAqIGJsb2NrIGhlaWdodCBmb3IgYSBnaXZlbiBibG9ja2hhc2ggdG8gY2hlY2sgZm9yIHRyYW5zYWN0aW9uIGV4cGlyYXRpb24uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb25zLlxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyoqXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGFzc2VydEVuZHBvaW50VXJsKHB1dGF0aXZlVXJsKSB7XG4gIGlmICgvXmh0dHBzPzovLnRlc3QocHV0YXRpdmVVcmwpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZHBvaW50IFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKTtcbiAgfVxuICByZXR1cm4gcHV0YXRpdmVVcmw7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgbGV0IGNvbW1pdG1lbnQ7XG4gIGxldCBjb25maWc7XG4gIGlmICh0eXBlb2YgY29tbWl0bWVudE9yQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWc7XG4gIH0gZWxzZSBpZiAoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudDogc3BlY2lmaWVkQ29tbWl0bWVudCxcbiAgICAgIC4uLnNwZWNpZmllZENvbmZpZ1xuICAgIH0gPSBjb21taXRtZW50T3JDb25maWc7XG4gICAgY29tbWl0bWVudCA9IHNwZWNpZmllZENvbW1pdG1lbnQ7XG4gICAgY29uZmlnID0gc3BlY2lmaWVkQ29uZmlnO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWl0bWVudCxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnBjUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gdW5pb24oW3R5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICByZXN1bHRcbiAgfSksIHR5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICBlcnJvcjogdHlwZSh7XG4gICAgICBjb2RlOiB1bmtub3duKCksXG4gICAgICBtZXNzYWdlOiBzdHJpbmcoKSxcbiAgICAgIGRhdGE6IG9wdGlvbmFsKGFueSgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG5jb25zdCBVbmtub3duUnBjUmVzdWx0ID0gY3JlYXRlUnBjUmVzdWx0KHVua25vd24oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHQoc2NoZW1hKSB7XG4gIHJldHVybiBjb2VyY2UoY3JlYXRlUnBjUmVzdWx0KHNjaGVtYSksIFVua25vd25ScGNSZXN1bHQsIHZhbHVlID0+IHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgcmVzdWx0OiBjcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCByZXNwb25zZSkge1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcjogcmVzcG9uc2UuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHJlc3BvbnNlLmFjY291bnRLZXlzLm1hcChhY2NvdW50S2V5ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiByZXNwb25zZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogcmVzcG9uc2UuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICAgIH0pKSxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IHJlc3BvbnNlLmFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UocmVzcG9uc2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCB3aGVuIHF1ZXJ5aW5nIHN0YXRlXG4gKiA8cHJlPlxuICogICAncHJvY2Vzc2VkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vLyBEZXByZWNhdGVkIGFzIG9mIHYxLjUuNVxuXG4vKipcbiAqIEEgc3Vic2V0IG9mIENvbW1pdG1lbnQgbGV2ZWxzLCB3aGljaCBhcmUgYXQgbGVhc3Qgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkXG4gKiA8cHJlPlxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbGFyZ2VzdCBhY2NvdW50cyBxdWVyeVxuICogPHByZT5cbiAqICAgJ2NpcmN1bGF0aW5nJzogICAgUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogICAnbm9uQ2lyY3VsYXRpbmcnOiBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEFjY291bnRJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCYWxhbmNlYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN0YWtlTWluaW11bURlbGVnYXRpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrSGVpZ2h0YCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRFcG9jaEluZm9gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEluZmxhdGlvblJld2FyZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGF0ZXN0QmxvY2toYXNoYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBpc0Jsb2NraGFzaFZhbGlkYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90YCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90TGVhZGVyYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhcmdlc3RBY2NvdW50c2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3VwcGx5YCByZXF1ZXN0IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSBjbHVzdGVyIG5vZGVcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSB2b3RlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjbHVzdGVyIHZvdGUgYWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE5ldHdvcmsgSW5mbGF0aW9uXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL2ltcGxlbWVudGVkLXByb3Bvc2Fscy9lZF9vdmVydmlldylcbiAqL1xuXG5jb25zdCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCA9IHR5cGUoe1xuICBmb3VuZGF0aW9uOiBudW1iZXIoKSxcbiAgZm91bmRhdGlvblRlcm06IG51bWJlcigpLFxuICBpbml0aWFsOiBudW1iZXIoKSxcbiAgdGFwZXI6IG51bWJlcigpLFxuICB0ZXJtaW5hbDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIFRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhbiBlcG9jaFxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJld2FyZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBlZmZlY3RpdmVTbG90OiBudW1iZXIoKSxcbiAgYW1vdW50OiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bWJlcigpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCA9IGFycmF5KHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgcHJpb3JpdGl6YXRpb25GZWU6IG51bWJlcigpXG59KSk7XG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SYXRlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SYXRlUmVzdWx0ID0gdHlwZSh7XG4gIHRvdGFsOiBudW1iZXIoKSxcbiAgdmFsaWRhdG9yOiBudW1iZXIoKSxcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGVwb2NoOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZXBvY2hcbiAqL1xuXG5jb25zdCBHZXRFcG9jaEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBzbG90SW5kZXg6IG51bWJlcigpLFxuICBzbG90c0luRXBvY2g6IG51bWJlcigpLFxuICBhYnNvbHV0ZVNsb3Q6IG51bWJlcigpLFxuICBibG9ja0hlaWdodDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICB0cmFuc2FjdGlvbkNvdW50OiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90c1BlckVwb2NoOiBudW1iZXIoKSxcbiAgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0OiBudW1iZXIoKSxcbiAgd2FybXVwOiBib29sZWFuKCksXG4gIGZpcnN0Tm9ybWFsRXBvY2g6IG51bWJlcigpLFxuICBmaXJzdE5vcm1hbFNsb3Q6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBMZWFkZXIgc2NoZWR1bGVcbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjbGVhZGVyLXNjaGVkdWxlKVxuICovXG5cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUmVzdWx0ID0gcmVjb3JkKHN0cmluZygpLCBhcnJheShudW1iZXIoKSkpO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGVycm9yIG9yIG51bGxcbiAqL1xuY29uc3QgVHJhbnNhY3Rpb25FcnJvclJlc3VsdCA9IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSk7XG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1cyBmb3IgYSB0cmFuc2FjdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0XG59KTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cbmNvbnN0IFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0ID0gbGl0ZXJhbCgncmVjZWl2ZWRTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBWZXJzaW9uIGluZm8gZm9yIGEgbm9kZVxuICovXG5cbmNvbnN0IFZlcnNpb25SZXN1bHQgPSB0eXBlKHtcbiAgJ3NvbGFuYS1jb3JlJzogc3RyaW5nKCksXG4gICdmZWF0dXJlLXNldCc6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGVycjogbnVsbGFibGUodW5pb24oW3R5cGUoe30pLCBzdHJpbmcoKV0pKSxcbiAgbG9nczogbnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSxcbiAgYWNjb3VudHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KG51bGxhYmxlKHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogc3RyaW5nKCksXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICByZW50RXBvY2g6IG9wdGlvbmFsKG51bWJlcigpKVxuICB9KSkpKSksXG4gIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgcmV0dXJuRGF0YTogb3B0aW9uYWwobnVsbGFibGUodHlwZSh7XG4gICAgcHJvZ3JhbUlkOiBzdHJpbmcoKSxcbiAgICBkYXRhOiB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSlcbiAgfSkpKVxufSkpO1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25NZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIGJ5IGEgdHJhbnNhY3Rpb24gdXNpbmcgYWRkcmVzcyB0YWJsZSBsb29rdXBzXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgcGFydGlhbGx5IGRlY29kZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFkZHJlc3MgdGFibGUgbG9va3VwXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYW5kIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbldpdGhNZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlciB3aXRoIG1ldGFcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIGJsb2NrIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIEJsb2NrIG9uIHRoZSBsZWRnZXIgd2l0aCBzaWduYXR1cmVzIG9ubHlcbiAqL1xuXG4vKipcbiAqIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tQcm9kdWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBieUlkZW50aXR5OiByZWNvcmQoc3RyaW5nKCksIGFycmF5KG51bWJlcigpKSksXG4gIHJhbmdlOiB0eXBlKHtcbiAgICBmaXJzdFNsb3Q6IG51bWJlcigpLFxuICAgIGxhc3RTbG90OiBudW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEEgcGVyZm9ybWFuY2Ugc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUnBjQ2xpZW50KHVybCwgaHR0cEhlYWRlcnMsIGN1c3RvbUZldGNoLCBmZXRjaE1pZGRsZXdhcmUsIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0LCBodHRwQWdlbnQpIHtcbiAgY29uc3QgZmV0Y2ggPSBjdXN0b21GZXRjaCA/IGN1c3RvbUZldGNoIDogZmV0Y2hJbXBsO1xuICBsZXQgYWdlbnQ7XG4gIHtcbiAgICBpZiAoaHR0cEFnZW50ID09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAgICAgIC8vIE9uZSBzZWNvbmQgZmV3ZXIgdGhhbiB0aGUgU29sYW5hIFJQQydzIGtlZXBhbGl2ZSB0aW1lb3V0LlxuICAgICAgICAgIC8vIFJlYWQgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMjc4NTkjaXNzdWVjb21tZW50LTEzNDAwOTc4ODlcbiAgICAgICAgICBmcmVlU29ja2V0VGltZW91dDogMTkwMDAsXG4gICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgIG1heFNvY2tldHM6IDI1XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykpIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBIdHRwc0FnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEtlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0dHBBZ2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgICAgICAgaWYgKGlzSHR0cHMgJiYgIShodHRwQWdlbnQgaW5zdGFuY2VvZiBBZ2VudCQxKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHBzLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgKyAnYGh0dHAuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSHR0cHMgJiYgaHR0cEFnZW50IGluc3RhbmNlb2YgQWdlbnQkMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHAuQWdlbnRgLiBZb3UgaGF2ZSwgaW5zdGVhZCwgc3VwcGxpZWQgYW4gJyArICdgaHR0cHMuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWdlbnQgPSBodHRwQWdlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmZXRjaFdpdGhNaWRkbGV3YXJlO1xuICBpZiAoZmV0Y2hNaWRkbGV3YXJlKSB7XG4gICAgZmV0Y2hXaXRoTWlkZGxld2FyZSA9IGFzeW5jIChpbmZvLCBpbml0KSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEZldGNoQXJncyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZXRjaE1pZGRsZXdhcmUoaW5mbywgaW5pdCwgKG1vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0KSA9PiByZXNvbHZlKFttb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdF0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaCguLi5tb2RpZmllZEZldGNoQXJncyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBjbGllbnRCcm93c2VyID0gbmV3IFJwY0NsaWVudChhc3luYyAocmVxdWVzdCwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgYWdlbnQsXG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSwgaHR0cEhlYWRlcnMgfHwge30sIENPTU1PTl9IVFRQX0hFQURFUlMpXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgbGV0IHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPSA1O1xuICAgICAgbGV0IHJlcztcbiAgICAgIGxldCB3YWl0VGltZSA9IDUwMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGZldGNoV2l0aE1pZGRsZXdhcmUpIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaFdpdGhNaWRkbGV3YXJlKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gNDI5IC8qIFRvbyBtYW55IHJlcXVlc3RzICovKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyAtPSAxO1xuICAgICAgICBpZiAodG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9LiAgUmV0cnlpbmcgYWZ0ZXIgJHt3YWl0VGltZX1tcyBkZWxheS4uLmApO1xuICAgICAgICBhd2FpdCBzbGVlcCh3YWl0VGltZSk7XG4gICAgICAgIHdhaXRUaW1lICo9IDI7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH06ICR7dGV4dH1gKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9LCB7fSk7XG4gIHJldHVybiBjbGllbnRCcm93c2VyO1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIChtZXRob2QsIGFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY2xpZW50LnJlcXVlc3QobWV0aG9kLCBhcmdzLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVScGNCYXRjaFJlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiByZXF1ZXN0cyA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaWYgcmVxdWVzdHMgaXMgZW1wdHlcbiAgICAgIGlmIChyZXF1ZXN0cy5sZW5ndGggPT09IDApIHJlc29sdmUoW10pO1xuICAgICAgY29uc3QgYmF0Y2ggPSByZXF1ZXN0cy5tYXAocGFyYW1zID0+IHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5yZXF1ZXN0KHBhcmFtcy5tZXRob2ROYW1lLCBwYXJhbXMuYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KGJhdGNoLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvbkdvdmVybm9yXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SYXRlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25SYXRlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoSW5mb1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hJbmZvUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaEluZm9SZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaFNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaFNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGVhZGVyU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcIm1pbmltdW1MZWRnZXJTbG90XCIgYW5kIFwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9ja1wiIG1lc3NhZ2VzXG4gKi9cbmNvbnN0IFNsb3RScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcblxuLyoqXG4gKiBTdXBwbHlcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTdXBwbHlcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFN1cHBseVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIGNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZ0FjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKVxufSkpO1xuXG4vKipcbiAqIFRva2VuIGFtb3VudCBvYmplY3Qgd2hpY2ggcmV0dXJucyBhIHRva2VuIGFtb3VudCBpbiBkaWZmZXJlbnQgZm9ybWF0c1xuICogZm9yIHZhcmlvdXMgY2xpZW50IHVzZSBjYXNlcy5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHN0cnVjdHVyZSBmb3IgdG9rZW4gYW1vdW50c1xuICovXG5jb25zdCBUb2tlbkFtb3VudFJlc3VsdCA9IHR5cGUoe1xuICBhbW91bnQ6IHN0cmluZygpLFxuICB1aUFtb3VudDogbnVsbGFibGUobnVtYmVyKCkpLFxuICBkZWNpbWFsczogbnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFRva2VuIGFkZHJlc3MgYW5kIGJhbGFuY2UuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRva2VuTGFyZ2VzdEFjY291bnRzUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXJcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcbmNvbnN0IFBhcnNlZEFjY291bnREYXRhUmVzdWx0ID0gdHlwZSh7XG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgc3BhY2U6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXJcIiBtZXNzYWdlIHdpdGggcGFyc2VkIGRhdGFcbiAqL1xuY29uc3QgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiB0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IFBhcnNlZEFjY291bnREYXRhUmVzdWx0LFxuICAgIHJlbnRFcG9jaDogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5cbi8qKlxuICogUGFpciBvZiBhbiBhY2NvdW50IGFkZHJlc3MgYW5kIGl0cyBiYWxhbmNlXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KSkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEtleWVkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5jb25zdCBQYXJzZWRPclJhd0FjY291bnREYXRhID0gY29lcmNlKHVuaW9uKFtpbnN0YW5jZShCdWZmZXIpLCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB1bmlvbihbUmF3QWNjb3VudERhdGFSZXN1bHQsIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHZhbHVlID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IFBhcnNlZE9yUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuY29uc3QgS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3Rha2VBY3RpdmF0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN0YXRlOiB1bmlvbihbbGl0ZXJhbCgnYWN0aXZlJyksIGxpdGVyYWwoJ2luYWN0aXZlJyksIGxpdGVyYWwoJ2FjdGl2YXRpbmcnKSwgbGl0ZXJhbCgnZGVhY3RpdmF0aW5nJyldKSxcbiAgYWN0aXZlOiBudW1iZXIoKSxcbiAgaW5hY3RpdmU6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXCIgbWVzc2FnZVxuICovXG5cbmNvbnN0IEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KHR5cGUoe1xuICBzaWduYXR1cmU6IHN0cmluZygpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImFjY291bnROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KEFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInByb2dyYW1Ob3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHJvb3Q6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBTbG90IHVwZGF0ZXMgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAqIC0gYFwiZmlyc3RTaHJlZFJlY2VpdmVkXCJgOiBjb25uZWN0ZWQgbm9kZSByZWNlaXZlZCB0aGUgZmlyc3Qgc2hyZWQgb2YgYSBibG9jay5cbiAqIEluZGljYXRlcyB0aGF0IGEgbmV3IGJsb2NrIHRoYXQgaXMgYmVpbmcgcHJvZHVjZWQuXG4gKiAtIGBcImNvbXBsZXRlZFwiYDogY29ubmVjdGVkIG5vZGUgaGFzIHJlY2VpdmVkIGFsbCBzaHJlZHMgb2YgYSBibG9jay4gSW5kaWNhdGVzXG4gKiBhIGJsb2NrIHdhcyByZWNlbnRseSBwcm9kdWNlZC5cbiAqIC0gYFwib3B0aW1pc3RpY0NvbmZpcm1hdGlvblwiYDogYmxvY2sgd2FzIG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZCBieSB0aGVcbiAqIGNsdXN0ZXIuIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgYW4gb3B0aW1pc3RpYyBjb25maXJtYXRpb24gbm90aWZpY2F0aW9uXG4gKiB3aWxsIGJlIHNlbnQgZm9yIGV2ZXJ5IGZpbmFsaXplZCBibG9ja3MuXG4gKiAtIGBcInJvb3RcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSByb290ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiY3JlYXRlZEJhbmtcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgc3RhcnRlZCB2YWxpZGF0aW5nIHRoaXMgYmxvY2suXG4gKiAtIGBcImZyb3plblwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyB2YWxpZGF0ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiZGVhZFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGZhaWxlZCB0byB2YWxpZGF0ZSB0aGlzIGJsb2NrLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVSZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHR5cGU6IHVuaW9uKFtsaXRlcmFsKCdmaXJzdFNocmVkUmVjZWl2ZWQnKSwgbGl0ZXJhbCgnY29tcGxldGVkJyksIGxpdGVyYWwoJ29wdGltaXN0aWNDb25maXJtYXRpb24nKSwgbGl0ZXJhbCgncm9vdCcpXSksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2NyZWF0ZWRCYW5rJyksXG4gIHBhcmVudDogbnVtYmVyKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2Zyb3plbicpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgc3RhdHM6IHR5cGUoe1xuICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogbnVtYmVyKCksXG4gICAgbnVtU3VjY2Vzc2Z1bFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbnVtRmFpbGVkVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogbnVtYmVyKClcbiAgfSlcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnZGVhZCcpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgZXJyOiBzdHJpbmcoKVxufSldKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdHNVcGRhdGVzTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdFVwZGF0ZVJlc3VsdFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNpZ25hdHVyZU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dCh1bmlvbihbU2lnbmF0dXJlU3RhdHVzUmVzdWx0LCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdF0pKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJvb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJvb3ROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBudW1iZXIoKVxufSk7XG5jb25zdCBDb250YWN0SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBnb3NzaXA6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdHB1OiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHJwYzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB2ZXJzaW9uOiBudWxsYWJsZShzdHJpbmcoKSlcbn0pO1xuY29uc3QgVm90ZUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHZvdGVQdWJrZXk6IHN0cmluZygpLFxuICBub2RlUHVia2V5OiBzdHJpbmcoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IG51bWJlcigpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBib29sZWFuKCksXG4gIGVwb2NoQ3JlZGl0czogYXJyYXkodHVwbGUoW251bWJlcigpLCBudW1iZXIoKSwgbnVtYmVyKCldKSksXG4gIGNvbW1pc3Npb246IG51bWJlcigpLFxuICBsYXN0Vm90ZTogbnVtYmVyKCksXG4gIHJvb3RTbG90OiBudWxsYWJsZShudW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRWb3RlQWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFZvdGVBY2NvdW50cyA9IGpzb25ScGNSZXN1bHQodHlwZSh7XG4gIGN1cnJlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdCksXG4gIGRlbGlucXVlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdClcbn0pKTtcbmNvbnN0IENvbmZpcm1hdGlvblN0YXR1cyA9IHVuaW9uKFtsaXRlcmFsKCdwcm9jZXNzZWQnKSwgbGl0ZXJhbCgnY29uZmlybWVkJyksIGxpdGVyYWwoJ2ZpbmFsaXplZCcpXSk7XG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXNwb25zZSA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgY29uZmlybWF0aW9uczogbnVsbGFibGUobnVtYmVyKCkpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGNvbmZpcm1hdGlvblN0YXR1czogb3B0aW9uYWwoQ29uZmlybWF0aW9uU3RhdHVzKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlKSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuY29uc3QgQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0ID0gdHlwZSh7XG4gIGFjY291bnRLZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHdyaXRhYmxlSW5kZXhlczogYXJyYXkobnVtYmVyKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGFycmF5KG51bWJlcigpKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShzdHJpbmcoKSksXG4gICAgaGVhZGVyOiB0eXBlKHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogbnVtYmVyKClcbiAgICB9KSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgICAgYWNjb3VudHM6IGFycmF5KG51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpXG4gICAgfSkpLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogb3B0aW9uYWwoYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSlcbiAgfSlcbn0pO1xuY29uc3QgQW5ub3RhdGVkQWNjb3VudEtleSA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHNpZ25lcjogYm9vbGVhbigpLFxuICB3cml0YWJsZTogYm9vbGVhbigpLFxuICBzb3VyY2U6IG9wdGlvbmFsKHVuaW9uKFtsaXRlcmFsKCd0cmFuc2FjdGlvbicpLCBsaXRlcmFsKCdsb29rdXBUYWJsZScpXSkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpXG59KTtcbmNvbnN0IFBhcnNlZEluc3RydWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IFJhd0luc3RydWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgZGF0YTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBJbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFtSYXdJbnN0cnVjdGlvblJlc3VsdCwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHRdKTtcbmNvbnN0IFVua25vd25JbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFt0eXBlKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN0cmluZygpXG59KSwgdHlwZSh7XG4gIGFjY291bnRzOiBhcnJheShzdHJpbmcoKSksXG4gIGRhdGE6IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN0cmluZygpXG59KV0pO1xuY29uc3QgUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiA9IGNvZXJjZShJbnN0cnVjdGlvblJlc3VsdCwgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0LCB2YWx1ZSA9PiB7XG4gIGlmICgnYWNjb3VudHMnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0KTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogdHlwZSh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkoUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKSlcbiAgfSlcbn0pO1xuY29uc3QgVG9rZW5CYWxhbmNlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRJbmRleDogbnVtYmVyKCksXG4gIG1pbnQ6IHN0cmluZygpLFxuICBvd25lcjogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSB0eXBlKHtcbiAgd3JpdGFibGU6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IG51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QgPSB1bmlvbihbbGl0ZXJhbCgwKSwgbGl0ZXJhbCgnbGVnYWN5JyldKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmV3YXJkc1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudWxsYWJsZShudW1iZXIoKSksXG4gIHJld2FyZFR5cGU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50QmxvY2toYXNoXCIgbWVzc2FnZVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0fSBpbnN0ZWFkLlxuICovXG5jb25zdCBHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBsYXN0VmFsaWRCbG9ja0hlaWdodDogbnVtYmVyKClcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiaXNCbG9ja2hhc2hWYWxpZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJvb2xlYW4oKSk7XG5jb25zdCBQZXJmU2FtcGxlUmVzdWx0ID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICBudW1TbG90czogbnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IG51bWJlcigpXG59KTtcblxuLypcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShQZXJmU2FtcGxlUmVzdWx0KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZSh0eXBlKHtcbiAgZmVlQ2FsY3VsYXRvcjogdHlwZSh7XG4gICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyZXF1ZXN0QWlyZHJvcFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2VuZFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF0ZXN0IHNsb3QgYmVpbmcgcHJvY2Vzc2VkIGJ5IGEgbm9kZVxuICovXG5cbi8qKlxuICogUGFyc2VkIGFjY291bnQgZGF0YVxuICovXG5cbi8qKlxuICogU3Rha2UgQWN0aXZhdGlvbiBkYXRhXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNsaWNlIGFyZ3VtZW50IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE1lbW9yeSBjb21wYXJpc29uIGZpbHRlciBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNpemUgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQSBmaWx0ZXIgb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHMgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRNdWx0aXBsZUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZUFuZENvbnRleHRgXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGFuIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEFjY291bnQgaW5mb3JtYXRpb24gaWRlbnRpZmllZCBieSBwdWJrZXlcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgcHJvZ3JhbSBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2xvdCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uIHdpdGggdHJhbnNhY3Rpb24gcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdWJzY3JpcHRpb24gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJvb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBMb2dzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbG9nczogYXJyYXkoc3RyaW5nKCkpLFxuICBzaWduYXR1cmU6IHN0cmluZygpXG59KTtcblxuLyoqXG4gKiBMb2dzIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJsb2dzTm90aWZpY2F0aW9uXCIgbWVzc2FnZS5cbiAqL1xuY29uc3QgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbG9nIHN1YnNjcmlwdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvclxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0YXR1c1xuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVmaW5pbmcgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBKYXZhU2NyaXB0IGBmZXRjaCgpYCBBUElcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBDb25uZWN0aW9uXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgQ09NTU9OX0hUVFBfSEVBREVSUyA9IHtcbiAgJ3NvbGFuYS1jbGllbnQnOiBganMvJHtcIjAuMC4wLWRldmVsb3BtZW50XCIgfWBcbn07XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggYSBKU09OIFJQQyBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBVUkwgdG8gdGhlIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gICAqIEBwYXJhbSBjb21taXRtZW50T3JDb25maWcgb3B0aW9uYWwgZGVmYXVsdCBjb21taXRtZW50IGxldmVsIG9yIG9wdGlvbmFsIENvbm5lY3Rpb25Db25maWcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbW1pdG1lbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsXG4gICAgICogQSBudW1iZXIgdGhhdCB3ZSBpbmNyZW1lbnQgZXZlcnkgdGltZSBhbiBhY3RpdmUgY29ubmVjdGlvbiBjbG9zZXMuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAgICogd2hlbiBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzIGFjdGl2ZSB3aGVuXG4gICAgICogaXRzIGNvbnRpbnVhdGlvbiBmaXJlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICBsYXRlc3RCbG9ja2hhc2g6IG51bGwsXG4gICAgICBsYXN0RmV0Y2g6IDAsXG4gICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2ggPSB7fTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyA9IG5ldyBTZXQoKTtcbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hlaWdodCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSB7fTtcbiAgICAgIHJldHVybiBhc3luYyBjb21taXRtZW50T3JDb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeSQxKGFyZ3MpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdID0gcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA/PyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja0hlaWdodCcsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBoZWlnaHQgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGxldCB3c0VuZHBvaW50O1xuICAgIGxldCBodHRwSGVhZGVycztcbiAgICBsZXQgZmV0Y2g7XG4gICAgbGV0IGZldGNoTWlkZGxld2FyZTtcbiAgICBsZXQgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgbGV0IGh0dHBBZ2VudDtcbiAgICBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZyAmJiB0eXBlb2YgX2NvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIH0gZWxzZSBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dDtcbiAgICAgIHdzRW5kcG9pbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLndzRW5kcG9pbnQ7XG4gICAgICBodHRwSGVhZGVycyA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2g7XG4gICAgICBmZXRjaE1pZGRsZXdhcmUgPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoTWlkZGxld2FyZTtcbiAgICAgIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IGFzc2VydEVuZHBvaW50VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gd3NFbmRwb2ludCB8fCBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoZW5kcG9pbnQsIGh0dHBIZWFkZXJzLCBmZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gY3JlYXRlUnBjUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IGNyZWF0ZVJwY0JhdGNoUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IG5ldyBScGNXZWJTb2NrZXRDbGllbnQodGhpcy5fcnBjV3NFbmRwb2ludCwge1xuICAgICAgYXV0b2Nvbm5lY3Q6IGZhbHNlLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IEluZmluaXR5XG4gICAgfSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdvcGVuJywgdGhpcy5fd3NPbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuX3dzT25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fd3NPbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignYWNjb3VudE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncHJvZ3JhbU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3RzVXBkYXRlc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3NpZ25hdHVyZU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdyb290Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblJvb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdsb2dzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkxvZ3NOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGNvbW1pdG1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdG1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFJQQyBlbmRwb2ludFxuICAgKi9cbiAgZ2V0IHJwY0VuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNFbmRwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJhbGFuY2UgZm9yICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2UocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGJhbGFuY2Ugb2YgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tUaW1lKHNsb3QpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1RpbWUnLCBbc2xvdF0pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYmxvY2sgdGltZSBmb3Igc2xvdCAke3Nsb3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsb3dlc3Qgc2xvdCB0aGF0IHRoZSBub2RlIGhhcyBpbmZvcm1hdGlvbiBhYm91dCBpbiBpdHMgbGVkZ2VyLlxuICAgKiBUaGlzIHZhbHVlIG1heSBpbmNyZWFzZSBvdmVyIHRpbWUgaWYgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB0byBwdXJnZSBvbGRlciBsZWRnZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUxlZGdlclNsb3QoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnbWluaW11bUxlZGdlclNsb3QnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNsb3Qgb2YgdGhlIGxvd2VzdCBjb25maXJtZWQgYmxvY2sgdGhhdCBoYXMgbm90IGJlZW4gcHVyZ2VkIGZyb20gdGhlIGxlZGdlclxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGaXJzdEF2YWlsYWJsZUJsb2NrJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNsb3RScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldFN1cHBseShjb25maWcpIHtcbiAgICBsZXQgY29uZmlnQXJnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZyAmJiBjb25maWcuY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdXBwbHknLCBbY29uZmlnQXJnXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U3VwcGx5UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5TdXBwbHkodG9rZW5NaW50QWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuTWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuU3VwcGx5JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgYmFsYW5jZSBvZiBhIHRva2VuIGFjY291bnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudEJhbGFuY2UodG9rZW5BZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5BZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50ICR7b3duZXJBZGRyZXNzLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxQYXJzZWRBY2NvdW50RGF0YT59Pj4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgIGlmICgnbWludCcgaW4gZmlsdGVyKSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICovXG4gIGFzeW5jIGdldExhcmdlc3RBY2NvdW50cyhjb25maWcpIHtcbiAgICBjb25zdCBhcmcgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gYXJnLmZpbHRlciB8fCBhcmcuY29tbWl0bWVudCA/IFthcmddIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSAyMCBsYXJnZXN0IHRva2VuIGFjY291bnRzIHdpdGggdGhlaXIgY3VycmVudCBiYWxhbmNlc1xuICAgKiBmb3IgYSBnaXZlbiBtaW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMobWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFttaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRBY2NvdW50SW5mbyhwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyhwdWJsaWNLZXlzLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5c1xuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8ocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICByZXR1cm4gcmVzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZXBvY2ggYWN0aXZhdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBzdGFrZSBhY2NvdW50IHRoYXQgaGFzIGJlZW4gZGVsZWdhdGVkXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZUFjdGl2YXRpb24ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcsIGVwb2NoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2RpbmcsXG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmdcbiAgICB9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsIGNvbmZpZ1dpdGhvdXRFbmNvZGluZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgYmFzZVNjaGVtYSA9IGFycmF5KEtleWVkQWNjb3VudEluZm9SZXN1bHQpO1xuICAgIGNvbnN0IHJlcyA9IGNvbmZpZ1dpdGhvdXRFbmNvZGluZy53aXRoQ29udGV4dCA9PT0gdHJ1ZSA/IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJhc2VTY2hlbWEpKSA6IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYmFzZVNjaGVtYSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW5kIHBhcnNlIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXIgfCBQYXJzZWRBY2NvdW50RGF0YT59Pj59XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGNvbmZpcm1UcmFuc2FjdGlvbmAgYW5kIHBhc3MgaW4ge0BsaW5rIFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvbihzdHJhdGVneSwgY29tbWl0bWVudCkge1xuICAgIGxldCByYXdTaWduYXR1cmU7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PSAnc3RyaW5nJykge1xuICAgICAgcmF3U2lnbmF0dXJlID0gc3RyYXRlZ3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHN0cmF0ZWd5O1xuICAgICAgaWYgKGNvbmZpZy5hYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29uZmlnLmFib3J0U2lnbmFsLnJlYXNvbik7XG4gICAgICB9XG4gICAgICByYXdTaWduYXR1cmUgPSBjb25maWcuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBsZXQgZGVjb2RlZFNpZ25hdHVyZTtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZFNpZ25hdHVyZSA9IGJzNTguZGVjb2RlKHJhd1NpZ25hdHVyZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25hdHVyZSBtdXN0IGJlIGJhc2U1OCBlbmNvZGVkOiAnICsgcmF3U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgYXNzZXJ0KGRlY29kZWRTaWduYXR1cmUubGVuZ3RoID09PSA2NCwgJ3NpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGgnKTtcbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc2lnbmF0dXJlOiByYXdTaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JyBpbiBzdHJhdGVneSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRDYW5jZWxsYXRpb25Qcm9taXNlKHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCBzaWduYXR1cmVTdWJzY3JpcHRpb25JZDtcbiAgICBsZXQgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXI7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB0aGlzLm9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgKHJlc3VsdCwgY29udGV4dCkgPT4ge1xuICAgICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBjb21taXRtZW50KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwID0+IHtcbiAgICAgICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdGhpcy5fb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShzaWduYXR1cmVTdWJzY3JpcHRpb25JZCwgbmV4dFN0YXRlID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZSA9PT0gJ3N1YnNjcmliZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZT8uZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodmFsdWUuZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChjb21taXRtZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJyB8fCB2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdjb25maXJtZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZXhoYXVzdCBlbnVtcyB0byBlbnN1cmUgZnVsbCBjb3ZlcmFnZVxuICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWJvcnRDb25maXJtYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAoZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIpIHtcbiAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIoKTtcbiAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfTtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHN0cmF0ZWd5OiB7XG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBjaGVja0Jsb2NrSGVpZ2h0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gYXdhaXQgdGhpcy5nZXRCbG9ja0hlaWdodChjb21taXRtZW50KTtcbiAgICAgICAgICByZXR1cm4gYmxvY2tIZWlnaHQ7XG4gICAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRCbG9ja0hlaWdodCA8PSBsYXN0VmFsaWRCbG9ja0hlaWdodCkge1xuICAgICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY3VycmVudEJsb2NrSGVpZ2h0ID0gYXdhaXQgY2hlY2tCbG9ja0hlaWdodCgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5CTE9DS0hFSUdIVF9FWENFRURFRFxuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25Qcm9taXNlID0gdGhpcy5nZXRDYW5jZWxsYXRpb25Qcm9taXNlKGFib3J0U2lnbmFsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWUsXG4gICAgICBzaWduYXR1cmVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9uY2VWYWx1ZSA9IG5vbmNlVmFsdWU7XG4gICAgICBsZXQgbGFzdENoZWNrZWRTbG90ID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldEN1cnJlbnROb25jZVZhbHVlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogbm9uY2VBY2NvdW50XG4gICAgICAgICAgfSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudFB1YmtleSwge1xuICAgICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICAgIG1pbkNvbnRleHRTbG90XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdENoZWNrZWRTbG90ID0gY29udGV4dC5zbG90O1xuICAgICAgICAgIHJldHVybiBub25jZUFjY291bnQ/Lm5vbmNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgZm9yIHdoYXRldmVyIHJlYXNvbiB3ZSBjYW4ndCByZWFjaC9yZWFkIHRoZSBub25jZVxuICAgICAgICAgIC8vIGFjY291bnQsIGp1c3Qga2VlcCB1c2luZyB0aGUgbGFzdC1rbm93biB2YWx1ZS5cbiAgICAgICAgICByZXR1cm4gY3VycmVudE5vbmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChub25jZVZhbHVlICE9PSBjdXJyZW50Tm9uY2VWYWx1ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuTk9OQ0VfSU5WQUxJRCxcbiAgICAgICAgICAgICAgc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2U6IGxhc3RDaGVja2VkU2xvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMDApO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25Qcm9taXNlID0gdGhpcy5nZXRDYW5jZWxsYXRpb25Qcm9taXNlKGFib3J0U2lnbmFsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgdGhlIHRyYW5zYWN0aW9uIGlzIGluZGVlZCB1bmNvbmZpcm1lZC5cbiAgICAgICAgbGV0IHNpZ25hdHVyZVN0YXR1cztcbiAgICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdHVzLmNvbnRleHQuc2xvdCA8IChvdXRjb21lLnNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlID8/IG1pbkNvbnRleHRTbG90KSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoNDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduYXR1cmVTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hdHVyZVN0YXR1cz8udmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBjb21taXRtZW50Rm9yU3RhdHVzID0gY29tbWl0bWVudCB8fCAnZmluYWxpemVkJztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb25maXJtYXRpb25TdGF0dXNcbiAgICAgICAgICB9ID0gc2lnbmF0dXJlU3RhdHVzLnZhbHVlO1xuICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudEZvclN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdwcm9jZXNzZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gRXhoYXVzdGl2ZSBzd2l0Y2guXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgKF8gPT4ge30pKGNvbW1pdG1lbnRGb3JTdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBzaWduYXR1cmVTdGF0dXMuY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIGVycjogc2lnbmF0dXJlU3RhdHVzLnZhbHVlLmVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHNpZ25hdHVyZVxuICB9KSB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgNjAgKiAxMDAwO1xuICAgICAgc3dpdGNoIChjb21taXRtZW50KSB7XG4gICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgMzAgKiAxMDAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHtcbiAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5USU1FRF9PVVQsXG4gICAgICAgIHRpbWVvdXRNc1xuICAgICAgfSksIHRpbWVvdXRNcyk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcihzaWduYXR1cmUsIG91dGNvbWUudGltZW91dE1zIC8gMTAwMCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldENsdXN0ZXJOb2RlcygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDbHVzdGVyTm9kZXMnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShDb250YWN0SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjbHVzdGVyIG5vZGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Vm90ZUFjY291bnRzKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWb3RlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRWb3RlQWNjb3VudHMpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZvdGUgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc2xvdCB0aGF0IHRoZSBub2RlIGlzIHByb2Nlc3NpbmdcbiAgICovXG4gIGFzeW5jIGdldFNsb3QoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgbGVhZGVyIG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVyKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3RMZWFkZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYGxpbWl0YCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0U2xvdGBcbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0U2xvdCBmZXRjaCBzbG90IGxlYWRlcnMgc3RhcnRpbmcgZnJvbSB0aGlzIHNsb3RcbiAgICogQHBhcmFtIGxpbWl0IG51bWJlciBvZiBzbG90IGxlYWRlcnMgdG8gcmV0dXJuXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVycyhzdGFydFNsb3QsIGxpbWl0KSB7XG4gICAgY29uc3QgYXJncyA9IFtzdGFydFNsb3QsIGxpbWl0XTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVycycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZykpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzIG9mIGEgc2lnbmF0dXJlXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlLCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlc1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1c2VzKFtzaWduYXR1cmVdLCBjb25maWcpO1xuICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoID09PSAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXNlcyBvZiBhIGJhdGNoIG9mIHNpZ25hdHVyZXNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZVN0YXR1c2VzKHNpZ25hdHVyZXMsIGNvbmZpZykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtzaWduYXR1cmVzXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBwYXJhbXMucHVzaChjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVTdGF0dXNlcycsIHBhcmFtcyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZSBzdGF0dXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb25Db3VudCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCB0b3RhbCBjdXJyZW5jeSBzdXBwbHkgb2YgdGhlIGNsdXN0ZXIgaW4gbGFtcG9ydHNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4yLjguIFBsZWFzZSB1c2Uge0BsaW5rIGdldFN1cHBseX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsU3VwcGx5KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFN1cHBseSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZS50b3RhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY2x1c3RlciBJbmZsYXRpb25Hb3Zlcm5vciBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25Hb3Zlcm5vcihjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uR292ZXJub3InLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGZvciBhbiBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmV3YXJkKGFkZHJlc3NlcywgZXBvY2gsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYWRkcmVzc2VzLm1hcChwdWJrZXkgPT4gcHVia2V5LnRvQmFzZTU4KCkpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaFxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJld2FyZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJld2FyZFJlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJld2FyZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgc3BlY2lmaWMgaW5mbGF0aW9uIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJhdGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmF0ZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggSW5mbyBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaEluZm8oY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hJbmZvUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBpbmZvJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBTY2hlZHVsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaFNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgY29uc3QgZXBvY2hTY2hlZHVsZSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBFcG9jaFNjaGVkdWxlKGVwb2NoU2NoZWR1bGUuc2xvdHNQZXJFcG9jaCwgZXBvY2hTY2hlZHVsZS5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIGVwb2NoU2NoZWR1bGUud2FybXVwLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsRXBvY2gsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxTbG90KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxMZWFkZXJTY2hlZHVsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGVhZGVyU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGVhZGVyU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxlYWRlciBzY2hlZHVsZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbWluaW11bSBiYWxhbmNlIG5lZWRlZCB0byBleGVtcHQgYW4gYWNjb3VudCBvZiBgZGF0YUxlbmd0aGBcbiAgICogc2l6ZSBmcm9tIHJlbnRcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhTGVuZ3RoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbZGF0YUxlbmd0aF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBmZXRjaCBtaW5pbXVtIGJhbGFuY2UgZm9yIHJlbnQgZXhlbXB0aW9uJyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT4+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudEJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHRScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxQZXJmU2FtcGxlPj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMobGltaXQpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMnLCBsaW1pdCA/IFtsaW1pdF0gOiBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGNhbGN1bGF0b3IgZm9yIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0RmVlRm9yTWVzc2FnZX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2goYmxvY2toYXNoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBjYWxjdWxhdG9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSByZXMucmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlICE9PSBudWxsID8gdmFsdWUuZmVlQ2FsY3VsYXRvciA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRGZWVGb3JNZXNzYWdlKG1lc3NhZ2UsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB3aXJlTWVzc2FnZSA9IHRvQnVmZmVyKG1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt3aXJlTWVzc2FnZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUZvck1lc3NhZ2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgZm9yIG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIHByaW9yaXRpemF0aW9uIGZlZXMgZnJvbSByZWNlbnQgYmxvY2tzLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY291bnRzID0gY29uZmlnPy5sb2NrZWRXcml0YWJsZUFjY291bnRzPy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gYWNjb3VudHM/Lmxlbmd0aCA/IFthY2NvdW50c10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwcmlvcml0aXphdGlvbiBmZWVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaChjb21taXRtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2goY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGF0ZXN0QmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXRlc3QgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGJsb2NraGFzaCBpcyBzdGlsbCB2YWxpZCBvciBub3RcbiAgICovXG4gIGFzeW5jIGlzQmxvY2toYXNoVmFsaWQoYmxvY2toYXNoLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdpc0Jsb2NraGFzaFZhbGlkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGJsb2NraGFzaCBgJyArIGJsb2NraGFzaCArICdgaXMgdmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG5vZGUgdmVyc2lvblxuICAgKi9cbiAgYXN5bmMgZ2V0VmVyc2lvbigpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWZXJzaW9uJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoVmVyc2lvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZlcnNpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGdlbmVzaXMgaGFzaFxuICAgKi9cbiAgYXN5bmMgZ2V0R2VuZXNpc0hhc2goKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0R2VuZXNpc0hhc2gnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGdlbmVzaXMgaGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0gPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgdHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCBibG9ja1xuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UGFyc2VkQmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFJldHVybnMgcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgY3VycmVudCBvciBwcmV2aW91cyBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tQcm9kdWN0aW9uKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGxldCBleHRyYTtcbiAgICBsZXQgY29tbWl0bWVudDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yQ29tbWl0bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbW1pdG1lbnQgPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgfSBlbHNlIGlmIChjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tbWl0bWVudDogYyxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICAgIGNvbW1pdG1lbnQgPSBjO1xuICAgICAgZXh0cmEgPSByZXN0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgZXh0cmEpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrUHJvZHVjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbmAgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbihzaWduYXR1cmUsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmsgVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uc2AgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgVHJhbnNhY3Rpb25zIGFuZCB0cmFuc2FjdGlvbiBzdGF0dXNlcyBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIGZvciBhIGNvbmZpcm1lZCBibG9jay5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4xMy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UodHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHRyYW5zYWN0aW9uczogYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uLm1lc3NhZ2UsIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMpXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggY29uZmlybWVkIGJsb2NrcyBiZXR3ZWVuIHR3byBzbG90c1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tzKHN0YXJ0U2xvdCwgZW5kU2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGVuZFNsb3QgIT09IHVuZGVmaW5lZCA/IFtzdGFydFNsb3QsIGVuZFNsb3RdIDogW3N0YXJ0U2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2tzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgY29uZmlybWVkIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrU2lnbmF0dXJlc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0VHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UocmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSByZXN1bHQudHJhbnNhY3Rpb24uc2lnbmF0dXJlcztcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW4gYWRkcmVzc1xuICAgKiB3aXRoaW4gYSBzcGVjaWZpZWQgc2xvdCByYW5nZS4gTWF4IHJhbmdlIGFsbG93ZWQgaXMgMTAsMDAwIHNsb3RzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYxLjMuIFBsZWFzZSB1c2Uge0BsaW5rIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBzdGFydFNsb3Qgc3RhcnQgc2xvdCwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSBlbmRTbG90IGVuZCBzbG90LCBpbmNsdXNpdmVcbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIHN0YXJ0U2xvdCwgZW5kU2xvdCkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgbGV0IGZpcnN0QXZhaWxhYmxlQmxvY2sgPSBhd2FpdCB0aGlzLmdldEZpcnN0QXZhaWxhYmxlQmxvY2soKTtcbiAgICB3aGlsZSAoISgndW50aWwnIGluIG9wdGlvbnMpKSB7XG4gICAgICBzdGFydFNsb3QtLTtcbiAgICAgIGlmIChzdGFydFNsb3QgPD0gMCB8fCBzdGFydFNsb3QgPCBmaXJzdEF2YWlsYWJsZUJsb2NrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzdGFydFNsb3QsICdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMudW50aWwgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoaWdoZXN0Q29uZmlybWVkUm9vdCA9IGF3YWl0IHRoaXMuZ2V0U2xvdCgnZmluYWxpemVkJyk7XG4gICAgd2hpbGUgKCEoJ2JlZm9yZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIGVuZFNsb3QrKztcbiAgICAgIGlmIChlbmRTbG90ID4gaGlnaGVzdENvbmZpcm1lZFJvb3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmUgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29uZmlybWVkU2lnbmF0dXJlSW5mby5tYXAoaW5mbyA9PiBpbmZvLnNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzTG9va3VwVGFibGUoYWNjb3VudEtleSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChhY2NvdW50S2V5LCBjb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50KHtcbiAgICAgICAga2V5OiBhY2NvdW50S2V5LFxuICAgICAgICBzdGF0ZTogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudC5kZXNlcmlhbGl6ZShhY2NvdW50SW5mby5kYXRhKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gTm9uY2VBY2NvdW50LmZyb21BY2NvdW50RGF0YShhY2NvdW50SW5mby5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXROb25jZShub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IG5vbmNlIGZvciBhY2NvdW50ICcgKyBub25jZUFjY291bnQudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFuIGFsbG9jYXRpb24gb2YgbGFtcG9ydHMgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBMQU1QT1JUU19QRVJfU09MIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuICAgKlxuICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgKiAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcImh0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcbiAgICogICBjb25zdCBteUFkZHJlc3MgPSBuZXcgUHVibGljS2V5KFwiMm5yMWJIRlQ4Nlc5dEdueXZtWVc0dmNIS3NRQjNzVlFmbmRkYXN6NGtFeE1cIik7XG4gICAqICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5yZXF1ZXN0QWlyZHJvcChteUFkZHJlc3MsIExBTVBPUlRTX1BFUl9TT0wpO1xuICAgKiAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAqIH0pKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdEFpcmRyb3AodG8sIGxhbXBvcnRzKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgncmVxdWVzdEFpcmRyb3AnLCBbdG8udG9CYXNlNTgoKSwgbGFtcG9ydHNdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGFpcmRyb3AgdG8gJHt0by50b0Jhc2U1OCgpfSBmYWlsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSkge1xuICAgIGlmICghZGlzYWJsZUNhY2hlKSB7XG4gICAgICAvLyBXYWl0IGZvciBwb2xsaW5nIHRvIGZpbmlzaFxuICAgICAgd2hpbGUgKHRoaXMuX3BvbGxpbmdCbG9ja2hhc2gpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZldGNoID0gRGF0ZS5ub3coKSAtIHRoaXMuX2Jsb2NraGFzaEluZm8ubGFzdEZldGNoO1xuICAgICAgY29uc3QgZXhwaXJlZCA9IHRpbWVTaW5jZUZldGNoID49IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TO1xuICAgICAgaWYgKHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoICE9PSBudWxsICYmICFleHBpcmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BvbGxOZXdCbG9ja2hhc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9wb2xsTmV3QmxvY2toYXNoKCkge1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgY2FjaGVkTGF0ZXN0QmxvY2toYXNoID0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICBjb25zdCBjYWNoZWRCbG9ja2hhc2ggPSBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPyBjYWNoZWRMYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoIDogbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaCgnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChjYWNoZWRCbG9ja2hhc2ggIT09IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2gpIHtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgICAgICAgbGF0ZXN0QmxvY2toYXNoLFxuICAgICAgICAgICAgbGFzdEZldGNoOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgICAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2toYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xlZXAgZm9yIGFwcHJveGltYXRlbHkgaGFsZiBhIHNsb3RcbiAgICAgICAgYXdhaXQgc2xlZXAoTVNfUEVSX1NMT1QgLyAyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9idGFpbiBhIG5ldyBibG9ja2hhc2ggYWZ0ZXIgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlTWluaW11bURlbGVnYXRpb24oY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZzogY29uZmlnQXJnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWdBcmcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlTWluaW11bURlbGVnYXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvbmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNpbXVsYXRlVHJhbnNhY3Rpb259IHdpdGgge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufSBhbmQge0BsaW5rIFNpbXVsYXRlVHJhbnNhY3Rpb25Db25maWd9IHBhcmFtZXRlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uT3JNZXNzYWdlLCBjb25maWdPclNpZ25lcnMsIGluY2x1ZGVBY2NvdW50cykge1xuICAgIGlmICgnbWVzc2FnZScgaW4gdHJhbnNhY3Rpb25Pck1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHZlcnNpb25lZFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB2ZXJzaW9uZWRUeC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25maWcgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICBjb25maWcuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzaW11bGF0ZSB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgaWYgKHRyYW5zYWN0aW9uT3JNZXNzYWdlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAgIGxldCBvcmlnaW5hbFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBvcmlnaW5hbFR4LmZlZVBheWVyO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2UuaW5zdHJ1Y3Rpb25zO1xuICAgICAgdHJhbnNhY3Rpb24ubm9uY2VJbmZvID0gb3JpZ2luYWxUeC5ub25jZUluZm87XG4gICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzID0gb3JpZ2luYWxUeC5zaWduYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uT3JNZXNzYWdlKTtcbiAgICAgIC8vIEhBQ0s6IHRoaXMgZnVuY3Rpb24gcmVsaWVzIG9uIG11dGF0aW5nIHRoZSBwb3B1bGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gdHJhbnNhY3Rpb24uX2pzb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjb25maWdPclNpZ25lcnMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBjb25maWdPclNpZ25lcnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAmJiBzaWduZXJzKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgaWYgKCFzaWduZXJzKSBicmVhaztcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkgJiYgIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdHJhbnNhY3Rpb24uX2NvbXBpbGUoKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gd2lyZVRyYW5zYWN0aW9uLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICBjb21taXRtZW50OiB0aGlzLmNvbW1pdG1lbnRcbiAgICB9O1xuICAgIGlmIChpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IChBcnJheS5pc0FycmF5KGluY2x1ZGVBY2NvdW50cykgPyBpbmNsdWRlQWNjb3VudHMgOiBtZXNzYWdlLm5vblByb2dyYW1JZHMoKSkubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgICBjb25maWdbJ2FjY291bnRzJ10gPSB7XG4gICAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgYWRkcmVzc2VzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2lnbmVycykge1xuICAgICAgY29uZmlnLnNpZ1ZlcmlmeSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICBjb25zdCBsb2dUcmFjZSA9IHRyYWNlSW5kZW50ICsgbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5lcnJvci5tZXNzYWdlLCBsb2dUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9nc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzZW5kVHJhbnNhY3Rpb259IHdpdGggYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259XG4gICAqL1xuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZFJhd1RyYW5zYWN0aW9uKHdpcmVUcmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChzaWduZXJzT3JPcHRpb25zID09PSB1bmRlZmluZWQgfHwgIUFycmF5LmlzQXJyYXkoc2lnbmVyc09yT3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IHNpZ25lcnNPck9wdGlvbnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdvdWxkIGJlIHRyZWF0ZWQgYXMgZHVwbGljYXRlIChpdHMgZGVyaXZlZCBzaWduYXR1cmVcbiAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgIC8vIFNvLCB3ZSBtdXN0IGZldGNoIGEgbmV3IGJsb2NraGFzaCBmb3IgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGJ5IGRpc2FibGluZ1xuICAgICAgICAgIC8vIG91ciBjYWNoZSBub3QgdG8gd2FpdCBmb3IgdGhlIGNhY2hlIGV4cGlyYXRpb24gKEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TKS5cbiAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkIGFuZCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0XG4gICAqL1xuICBhc3luYyBzZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSB0b0J1ZmZlcihyYXdUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZEVuY29kZWRUcmFuc2FjdGlvbihlbmNvZGVkVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQsIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXQsIGFuZCBlbmNvZGVkIGFzIGEgYmFzZTY0IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgc2VuZEVuY29kZWRUcmFuc2FjdGlvbihlbmNvZGVkVHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCdcbiAgICB9O1xuICAgIGNvbnN0IHNraXBQcmVmbGlnaHQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcFByZWZsaWdodDtcbiAgICBjb25zdCBwcmVmbGlnaHRDb21taXRtZW50ID0gc2tpcFByZWZsaWdodCA9PT0gdHJ1ZSA/ICdwcm9jZXNzZWQnIC8vIEZJWE1FIFJlbW92ZSB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9wdWxsLzQ4MyBpcyBkZXBsb3llZC5cbiAgICA6IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWluQ29udGV4dFNsb3QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1pbkNvbnRleHRTbG90ID0gb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICB9XG4gICAgaWYgKHNraXBQcmVmbGlnaHQpIHtcbiAgICAgIGNvbmZpZy5za2lwUHJlZmxpZ2h0ID0gc2tpcFByZWZsaWdodDtcbiAgICB9XG4gICAgaWYgKHByZWZsaWdodENvbW1pdG1lbnQpIHtcbiAgICAgIGNvbmZpZy5wcmVmbGlnaHRDb21taXRtZW50ID0gcHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2VuZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246IHNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6ICcnLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICBsb2dzOiBsb2dzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbk9wZW4oKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAvLyBQaW5nIHNlcnZlciBldmVyeSA1cyB0byBwcmV2ZW50IGlkbGUgdGltZW91dHNcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0Lm5vdGlmeSgncGluZycpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9KSgpO1xuICAgIH0sIDUwMDApO1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25DbG9zZShjb2RlKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9ICh0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMDAwKSB7XG4gICAgICAvLyBleHBsaWNpdCBjbG9zZSwgY2hlY2sgaWYgYW55IHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIG1hZGUgc2luY2UgY2xvc2VcbiAgICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbXBsaWNpdCBjbG9zZSwgcHJlcGFyZSBzdWJzY3JpcHRpb25zIGZvciBhdXRvLXJlY29ubmVjdFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5mb3JFYWNoKChbaGFzaCwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTdWJzY3JpcHRpb24oaGFzaCwgbmV4dFN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0/LnN0YXRlO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSBuZXh0U3Vic2NyaXB0aW9uO1xuICAgIGlmIChwcmV2U3RhdGUgIT09IG5leHRTdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiKG5leHRTdWJzY3JpcHRpb24uc3RhdGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShjbGllbnRTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChoYXNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXSB8fD0gbmV3IFNldCgpO1xuICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGVuIGNsb3Npbmcgc29ja2V0IGNvbm5lY3Rpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgY29uc3QgaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPT09IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgfTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAvLyBEb24ndCBiZSB0ZW1wdGVkIHRvIGNoYW5nZSB0aGlzIHRvIGBPYmplY3QuZW50cmllc2AuIFdlIGNhbGxcbiAgICAvLyBgX3VwZGF0ZVN1YnNjcmlwdGlvbnNgIHJlY3Vyc2l2ZWx5IHdoZW4gcHJvY2Vzc2luZyB0aGUgc3RhdGUsXG4gICAgLy8gc28gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBsb29rIHVwIHRoZSAqY3VycmVudCogdmVyc2lvbiBvZlxuICAgIC8vIGVhY2ggc3Vic2NyaXB0aW9uLCBldmVyeSB0aW1lIHdlIHByb2Nlc3MgYSBoYXNoLlxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLm1hcChhc3luYyBoYXNoID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBlbnRyeSBoYXMgc2luY2UgYmVlbiBkZWxldGVkLiBTa2lwLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndW5zdWJzY3JpYmVkJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFlvdSBjYW4gZW5kIHVwIGhlcmUgd2hlbjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGEgc3Vic2NyaXB0aW9uIGhhcyByZWNlbnRseSB1bnN1YnNjcmliZWRcbiAgICAgICAgICAgICAqICAgd2l0aG91dCBoYXZpbmcgbmV3IGNhbGxiYWNrcyBhZGRlZCB0byBpdFxuICAgICAgICAgICAgICogICB3aGlsZSB0aGUgdW5zdWJzY3JpYmUgd2FzIGluIGZsaWdodCwgb3JcbiAgICAgICAgICAgICAqIC0gd2hlbiBhIHBlbmRpbmcgc3Vic2NyaXB0aW9uIGhhcyBpdHNcbiAgICAgICAgICAgICAqICAgbGlzdGVuZXJzIHJlbW92ZWQgYmVmb3JlIGEgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAqICAgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEJlaW5nIHRoYXQgbm9ib2R5IGlzIGludGVyZXN0ZWQgaW4gdGhpc1xuICAgICAgICAgICAgICogc3Vic2NyaXB0aW9uIGFueSBsb25nZXIsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3Vic2NyaXB0aW9uSWQgPSBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQuY2FsbChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXSA9IHN1YnNjcmlwdGlvbi5jYWxsYmFja3M7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7bWV0aG9kfSBlcnJvciBmb3IgYXJndW1lbnRgLCBhcmdzLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnkgdGhlIHRpbWUgd2Ugc3VjY2Vzc2Z1bGx5IHNldCB1cCBhIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2VydmVyLCB0aGUgY2xpZW50IHN0b3BwZWQgY2FyaW5nIGFib3V0IGl0LlxuICAgICAgICAgICAgLy8gVGVhciBpdCBkb3duIG5vdy5cbiAgICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1ldGhvZFxuICAgICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmhhcyhzZXJ2ZXJTdWJzY3JpcHRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgICAgICAgICAgICogSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgc3Vic2NyaXB0aW9uIHRoYXQgaGFzIGJlZW4gYXV0by1cbiAgICAgICAgICAgICAgICAgKiBkaXNwb3NlZCBieSB0aGUgUlBDLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBSUEMgY2FsbCB0b1xuICAgICAgICAgICAgICAgICAqIHRlYXIgZG93biB0aGUgc3Vic2NyaXB0aW9uIGhlcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5kZWxldGUoc2VydmVyU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwodW5zdWJzY3JpYmVNZXRob2QsIFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHt1bnN1YnNjcmliZU1ldGhvZH0gZXJyb3I6YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHNlcnZlclN1YnNjcmlwdGlvbklkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoXG4gICAgICAgIC8vIEkgZmFpbGVkIHRvIGZpbmQgYSB3YXkgdG8gY29udmluY2UgVHlwZVNjcmlwdCB0aGF0IGBjYmAgaXMgb2YgdHlwZVxuICAgICAgICAvLyBgVENhbGxiYWNrYCB3aGljaCBpcyBjZXJ0YWlubHkgY29tcGF0aWJsZSB3aXRoIGBQYXJhbWV0ZXJzPFRDYWxsYmFjaz5gLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NzYxNVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC4uLmNhbGxiYWNrQXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIEFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25Db25maWcsXG4gIC8qKlxuICAgKiBXaGVuIHByZXBhcmluZyBgYXJnc2AgZm9yIGEgY2FsbCB0byBgX21ha2VTdWJzY3JpcHRpb25gLCBiZSBzdXJlXG4gICAqIHRvIGNhcmVmdWxseSBhcHBseSBhIGRlZmF1bHQgYGNvbW1pdG1lbnRgIHByb3BlcnR5LCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIC0gSWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBgY29tbWl0bWVudGAgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYENvbm5lY3Rpb246OmNvbW1pdG1lbnRgIGlzIHNldCwgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBzZXQgaXQgdG8gdGhlIFJQQyBzZXJ2ZXIgZGVmYXVsdDogYGZpbmFsaXplZGAuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGVzZSB0d28gZnVuZGFtZW50YWxseVxuICAgKiBpZGVudGljYWwgc3Vic2NyaXB0aW9ucyBwcm9kdWNlIHRoZSBzYW1lIGlkZW50aWZ5aW5nIGhhc2g6XG4gICAqXG4gICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aXRob3V0IHNwZWNpZnlpbmcgYSBjb21taXRtZW50LlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2hlcmUgdGhlIGNvbW1pdG1lbnQgc3BlY2lmaWVkIGlzIHRoZSBzYW1lXG4gICAqICAgYXMgdGhlIGRlZmF1bHQgYXBwbGllZCB0byB0aGUgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICAgKlxuICAgKiBFeGFtcGxlOyB0aGVzZSB0d28gc3Vic2NyaXB0aW9ucyBtdXN0IHByb2R1Y2UgdGhlIHNhbWUgaGFzaDpcbiAgICpcbiAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYCB3aXRoIGNvbW1pdG1lbnRcbiAgICogICBgJ2ZpbmFsaXplZCdgLlxuICAgKlxuICAgKiBTZWUgdGhlICdtYWtpbmcgYSBzdWJzY3JpcHRpb24gd2l0aCBkZWZhdWx0ZWQgcGFyYW1zIG9taXR0ZWQnIHRlc3RcbiAgICogaW4gYGNvbm5lY3Rpb24tc3Vic2NyaXB0aW9ucy50c2AgZm9yIG1vcmUuXG4gICAqL1xuICBhcmdzKSB7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQrKztcbiAgICBjb25zdCBoYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeSQxKFtzdWJzY3JpcHRpb25Db25maWcubWV0aG9kLCBhcmdzXSk7XG4gICAgY29uc3QgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgIGlmIChleGlzdGluZ1N1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0ge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb25Db25maWcsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNhbGxiYWNrczogbmV3IFNldChbc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrXSksXG4gICAgICAgIHN0YXRlOiAncGVuZGluZydcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nU3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5hZGQoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gaGFzaDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBhc3NlcnQoc3Vic2NyaXB0aW9uICE9PSB1bmRlZmluZWQsIGBDb3VsZCBub3QgZmluZCBhIFxcYFN1YnNjcmlwdGlvblxcYCB3aGVuIHRlYXJpbmcgZG93biBjbGllbnQgc3Vic2NyaXB0aW9uICMke2NsaWVudFN1YnNjcmlwdGlvbklkfWApO1xuICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5kZWxldGUoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgYWNjb3VudCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXkgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIGFjY291bnQgY2hhbmdlcyBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdhY2NvdW50U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnYWNjb3VudFVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFt7XG4gICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICBhY2NvdW50SW5mbzogcmVzdWx0LnZhbHVlLmFjY291bnRcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIGFjY291bnQgY2hhbmdlcyBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIGZpbHRlcnMgVGhlIHByb2dyYW0gYWNjb3VudCBmaWx0ZXJzIHRvIHBhc3MgaW50byB0aGUgUlBDIG1ldGhvZFxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Qcm9ncmFtQWNjb3VudENoYW5nZShwcm9ncmFtSWQsIGNhbGxiYWNrLCBjb21taXRtZW50LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0JyAvKiBlbmNvZGluZyAqLywgZmlsdGVycyA/IHtcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnNcbiAgICB9IDogdW5kZWZpbmVkIC8qIGV4dHJhICovKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Byb2dyYW1TdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdwcm9ncmFtVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdwcm9ncmFtIGFjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBsb2dzIGFyZSBlbWl0dGVkLlxuICAgKi9cbiAgb25Mb2dzKGZpbHRlciwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IHtcbiAgICAgIG1lbnRpb25zOiBbZmlsdGVyLnRvU3RyaW5nKCldXG4gICAgfSA6IGZpbHRlcl0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdsb2dzU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnbG9nc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlT25Mb2dzTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2xvZ3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uTG9nc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgTG9nc05vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdC52YWx1ZSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnc2xvdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgdXBkYXRlcy4ge0BsaW5rIFNsb3RVcGRhdGV9J3NcbiAgICogbWF5IGJlIHVzZWZ1bCB0byB0cmFjayBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCB1cGRhdGVzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RVcGRhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RzVXBkYXRlc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzbG90IHVwZGF0ZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdFVwZGF0ZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IHVwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBhc3luYyBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsIHN1YnNjcmlwdGlvbk5hbWUpIHtcbiAgICBjb25zdCBkaXNwb3NlID0gdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChkaXNwb3NlKSB7XG4gICAgICBhd2FpdCBkaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSWdub3JlZCB1bnN1YnNjcmliZSByZXF1ZXN0IGJlY2F1c2UgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiB3aXRoIGlkICcgKyBgXFxgJHtjbGllbnRTdWJzY3JpcHRpb25JZH1cXGAgZm9yICcke3N1YnNjcmlwdGlvbk5hbWV9JyBldmVudHMgYCArICdjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgfVxuICB9XG4gIF9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSkge1xuICAgIGNvbnN0IGNvbW1pdG1lbnQgPSBvdmVycmlkZSB8fCB0aGlzLl9jb21taXRtZW50O1xuICAgIGlmIChjb21taXRtZW50IHx8IGVuY29kaW5nIHx8IGV4dHJhKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZXh0cmEpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCAmJiAhWydjb25maXJtZWQnLCAnZmluYWxpemVkJ10uaW5jbHVkZXMoY29tbWl0bWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgQ29ubmVjdGlvbiB3aXRoIGRlZmF1bHQgY29tbWl0bWVudDogYCcgKyB0aGlzLl9jb21taXRtZW50ICsgJ2AsIGJ1dCBtZXRob2QgcmVxdWlyZXMgYXQgbGVhc3QgYGNvbmZpcm1lZGAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkQXJncyhhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIGlmIChyZXN1bHQudmFsdWUgIT09ICdyZWNlaXZlZFNpZ25hdHVyZScpIHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnID8gW3tcbiAgICAgIHR5cGU6ICdyZWNlaXZlZCdcbiAgICB9LCByZXN1bHQuY29udGV4dF0gOiBbe1xuICAgICAgdHlwZTogJ3N0YXR1cycsXG4gICAgICByZXN1bHQ6IHJlc3VsdC52YWx1ZVxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2lnbmF0dXJlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLnJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGEgdHJhbnNhY3Rpb24gaXNcbiAgICogcmVjZWl2ZWQgYW5kL29yIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBFbmFibGUgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucyBhbmQgc2V0IHRoZSBjb21taXRtZW50XG4gICAqICAgbGV2ZWwgdGhhdCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZVdpdGhPcHRpb25zKHNpZ25hdHVyZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgLi4uZXh0cmFcbiAgICB9ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgZXh0cmEpO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24sIGNvbnRleHQpO1xuICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2lnbmF0dXJlIHJlc3VsdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Sb290Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBSb290Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gcm9vdCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHJvb3QgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Sb290Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdyb290U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncm9vdFVuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSByb290IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Jvb3QgY2hhbmdlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZXlwYWlyIHNpZ25lciBpbnRlcmZhY2VcbiAqL1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5cGFpciB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgS2V5cGFpciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2V5cGFpciBpbnN0YW5jZS5cbiAgICogR2VuZXJhdGUgcmFuZG9tIGtleXBhaXIgaWYgbm8ge0BsaW5rIEVkMjU1MTlLZXlwYWlyfSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFZDI1NTE5S2V5cGFpcn0ga2V5cGFpciBlZDI1NTE5IGtleXBhaXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXBhaXIpIHtcbiAgICB0aGlzLl9rZXlwYWlyID0gdm9pZCAwO1xuICAgIHRoaXMuX2tleXBhaXIgPSBrZXlwYWlyID8/IGdlbmVyYXRlS2V5cGFpcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKGdlbmVyYXRlS2V5cGFpcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXlwYWlyIGZyb20gYSByYXcgc2VjcmV0IGtleSBieXRlIGFycmF5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlY3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcHJldmlvdXNseVxuICAgKiBnZW5lcmF0ZWQgc2VjcmV0IGtleS4gR2VuZXJhdGluZyBrZXlwYWlycyBmcm9tIGEgcmFuZG9tIHNlZWQgc2hvdWxkIGJlIGRvbmVcbiAgICogd2l0aCB0aGUge0BsaW5rIEtleXBhaXIuZnJvbVNlZWR9IG1ldGhvZC5cbiAgICpcbiAgICogQHRocm93cyBlcnJvciBpZiB0aGUgcHJvdmlkZWQgc2VjcmV0IGtleSBpcyBpbnZhbGlkIGFuZCB2YWxpZGF0aW9uIGlzIG5vdCBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IHNlY3JldCBrZXkgYnl0ZSBhcnJheVxuICAgKiBAcGFyYW0gb3B0aW9ucyBza2lwIHNlY3JldCBrZXkgdmFsaWRhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNyZXRLZXkoc2VjcmV0S2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKHNlY3JldEtleS5ieXRlTGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3JldEtleS5zbGljZSgzMiwgNjQpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IHNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICBjb25zdCBjb21wdXRlZFB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAzMjsgaWkrKykge1xuICAgICAgICBpZiAocHVibGljS2V5W2lpXSAhPT0gY29tcHV0ZWRQdWJsaWNLZXlbaWldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBzZWNyZXRLZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGtleXBhaXIgZnJvbSBhIDMyIGJ5dGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlZWQgc2VlZCBieXRlIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZWVkKTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgc2VjcmV0S2V5LnNldChzZWVkKTtcbiAgICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IFB1YmxpY0tleVxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9rZXlwYWlyLnB1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJhdyBzZWNyZXQga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFNlY3JldCBrZXkgaW4gYW4gYXJyYXkgb2YgVWludDggYnl0ZXNcbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2tleXBhaXIuc2VjcmV0S2V5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIGFkZHJlc3MgbG9va3VwIHRhYmxlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgncmVjZW50U2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2J1bXBTZWVkJyldKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2FkZHJlc3NlcycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbbGF5b3V0VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGxheW91dFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGEgTG9va3VwVGFibGUgSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY2VudFNsb3RcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIHJlY2VudFNsb3Q6IE51bWJlcihyZWNlbnRTbG90KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUV4dGVuZExvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgMmApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDIgPyBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChidWZmZXIgPT4gbmV3IFB1YmxpY0tleShidWZmZXIpKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUNsb3NlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICByZWNpcGllbnQ6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRnJlZXplTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBBZGRyZXNzTG9va3VwVGFibGUgUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlzTGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBjcmVhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBidW1wU2VlZF0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbcGFyYW1zLmF1dGhvcml0eS50b0J1ZmZlcigpLCB0b0J1ZmZlckxFKEJpZ0ludChwYXJhbXMucmVjZW50U2xvdCksIDgpXSwgdGhpcy5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICByZWNlbnRTbG90OiBCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLFxuICAgICAgYnVtcFNlZWQ6IGJ1bXBTZWVkXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGxvb2t1cFRhYmxlQWRkcmVzcyxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gW25ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pLCBsb29rdXBUYWJsZUFkZHJlc3NdO1xuICB9XG4gIHN0YXRpYyBmcmVlemVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRnJlZXplTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBleHRlbmRMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRXh0ZW5kTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYWRkcmVzc2VzOiBwYXJhbXMuYWRkcmVzc2VzLm1hcChhZGRyID0+IGFkZHIudG9CeXRlcygpKVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChwYXJhbXMucGF5ZXIpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBkZWFjdGl2YXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsb3NlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNsb3NlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxufVxuQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdBZGRyZXNzTG9va3VwVGFiMWUxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQ29tcHV0ZSBCdWRnZXQgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSByZXF1ZXN0IHVuaXRzIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RVbml0cyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0cyxcbiAgICAgIGFkZGl0aW9uYWxGZWVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCBoZWFwIGZyYW1lIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RIZWFwRnJhbWUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgYnl0ZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdEhlYXBGcmFtZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgc2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaXRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB1bml0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgcHJpY2UgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRQcmljZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IENvbXB1dGVCdWRnZXRQcm9ncmFtJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IHVuaXRzIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCBoZWFwIGZyYW1lIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgcHJpY2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0IEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKSwgQnVmZmVyTGF5b3V0LnUzMignYWRkaXRpb25hbEZlZScpXSlcbiAgfSxcbiAgUmVxdWVzdEhlYXBGcmFtZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlcycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCB1NjQoJ21pY3JvTGFtcG9ydHMnKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRMaW1pdH0gYW5kL29yIHtAbGluayBzZXRDb21wdXRlVW5pdFByaWNlfVxuICAgKi9cbiAgc3RhdGljIHJlcXVlc3RVbml0cyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHM7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZXF1ZXN0SGVhcEZyYW1lKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdExpbWl0KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdFByaWNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbWljcm9MYW1wb3J0czogQmlnSW50KHBhcmFtcy5taWNyb0xhbXBvcnRzKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkNvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0NvbXB1dGVCdWRnZXQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMkMSA9IDY0O1xuY29uc3QgUFVCTElDX0tFWV9CWVRFUyQxID0gMzI7XG5jb25zdCBTSUdOQVRVUkVfQllURVMgPSA2NDtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgncGFkZGluZycpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdwdWJsaWNLZXlPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKV0pO1xuY2xhc3MgRWQyNTUxOVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBlZDI1NTE5IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUuIFRoZVxuICAgKiBwdWJsaWMga2V5IG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLCBhbmQgdGhlIHNpZ25hdHVyZVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIG9mIDY0IGJ5dGVzLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMkMSwgYFB1YmxpYyBLZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHVibGljS2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gU0lHTkFUVVJFX0JZVEVTLCBgU2lnbmF0dXJlIG11c3QgYmUgJHtTSUdOQVRVUkVfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3NpZ25hdHVyZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgcHVibGljS2V5T2Zmc2V0ID0gRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbjtcbiAgICBjb25zdCBzaWduYXR1cmVPZmZzZXQgPSBwdWJsaWNLZXlPZmZzZXQgKyBwdWJsaWNLZXkubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aDtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MobWVzc2FnZURhdGFPZmZzZXQgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvbkluZGV4ID09IG51bGwgPyAweGZmZmYgLy8gQW4gaW5kZXggb2YgYHUxNjo6TUFYYCBtYWtlcyBpdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGluc3RydWN0aW9uLlxuICAgIDogaW5zdHJ1Y3Rpb25JbmRleDtcbiAgICBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgbnVtU2lnbmF0dXJlcyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIHB1YmxpY0tleU9mZnNldCxcbiAgICAgIHB1YmxpY0tleUluc3RydWN0aW9uSW5kZXg6IGluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluZGV4XG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChwdWJsaWNLZXksIHB1YmxpY0tleU9mZnNldCk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwoc2lnbmF0dXJlLCBzaWduYXR1cmVPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKG1lc3NhZ2UsIG1lc3NhZ2VEYXRhT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IEVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGRhdGE6IGluc3RydWN0aW9uRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTJDEsIGBQcml2YXRlIGtleSBtdXN0IGJlICR7UFJJVkFURV9LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHJpdmF0ZUtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXBhaXIgPSBLZXlwYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlwYWlyLnB1YmxpY0tleS50b0J5dGVzKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKG1lc3NhZ2UsIGtleXBhaXIuc2VjcmV0S2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbkVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0VkMjU1MTlTaWdWZXJpZnkxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgZWNkc2FTaWduID0gKG1zZ0hhc2gsIHByaXZLZXkpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdktleSk7XG4gIHJldHVybiBbc2lnbmF0dXJlLnRvQ29tcGFjdFJhd0J5dGVzKCksIHNpZ25hdHVyZS5yZWNvdmVyeV07XG59O1xuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5O1xuY29uc3QgcHVibGljS2V5Q3JlYXRlID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMgPSAzMjtcbmNvbnN0IEVUSEVSRVVNX0FERFJFU1NfQllURVMgPSAyMDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMgPSA2NDtcbmNvbnN0IFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSA9IDExO1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYW4gRXRoZXJldW0gYWRkcmVzc1xuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51OCgnc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdldGhBZGRyZXNzT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51OCgnZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51OCgnbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMjAsICdldGhBZGRyZXNzJyksIEJ1ZmZlckxheW91dC5ibG9iKDY0LCAnc2lnbmF0dXJlJyksIEJ1ZmZlckxheW91dC51OCgncmVjb3ZlcnlJZCcpXSk7XG5jbGFzcyBTZWNwMjU2azFQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgc2VjcDI1NmsxIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBFdGhlcmV1bSBhZGRyZXNzIGZyb20gYSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXIuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgYSA2NCBieXRlIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHB1YmxpY0tleVRvRXRoQWRkcmVzcyhwdWJsaWNLZXkpIHtcbiAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUywgYFB1YmxpYyBrZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKHB1YmxpY0tleSkpKS5zbGljZSgtRVRIRVJFVU1fQUREUkVTU19CWVRFUyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY29uc3RydWN0aW5nIEV0aGVyZXVtIGFkZHJlc3M6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHB1YmxpYyBrZXkuIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBTZWNwMjU2azFQcm9ncmFtLmNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3Moe1xuICAgICAgZXRoQWRkcmVzczogU2VjcDI1NmsxUHJvZ3JhbS5wdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhbiBFdGhlcmV1bSBhZGRyZXNzLiBUaGUgYWRkcmVzc1xuICAgKiBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBhIGJ1ZmZlciB0aGF0IGlzIDIwIGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBldGhBZGRyZXNzOiByYXdBZGRyZXNzLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4ID0gMFxuICAgIH0gPSBwYXJhbXM7XG4gICAgbGV0IGV0aEFkZHJlc3M7XG4gICAgaWYgKHR5cGVvZiByYXdBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHJhd0FkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcy5zdWJzdHIoMiksICdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV0aEFkZHJlc3MgPSBCdWZmZXIuZnJvbShyYXdBZGRyZXNzLCAnaGV4Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV0aEFkZHJlc3MgPSByYXdBZGRyZXNzO1xuICAgIH1cbiAgICBhc3NlcnQoZXRoQWRkcmVzcy5sZW5ndGggPT09IEVUSEVSRVVNX0FERFJFU1NfQllURVMsIGBBZGRyZXNzIG11c3QgYmUgJHtFVEhFUkVVTV9BRERSRVNTX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtldGhBZGRyZXNzLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBjb25zdCBkYXRhU3RhcnQgPSAxICsgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFO1xuICAgIGNvbnN0IGV0aEFkZHJlc3NPZmZzZXQgPSBkYXRhU3RhcnQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gZGF0YVN0YXJ0ICsgZXRoQWRkcmVzcy5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoICsgMTtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MoU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgZXRoQWRkcmVzc09mZnNldCxcbiAgICAgIGV0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICBzaWduYXR1cmU6IHRvQnVmZmVyKHNpZ25hdHVyZSksXG4gICAgICBldGhBZGRyZXNzOiB0b0J1ZmZlcihldGhBZGRyZXNzKSxcbiAgICAgIHJlY292ZXJ5SWRcbiAgICB9LCBpbnN0cnVjdGlvbkRhdGEpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHRvQnVmZmVyKG1lc3NhZ2UpLCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW4pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogU2VjcDI1NmsxUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleTogcGtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocGtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwa2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHRvQnVmZmVyKHBrZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlIC8qIGlzQ29tcHJlc3NlZCAqLykuc2xpY2UoMSk7IC8vIHRocm93IGF3YXkgbGVhZGluZyBieXRlXG4gICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2Nha18yNTYodG9CdWZmZXIobWVzc2FnZSkpKTtcbiAgICAgIGNvbnN0IFtzaWduYXR1cmUsIHJlY292ZXJ5SWRdID0gZWNkc2FTaWduKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICByZWNvdmVyeUlkLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cblNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnS2VjY2FrU2VjcDI1NmsxMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG52YXIgX0xvY2t1cDtcblxuLyoqXG4gKiBBZGRyZXNzIG9mIHRoZSBzdGFrZSBjb25maWcgYWNjb3VudCB3aGljaCBjb25maWd1cmVzIHRoZSByYXRlXG4gKiBvZiBzdGFrZSB3YXJtdXAgYW5kIGNvb2xkb3duIGFzIHdlbGwgYXMgdGhlIHNsYXNoaW5nIHBlbmFsdHkuXG4gKi9cbmNvbnN0IFNUQUtFX0NPTkZJR19JRCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlQ29uZmlnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGF1dGhvcml0eSBpbmZvXG4gKi9cbmNsYXNzIEF1dGhvcml6ZWQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEF1dGhvcml6ZWQgb2JqZWN0XG4gICAqIEBwYXJhbSBzdGFrZXIgdGhlIHN0YWtlIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gd2l0aGRyYXdlciB0aGUgd2l0aGRyYXcgYXV0aG9yaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGFrZXIsIHdpdGhkcmF3ZXIpIHtcbiAgICAvKiogc3Rha2UgYXV0aG9yaXR5ICovXG4gICAgdGhpcy5zdGFrZXIgPSB2b2lkIDA7XG4gICAgLyoqIHdpdGhkcmF3IGF1dGhvcml0eSAqL1xuICAgIHRoaXMud2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWtlciA9IHN0YWtlcjtcbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB3aXRoZHJhd2VyO1xuICB9XG59XG4vKipcbiAqIFN0YWtlIGFjY291bnQgbG9ja3VwIGluZm9cbiAqL1xuY2xhc3MgTG9ja3VwIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBMb2NrdXAgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1bml4VGltZXN0YW1wLCBlcG9jaCwgY3VzdG9kaWFuKSB7XG4gICAgLyoqIFVuaXggdGltZXN0YW1wIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIC8qKiBFcG9jaCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMuZXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIExvY2t1cCBjdXN0b2RpYW4gYXV0aG9yaXR5ICovXG4gICAgdGhpcy5jdXN0b2RpYW4gPSB2b2lkIDA7XG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdW5peFRpbWVzdGFtcDtcbiAgICB0aGlzLmVwb2NoID0gZXBvY2g7XG4gICAgdGhpcy5jdXN0b2RpYW4gPSBjdXN0b2RpYW47XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCwgaW5hY3RpdmUgTG9ja3VwIHZhbHVlXG4gICAqL1xufVxuX0xvY2t1cCA9IExvY2t1cDtcbkxvY2t1cC5kZWZhdWx0ID0gbmV3IF9Mb2NrdXAoMCwgMCwgUHVibGljS2V5LmRlZmF1bHQpO1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB3aXRoIHNlZWQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogSW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtcyB1c2luZyBhIGRlcml2ZWQga2V5XG4gKi9cbi8qKlxuICogU3BsaXQgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3BsaXQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIERlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogTWVyZ2Ugc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3Rha2UgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3Rha2VJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTdGFrZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQ6IG5ldyBBdXRob3JpemVkKG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC5zdGFrZXIpLCBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQud2l0aGRyYXdlcikpLFxuICAgICAgbG9ja3VwOiBuZXcgTG9ja3VwKGxvY2t1cC51bml4VGltZXN0YW1wLCBsb2NrdXAuZXBvY2gsIG5ldyBQdWJsaWNLZXkobG9ja3VwLmN1c3RvZGlhbikpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWxlZ2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDYpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplLXdpdGgtc2VlZCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXR5T3duZXIpLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNwbGl0IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNwbGl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuU3BsaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG1lcmdlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU1lcmdlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzb3VyY2VTdGFrZVB1YktleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDUpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3Rha2VQcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzdGFrZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgYXV0aG9yaXplZCgpLCBsb2NrdXAoKV0pXG4gIH0sXG4gIEF1dGhvcml6ZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YWtlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIERlbGVnYXRlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgU3BsaXQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgV2l0aGRyYXc6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZToge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIE1lcmdlOiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyksIHJ1c3RTdHJpbmcoJ2F1dGhvcml0eVNlZWQnKSwgcHVibGljS2V5KCdhdXRob3JpdHlPd25lcicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogU3Rha2UgYXV0aG9yaXphdGlvbiB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQnc1xuICovXG5jb25zdCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgU3Rha2VyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTdGFrZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN0YWtlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN0YWtlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24gdG8gYWRkIHRvIGEgU3Rha2UgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXA6IG1heWJlTG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsb2NrdXAgPSBtYXliZUxvY2t1cCB8fCBMb2NrdXAuZGVmYXVsdDtcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHtcbiAgICAgICAgc3Rha2VyOiB0b0J1ZmZlcihhdXRob3JpemVkLnN0YWtlci50b0J1ZmZlcigpKSxcbiAgICAgICAgd2l0aGRyYXdlcjogdG9CdWZmZXIoYXV0aG9yaXplZC53aXRoZHJhd2VyLnRvQnVmZmVyKCkpXG4gICAgICB9LFxuICAgICAgbG9ja3VwOiB7XG4gICAgICAgIHVuaXhUaW1lc3RhbXA6IGxvY2t1cC51bml4VGltZXN0YW1wLFxuICAgICAgICBlcG9jaDogbG9ja3VwLmVwb2NoLFxuICAgICAgICBjdXN0b2RpYW46IHRvQnVmZmVyKGxvY2t1cC5jdXN0b2RpYW4udG9CdWZmZXIoKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgdGhlIFN0YWtlIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZSh7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlbGVnYXRlcyBTdGFrZSB0b2tlbnMgdG8gYSB2YWxpZGF0b3JcbiAgICogVm90ZSBQdWJsaWNLZXkuIFRoaXMgdHJhbnNhY3Rpb24gY2FuIGFsc28gYmUgdXNlZCB0byByZWRlbGVnYXRlIFN0YWtlXG4gICAqIHRvIGEgbmV3IHZhbGlkYXRvciBWb3RlIFB1YmxpY0tleS5cbiAgICovXG4gIHN0YXRpYyBkZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1RBS0VfQ09ORklHX0lELFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiBzdGFrZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcixcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgY3VzdG9kaWFuUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleCxcbiAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcjogdG9CdWZmZXIoYXV0aG9yaXR5T3duZXIudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpdHlCYXNlLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgc3BsaXRJbnN0cnVjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBzdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgc3BsaXQocGFyYW1zLFxuICAvLyBDb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgdGhlIG5ldyBzdGFrZSBhY2NvdW50IGluIGxhbXBvcnRzXG4gIHJlbnRFeGVtcHRSZXNlcnZlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcmVudEV4ZW1wdFJlc2VydmUsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLnNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHNwbGl0cyBTdGFrZSB0b2tlbnMgaW50byBhbm90aGVyIGFjY291bnRcbiAgICogZGVyaXZlZCBmcm9tIGEgYmFzZSBwdWJsaWMga2V5IGFuZCBzZWVkXG4gICAqL1xuICBzdGF0aWMgc3BsaXRXaXRoU2VlZChwYXJhbXMsXG4gIC8vIElmIHRoaXMgc3Rha2UgYWNjb3VudCBpcyBuZXcsIGNvbXB1dGUgdGhlIGNvc3Qgb2YgYWxsb2NhdGluZyBpdCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgIGFjY291bnRQdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBpZiAocmVudEV4ZW1wdFJlc2VydmUgJiYgcmVudEV4ZW1wdFJlc2VydmUgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICB0b1B1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgbWVyZ2VzIFN0YWtlIGFjY291bnRzLlxuICAgKi9cbiAgc3RhdGljIG1lcmdlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHdpdGhkcmF3cyBkZWFjdGl2YXRlZCBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdG9QdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlYWN0aXZhdGVzIFN0YWtlIHRva2Vucy5cbiAgICovXG4gIHN0YXRpYyBkZWFjdGl2YXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3Rha2VQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbi8qKlxuICogTWF4IHNwYWNlIG9mIGEgU3Rha2UgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS1zdGFrZS1wcm9ncmFtIFN0YWtlU3RhdGUgc3RydWN0IGFzXG4gKiBgU3Rha2VTdGF0ZVYyOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS1zdGFrZS1wcm9ncmFtL2xhdGVzdC9zb2xhbmFfc3Rha2VfcHJvZ3JhbS9zdGFrZV9zdGF0ZS9lbnVtLlN0YWtlU3RhdGVWMi5odG1sXG4gKi9cblN0YWtlUHJvZ3JhbS5zcGFjZSA9IDIwMDtcblxuLyoqXG4gKiBWb3RlIGFjY291bnQgaW5mb1xuICovXG5jbGFzcyBWb3RlSW5pdCB7XG4gIC8qKiBbMCwgMTAwXSAqL1xuXG4gIGNvbnN0cnVjdG9yKG5vZGVQdWJrZXksIGF1dGhvcml6ZWRWb3RlciwgYXV0aG9yaXplZFdpdGhkcmF3ZXIsIGNvbW1pc3Npb24pIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gbm9kZVB1YmtleTtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IGF1dGhvcml6ZWRWb3RlcjtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gY29tbWlzc2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplQWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZVdpdGhTZWVkIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgZnJvbSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgdm90ZSBhY2NvdW50IGluc3RydWN0aW9uIHBhcmFtcy5cbiAqL1xuXG4vKipcbiAqIFZvdGUgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBWb3RlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGluaXRpYWxpemUgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVJbml0XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5LFxuICAgICAgdm90ZUluaXQ6IG5ldyBWb3RlSW5pdChuZXcgUHVibGljS2V5KHZvdGVJbml0Lm5vZGVQdWJrZXkpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRWb3RlciksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLCB2b3RlSW5pdC5jb21taXNzaW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBuZXcgUHVibGljS2V5KGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkpLFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH0sXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFZvdGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBWb3RlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgVm90ZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuXG5jb25zdCBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZUFjY291bnQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVJbml0KCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFVwZGF0ZVZhbGlkYXRvcklkZW50aXR5OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzKCldKVxuICB9XG59KTtcblxuLyoqXG4gKiBWb3RlQXV0aG9yaXplIHR5cGVcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVBdXRob3JpemF0aW9uIGxheW91dHMuXG4gKi9cbmNvbnN0IFZvdGVBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFZvdGVyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBWb3RlIHByb2dyYW1cbiAqL1xuY2xhc3MgVm90ZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBWb3RlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlSW5pdDoge1xuICAgICAgICBub2RlUHVia2V5OiB0b0J1ZmZlcih2b3RlSW5pdC5ub2RlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBhdXRob3JpemVkVm90ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRWb3Rlci50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyLnRvQnVmZmVyKCkpLFxuICAgICAgICBjb21taXNzaW9uOiB2b3RlSW5pdC5jb21taXNzaW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogbm9kZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemVBY2NvdW50KHtcbiAgICAgIHZvdGVQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgbm9kZVB1YmtleTogcGFyYW1zLnZvdGVJbml0Lm5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdDogcGFyYW1zLnZvdGVJbml0XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudFxuICAgKiB3aGVyZSB0aGUgY3VycmVudCBWb3RlciBvciBXaXRoZHJhd2VyIGF1dGhvcml0eSBpcyBhIGRlcml2ZWQga2V5LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IHRvQnVmZmVyKGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gd2l0aGRyYXcgc2FmZWx5IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2FzIGNyZWF0ZWQgYXMgYSBzYWZlZ3VhcmQgZm9yIHZvdGUgYWNjb3VudHMgcnVubmluZyB2YWxpZGF0b3JzLCBgc2FmZVdpdGhkcmF3YFxuICAgKiBjaGVja3MgdGhhdCB0aGUgd2l0aGRyYXcgYW1vdW50IHdpbGwgbm90IGV4Y2VlZCB0aGUgc3BlY2lmaWVkIGJhbGFuY2Ugd2hpbGUgbGVhdmluZyBlbm91Z2ggbGVmdFxuICAgKiB0byBjb3ZlciByZW50LiBJZiB5b3Ugd2lzaCB0byBjbG9zZSB0aGUgdm90ZSBhY2NvdW50IGJ5IHdpdGhkcmF3aW5nIHRoZSBmdWxsIGFtb3VudCwgY2FsbCB0aGVcbiAgICogYHdpdGhkcmF3YCBtZXRob2QgZGlyZWN0bHkuXG4gICAqL1xuICBzdGF0aWMgc2FmZVdpdGhkcmF3KHBhcmFtcywgY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSwgcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICBpZiAocGFyYW1zLmxhbXBvcnRzID4gY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSAtIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGhkcmF3IHdpbGwgbGVhdmUgdm90ZSBhY2NvdW50IHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gVm90ZVByb2dyYW0ud2l0aGRyYXcocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgb2YgYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbm9kZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5VcGRhdGVWYWxpZGF0b3JJZGVudGl0eTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Wb3RlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFZvdGUgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS12b3RlLXByb2dyYW0gVm90ZVN0YXRlIHN0cnVjdCBhc1xuICogYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtdm90ZS1wcm9ncmFtLzEuOS41L3NvbGFuYV92b3RlX3Byb2dyYW0vdm90ZV9zdGF0ZS9zdHJ1Y3QuVm90ZVN0YXRlLmh0bWwjbWV0aG9kLnNpemVfb2ZcbiAqXG4gKiBLRUVQIElOIFNZTkMgV0lUSCBgVm90ZVN0YXRlOjpzaXplX29mKClgIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9hNDc0Y2IyNGI5MjM4ZjVlZGNjOTgyZjY1YzBiMzdkNGExMDQ2ZjdlL3Nkay9wcm9ncmFtL3NyYy92b3RlL3N0YXRlL21vZC5ycyNMMzQwLUwzNDJcbiAqL1xuVm90ZVByb2dyYW0uc3BhY2UgPSAzNzYyO1xuXG5jb25zdCBWQUxJREFUT1JfSU5GT19LRVkgPSBuZXcgUHVibGljS2V5KCdWYTFpZGF0b3IxbmZvMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBJbmZvIHVzZWQgdG8gaWRlbnRpdHkgdmFsaWRhdG9ycy5cbiAqL1xuXG5jb25zdCBJbmZvU3RyaW5nID0gdHlwZSh7XG4gIG5hbWU6IHN0cmluZygpLFxuICB3ZWJzaXRlOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGRldGFpbHM6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAga2V5YmFzZVVzZXJuYW1lOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFZhbGlkYXRvckluZm8gY2xhc3NcbiAqL1xuY2xhc3MgVmFsaWRhdG9ySW5mbyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXksIGluZm8pIHtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZhbGlkYXRvckluZm8gZnJvbSB0aGUgY29uZmlnIGFjY291bnQgZGF0YS4gRXhhY3RseSB0d28gY29uZmlnXG4gICAqIGtleXMgYXJlIHJlcXVpcmVkIGluIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGNvbmZpZyBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBudWxsIGlmIGluZm8gd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZyb21Db25maWdEYXRhKGJ1ZmZlcikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSkpO1xuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShyYXdJbmZvKTtcbiAgICAgICAgYXNzZXJ0JDEoaW5mbywgSW5mb1N0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9ySW5mbyhjb25maWdLZXlzWzFdLnB1YmxpY0tleSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBIaXN0b3J5IG9mIGhvdyBtYW55IGNyZWRpdHMgZWFybmVkIGJ5IHRoZSBlbmQgb2YgZWFjaCBlcG9jaFxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi84YTEyZWQwMjljZmEzOGQ0YTQ1NDAwOTE2YzI0NjNmYjgyYmJlYzhjL3Byb2dyYW1zL3ZvdGVfYXBpL3NyYy92b3RlX3N0YXRlLnJzI0w2OC1MODhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVm90ZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIHZvdGVzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLCBCdWZmZXJMYXlvdXQudTMyKCdjb25maXJtYXRpb25Db3VudCcpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICd2b3RlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3Jvb3RTbG90VmFsaWQnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBhdXRob3JpemVkVm90ZXJzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoJyksIEJ1ZmZlckxheW91dC5udTY0KCd0YXJnZXRFcG9jaCcpXSksIDMyLCAnYnVmJyksIEJ1ZmZlckxheW91dC5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0LnU4KCdpc0VtcHR5JyldLCAncHJpb3JWb3RlcnMnKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIEJ1ZmZlckxheW91dC5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dC5udTY0KCdwcmV2Q3JlZGl0cycpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogc2VuZE9wdGlvbnM/LnNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0sIEF1dGhvcml6ZWQsIEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TLCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCwgQlBGX0xPQURFUl9QUk9HUkFNX0lELCBCcGZMb2FkZXIsIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiwgQ29tcHV0ZUJ1ZGdldFByb2dyYW0sIENvbm5lY3Rpb24sIEVkMjU1MTlQcm9ncmFtLCBFbnVtLCBFcG9jaFNjaGVkdWxlLCBGZWVDYWxjdWxhdG9yTGF5b3V0LCBLZXlwYWlyLCBMQU1QT1JUU19QRVJfU09MLCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUywgTG9hZGVyLCBMb2NrdXAsIE1BWF9TRUVEX0xFTkdUSCwgTWVzc2FnZSwgTWVzc2FnZUFjY291bnRLZXlzLCBNZXNzYWdlVjAsIE5PTkNFX0FDQ09VTlRfTEVOR1RILCBOb25jZUFjY291bnQsIFBBQ0tFVF9EQVRBX1NJWkUsIFBVQkxJQ19LRVlfTEVOR1RILCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFNPTEFOQV9TQ0hFTUEsIFNUQUtFX0NPTkZJR19JRCwgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVksIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZLCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSwgU1lTVkFSX1JFTlRfUFVCS0VZLCBTWVNWQVJfUkVXQVJEU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZLCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksIFNlY3AyNTZrMVByb2dyYW0sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCBTb2xhbmFKU09OUlBDRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvckNvZGUsIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCwgU3Rha2VJbnN0cnVjdGlvbiwgU3Rha2VQcm9ncmFtLCBTdHJ1Y3QsIFN5c3RlbUluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBUcmFuc2FjdGlvbk1lc3NhZ2UsIFRyYW5zYWN0aW9uU3RhdHVzLCBWQUxJREFUT1JfSU5GT19LRVksIFZFUlNJT05fUFJFRklYX01BU0ssIFZPVEVfUFJPR1JBTV9JRCwgVmFsaWRhdG9ySW5mbywgVmVyc2lvbmVkTWVzc2FnZSwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFZvdGVBY2NvdW50LCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCwgVm90ZUluaXQsIFZvdGVJbnN0cnVjdGlvbiwgVm90ZVByb2dyYW0sIGNsdXN0ZXJBcGlVcmwsIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJlZDI1NTE5IiwiQk4iLCJiczU4Iiwic2hhMjU2Iiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZVVuY2hlY2tlZCIsIkJ1ZmZlckxheW91dCIsImJsb2IiLCJ0b0JpZ0ludExFIiwidG9CdWZmZXJMRSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQwJDEiLCJyZXF1aXJlJCQwJDIiLCJBZ2VudCIsIkFnZW50JDEiLCJjb2VyY2UiLCJpbnN0YW5jZSIsInN0cmluZyIsInR1cGxlIiwibGl0ZXJhbCIsInVua25vd24iLCJ0eXBlIiwibnVtYmVyIiwiYXJyYXkiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwiYm9vbGVhbiIsInJlY29yZCIsInVuaW9uIiwiY3JlYXRlIiwiYW55IiwiYXNzZXJ0IiwiYXNzZXJ0JDEiLCJScGNDbGllbnQiLCJub2RlRmV0Y2giLCJDb21tb25DbGllbnQiLCJXZWJTb2NrZXQiLCJrZWNjYWtfMjU2Iiwic2VjcDI1NmsxIiwiZ2VuZXJhdGVQcml2YXRlS2V5IiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2VuZXJhdGVLZXlwYWlyIiwicHJpdmF0ZVNjYWxhciIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInNlY3JldEtleSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJpc09uQ3VydmUiLCJFeHRlbmRlZFBvaW50IiwiZnJvbUhleCIsInNpZ24iLCJtZXNzYWdlIiwic2xpY2UiLCJ2ZXJpZnkiLCJ0b0J1ZmZlciIsImFyciIsImlzQnVmZmVyIiwiZnJvbSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiU3RydWN0IiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0aWVzIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlIiwiU09MQU5BX1NDSEVNQSIsImRlY29kZSIsImRhdGEiLCJkZWNvZGVVbmNoZWNrZWQiLCJFbnVtIiwiZW51bSIsImtleXMiLCJsZW5ndGgiLCJFcnJvciIsIm1hcCIsImtleSIsIk1hcCIsIl9QdWJsaWNLZXkiLCJNQVhfU0VFRF9MRU5HVEgiLCJQVUJMSUNfS0VZX0xFTkdUSCIsImlzUHVibGljS2V5RGF0YSIsInZhbHVlIiwiX2JuIiwidW5kZWZpbmVkIiwidW5pcXVlUHVibGljS2V5Q291bnRlciIsIlB1YmxpY0tleSIsImRlY29kZWQiLCJ1bmlxdWUiLCJlcXVhbHMiLCJlcSIsInRvQmFzZTU4IiwidG9CeXRlcyIsInRvSlNPTiIsImJ1ZiIsImIiLCJ0b0FycmF5TGlrZSIsInplcm9QYWQiLCJhbGxvYyIsImNvcHkiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwiY3JlYXRlV2l0aFNlZWQiLCJmcm9tUHVibGljS2V5Iiwic2VlZCIsInByb2dyYW1JZCIsImNvbmNhdCIsInB1YmxpY0tleUJ5dGVzIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jIiwic2VlZHMiLCJmb3JFYWNoIiwiVHlwZUVycm9yIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3MiLCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwibm9uY2UiLCJhZGRyZXNzIiwic2VlZHNXaXRoTm9uY2UiLCJlcnIiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJwdWJrZXlEYXRhIiwicHVia2V5IiwiZGVmYXVsdCIsImtpbmQiLCJmaWVsZHMiLCJBY2NvdW50IiwiX3B1YmxpY0tleSIsIl9zZWNyZXRLZXkiLCJzZWNyZXRLZXlCdWZmZXIiLCJCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCIsIlBBQ0tFVF9EQVRBX1NJWkUiLCJWRVJTSU9OX1BSRUZJWF9NQVNLIiwiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyIsIlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciIsInNpZ25hdHVyZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwidGltZW91dFNlY29uZHMiLCJ0b0ZpeGVkIiwiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCJNZXNzYWdlQWNjb3VudEtleXMiLCJzdGF0aWNBY2NvdW50S2V5cyIsImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJrZXlTZWdtZW50cyIsInB1c2giLCJ3cml0YWJsZSIsInJlYWRvbmx5IiwiZ2V0IiwiaW5kZXgiLCJrZXlTZWdtZW50IiwiZmxhdCIsImNvbXBpbGVJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbnMiLCJVOF9NQVgiLCJrZXlJbmRleE1hcCIsImZpbmRLZXlJbmRleCIsImtleUluZGV4IiwiaW5zdHJ1Y3Rpb24iLCJwcm9ncmFtSWRJbmRleCIsImFjY291bnRLZXlJbmRleGVzIiwibWV0YSIsInByb3BlcnR5IiwicnVzdFN0cmluZyIsInJzbCIsInN0cnVjdCIsInUzMiIsIm9mZnNldCIsIl9kZWNvZGUiLCJiaW5kIiwiX2VuY29kZSIsInJzbFNoaW0iLCJzdHIiLCJjaGFycyIsInNwYW4iLCJhdXRob3JpemVkIiwibG9ja3VwIiwibnM2NCIsInZvdGVJbml0IiwidTgiLCJ2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIiwiZ2V0QWxsb2MiLCJnZXRJdGVtQWxsb2MiLCJpdGVtIiwiZmllbGQiLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50TGF5b3V0IiwibGF5b3V0IiwiZGVjb2RlTGVuZ3RoIiwiYnl0ZXMiLCJsZW4iLCJzaXplIiwiZWxlbSIsInNoaWZ0IiwiZW5jb2RlTGVuZ3RoIiwicmVtX2xlbiIsImNvbmRpdGlvbiIsIkNvbXBpbGVkS2V5cyIsInBheWVyIiwia2V5TWV0YU1hcCIsImNvbXBpbGUiLCJnZXRPckluc2VydERlZmF1bHQiLCJrZXlNZXRhIiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiaXNJbnZva2VkIiwicGF5ZXJLZXlNZXRhIiwiaXgiLCJhY2NvdW50TWV0YSIsImdldE1lc3NhZ2VDb21wb25lbnRzIiwibWFwRW50cmllcyIsImVudHJpZXMiLCJ3cml0YWJsZVNpZ25lcnMiLCJmaWx0ZXIiLCJyZWFkb25seVNpZ25lcnMiLCJ3cml0YWJsZU5vblNpZ25lcnMiLCJyZWFkb25seU5vblNpZ25lcnMiLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJudW1SZWFkb25seVNpZ25lZEFjY291bnRzIiwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzIiwicGF5ZXJBZGRyZXNzIiwiZXh0cmFjdFRhYmxlTG9va3VwIiwibG9va3VwVGFibGUiLCJ3cml0YWJsZUluZGV4ZXMiLCJkcmFpbmVkV3JpdGFibGVLZXlzIiwiZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlIiwic3RhdGUiLCJhZGRyZXNzZXMiLCJyZWFkb25seUluZGV4ZXMiLCJkcmFpbmVkUmVhZG9ubHlLZXlzIiwiYWNjb3VudEtleSIsImxvb2t1cFRhYmxlRW50cmllcyIsImtleU1ldGFGaWx0ZXIiLCJsb29rdXBUYWJsZUluZGV4ZXMiLCJkcmFpbmVkS2V5cyIsImxvb2t1cFRhYmxlSW5kZXgiLCJmaW5kSW5kZXgiLCJlbnRyeSIsImRlbGV0ZSIsIkVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSIsImd1YXJkZWRTaGlmdCIsImJ5dGVBcnJheSIsImd1YXJkZWRTcGxpY2UiLCJhcmdzIiwic3RhcnQiLCJzcGxpY2UiLCJNZXNzYWdlIiwiYWNjb3VudEtleXMiLCJyZWNlbnRCbG9ja2hhc2giLCJpbmRleFRvUHJvZ3JhbUlkcyIsImFjY291bnQiLCJ2ZXJzaW9uIiwiY29tcGlsZWRJbnN0cnVjdGlvbnMiLCJhY2NvdW50cyIsImFkZHJlc3NUYWJsZUxvb2t1cHMiLCJnZXRBY2NvdW50S2V5cyIsImNvbXBpbGVkS2V5cyIsInBheWVyS2V5IiwiaXNBY2NvdW50U2lnbmVyIiwiaXNBY2NvdW50V3JpdGFibGUiLCJudW1TaWduZWRBY2NvdW50cyIsInVuc2lnbmVkQWNjb3VudEluZGV4IiwibnVtVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMiLCJpc1Byb2dyYW1JZCIsImhhcyIsInByb2dyYW1JZHMiLCJ2YWx1ZXMiLCJub25Qcm9ncmFtSWRzIiwiXyIsIm51bUtleXMiLCJrZXlDb3VudCIsImtleUluZGljZXNDb3VudCIsImRhdGFDb3VudCIsImtleUluZGljZXMiLCJkYXRhTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25Db3VudCIsImluc3RydWN0aW9uQnVmZmVyIiwiaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgiLCJpbnN0cnVjdGlvbkxheW91dCIsInNlcSIsInNpZ25EYXRhTGF5b3V0IiwidHJhbnNhY3Rpb24iLCJzaWduRGF0YSIsImFjY291bnRDb3VudCIsImkiLCJkYXRhU2xpY2UiLCJtZXNzYWdlQXJncyIsIk1lc3NhZ2VWMCIsIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJjb3VudCIsImxvb2t1cCIsImFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIiwicmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJudW1TdGF0aWNBY2NvdW50S2V5cyIsImxvb2t1cEFjY291bnRLZXlzSW5kZXgiLCJudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzIiwicmVkdWNlIiwidGFibGVMb29rdXAiLCJ0YWJsZUFjY291bnQiLCJmaW5kIiwibG9va3VwVGFibGVBY2NvdW50cyIsImV4dHJhY3RSZXN1bHQiLCJhZGRyZXNzVGFibGVMb29rdXAiLCJlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zIiwic2VyaWFsaXplSW5zdHJ1Y3Rpb25zIiwiZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCIsInNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzIiwic2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcyIsImVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwibWVzc2FnZUxheW91dCIsInNlcmlhbGl6ZWRNZXNzYWdlIiwiTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYIiwic2VyaWFsaXplZE1lc3NhZ2VMZW5ndGgiLCJwcmVmaXgiLCJzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsImluc3RydWN0aW9uc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCJzZXJpYWxpemVkTGVuZ3RoIiwiZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZERhdGFMZW5ndGgiLCJlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cExheW91dCIsIm1hc2tlZFByZWZpeCIsImFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50Iiwid3JpdGFibGVJbmRleGVzTGVuZ3RoIiwicmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwiVmVyc2lvbmVkTWVzc2FnZSIsImRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24iLCJUcmFuc2FjdGlvblN0YXR1cyIsIkRFRkFVTFRfU0lHTkFUVVJFIiwiZmlsbCIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJvcHRzIiwiVHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwiZmVlUGF5ZXIiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsIm5vbmNlSW5mbyIsIm1pbk5vbmNlQ29udGV4dFNsb3QiLCJfbWVzc2FnZSIsIl9qc29uIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibWluQ29udGV4dFNsb3QiLCJibG9ja2hhc2giLCJub25jZUluc3RydWN0aW9uIiwic2lnbmVycyIsImFkZCIsIml0ZW1zIiwiY29tcGlsZU1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsIndhcm4iLCJhY2NvdW50TWV0YXMiLCJpbmNsdWRlcyIsInVuaXF1ZU1ldGFzIiwicHVia2V5U3RyaW5nIiwidW5pcXVlSW5kZXgiLCJ4Iiwic29ydCIsInkiLCJvcHRpb25zIiwibG9jYWxlTWF0Y2hlciIsInVzYWdlIiwic2Vuc2l0aXZpdHkiLCJpZ25vcmVQdW5jdHVhdGlvbiIsIm51bWVyaWMiLCJjYXNlRmlyc3QiLCJsb2NhbGVDb21wYXJlIiwiZmVlUGF5ZXJJbmRleCIsInBheWVyTWV0YSIsInVuc2hpZnQiLCJzaWduZWRLZXlzIiwidW5zaWduZWRLZXlzIiwiaW5kZXhPZiIsIl9jb21waWxlIiwidmFsaWQiLCJldmVyeSIsInBhaXIiLCJzZXJpYWxpemVNZXNzYWdlIiwiZ2V0RXN0aW1hdGVkRmVlIiwiY29ubmVjdGlvbiIsImdldEZlZUZvck1lc3NhZ2UiLCJzZXRTaWduZXJzIiwic2VlbiIsIlNldCIsInVuaXF1ZVNpZ25lcnMiLCJzaWduZXIiLCJfcGFydGlhbFNpZ24iLCJwYXJ0aWFsU2lnbiIsIl9hZGRTaWduYXR1cmUiLCJhZGRTaWduYXR1cmUiLCJzaWdwYWlyIiwidmVyaWZ5U2lnbmF0dXJlcyIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwic2lnbmF0dXJlRXJyb3JzIiwiX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzIiwiZXJyb3JzIiwibWlzc2luZyIsImludmFsaWQiLCJjb25maWciLCJzaWdFcnJvcnMiLCJlcnJvck1lc3NhZ2UiLCJwIiwiam9pbiIsIl9zZXJpYWxpemUiLCJzaWduYXR1cmVDb3VudCIsInRyYW5zYWN0aW9uTGVuZ3RoIiwid2lyZVRyYW5zYWN0aW9uIiwia2V5T2JqIiwicG9wdWxhdGUiLCJzaWdQdWJrZXlQYWlyIiwic29tZSIsIlRyYW5zYWN0aW9uTWVzc2FnZSIsImRlY29tcGlsZSIsImNvbXBpbGVkSXgiLCJjb21waWxlVG9MZWdhY3lNZXNzYWdlIiwiY29tcGlsZVRvVjBNZXNzYWdlIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJkZWZhdWx0U2lnbmF0dXJlcyIsImVuY29kZWRTaWduYXR1cmVzTGVuZ3RoIiwidHJhbnNhY3Rpb25MYXlvdXQiLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgiLCJzaWduYXR1cmVzTGVuZ3RoIiwibWVzc2FnZURhdGEiLCJzaWduZXJQdWJrZXlzIiwic2lnbmVySW5kZXgiLCJOVU1fVElDS1NfUEVSX1NFQ09ORCIsIkRFRkFVTFRfVElDS1NfUEVSX1NMT1QiLCJOVU1fU0xPVFNfUEVSX1NFQ09ORCIsIk1TX1BFUl9TTE9UIiwiU1lTVkFSX0NMT0NLX1BVQktFWSIsIlNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkiLCJTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSIsIlNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZIiwiU1lTVkFSX1JFTlRfUFVCS0VZIiwiU1lTVkFSX1JFV0FSRFNfUFVCS0VZIiwiU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZIiwiU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZIiwiU2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJhY3Rpb24iLCJ0cmFuc2FjdGlvbk1lc3NhZ2UiLCJsb2dzIiwibWF5YmVMb2dzT3V0cHV0IiwiZ3VpZGVUZXh0IiwiYSIsInRyYW5zYWN0aW9uTG9ncyIsInRyYW5zYWN0aW9uRXJyb3IiLCJjYWNoZWRMb2dzIiwiZ2V0TG9ncyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0VHJhbnNhY3Rpb24iLCJ0aGVuIiwidHgiLCJsb2dNZXNzYWdlcyIsImNhdGNoIiwiU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TQ0FOX0VSUk9SIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNvbGFuYUpTT05SUENFcnJvciIsImNvZGUiLCJjdXN0b21NZXNzYWdlIiwibmFtZSIsInNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24iLCJzZW5kT3B0aW9ucyIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwiY29tbWl0bWVudCIsIm1heFJldHJpZXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzdGF0dXMiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJhYm9ydFNpZ25hbCIsIm5vbmNlQWNjb3VudFB1YmtleSIsIm5vbmNlVmFsdWUiLCJzbGVlcCIsIm1zIiwic2V0VGltZW91dCIsImVuY29kZURhdGEiLCJhbGxvY0xlbmd0aCIsImxheW91dEZpZWxkcyIsImRlY29kZURhdGEkMSIsIkZlZUNhbGN1bGF0b3JMYXlvdXQiLCJudTY0IiwiTm9uY2VBY2NvdW50TGF5b3V0IiwiTk9OQ0VfQUNDT1VOVF9MRU5HVEgiLCJOb25jZUFjY291bnQiLCJhdXRob3JpemVkUHVia2V5IiwiZmVlQ2FsY3VsYXRvciIsImZyb21BY2NvdW50RGF0YSIsIm5vbmNlQWNjb3VudCIsImVuY29kZURlY29kZSIsImJpZ0ludCIsImJpZ0ludExheW91dCIsInNyYyIsInU2NCIsIlN5c3RlbUluc3RydWN0aW9uIiwiZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlIiwiY2hlY2tQcm9ncmFtSWQiLCJpbnN0cnVjdGlvblR5cGVMYXlvdXQiLCJ0eXBlSW5kZXgiLCJpeFR5cGUiLCJTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUNyZWF0ZUFjY291bnQiLCJjaGVja0tleUxlbmd0aCIsImxhbXBvcnRzIiwic3BhY2UiLCJDcmVhdGUiLCJmcm9tUHVia2V5IiwibmV3QWNjb3VudFB1YmtleSIsImRlY29kZVRyYW5zZmVyIiwiVHJhbnNmZXIiLCJ0b1B1YmtleSIsImRlY29kZVRyYW5zZmVyV2l0aFNlZWQiLCJUcmFuc2ZlcldpdGhTZWVkIiwiYmFzZVB1YmtleSIsImRlY29kZUFsbG9jYXRlIiwiQWxsb2NhdGUiLCJhY2NvdW50UHVia2V5IiwiZGVjb2RlQWxsb2NhdGVXaXRoU2VlZCIsImJhc2UiLCJBbGxvY2F0ZVdpdGhTZWVkIiwiZGVjb2RlQXNzaWduIiwiQXNzaWduIiwiZGVjb2RlQXNzaWduV2l0aFNlZWQiLCJBc3NpZ25XaXRoU2VlZCIsImRlY29kZUNyZWF0ZVdpdGhTZWVkIiwiQ3JlYXRlV2l0aFNlZWQiLCJkZWNvZGVOb25jZUluaXRpYWxpemUiLCJJbml0aWFsaXplTm9uY2VBY2NvdW50Iiwibm9uY2VQdWJrZXkiLCJkZWNvZGVOb25jZUFkdmFuY2UiLCJBZHZhbmNlTm9uY2VBY2NvdW50IiwiZGVjb2RlTm9uY2VXaXRoZHJhdyIsIldpdGhkcmF3Tm9uY2VBY2NvdW50IiwiZGVjb2RlTm9uY2VBdXRob3JpemUiLCJBdXRob3JpemVOb25jZUFjY291bnQiLCJuZXdBdXRob3JpemVkUHVia2V5IiwiU3lzdGVtUHJvZ3JhbSIsImV4cGVjdGVkTGVuZ3RoIiwiZnJlZXplIiwiVXBncmFkZU5vbmNlQWNjb3VudCIsImNyZWF0ZUFjY291bnQiLCJwYXJhbXMiLCJ0cmFuc2ZlciIsIkJpZ0ludCIsImNyZWF0ZUFjY291bnRXaXRoU2VlZCIsImNyZWF0ZU5vbmNlQWNjb3VudCIsImluaXRQYXJhbXMiLCJub25jZUluaXRpYWxpemUiLCJpbnN0cnVjdGlvbkRhdGEiLCJub25jZUFkdmFuY2UiLCJub25jZVdpdGhkcmF3Iiwibm9uY2VBdXRob3JpemUiLCJhbGxvY2F0ZSIsIkNIVU5LX1NJWkUiLCJMb2FkZXIiLCJnZXRNaW5OdW1TaWduYXR1cmVzIiwiTWF0aCIsImNlaWwiLCJjaHVua1NpemUiLCJsb2FkIiwicHJvZ3JhbSIsImJhbGFuY2VOZWVkZWQiLCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24iLCJwcm9ncmFtSW5mbyIsImdldEFjY291bnRJbmZvIiwiZXhlY3V0YWJsZSIsImVycm9yIiwib3duZXIiLCJkYXRhTGF5b3V0IiwidHJhbnNhY3Rpb25zIiwiYnl0ZXNMZW5ndGgiLCJieXRlc0xlbmd0aFBhZGRpbmciLCJfcnBjRW5kcG9pbnQiLCJSRVFVRVNUU19QRVJfU0VDT05EIiwiYWxsIiwiZGVwbG95Q29tbWl0bWVudCIsImZpbmFsaXplU2lnbmF0dXJlIiwiY29udGV4dCIsImN1cnJlbnRTbG90IiwiZ2V0U2xvdCIsInNsb3QiLCJyb3VuZCIsIkJQRl9MT0FERVJfUFJPR1JBTV9JRCIsIkJwZkxvYWRlciIsImVsZiIsImxvYWRlclByb2dyYW1JZCIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwiX19lc01vZHVsZSIsImFnZW50a2VlcGFsaXZlIiwiZXhwb3J0cyIsInMiLCJtIiwiaCIsImQiLCJ3IiwibXMkMiIsInZhbCIsInBhcnNlIiwiaXNGaW5pdGUiLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0IiwiU3RyaW5nIiwibWF0Y2giLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsIm1zQWJzIiwiYWJzIiwicGx1cmFsIiwiaXNQbHVyYWwiLCJ1dGlsIiwibXMkMSIsImh1bWFuaXplTXMiLCJ0IiwiciIsImZvcm1hdCIsInN0YWNrIiwiY29uc3RhbnRzIiwiQ1VSUkVOVF9JRCIsIkNSRUFURV9JRCIsIklOSVRfU09DS0VUIiwiQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04iLCJTT0NLRVRfQ1JFQVRFRF9USU1FIiwiU09DS0VUX05BTUUiLCJTT0NLRVRfUkVRVUVTVF9DT1VOVCIsIlNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UIiwiT3JpZ2luYWxBZ2VudCIsImRlYnVnIiwiZGVidWdsb2ciLCJJTklUX1NPQ0tFVCQxIiwiZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50IiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwic3BsaXQiLCJzdWJzdHJpbmciLCJkZXByZWNhdGUiLCJsb2ciLCJrZWVwQWxpdmUiLCJmcmVlU29ja2V0VGltZW91dCIsImtlZXBBbGl2ZVRpbWVvdXQiLCJmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCIsInRpbWVvdXQiLCJtYXgiLCJzb2NrZXRBY3RpdmVUVEwiLCJjcmVhdGVTb2NrZXRDb3VudCIsImNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudCIsImNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2siLCJjbG9zZVNvY2tldENvdW50IiwiY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayIsImVycm9yU29ja2V0Q291bnQiLCJlcnJvclNvY2tldENvdW50TGFzdENoZWNrIiwicmVxdWVzdENvdW50IiwicmVxdWVzdENvdW50TGFzdENoZWNrIiwidGltZW91dFNvY2tldENvdW50IiwidGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIiwib24iLCJzb2NrZXQiLCJjYWxjU29ja2V0VGltZW91dCIsImFsaXZlVGltZSIsIkRhdGUiLCJub3ciLCJkaWZmIiwiY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQiLCJrZWVwU29ja2V0QWxpdmUiLCJyZXN1bHQiLCJjdXN0b21UaW1lb3V0IiwicmV1c2VTb2NrZXQiLCJyZXEiLCJyZXVzZWRTb2NrZXQiLCJhZ2VudFRpbWVvdXQiLCJnZXRTb2NrZXRUaW1lb3V0IiwiaWQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic2V0Tm9EZWxheSIsIl9hZ2VudEtleSIsImluc3RhbGxMaXN0ZW5lcnMiLCJjcmVhdGVDb25uZWN0aW9uIiwib25jcmVhdGUiLCJjYWxsZWQiLCJvbk5ld0NyZWF0ZSIsIm5ld1NvY2tldCIsInN0YXR1c0NoYW5nZWQiLCJjaGFuZ2VkIiwiZ2V0Q3VycmVudFN0YXR1cyIsImZyZWVTb2NrZXRzIiwiaW5zcGVjdCIsInNvY2tldHMiLCJyZXF1ZXN0cyIsIl9pZGxlVGltZW91dCIsImFnZW50Iiwib25GcmVlIiwiX2h0dHBNZXNzYWdlIiwiZ2V0TmFtZSIsIm9uQ2xvc2UiLCJpc0Vycm9yIiwib25UaW1lb3V0IiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsInJlcVRpbWVvdXRMaXN0ZW5lckNvdW50IiwiZW5hYmxlZCIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0Iiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiT3JpZ2luYWxIdHRwc0FnZW50IiwiSHR0cEFnZW50IiwiSHR0cHNBZ2VudCQxIiwiSHR0cHNBZ2VudCIsImRlZmF1bHRQb3J0IiwicHJvdG9jb2wiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJsaXN0IiwibWV0aG9kIiwiaHR0cHNfYWdlbnQiLCJhZ2VudGtlZXBhbGl2ZUV4cG9ydHMiLCJIdHRwS2VlcEFsaXZlQWdlbnQiLCJvYmpUb1N0cmluZyIsIm9iaktleXMiLCJpc0FycmF5UHJvcCIsInByb3BWYWwiLCJ0b1N0ciIsImZhc3RTdGFibGVTdHJpbmdpZnkiLCJyZXR1cm5WYWwiLCJmYXN0U3RhYmxlU3RyaW5naWZ5JDEiLCJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwidHJhaWxpbmdaZXJvcyIsIm5leHRQb3dlck9mVHdvIiwiRXBvY2hTY2hlZHVsZSIsInNsb3RzUGVyRXBvY2giLCJsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQiLCJ3YXJtdXAiLCJmaXJzdE5vcm1hbEVwb2NoIiwiZmlyc3ROb3JtYWxTbG90IiwiZ2V0RXBvY2giLCJnZXRFcG9jaEFuZFNsb3RJbmRleCIsImVwb2NoIiwiZXBvY2hMZW4iLCJnZXRTbG90c0luRXBvY2giLCJzbG90SW5kZXgiLCJub3JtYWxTbG90SW5kZXgiLCJub3JtYWxFcG9jaEluZGV4IiwiZmxvb3IiLCJnZXRGaXJzdFNsb3RJbkVwb2NoIiwicG93IiwiZ2V0TGFzdFNsb3RJbkVwb2NoIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwicHJvY2Vzc2VkSW5wdXQiLCJScGNXZWJTb2NrZXRDbGllbnQiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwid2ViU29ja2V0RmFjdG9yeSIsInVybCIsInJwYyIsImF1dG9jb25uZWN0IiwibWF4X3JlY29ubmVjdHMiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJ1bmRlcmx5aW5nU29ja2V0IiwicmVhZHlTdGF0ZSIsIm5vdGlmeSIsImRlY29kZURhdGEiLCJMT09LVVBfVEFCTEVfTUVUQV9TSVpFIiwiQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCIsImlzQWN0aXZlIiwiVTY0X01BWCIsImRlYWN0aXZhdGlvblNsb3QiLCJhY2NvdW50RGF0YSIsIkxvb2t1cFRhYmxlTWV0YUxheW91dCIsInNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4iLCJudW1TZXJpYWxpemVkQWRkcmVzc2VzIiwibGFzdEV4dGVuZGVkU2xvdCIsImxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4IiwibGFzdEV4dGVuZGVkU3RhcnRJbmRleCIsImF1dGhvcml0eSIsIlVSTF9SRSIsIm1ha2VXZWJzb2NrZXRVcmwiLCJlbmRwb2ludCIsIm1hdGNoZXMiLCJob3N0aXNoIiwicG9ydFdpdGhDb2xvbiIsInJlc3QiLCJzdGFydHNXaXRoIiwic3RhcnRQb3J0Iiwid2Vic29ja2V0UG9ydCIsIlB1YmxpY0tleUZyb21TdHJpbmciLCJSYXdBY2NvdW50RGF0YVJlc3VsdCIsIkJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSIsIkJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TIiwiYXNzZXJ0RW5kcG9pbnRVcmwiLCJwdXRhdGl2ZVVybCIsInRlc3QiLCJleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWciLCJjb21taXRtZW50T3JDb25maWciLCJzcGVjaWZpZWRDb21taXRtZW50Iiwic3BlY2lmaWVkQ29uZmlnIiwiY3JlYXRlUnBjUmVzdWx0IiwianNvbnJwYyIsIlVua25vd25ScGNSZXN1bHQiLCJqc29uUnBjUmVzdWx0Iiwic2NoZW1hIiwianNvblJwY1Jlc3VsdEFuZENvbnRleHQiLCJub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0IiwidmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSIsInJlc3BvbnNlIiwiR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQiLCJmb3VuZGF0aW9uIiwiZm91bmRhdGlvblRlcm0iLCJpbml0aWFsIiwidGFwZXIiLCJ0ZXJtaW5hbCIsIkdldEluZmxhdGlvblJld2FyZFJlc3VsdCIsImVmZmVjdGl2ZVNsb3QiLCJhbW91bnQiLCJwb3N0QmFsYW5jZSIsImNvbW1pc3Npb24iLCJHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQiLCJwcmlvcml0aXphdGlvbkZlZSIsIkdldEluZmxhdGlvblJhdGVSZXN1bHQiLCJ0b3RhbCIsInZhbGlkYXRvciIsIkdldEVwb2NoSW5mb1Jlc3VsdCIsInNsb3RzSW5FcG9jaCIsImFic29sdXRlU2xvdCIsImJsb2NrSGVpZ2h0IiwidHJhbnNhY3Rpb25Db3VudCIsIkdldEVwb2NoU2NoZWR1bGVSZXN1bHQiLCJHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCIsIlRyYW5zYWN0aW9uRXJyb3JSZXN1bHQiLCJTaWduYXR1cmVTdGF0dXNSZXN1bHQiLCJTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCIsIlZlcnNpb25SZXN1bHQiLCJTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0IiwicmVudEVwb2NoIiwidW5pdHNDb25zdW1lZCIsInJldHVybkRhdGEiLCJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsImJ5SWRlbnRpdHkiLCJyYW5nZSIsImZpcnN0U2xvdCIsImxhc3RTbG90IiwiY3JlYXRlUnBjQ2xpZW50IiwiaHR0cEhlYWRlcnMiLCJjdXN0b21GZXRjaCIsImZldGNoTWlkZGxld2FyZSIsImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwiaHR0cEFnZW50IiwiYWdlbnRPcHRpb25zIiwibWF4U29ja2V0cyIsImlzSHR0cHMiLCJmZXRjaFdpdGhNaWRkbGV3YXJlIiwiaW5mbyIsIm1vZGlmaWVkRmV0Y2hBcmdzIiwibW9kaWZpZWRJbmZvIiwibW9kaWZpZWRJbml0IiwiY2xpZW50QnJvd3NlciIsInJlcXVlc3QiLCJjYWxsYmFjayIsImJvZHkiLCJoZWFkZXJzIiwiQ09NTU9OX0hUVFBfSEVBREVSUyIsInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCJ3YWl0VGltZSIsInN0YXR1c1RleHQiLCJ0ZXh0Iiwib2siLCJjcmVhdGVScGNSZXF1ZXN0IiwiY2xpZW50IiwiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwiYmF0Y2giLCJtZXRob2ROYW1lIiwiR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQiLCJHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0IiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwiR2V0RXBvY2hJbmZvUnBjUmVzdWx0IiwiR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwiU2xvdFJwY1Jlc3VsdCIsIkdldFN1cHBseVJwY1Jlc3VsdCIsImNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZ0FjY291bnRzIiwiVG9rZW5BbW91bnRSZXN1bHQiLCJ1aUFtb3VudCIsImRlY2ltYWxzIiwidWlBbW91bnRTdHJpbmciLCJHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCIsIkdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCJwYXJzZWQiLCJHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsIkdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCIsIkFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlBhcnNlZE9yUmF3QWNjb3VudERhdGEiLCJQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJTdGFrZUFjdGl2YXRpb25SZXN1bHQiLCJhY3RpdmUiLCJpbmFjdGl2ZSIsIkdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCIsIm1lbW8iLCJibG9ja1RpbWUiLCJHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCIsIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJzdWJzY3JpcHRpb24iLCJQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQiLCJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RJbmZvUmVzdWx0IiwicGFyZW50Iiwicm9vdCIsIlNsb3ROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90VXBkYXRlUmVzdWx0IiwidGltZXN0YW1wIiwic3RhdHMiLCJudW1UcmFuc2FjdGlvbkVudHJpZXMiLCJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwibnVtRmFpbGVkVHJhbnNhY3Rpb25zIiwibWF4VHJhbnNhY3Rpb25zUGVyRW50cnkiLCJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwiU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0IiwiUm9vdE5vdGlmaWNhdGlvblJlc3VsdCIsIkNvbnRhY3RJbmZvUmVzdWx0IiwiZ29zc2lwIiwidHB1IiwiVm90ZUFjY291bnRJbmZvUmVzdWx0Iiwidm90ZVB1YmtleSIsIm5vZGVQdWJrZXkiLCJhY3RpdmF0ZWRTdGFrZSIsImVwb2NoVm90ZUFjY291bnQiLCJlcG9jaENyZWRpdHMiLCJsYXN0Vm90ZSIsInJvb3RTbG90IiwiR2V0Vm90ZUFjY291bnRzIiwiY3VycmVudCIsImRlbGlucXVlbnQiLCJDb25maXJtYXRpb25TdGF0dXMiLCJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsImNvbmZpcm1hdGlvbnMiLCJjb25maXJtYXRpb25TdGF0dXMiLCJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsIkdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCIsIkFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiQW5ub3RhdGVkQWNjb3VudEtleSIsInNvdXJjZSIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQiLCJSYXdJbnN0cnVjdGlvblJlc3VsdCIsIkluc3RydWN0aW9uUmVzdWx0IiwiVW5rbm93bkluc3RydWN0aW9uUmVzdWx0IiwiUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiVG9rZW5CYWxhbmNlUmVzdWx0IiwiYWNjb3VudEluZGV4IiwibWludCIsInVpVG9rZW5BbW91bnQiLCJMb2FkZWRBZGRyZXNzZXNSZXN1bHQiLCJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJmZWUiLCJpbm5lckluc3RydWN0aW9ucyIsInByZUJhbGFuY2VzIiwicG9zdEJhbGFuY2VzIiwicHJlVG9rZW5CYWxhbmNlcyIsInBvc3RUb2tlbkJhbGFuY2VzIiwibG9hZGVkQWRkcmVzc2VzIiwiY29tcHV0ZVVuaXRzQ29uc3VtZWQiLCJQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QiLCJSZXdhcmRzUmVzdWx0IiwicmV3YXJkVHlwZSIsIkdldEJsb2NrUnBjUmVzdWx0IiwicHJldmlvdXNCbG9ja2hhc2giLCJwYXJlbnRTbG90IiwicmV3YXJkcyIsIkdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQiLCJHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQiLCJHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiR2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dFJwY1Jlc3VsdCIsImxhbXBvcnRzUGVyU2lnbmF0dXJlIiwiR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0IiwiSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCIsIlBlcmZTYW1wbGVSZXN1bHQiLCJudW1UcmFuc2FjdGlvbnMiLCJudW1TbG90cyIsInNhbXBsZVBlcmlvZFNlY3MiLCJHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQiLCJHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0IiwiUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQiLCJTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJMb2dzUmVzdWx0IiwiTG9nc05vdGlmaWNhdGlvblJlc3VsdCIsIkNvbm5lY3Rpb24iLCJfY29tbWl0bWVudE9yQ29uZmlnIiwiX2NvbW1pdG1lbnQiLCJfY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJfcnBjV3NFbmRwb2ludCIsIl9ycGNDbGllbnQiLCJfcnBjUmVxdWVzdCIsIl9ycGNCYXRjaFJlcXVlc3QiLCJfcnBjV2ViU29ja2V0IiwiX3JwY1dlYlNvY2tldENvbm5lY3RlZCIsIl9ycGNXZWJTb2NrZXRIZWFydGJlYXQiLCJfcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQiLCJfcnBjV2ViU29ja2V0R2VuZXJhdGlvbiIsIl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyIsIl9wb2xsaW5nQmxvY2toYXNoIiwiX2Jsb2NraGFzaEluZm8iLCJsYXRlc3RCbG9ja2hhc2giLCJsYXN0RmV0Y2giLCJ0cmFuc2FjdGlvblNpZ25hdHVyZXMiLCJzaW11bGF0ZWRTaWduYXR1cmVzIiwiX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCIsIl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbnNCeUhhc2giLCJfc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjIiwiZ2V0QmxvY2tIZWlnaHQiLCJyZXF1ZXN0UHJvbWlzZXMiLCJfYnVpbGRBcmdzIiwicmVxdWVzdEhhc2giLCJ1bnNhZmVSZXMiLCJ3c0VuZHBvaW50IiwiY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJJbmZpbml0eSIsIl93c09uT3BlbiIsIl93c09uRXJyb3IiLCJfd3NPbkNsb3NlIiwiX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uIiwiX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24iLCJfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbiIsIl93c09uUm9vdE5vdGlmaWNhdGlvbiIsIl93c09uTG9nc05vdGlmaWNhdGlvbiIsInJwY0VuZHBvaW50IiwiZ2V0QmFsYW5jZUFuZENvbnRleHQiLCJnZXRCYWxhbmNlIiwiZSIsImdldEJsb2NrVGltZSIsImdldE1pbmltdW1MZWRnZXJTbG90IiwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9jayIsImdldFN1cHBseSIsImNvbmZpZ0FyZyIsImdldFRva2VuU3VwcGx5IiwidG9rZW5NaW50QWRkcmVzcyIsImdldFRva2VuQWNjb3VudEJhbGFuY2UiLCJ0b2tlbkFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsIm93bmVyQWRkcmVzcyIsIl9hcmdzIiwiZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJnZXRMYXJnZXN0QWNjb3VudHMiLCJhcmciLCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyIsIm1pbnRBZGRyZXNzIiwiZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0IiwiZ2V0UGFyc2VkQWNjb3VudEluZm8iLCJnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzIiwicHVibGljS2V5cyIsInJhd0NvbmZpZyIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvIiwiZ2V0U3Rha2VBY3RpdmF0aW9uIiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwiY29uZmlnT3JDb21taXRtZW50IiwiZW5jb2RpbmciLCJjb25maWdXaXRob3V0RW5jb2RpbmciLCJiYXNlU2NoZW1hIiwid2l0aENvbnRleHQiLCJnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMiLCJzdHJhdGVneSIsInJhd1NpZ25hdHVyZSIsImFib3J0ZWQiLCJyZWFzb24iLCJkZWNvZGVkU2lnbmF0dXJlIiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3kiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5IiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSIsImdldENhbmNlbGxhdGlvblByb21pc2UiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlIiwic2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQiLCJkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciIsImRvbmUiLCJjb25maXJtYXRpb25Qcm9taXNlIiwib25TaWduYXR1cmUiLCJfX3R5cGUiLCJQUk9DRVNTRUQiLCJzdWJzY3JpcHRpb25TZXR1cFByb21pc2UiLCJyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAiLCJfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZSIsIm5leHRTdGF0ZSIsImdldFNpZ25hdHVyZVN0YXR1cyIsImFib3J0Q29uZmlybWF0aW9uIiwicmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIiLCJleHBpcnlQcm9taXNlIiwiY2hlY2tCbG9ja0hlaWdodCIsIl9lIiwiY3VycmVudEJsb2NrSGVpZ2h0IiwiQkxPQ0tIRUlHSFRfRVhDRUVERUQiLCJjYW5jZWxsYXRpb25Qcm9taXNlIiwib3V0Y29tZSIsInJhY2UiLCJjdXJyZW50Tm9uY2VWYWx1ZSIsImxhc3RDaGVja2VkU2xvdCIsImdldEN1cnJlbnROb25jZVZhbHVlIiwiZ2V0Tm9uY2VBbmRDb250ZXh0IiwiTk9OQ0VfSU5WQUxJRCIsInNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlIiwic2lnbmF0dXJlU3RhdHVzIiwiY29tbWl0bWVudEZvclN0YXR1cyIsInRpbWVvdXRJZCIsInRpbWVvdXRNcyIsIlRJTUVEX09VVCIsImNsZWFyVGltZW91dCIsImdldENsdXN0ZXJOb2RlcyIsImdldFZvdGVBY2NvdW50cyIsImdldFNsb3RMZWFkZXIiLCJnZXRTbG90TGVhZGVycyIsInN0YXJ0U2xvdCIsImxpbWl0IiwiZ2V0U2lnbmF0dXJlU3RhdHVzZXMiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwiZ2V0VG90YWxTdXBwbHkiLCJleGNsdWRlTm9uQ2lyY3VsYXRpbmdBY2NvdW50c0xpc3QiLCJnZXRJbmZsYXRpb25Hb3Zlcm5vciIsImdldEluZmxhdGlvblJld2FyZCIsImdldEluZmxhdGlvblJhdGUiLCJnZXRFcG9jaEluZm8iLCJnZXRFcG9jaFNjaGVkdWxlIiwiZXBvY2hTY2hlZHVsZSIsImdldExlYWRlclNjaGVkdWxlIiwiZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dCIsImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyIsImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2giLCJ3aXJlTWVzc2FnZSIsImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyIsImxvY2tlZFdyaXRhYmxlQWNjb3VudHMiLCJnZXRSZWNlbnRCbG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0IiwiaXNCbG9ja2hhc2hWYWxpZCIsImdldFZlcnNpb24iLCJnZXRHZW5lc2lzSGFzaCIsImdldEJsb2NrIiwiX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQiLCJ0cmFuc2FjdGlvbkRldGFpbHMiLCJnZXRQYXJzZWRCbG9jayIsImdldEJsb2NrUHJvZHVjdGlvbiIsImV4dHJhIiwiYyIsImdldFBhcnNlZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkQmxvY2siLCJibG9jayIsImdldEJsb2NrcyIsImVuZFNsb3QiLCJnZXRCbG9ja1NpZ25hdHVyZXMiLCJnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMiLCJnZXRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJmaXJzdEF2YWlsYWJsZUJsb2NrIiwidW50aWwiLCJoaWdoZXN0Q29uZmlybWVkUm9vdCIsImJlZm9yZSIsImNvbmZpcm1lZFNpZ25hdHVyZUluZm8iLCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIiLCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImdldEFkZHJlc3NMb29rdXBUYWJsZSIsImFjY291bnRJbmZvIiwiZ2V0Tm9uY2UiLCJyZXF1ZXN0QWlyZHJvcCIsInRvIiwiX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodCIsImRpc2FibGVDYWNoZSIsInRpbWVTaW5jZUZldGNoIiwiZXhwaXJlZCIsIl9wb2xsTmV3QmxvY2toYXNoIiwic3RhcnRUaW1lIiwiY2FjaGVkTGF0ZXN0QmxvY2toYXNoIiwiY2FjaGVkQmxvY2toYXNoIiwiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbk9yTWVzc2FnZSIsImNvbmZpZ09yU2lnbmVycyIsImluY2x1ZGVBY2NvdW50cyIsInZlcnNpb25lZFR4IiwiZW5jb2RlZFRyYW5zYWN0aW9uIiwib3JpZ2luYWxUeCIsInNpZ1ZlcmlmeSIsInRyYWNlSW5kZW50IiwibG9nVHJhY2UiLCJzaWduZXJzT3JPcHRpb25zIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwicmF3VHJhbnNhY3Rpb24iLCJzZW5kRW5jb2RlZFRyYW5zYWN0aW9uIiwic2V0SW50ZXJ2YWwiLCJfdXBkYXRlU3Vic2NyaXB0aW9ucyIsImNsZWFySW50ZXJ2YWwiLCJoYXNoIiwiX3NldFN1YnNjcmlwdGlvbiIsIm5leHRTdWJzY3JpcHRpb24iLCJwcmV2U3RhdGUiLCJzdGF0ZUNoYW5nZUNhbGxiYWNrcyIsImNiIiwiY2xpZW50U3Vic2NyaXB0aW9uSWQiLCJjbG9zZSIsImNvbm5lY3QiLCJhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uIiwiaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlIiwiY2FsbGJhY2tzIiwic2VydmVyU3Vic2NyaXB0aW9uSWQiLCJ1bnN1YnNjcmliZU1ldGhvZCIsIl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24iLCJjYWxsYmFja0FyZ3MiLCJub3RpZmljYXRpb24iLCJfbWFrZVN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbkNvbmZpZyIsImV4aXN0aW5nU3Vic2NyaXB0aW9uIiwib25BY2NvdW50Q2hhbmdlIiwicmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyIiwiX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uIiwiYWNjb3VudElkIiwib25Qcm9ncmFtQWNjb3VudENoYW5nZSIsImZpbHRlcnMiLCJyZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyIiwib25Mb2dzIiwibWVudGlvbnMiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsIm9uU2xvdENoYW5nZSIsInJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lciIsIm9uU2xvdFVwZGF0ZSIsInJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lciIsInN1YnNjcmlwdGlvbk5hbWUiLCJkaXNwb3NlIiwib3ZlcnJpZGUiLCJfZXJyIiwib25TaWduYXR1cmVXaXRoT3B0aW9ucyIsIm9uUm9vdENoYW5nZSIsInJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lciIsIktleXBhaXIiLCJrZXlwYWlyIiwiX2tleXBhaXIiLCJnZW5lcmF0ZSIsImZyb21TZWNyZXRLZXkiLCJza2lwVmFsaWRhdGlvbiIsImNvbXB1dGVkUHVibGljS2V5IiwiaWkiLCJmcm9tU2VlZCIsIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiQ3JlYXRlTG9va3VwVGFibGUiLCJGcmVlemVMb29rdXBUYWJsZSIsIkV4dGVuZExvb2t1cFRhYmxlIiwiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQ2xvc2VMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIiwibGF5b3V0VHlwZSIsImRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlIiwiY2hlY2tLZXlzTGVuZ3RoIiwicmVjZW50U2xvdCIsImRlY29kZUV4dGVuZExvb2t1cFRhYmxlIiwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZSIsInJlY2lwaWVudCIsImRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlIiwiZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsImNyZWF0ZUxvb2t1cFRhYmxlIiwibG9va3VwVGFibGVBZGRyZXNzIiwiYnVtcFNlZWQiLCJmcmVlemVMb29rdXBUYWJsZSIsImV4dGVuZExvb2t1cFRhYmxlIiwiYWRkciIsImRlYWN0aXZhdGVMb29rdXBUYWJsZSIsImNsb3NlTG9va3VwVGFibGUiLCJDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24iLCJDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlUmVxdWVzdFVuaXRzIiwidW5pdHMiLCJhZGRpdGlvbmFsRmVlIiwiUmVxdWVzdFVuaXRzIiwiZGVjb2RlUmVxdWVzdEhlYXBGcmFtZSIsIlJlcXVlc3RIZWFwRnJhbWUiLCJkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0IiwiU2V0Q29tcHV0ZVVuaXRMaW1pdCIsImRlY29kZVNldENvbXB1dGVVbml0UHJpY2UiLCJtaWNyb0xhbXBvcnRzIiwiU2V0Q29tcHV0ZVVuaXRQcmljZSIsIkNvbXB1dGVCdWRnZXRQcm9ncmFtIiwicmVxdWVzdFVuaXRzIiwicmVxdWVzdEhlYXBGcmFtZSIsInNldENvbXB1dGVVbml0TGltaXQiLCJzZXRDb21wdXRlVW5pdFByaWNlIiwiUFJJVkFURV9LRVlfQllURVMkMSIsIlBVQkxJQ19LRVlfQllURVMkMSIsIlNJR05BVFVSRV9CWVRFUyIsIkVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUIiwidTE2IiwiRWQyNTUxOVByb2dyYW0iLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkiLCJpbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5T2Zmc2V0Iiwic2lnbmF0dXJlT2Zmc2V0IiwibWVzc2FnZURhdGFPZmZzZXQiLCJudW1TaWduYXR1cmVzIiwicGFkZGluZyIsInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4IiwibWVzc2FnZURhdGFTaXplIiwibWVzc2FnZUluc3RydWN0aW9uSW5kZXgiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVjZHNhU2lnbiIsIm1zZ0hhc2giLCJwcml2S2V5IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyZWNvdmVyeSIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Q3JlYXRlIiwiUFJJVkFURV9LRVlfQllURVMiLCJFVEhFUkVVTV9BRERSRVNTX0JZVEVTIiwiUFVCTElDX0tFWV9CWVRFUyIsIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsIlNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQiLCJTZWNwMjU2azFQcm9ncmFtIiwicHVibGljS2V5VG9FdGhBZGRyZXNzIiwicmVjb3ZlcnlJZCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MiLCJldGhBZGRyZXNzIiwicmF3QWRkcmVzcyIsInN1YnN0ciIsImRhdGFTdGFydCIsImV0aEFkZHJlc3NPZmZzZXQiLCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCIsInBrZXkiLCJtZXNzYWdlSGFzaCIsIl9Mb2NrdXAiLCJTVEFLRV9DT05GSUdfSUQiLCJBdXRob3JpemVkIiwic3Rha2VyIiwid2l0aGRyYXdlciIsIkxvY2t1cCIsInVuaXhUaW1lc3RhbXAiLCJjdXN0b2RpYW4iLCJTdGFrZUluc3RydWN0aW9uIiwiU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemUiLCJJbml0aWFsaXplIiwic3Rha2VQdWJrZXkiLCJkZWNvZGVEZWxlZ2F0ZSIsIkRlbGVnYXRlIiwiZGVjb2RlQXV0aG9yaXplIiwibmV3QXV0aG9yaXplZCIsInN0YWtlQXV0aG9yaXphdGlvblR5cGUiLCJBdXRob3JpemUiLCJvIiwiY3VzdG9kaWFuUHVia2V5IiwiZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlTZWVkIiwiYXV0aG9yaXR5T3duZXIiLCJBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eUJhc2UiLCJkZWNvZGVTcGxpdCIsIlNwbGl0Iiwic3BsaXRTdGFrZVB1YmtleSIsImRlY29kZU1lcmdlIiwiTWVyZ2UiLCJzb3VyY2VTdGFrZVB1YktleSIsImRlY29kZVdpdGhkcmF3IiwiV2l0aGRyYXciLCJkZWNvZGVEZWFjdGl2YXRlIiwiRGVhY3RpdmF0ZSIsIlN0YWtlUHJvZ3JhbSIsIlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCIsIlN0YWtlciIsIldpdGhkcmF3ZXIiLCJpbml0aWFsaXplIiwibWF5YmVMb2NrdXAiLCJkZWxlZ2F0ZSIsImF1dGhvcml6ZSIsImF1dGhvcml6ZVdpdGhTZWVkIiwic3BsaXRJbnN0cnVjdGlvbiIsInJlbnRFeGVtcHRSZXNlcnZlIiwic3BsaXRXaXRoU2VlZCIsIm1lcmdlIiwid2l0aGRyYXciLCJkZWFjdGl2YXRlIiwiVm90ZUluaXQiLCJhdXRob3JpemVkVm90ZXIiLCJhdXRob3JpemVkV2l0aGRyYXdlciIsIlZvdGVJbnN0cnVjdGlvbiIsIlZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemVBY2NvdW50IiwiSW5pdGlhbGl6ZUFjY291bnQiLCJ2b3RlQXV0aG9yaXphdGlvblR5cGUiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5IiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCJWb3RlUHJvZ3JhbSIsIlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCJWb3RlciIsImluaXRpYWxpemVBY2NvdW50Iiwic2FmZVdpdGhkcmF3IiwiY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSIsInJlbnRFeGVtcHRNaW5pbXVtIiwidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWQUxJREFUT1JfSU5GT19LRVkiLCJJbmZvU3RyaW5nIiwid2Vic2l0ZSIsImRldGFpbHMiLCJrZXliYXNlVXNlcm5hbWUiLCJWYWxpZGF0b3JJbmZvIiwiZnJvbUNvbmZpZ0RhdGEiLCJjb25maWdLZXlDb3VudCIsImNvbmZpZ0tleXMiLCJyYXdJbmZvIiwiVk9URV9QUk9HUkFNX0lEIiwiVm90ZUFjY291bnRMYXlvdXQiLCJWb3RlQWNjb3VudCIsInZvdGVzIiwiYXV0aG9yaXplZFZvdGVycyIsInByaW9yVm90ZXJzIiwibGFzdFRpbWVzdGFtcCIsInZlcnNpb25PZmZzZXQiLCJ2YSIsInJvb3RTbG90VmFsaWQiLCJwYXJzZUF1dGhvcml6ZWRWb3RlciIsImdldFByaW9yVm90ZXJzIiwicGFyc2VQcmlvclZvdGVycyIsImVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCIsInRhcmdldEVwb2NoIiwiaWR4IiwiaXNFbXB0eSIsImh0dHAiLCJkZXZuZXQiLCJ0ZXN0bmV0IiwiaHR0cHMiLCJjbHVzdGVyQXBpVXJsIiwiY2x1c3RlciIsInRscyIsInNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24iLCJjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMiLCJtYXliZUNvbmZpcm1PcHRpb25zIiwiY29uZmlybWF0aW9uU3RyYXRlZ3kiLCJMQU1QT1JUU19QRVJfU09MIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePostMessageStream: () => (/* binding */ BasePostMessageStream),\n/* harmony export */   IGNORE_SUBSTREAM: () => (/* binding */ IGNORE_SUBSTREAM),\n/* harmony export */   JRPCEngine: () => (/* binding */ JRPCEngine),\n/* harmony export */   ObjectMultiplex: () => (/* binding */ ObjectMultiplex),\n/* harmony export */   PostMessageStream: () => (/* binding */ PostMessageStream),\n/* harmony export */   SafeEventEmitter: () => (/* binding */ SafeEventEmitter),\n/* harmony export */   SerializableError: () => (/* binding */ SerializableError),\n/* harmony export */   Substream: () => (/* binding */ Substream),\n/* harmony export */   createAsyncMiddleware: () => (/* binding */ createAsyncMiddleware),\n/* harmony export */   createEngineStream: () => (/* binding */ createEngineStream),\n/* harmony export */   createErrorMiddleware: () => (/* binding */ createErrorMiddleware),\n/* harmony export */   createIdRemapMiddleware: () => (/* binding */ createIdRemapMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createScaffoldMiddleware: () => (/* binding */ createScaffoldMiddleware),\n/* harmony export */   createStreamMiddleware: () => (/* binding */ createStreamMiddleware),\n/* harmony export */   getRpcPromiseCallback: () => (/* binding */ getRpcPromiseCallback),\n/* harmony export */   mergeMiddleware: () => (/* binding */ mergeMiddleware),\n/* harmony export */   setupMultiplex: () => (/* binding */ setupMultiplex)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"(ssr)/../node_modules/readable-stream/readable.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/openlogin-utils */ \"(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/../node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eth-rpc-errors */ \"(ssr)/../node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! end-of-stream */ \"(ssr)/../node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! once */ \"(ssr)/../node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pump */ \"(ssr)/../node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\nfunction noop() {\n    return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { name, target, targetWindow = window, targetOrigin = \"*\" } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_init\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_haveSyn\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetOrigin\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_onMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_synIntervalId\", void 0);\n        if (!name || !target) {\n            throw new Error(\"Invalid input.\");\n        }\n        this._init = false;\n        this._haveSyn = false;\n        this._name = name;\n        this._target = target; // target origin\n        this._targetWindow = targetWindow;\n        this._targetOrigin = targetOrigin;\n        this._onMessage = this.onMessage.bind(this);\n        this._synIntervalId = null;\n        window.addEventListener(\"message\", this._onMessage, false);\n        this._handShake();\n    }\n    _break() {\n        this.cork();\n        this._write(BRK, null, noop);\n        this._haveSyn = false;\n        this._init = false;\n    }\n    _handShake() {\n        this._write(SYN, null, noop);\n        this.cork();\n    }\n    _onData(data) {\n        if (!this._init) {\n            // listen for handshake\n            if (data === SYN) {\n                this._haveSyn = true;\n                this._write(ACK, null, noop);\n            } else if (data === ACK) {\n                this._init = true;\n                if (!this._haveSyn) {\n                    this._write(ACK, null, noop);\n                }\n                this.uncork();\n            }\n        } else if (data === BRK) {\n            this._break();\n        } else {\n            // forward message\n            try {\n                this.push(data);\n            } catch (err) {\n                this.emit(\"error\", err);\n            }\n        }\n    }\n    _postMessage(data) {\n        const originConstraint = this._targetOrigin;\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n    onMessage(event) {\n        const message = event.data;\n        // validate message\n        if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n            return;\n        }\n        this._onData(message.data);\n    }\n    _read() {\n        return undefined;\n    }\n    _write(data, _, cb) {\n        this._postMessage(data);\n        cb();\n    }\n    _destroy() {\n        window.removeEventListener(\"message\", this._onMessage, false);\n    }\n}\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    } catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(()=>{\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for(let i = 0; i < n; i += 1){\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    emit(type) {\n        let doError = type === \"error\";\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        } else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === \"function\") {\n            safeApply(handler, this, args);\n        } else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for(let i = 0; i < len; i += 1){\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nclass SerializableError extends Error {\n    constructor(_ref){\n        let { code, message, data } = _ref;\n        if (!Number.isInteger(code)) {\n            throw new Error(\"code must be an integer\");\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error(\"message must be string\");\n        }\n        super(message);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n    toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4___default()({\n            code: this.code,\n            message: this.message,\n            data: this.data,\n            stack: this.stack\n        });\n    }\n}\nconst getRpcPromiseCallback = function(resolve, reject) {\n    let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return (error, response)=>{\n        if (error || response.error) {\n            reject(error || response.error);\n        } else if (!unwrapResult || Array.isArray(response)) {\n            resolve(response);\n        } else {\n            resolve(response.result);\n        }\n    };\n};\nfunction createErrorMiddleware(log) {\n    return (req, res, next, end)=>{\n        try {\n            // json-rpc-engine will terminate the request when it notices this error\n            if (typeof req.method !== \"string\" || !req.method) {\n                res.error = new SerializableError({\n                    code: -32603,\n                    message: \"invalid method\"\n                });\n                end();\n                return;\n            }\n            next((done)=>{\n                const { error } = res;\n                if (!error) {\n                    return done();\n                }\n                log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n                return done();\n            });\n        } catch (error) {\n            log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n            res.error = new SerializableError({\n                code: -32603,\n                message: error.message\n            });\n            end();\n        }\n    };\n}\nfunction createStreamMiddleware() {\n    const idMap = {};\n    function readNoop() {\n        return false;\n    }\n    const events = new SafeEventEmitter();\n    function processResponse(res) {\n        const context = idMap[res.id];\n        if (!context) {\n            throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n        }\n        delete idMap[res.id];\n        // copy whole res onto original res\n        Object.assign(context.res, res);\n        // run callback on empty stack,\n        // prevent internal stream-handler from catching errors\n        setTimeout(context.end);\n    }\n    function processNotification(res) {\n        events.emit(\"notification\", res);\n    }\n    function processMessage(res, _encoding, cb) {\n        let err;\n        try {\n            const isNotification = !res.id;\n            if (isNotification) {\n                processNotification(res);\n            } else {\n                processResponse(res);\n            }\n        } catch (_err) {\n            err = _err;\n        }\n        // continue processing stream\n        cb(err);\n    }\n    const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read: readNoop,\n        write: processMessage\n    });\n    const middleware = (req, res, next, end)=>{\n        // write req to stream\n        stream.push(req);\n        // register request on id map\n        idMap[req.id] = {\n            req,\n            res,\n            next,\n            end\n        };\n    };\n    return {\n        events,\n        middleware,\n        stream\n    };\n}\nfunction createScaffoldMiddleware(handlers) {\n    return (req, res, next, end)=>{\n        const handler = handlers[req.method];\n        // if no handler, return\n        if (handler === undefined) {\n            return next();\n        }\n        // if handler is fn, call as middleware\n        if (typeof handler === \"function\") {\n            return handler(req, res, next, end);\n        }\n        // if handler is some other value, use as result\n        res.result = handler;\n        return end();\n    };\n}\nfunction createIdRemapMiddleware() {\n    return (req, res, next, _end)=>{\n        const originalId = req.id;\n        const newId = (0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__.randomId)();\n        req.id = newId;\n        res.id = newId;\n        next((done)=>{\n            req.id = originalId;\n            res.id = originalId;\n            done();\n        });\n    };\n}\nfunction createLoggerMiddleware(logger) {\n    return (req, res, next, _)=>{\n        logger.debug(\"REQ\", req, \"RES\", res);\n        next();\n    };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n    return async (req, res, next, end)=>{\n        // nextPromise is the key to the implementation\n        // it is resolved by the return handler passed to the\n        // \"next\" function\n        let resolveNextPromise;\n        const nextPromise = new Promise((resolve)=>{\n            resolveNextPromise = resolve;\n        });\n        let returnHandlerCallback = null;\n        let nextWasCalled = false;\n        // This will be called by the consumer's async middleware.\n        const asyncNext = async ()=>{\n            nextWasCalled = true;\n            // We pass a return handler to next(). When it is called by the engine,\n            // the consumer's async middleware will resume executing.\n            next((runReturnHandlersCallback)=>{\n                // This callback comes from JRPCEngine._runReturnHandlers\n                returnHandlerCallback = runReturnHandlersCallback;\n                resolveNextPromise();\n            });\n            await nextPromise;\n        };\n        try {\n            await asyncMiddleware(req, res, asyncNext);\n            if (nextWasCalled) {\n                await nextPromise; // we must wait until the return handler is called\n                returnHandlerCallback(null);\n            } else {\n                end(null);\n            }\n        } catch (error) {\n            if (returnHandlerCallback) {\n                returnHandlerCallback(error);\n            } else {\n                end(error);\n            }\n        }\n    };\n}\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */ class JRPCEngine extends SafeEventEmitter {\n    constructor(){\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_middleware\", void 0);\n        this._middleware = [];\n    }\n    /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */ static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack){\n            [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [\n            error,\n            isComplete,\n            returnHandlers.reverse()\n        ];\n    }\n    /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */ static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve)=>{\n            const end = (err)=>{\n                const error = err || res.error;\n                if (error) {\n                    res.error = (0,eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.serializeError)(error);\n                }\n                // True indicates that the request should end\n                resolve([\n                    error,\n                    true\n                ]);\n            };\n            const next = (returnHandler)=>{\n                if (res.error) {\n                    end(res.error);\n                } else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== \"function\") {\n                            end(new SerializableError({\n                                code: -32603,\n                                message: \"JRPCEngine: 'next' return handlers must be functions\"\n                            }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([\n                        null,\n                        false\n                    ]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            } catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */ static async _runReturnHandlers(handlers) {\n        for (const handler of handlers){\n            await new Promise((resolve, reject)=>{\n                handler((err)=>err ? reject(err) : resolve());\n            });\n        }\n    }\n    /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */ static _checkForCompletion(req, res, isComplete) {\n        if (!(\"result\" in res) && !(\"error\" in res)) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Response has no error or result for request\"\n            });\n        }\n        if (!isComplete) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Nothing ended request\"\n            });\n        }\n    }\n    /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */ push(middleware) {\n        this._middleware.push(middleware);\n    }\n    handle(req, cb) {\n        if (cb && typeof cb !== \"function\") {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */ asMiddleware() {\n        return async (req, res, next, end)=>{\n            try {\n                const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JRPCEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback)=>{\n                    try {\n                        await JRPCEngine._runReturnHandlers(returnHandlers);\n                    } catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            } catch (error) {\n                return end(error);\n            }\n        };\n    }\n    async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(// 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        } catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n   * A promise-wrapped _handle.\n   */ _promiseHandle(req) {\n        return new Promise((resolve)=>{\n            this._handle(req, (_err, res)=>{\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                resolve(res);\n            });\n        });\n    }\n    /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */ async _handle(callerReq, cb) {\n        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"request must be plain object\"\n            });\n            return cb(error, {\n                id: undefined,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        if (typeof callerReq.method !== \"string\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"method must be string\"\n            });\n            return cb(error, {\n                id: callerReq.id,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        const req = _objectSpread$1({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        } catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                res.error = (0,eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.serializeError)(error);\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */ async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JRPCEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JRPCEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n}\nfunction mergeMiddleware(middlewareStack) {\n    const engine = new JRPCEngine();\n    middlewareStack.forEach((middleware)=>engine.push(middleware));\n    return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n    if (!opts || !opts.engine) {\n        throw new Error(\"Missing engine parameter!\");\n    }\n    const { engine } = opts;\n    // eslint-disable-next-line prefer-const\n    let stream;\n    function read() {\n        return undefined;\n    }\n    function write(req, _encoding, cb) {\n        engine.handle(req, (_err, res)=>{\n            stream.push(res);\n        });\n        cb();\n    }\n    stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read,\n        write\n    });\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            stream.push(message);\n        });\n    }\n    return stream;\n}\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { parent, name } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_parent\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        this._parent = parent;\n        this._name = name;\n    }\n    /**\n   * Explicitly sets read operations to a no-op.\n   */ _read() {\n        return undefined;\n    }\n    /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */ _write(chunk, _encoding, callback) {\n        this._parent.push({\n            name: this._name,\n            data: chunk\n        });\n        callback();\n    }\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(){\n        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super(_objectSpread(_objectSpread({}, opts), {}, {\n            objectMode: true\n        }));\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_substreams\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getStream\", void 0);\n        this._substreams = {};\n    }\n    createStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // create substream\n        const substream = new Substream({\n            parent: this,\n            name\n        });\n        this._substreams[name] = substream;\n        // listen for parent stream to end\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        anyStreamEnd(this, (_error)=>substream.destroy(_error || undefined));\n        return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n    ignoreStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // set\n        this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n    _read() {\n        return undefined;\n    }\n    _write(chunk, _encoding, callback) {\n        const { name, data } = chunk;\n        if (!name) {\n            window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n            return callback();\n        }\n        // get corresponding substream\n        const substream = this._substreams[name];\n        if (!substream) {\n            window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n            return callback();\n        }\n        // push data into substream\n        if (substream !== IGNORE_SUBSTREAM) {\n            substream.push(data);\n        }\n        return callback();\n    }\n}\n// util\nfunction anyStreamEnd(stream, _cb) {\n    const cb = once__WEBPACK_IMPORTED_MODULE_7___default()(_cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_6___default()(stream, {\n        readable: false\n    }, cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_6___default()(stream, {\n        writable: false\n    }, cb);\n}\nfunction setupMultiplex(stream) {\n    const mux = new ObjectMultiplex();\n    mux.getStream = function streamHelper(name) {\n        if (this._substreams[name]) {\n            return this._substreams[name];\n        }\n        return this.createStream(name);\n    };\n    pump__WEBPACK_IMPORTED_MODULE_8___default()(stream, mux, stream, (err)=>{\n        if (err) window.console.error(err);\n    });\n    return mux;\n}\nclass PostMessageStream extends BasePostMessageStream {\n    _postMessage(data) {\n        let originConstraint = this._targetOrigin;\n        if (typeof data === \"object\") {\n            const dataObj = data;\n            if (typeof dataObj.data === \"object\") {\n                const dataObjData = dataObj.data;\n                if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n                    const dataObjDataParam = dataObjData.params[0];\n                    if (dataObjDataParam._origin) {\n                        originConstraint = dataObjDataParam._origin;\n                    }\n                    // add a constraint for the response\n                    dataObjDataParam._origin = window.location.origin;\n                }\n            }\n        }\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n}\n //# sourceMappingURL=openloginJrpc.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL2Rpc3Qvb3BlbmxvZ2luSnJwYy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUMzQjtBQUNhO0FBQ2hCO0FBQ007QUFDSTtBQUNoQjtBQUNSO0FBQ0E7QUFFeEIsU0FBU1M7SUFDUCxPQUFPQztBQUNUO0FBQ0EsTUFBTUMsTUFBTTtBQUNaLE1BQU1DLE1BQU07QUFDWixNQUFNQyxNQUFNO0FBQ1osTUFBTUMsOEJBQThCYixtREFBTUE7SUFDeENjLFlBQVlDLElBQUksQ0FBRTtRQUNoQixJQUFJLEVBQ0ZDLElBQUksRUFDSkMsTUFBTSxFQUNOQyxlQUFlQyxNQUFNLEVBQ3JCQyxlQUFlLEdBQUcsRUFDbkIsR0FBR0w7UUFDSixLQUFLLENBQUM7WUFDSk0sWUFBWTtRQUNkO1FBQ0F0Qiw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsU0FBUyxLQUFLO1FBQ3BDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsWUFBWSxLQUFLO1FBQ3ZDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsU0FBUyxLQUFLO1FBQ3BDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsV0FBVyxLQUFLO1FBQ3RDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLEtBQUs7UUFDNUNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsS0FBSztRQUM1Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGNBQWMsS0FBSztRQUN6Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGtCQUFrQixLQUFLO1FBQzdDLElBQUksQ0FBQ2lCLFFBQVEsQ0FBQ0MsUUFBUTtZQUNwQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FB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QUFtQkYsWUFBWUMsTUFBTSxDQUFDLEVBQUU7b0JBQzlDLElBQUlDLGlCQUFpQkMsT0FBTyxFQUFFO3dCQUM1QnpLLG1CQUFtQndLLGlCQUFpQkMsT0FBTztvQkFDN0M7b0JBQ0Esb0NBQW9DO29CQUNwQ0QsaUJBQWlCQyxPQUFPLEdBQUduTSxPQUFPb00sUUFBUSxDQUFDdEssTUFBTTtnQkFDbkQ7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDdEIsYUFBYSxDQUFDbUIsV0FBVyxDQUFDO1lBQzdCN0IsUUFBUSxJQUFJLENBQUNTLE9BQU87WUFDcEJhO1FBQ0YsR0FBR007SUFDTDtBQUNGO0FBRWdYLENBQ2hYLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvZGlzdC9vcGVubG9naW5KcnBjLmVzbS5qcz9lNDFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBEdXBsZXggfSBmcm9tICdyZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgcmFuZG9tSWQgfSBmcm9tICdAdG9ydXNsYWJzL29wZW5sb2dpbi11dGlscyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdmYXN0LXNhZmUtc3RyaW5naWZ5JztcbmltcG9ydCB7IHNlcmlhbGl6ZUVycm9yIH0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IGVvcyBmcm9tICdlbmQtb2Ytc3RyZWFtJztcbmltcG9ydCBvbmNlIGZyb20gJ29uY2UnO1xuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBTWU4gPSBcIlNZTlwiO1xuY29uc3QgQUNLID0gXCJBQ0tcIjtcbmNvbnN0IEJSSyA9IFwiQlJLXCI7XG5jbGFzcyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0gZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0YXJnZXRXaW5kb3cgPSB3aW5kb3csXG4gICAgICB0YXJnZXRPcmlnaW4gPSBcIipcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW5pdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYXZlU3luXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFdpbmRvd1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRPcmlnaW5cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25NZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N5bkludGVydmFsSWRcIiwgdm9pZCAwKTtcbiAgICBpZiAoIW5hbWUgfHwgIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XG4gICAgfVxuICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0OyAvLyB0YXJnZXQgb3JpZ2luXG4gICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gdGFyZ2V0V2luZG93O1xuICAgIHRoaXMuX3RhcmdldE9yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICB0aGlzLl9vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N5bkludGVydmFsSWQgPSBudWxsO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICB0aGlzLl9oYW5kU2hha2UoKTtcbiAgfVxuICBfYnJlYWsoKSB7XG4gICAgdGhpcy5jb3JrKCk7XG4gICAgdGhpcy5fd3JpdGUoQlJLLCBudWxsLCBub29wKTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuICB9XG4gIF9oYW5kU2hha2UoKSB7XG4gICAgdGhpcy5fd3JpdGUoU1lOLCBudWxsLCBub29wKTtcbiAgICB0aGlzLmNvcmsoKTtcbiAgfVxuICBfb25EYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2luaXQpIHtcbiAgICAgIC8vIGxpc3RlbiBmb3IgaGFuZHNoYWtlXG4gICAgICBpZiAoZGF0YSA9PT0gU1lOKSB7XG4gICAgICAgIHRoaXMuX2hhdmVTeW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBBQ0spIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faGF2ZVN5bikge1xuICAgICAgICAgIHRoaXMuX3dyaXRlKEFDSywgbnVsbCwgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEJSSykge1xuICAgICAgdGhpcy5fYnJlYWsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yd2FyZCBtZXNzYWdlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBvcmlnaW5Db25zdHJhaW50ID0gdGhpcy5fdGFyZ2V0T3JpZ2luO1xuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGRhdGFcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcbiAgfVxuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgaWYgKHRoaXMuX3RhcmdldE9yaWdpbiAhPT0gXCIqXCIgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl90YXJnZXRPcmlnaW4gfHwgZXZlbnQuc291cmNlICE9PSB0aGlzLl90YXJnZXRXaW5kb3cgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZS50YXJnZXQgIT09IHRoaXMuX25hbWUgfHwgIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vbkRhdGEobWVzc2FnZS5kYXRhKTtcbiAgfVxuICBfcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIF93cml0ZShkYXRhLCBfLCBjYikge1xuICAgIHRoaXMuX3Bvc3RNZXNzYWdlKGRhdGEpO1xuICAgIGNiKCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uTWVzc2FnZSwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgY29uc3QgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuY2xhc3MgU2FmZUV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGVtaXQodHlwZSkge1xuICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gXCJlcnJvclwiO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgbGV0IGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBbZXJdID0gYXJncztcbiAgICAgIH1cbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5oYW5kbGVkIGVycm9yLiR7ZXIgPyBgICgke2VyLm1lc3NhZ2V9KWAgOiBcIlwifWApO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuY2xhc3MgU2VyaWFsaXphYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2RlIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXNzYWdlIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeSh7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGdldFJwY1Byb21pc2VDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgbGV0IHVud3JhcFJlc3VsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgcmV0dXJuIChlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICBpZiAoZXJyb3IgfHwgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvciB8fCByZXNwb25zZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmICghdW53cmFwUmVzdWx0IHx8IEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVFcnJvck1pZGRsZXdhcmUobG9nKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcbiAgICAgIGlmICh0eXBlb2YgcmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhcmVxLm1ldGhvZCkge1xuICAgICAgICByZXMuZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgICBtZXNzYWdlOiBcImludmFsaWQgbWV0aG9kXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXh0KGRvbmUgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IHJlcztcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLmVycm9yKGBPcGVuTG9naW4gLSBSUEMgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGBPcGVuTG9naW4gLSBSUEMgRXJyb3IgdGhyb3duOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgcmVzLmVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUoKSB7XG4gIGNvbnN0IGlkTWFwID0ge307XG4gIGZ1bmN0aW9uIHJlYWROb29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBldmVudHMgPSBuZXcgU2FmZUV2ZW50RW1pdHRlcigpO1xuICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF07XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmVhbU1pZGRsZXdhcmUgLSBVbmtub3duIHJlc3BvbnNlIGlkIFwiJHtyZXMuaWR9XCJgKTtcbiAgICB9XG4gICAgZGVsZXRlIGlkTWFwW3Jlcy5pZF07XG4gICAgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXNcbiAgICBPYmplY3QuYXNzaWduKGNvbnRleHQucmVzLCByZXMpO1xuICAgIC8vIHJ1biBjYWxsYmFjayBvbiBlbXB0eSBzdGFjayxcbiAgICAvLyBwcmV2ZW50IGludGVybmFsIHN0cmVhbS1oYW5kbGVyIGZyb20gY2F0Y2hpbmcgZXJyb3JzXG4gICAgc2V0VGltZW91dChjb250ZXh0LmVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpIHtcbiAgICBldmVudHMuZW1pdChcIm5vdGlmaWNhdGlvblwiLCByZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKHJlcywgX2VuY29kaW5nLCBjYikge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzTm90aWZpY2F0aW9uID0gIXJlcy5pZDtcbiAgICAgIGlmIChpc05vdGlmaWNhdGlvbikge1xuICAgICAgICBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzUmVzcG9uc2UocmVzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICBlcnIgPSBfZXJyO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nIHN0cmVhbVxuICAgIGNiKGVycik7XG4gIH1cbiAgY29uc3Qgc3RyZWFtID0gbmV3IER1cGxleCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICByZWFkOiByZWFkTm9vcCxcbiAgICB3cml0ZTogcHJvY2Vzc01lc3NhZ2VcbiAgfSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIC8vIHdyaXRlIHJlcSB0byBzdHJlYW1cbiAgICBzdHJlYW0ucHVzaChyZXEpO1xuICAgIC8vIHJlZ2lzdGVyIHJlcXVlc3Qgb24gaWQgbWFwXG4gICAgaWRNYXBbcmVxLmlkXSA9IHtcbiAgICAgIHJlcSxcbiAgICAgIHJlcyxcbiAgICAgIG5leHQsXG4gICAgICBlbmRcbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGV2ZW50cyxcbiAgICBtaWRkbGV3YXJlLFxuICAgIHN0cmVhbVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKGhhbmRsZXJzKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tyZXEubWV0aG9kXTtcbiAgICAvLyBpZiBubyBoYW5kbGVyLCByZXR1cm5cbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICAvLyBpZiBoYW5kbGVyIGlzIGZuLCBjYWxsIGFzIG1pZGRsZXdhcmVcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgfVxuICAgIC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxuICAgIHJlcy5yZXN1bHQgPSBoYW5kbGVyO1xuICAgIHJldHVybiBlbmQoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxJZCA9IHJlcS5pZDtcbiAgICBjb25zdCBuZXdJZCA9IHJhbmRvbUlkKCk7XG4gICAgcmVxLmlkID0gbmV3SWQ7XG4gICAgcmVzLmlkID0gbmV3SWQ7XG4gICAgbmV4dChkb25lID0+IHtcbiAgICAgIHJlcS5pZCA9IG9yaWdpbmFsSWQ7XG4gICAgICByZXMuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyTWlkZGxld2FyZShsb2dnZXIpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgXykgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlJFUVwiLCByZXEsIFwiUkVTXCIsIHJlcyk7XG4gICAgbmV4dCgpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jTWlkZGxld2FyZSkge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAvLyBuZXh0UHJvbWlzZSBpcyB0aGUga2V5IHRvIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGl0IGlzIHJlc29sdmVkIGJ5IHRoZSByZXR1cm4gaGFuZGxlciBwYXNzZWQgdG8gdGhlXG4gICAgLy8gXCJuZXh0XCIgZnVuY3Rpb25cbiAgICBsZXQgcmVzb2x2ZU5leHRQcm9taXNlO1xuICAgIGNvbnN0IG5leHRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlTmV4dFByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgIGxldCBuZXh0V2FzQ2FsbGVkID0gZmFsc2U7XG4gICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBieSB0aGUgY29uc3VtZXIncyBhc3luYyBtaWRkbGV3YXJlLlxuICAgIGNvbnN0IGFzeW5jTmV4dCA9IGFzeW5jICgpID0+IHtcbiAgICAgIG5leHRXYXNDYWxsZWQgPSB0cnVlO1xuICAgICAgLy8gV2UgcGFzcyBhIHJldHVybiBoYW5kbGVyIHRvIG5leHQoKS4gV2hlbiBpdCBpcyBjYWxsZWQgYnkgdGhlIGVuZ2luZSxcbiAgICAgIC8vIHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUgd2lsbCByZXN1bWUgZXhlY3V0aW5nLlxuICAgICAgbmV4dChydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrID0+IHtcbiAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBjb21lcyBmcm9tIEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayA9IHJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2s7XG4gICAgICAgIHJlc29sdmVOZXh0UHJvbWlzZSgpO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBuZXh0UHJvbWlzZTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhc3luY01pZGRsZXdhcmUocmVxLCByZXMsIGFzeW5jTmV4dCk7XG4gICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICBhd2FpdCBuZXh0UHJvbWlzZTsgLy8gd2UgbXVzdCB3YWl0IHVudGlsIHRoZSByZXR1cm4gaGFuZGxlciBpcyBjYWxsZWRcbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kKG51bGwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocmV0dXJuSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxuICogQSBKU09OLVJQQyByZXF1ZXN0IGFuZCByZXNwb25zZSBwcm9jZXNzb3IuXG4gKiBHaXZlIGl0IGEgc3RhY2sgb2YgbWlkZGxld2FyZSwgcGFzcyBpdCByZXF1ZXN0cywgYW5kIGdldCBiYWNrIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgSlJQQ0VuZ2luZSBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9taWRkbGV3YXJlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fbWlkZGxld2FyZSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxseSBleGVjdXRlcyB0aGUgZ2l2ZW4gc3RhY2sgb2YgbWlkZGxld2FyZS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYW55IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBtaWRkbGV3YXJlIGV4ZWN1dGlvbixcbiAgICogYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLCBhbmQgYW4gYXJyYXkgb2ZcbiAgICogbWlkZGxld2FyZS1kZWZpbmVkIHJldHVybiBoYW5kbGVycy5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBfcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZVN0YWNrKSB7XG4gICAgY29uc3QgcmV0dXJuSGFuZGxlcnMgPSBbXTtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgLy8gR28gZG93biBzdGFjayBvZiBtaWRkbGV3YXJlLCBjYWxsIGFuZCBjb2xsZWN0IG9wdGlvbmFsIHJldHVybkhhbmRsZXJzXG4gICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG1pZGRsZXdhcmVTdGFjaykge1xuICAgICAgW2Vycm9yLCBpc0NvbXBsZXRlXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmUsIHJldHVybkhhbmRsZXJzKTtcbiAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVycy5yZXZlcnNlKCldO1xuICB9XG4gIC8qKlxuICAgKiBSdW5zIGFuIGluZGl2aWR1YWwgbWlkZGxld2FyZS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYW55IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBtaWRkbGV3YXJlIGV4ZWN0aW9uLFxuICAgKiBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgZW5kLlxuICAgKi9cbiAgc3RhdGljIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGVuZCA9IGVyciA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyIHx8IHJlcy5lcnJvcjtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVzLmVycm9yID0gc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3Qgc2hvdWxkIGVuZFxuICAgICAgICByZXNvbHZlKFtlcnJvciwgdHJ1ZV0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5leHQgPSByZXR1cm5IYW5kbGVyID0+IHtcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgIGVuZChyZXMuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXR1cm5IYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldHVybkhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBlbmQobmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJKUlBDRW5naW5lOiAnbmV4dCcgcmV0dXJuIGhhbmRsZXJzIG11c3QgYmUgZnVuY3Rpb25zXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuSGFuZGxlcnMucHVzaChyZXR1cm5IYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3Qgc2hvdWxkIG5vdCBlbmRcbiAgICAgICAgICByZXNvbHZlKFtudWxsLCBmYWxzZV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgZW5kKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGx5IGV4ZWN1dGVzIGFycmF5IG9mIHJldHVybiBoYW5kbGVycy4gVGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGFyZVxuICAgKiBhc3N1bWVkIHRvIGJlIGluIHRoZWlyIHNjb3BlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIF9ydW5SZXR1cm5IYW5kbGVycyhoYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBoYW5kbGVyKGVyciA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yLCBvciBpZlxuICAgKiB0aGUgXCJpc0NvbXBsZXRlXCIgZmxhZyBpcyBmYWxzeS5cbiAgICovXG4gIHN0YXRpYyBfY2hlY2tGb3JDb21wbGV0aW9uKHJlcSwgcmVzLCBpc0NvbXBsZXRlKSB7XG4gICAgaWYgKCEoXCJyZXN1bHRcIiBpbiByZXMpICYmICEoXCJlcnJvclwiIGluIHJlcykpIHtcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBoYXMgbm8gZXJyb3Igb3IgcmVzdWx0IGZvciByZXF1ZXN0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJOb3RoaW5nIGVuZGVkIHJlcXVlc3RcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHRoZSBlbmdpbmUncyBtaWRkbGV3YXJlIHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0gbWlkZGxld2FyZSAtIFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIGFkZC5cbiAgICovXG4gIHB1c2gobWlkZGxld2FyZSkge1xuICAgIHRoaXMuX21pZGRsZXdhcmUucHVzaChtaWRkbGV3YXJlKTtcbiAgfVxuICBoYW5kbGUocmVxLCBjYikge1xuICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNhbGxiYWNrXCIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSwgY2IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSk7XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZShyZXEsIGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VIYW5kbGUocmVxKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIGVuZ2luZSBhcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcHVzaGVkIHRvIG90aGVyXG4gICAqIGVuZ2luZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbi5cbiAgICovXG4gIGFzTWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFttaWRkbGV3YXJlRXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgIGF3YWl0IEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgICByZXR1cm4gZW5kKG1pZGRsZXdhcmVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoYXN5bmMgaGFuZGxlckNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXJDYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgX2hhbmRsZUJhdGNoKHJlcXMsIGNiKSB7XG4gICAgLy8gVGhlIG9yZGVyIGhlcmUgaXMgaW1wb3J0YW50XG4gICAgdHJ5IHtcbiAgICAgIC8vIDIuIFdhaXQgZm9yIGFsbCByZXF1ZXN0cyB0byBmaW5pc2gsIG9yIHRocm93IG9uIHNvbWUga2luZCBvZiBmYXRhbFxuICAgICAgLy8gZXJyb3JcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgLy8gMS4gQmVnaW4gZXhlY3V0aW5nIGVhY2ggcmVxdWVzdCBpbiB0aGUgb3JkZXIgcmVjZWl2ZWRcbiAgICAgIHJlcXMubWFwKHRoaXMuX3Byb21pc2VIYW5kbGUuYmluZCh0aGlzKSkpO1xuICAgICAgLy8gMy4gUmV0dXJuIGJhdGNoIHJlc3BvbnNlXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3BvbnNlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBwcm9taXNlLXdyYXBwZWQgX2hhbmRsZS5cbiAgICovXG4gIF9wcm9taXNlSGFuZGxlKHJlcSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYSByZXNwb25zZSwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhdmUgYW55IGVycm9yXG4gICAgICAgIC8vIHRoYXQgaXMgY2F1Z2h0IGFuZCBwcm9wYWdhdGVkLlxuICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0IG9iamVjdCBpcyB2YWxpZCwgcHJvY2Vzc2VzIGl0LCBhbmQgcGFzc2VzIGFueVxuICAgKiBlcnJvciBhbmQgdGhlIHJlc3BvbnNlIG9iamVjdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIERvZXMgbm90IHJlamVjdC5cbiAgICovXG4gIGFzeW5jIF9oYW5kbGUoY2FsbGVyUmVxLCBjYikge1xuICAgIGlmICghY2FsbGVyUmVxIHx8IEFycmF5LmlzQXJyYXkoY2FsbGVyUmVxKSB8fCB0eXBlb2YgY2FsbGVyUmVxICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJyZXF1ZXN0IG11c3QgYmUgcGxhaW4gb2JqZWN0XCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKGVycm9yLCB7XG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsZXJSZXEubWV0aG9kICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJtZXRob2QgbXVzdCBiZSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHtcbiAgICAgICAgaWQ6IGNhbGxlclJlcS5pZCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSBfb2JqZWN0U3ByZWFkJDEoe30sIGNhbGxlclJlcSk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjXG4gICAgfTtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAvLyBBIHJlcXVlc3QgaGFuZGxlciBlcnJvciwgYSByZS10aHJvd24gbWlkZGxld2FyZSBlcnJvciwgb3Igc29tZXRoaW5nXG4gICAgICAvLyB1bmV4cGVjdGVkLlxuICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgLy8gRW5zdXJlIG5vIHJlc3VsdCBpcyBwcmVzZW50IG9uIGFuIGVycm9yZWQgcmVzcG9uc2VcbiAgICAgIGRlbGV0ZSByZXMucmVzdWx0O1xuICAgICAgaWYgKCFyZXMuZXJyb3IpIHtcbiAgICAgICAgcmVzLmVycm9yID0gc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2IoZXJyb3IsIHJlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEZvciB0aGUgZ2l2ZW4gcmVxdWVzdCBhbmQgcmVzcG9uc2UsIHJ1bnMgYWxsIG1pZGRsZXdhcmUgYW5kIHRoZWlyIHJldHVyblxuICAgKiBoYW5kbGVycywgaWYgYW55LCBhbmQgZW5zdXJlcyB0aGF0IGludGVybmFsIHJlcXVlc3QgcHJvY2Vzc2luZyBzZW1hbnRpY3NcbiAgICogYXJlIHNhdGlzZmllZC5cbiAgICovXG4gIGFzeW5jIF9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcykge1xuICAgIGNvbnN0IFtlcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnNdID0gYXdhaXQgSlJQQ0VuZ2luZS5fcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgdGhpcy5fbWlkZGxld2FyZSk7XG4gICAgLy8gVGhyb3cgaWYgXCJlbmRcIiB3YXMgbm90IGNhbGxlZCwgb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0XG4gICAgLy8gbm9yIGFuIGVycm9yLlxuICAgIEpSUENFbmdpbmUuX2NoZWNrRm9yQ29tcGxldGlvbihyZXEsIHJlcywgaXNDb21wbGV0ZSk7XG4gICAgLy8gVGhlIHJldHVybiBoYW5kbGVycyBzaG91bGQgcnVuIGV2ZW4gaWYgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIGR1cmluZ1xuICAgIC8vIG1pZGRsZXdhcmUgcHJvY2Vzc2luZy5cbiAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG4gICAgLy8gTm93IHdlIHJlLXRocm93IHRoZSBtaWRkbGV3YXJlIHByb2Nlc3NpbmcgZXJyb3IsIGlmIGFueSwgdG8gY2F0Y2ggaXRcbiAgICAvLyBmdXJ0aGVyIHVwIHRoZSBjYWxsIGNoYWluLlxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtZXJnZU1pZGRsZXdhcmUobWlkZGxld2FyZVN0YWNrKSB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gIG1pZGRsZXdhcmVTdGFjay5mb3JFYWNoKG1pZGRsZXdhcmUgPT4gZW5naW5lLnB1c2gobWlkZGxld2FyZSkpO1xuICByZXR1cm4gZW5naW5lLmFzTWlkZGxld2FyZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5naW5lU3RyZWFtKG9wdHMpIHtcbiAgaWYgKCFvcHRzIHx8ICFvcHRzLmVuZ2luZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZW5naW5lIHBhcmFtZXRlciFcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGVuZ2luZVxuICB9ID0gb3B0cztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQgc3RyZWFtO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGUocmVxLCBfZW5jb2RpbmcsIGNiKSB7XG4gICAgZW5naW5lLmhhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgIHN0cmVhbS5wdXNoKHJlcyk7XG4gICAgfSk7XG4gICAgY2IoKTtcbiAgfVxuICBzdHJlYW0gPSBuZXcgRHVwbGV4KHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIHJlYWQsXG4gICAgd3JpdGVcbiAgfSk7XG4gIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICBpZiAoZW5naW5lLm9uKSB7XG4gICAgZW5naW5lLm9uKFwibm90aWZpY2F0aW9uXCIsIG1lc3NhZ2UgPT4ge1xuICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuY2xhc3MgU3Vic3RyZWFtIGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBwYXJlbnQsXG4gICAgICBuYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuICAvKipcbiAgICogRXhwbGljaXRseSBzZXRzIHJlYWQgb3BlcmF0aW9ucyB0byBhIG5vLW9wLlxuICAgKi9cbiAgX3JlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZGF0YSBzaG91bGQgYmUgd3JpdHRlbiB0byB0aGlzIHdyaXRhYmxlIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIGNodW5rIC0gQXJiaXRyYXJ5IG9iamVjdCB0byB3cml0ZVxuICAgKiBAcGFyYW0gZW5jb2RpbmcgLSBFbmNvZGluZyB0byB1c2Ugd2hlbiB3cml0aW5nIHBheWxvYWRcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGVkIHdoZW4gd3JpdGluZyBpcyBjb21wbGV0ZSBvciBhbiBlcnJvciBvY2N1cnNcbiAgICovXG4gIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3BhcmVudC5wdXNoKHtcbiAgICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgICBkYXRhOiBjaHVua1xuICAgIH0pO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jb25zdCBJR05PUkVfU1VCU1RSRUFNID0gU3ltYm9sKFwiSUdOT1JFX1NVQlNUUkVBTVwiKTtcbmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdHMpLCB7fSwge1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Vic3RyZWFtc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFN0cmVhbVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fTtcbiAgfVxuICBjcmVhdGVTdHJlYW0obmFtZSkge1xuICAgIC8vIHZhbGlkYXRlIG5hbWVcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdE11bHRpcGxleCAtIG5hbWUgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc3Vic3RyZWFtXG4gICAgY29uc3Qgc3Vic3RyZWFtID0gbmV3IFN1YnN0cmVhbSh7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IHN1YnN0cmVhbTtcbiAgICAvLyBsaXN0ZW4gZm9yIHBhcmVudCBzdHJlYW0gdG8gZW5kXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIGFueVN0cmVhbUVuZCh0aGlzLCBfZXJyb3IgPT4gc3Vic3RyZWFtLmRlc3Ryb3koX2Vycm9yIHx8IHVuZGVmaW5lZCkpO1xuICAgIHJldHVybiBzdWJzdHJlYW07XG4gIH1cbiAgLy8gaWdub3JlIHN0cmVhbXMgKGRvbnQgZGlzcGxheSBvcnBoYW5lZCBkYXRhIHdhcm5pbmcpXG4gIGlnbm9yZVN0cmVhbShuYW1lKSB7XG4gICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIC8vIHNldFxuICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBJR05PUkVfU1VCU1RSRUFNO1xuICB9XG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGRhdGFcbiAgICB9ID0gY2h1bms7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBtYWxmb3JtZWQgY2h1bmsgd2l0aG91dCBuYW1lIFwiJHtjaHVua31cImApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIGdldCBjb3JyZXNwb25kaW5nIHN1YnN0cmVhbVxuICAgIGNvbnN0IHN1YnN0cmVhbSA9IHRoaXMuX3N1YnN0cmVhbXNbbmFtZV07XG4gICAgaWYgKCFzdWJzdHJlYW0pIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG9ycGhhbmVkIGRhdGEgZm9yIHN0cmVhbSBcIiR7bmFtZX1cImApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbVxuICAgIGlmIChzdWJzdHJlYW0gIT09IElHTk9SRV9TVUJTVFJFQU0pIHtcbiAgICAgIHN1YnN0cmVhbS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxufVxuLy8gdXRpbFxuZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7XG4gIGNvbnN0IGNiID0gb25jZShfY2IpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IGZhbHNlXG4gIH0sIGNiKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LCBjYik7XG59XG5mdW5jdGlvbiBzZXR1cE11bHRpcGxleChzdHJlYW0pIHtcbiAgY29uc3QgbXV4ID0gbmV3IE9iamVjdE11bHRpcGxleCgpO1xuICBtdXguZ2V0U3RyZWFtID0gZnVuY3Rpb24gc3RyZWFtSGVscGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0cmVhbShuYW1lKTtcbiAgfTtcbiAgcHVtcChzdHJlYW0sIG11eCwgc3RyZWFtLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHdpbmRvdy5jb25zb2xlLmVycm9yKGVycik7XG4gIH0pO1xuICByZXR1cm4gbXV4O1xufVxuXG5jbGFzcyBQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSB7XG4gIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgbGV0IG9yaWdpbkNvbnN0cmFpbnQgPSB0aGlzLl90YXJnZXRPcmlnaW47XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBkYXRhT2JqID0gZGF0YTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YU9iai5kYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGFPYmpEYXRhID0gZGF0YU9iai5kYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhT2JqRGF0YS5wYXJhbXMpICYmIGRhdGFPYmpEYXRhLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZGF0YU9iakRhdGFQYXJhbSA9IGRhdGFPYmpEYXRhLnBhcmFtc1swXTtcbiAgICAgICAgICBpZiAoZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luKSB7XG4gICAgICAgICAgICBvcmlnaW5Db25zdHJhaW50ID0gZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGQgYSBjb25zdHJhaW50IGZvciB0aGUgcmVzcG9uc2VcbiAgICAgICAgICBkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGRhdGFcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0sIElHTk9SRV9TVUJTVFJFQU0sIEpSUENFbmdpbmUsIE9iamVjdE11bHRpcGxleCwgUG9zdE1lc3NhZ2VTdHJlYW0sIFNhZmVFdmVudEVtaXR0ZXIsIFNlcmlhbGl6YWJsZUVycm9yLCBTdWJzdHJlYW0sIGNyZWF0ZUFzeW5jTWlkZGxld2FyZSwgY3JlYXRlRW5naW5lU3RyZWFtLCBjcmVhdGVFcnJvck1pZGRsZXdhcmUsIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlLCBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUsIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUsIGdldFJwY1Byb21pc2VDYWxsYmFjaywgbWVyZ2VNaWRkbGV3YXJlLCBzZXR1cE11bHRpcGxleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbmxvZ2luSnJwYy5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5IiwiRHVwbGV4IiwicmFuZG9tSWQiLCJFdmVudEVtaXR0ZXIiLCJzdHJpbmdpZnkiLCJzZXJpYWxpemVFcnJvciIsImVvcyIsIm9uY2UiLCJwdW1wIiwibm9vcCIsInVuZGVmaW5lZCIsIlNZTiIsIkFDSyIsIkJSSyIsIkJhc2VQb3N0TWVzc2FnZVN0cmVhbSIsImNvbnN0cnVjdG9yIiwiX3JlZiIsIm5hbWUiLCJ0YXJnZXQiLCJ0YXJnZXRXaW5kb3ciLCJ3aW5kb3ciLCJ0YXJnZXRPcmlnaW4iLCJvYmplY3RNb2RlIiwiRXJyb3IiLCJfaW5pdCIsIl9oYXZlU3luIiwiX25hbWUiLCJfdGFyZ2V0IiwiX3RhcmdldFdpbmRvdyIsIl90YXJnZXRPcmlnaW4iLCJfb25NZXNzYWdlIiwib25NZXNzYWdlIiwiYmluZCIsIl9zeW5JbnRlcnZhbElkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9oYW5kU2hha2UiLCJfYnJlYWsiLCJjb3JrIiwiX3dyaXRlIiwiX29uRGF0YSIsImRhdGEiLCJ1bmNvcmsiLCJwdXNoIiwiZXJyIiwiZW1pdCIsIl9wb3N0TWVzc2FnZSIsIm9yaWdpbkNvbnN0cmFpbnQiLCJwb3N0TWVzc2FnZSIsImV2ZW50IiwibWVzc2FnZSIsIm9yaWdpbiIsInNvdXJjZSIsIl9yZWFkIiwiXyIsImNiIiwiX2Rlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2FmZUFwcGx5IiwiaGFuZGxlciIsImNvbnRleHQiLCJhcmdzIiwiUmVmbGVjdCIsImFwcGx5Iiwic2V0VGltZW91dCIsImFycmF5Q2xvbmUiLCJhcnIiLCJuIiwibGVuZ3RoIiwiY29weSIsIkFycmF5IiwiaSIsIlNhZmVFdmVudEVtaXR0ZXIiLCJ0eXBlIiwiZG9FcnJvciIsImV2ZW50cyIsIl9ldmVudHMiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJfa2V5IiwiZXIiLCJsZW4iLCJsaXN0ZW5lcnMiLCJTZXJpYWxpemFibGVFcnJvciIsImNvZGUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ0b1N0cmluZyIsInN0YWNrIiwiZ2V0UnBjUHJvbWlzZUNhbGxiYWNrIiwicmVzb2x2ZSIsInJlamVjdCIsInVud3JhcFJlc3VsdCIsInJlc3BvbnNlIiwiaXNBcnJheSIsInJlc3VsdCIsImNyZWF0ZUVycm9yTWlkZGxld2FyZSIsImxvZyIsInJlcSIsInJlcyIsIm5leHQiLCJlbmQiLCJtZXRob2QiLCJkb25lIiwiY3JlYXRlU3RyZWFtTWlkZGxld2FyZSIsImlkTWFwIiwicmVhZE5vb3AiLCJwcm9jZXNzUmVzcG9uc2UiLCJpZCIsIk9iamVjdCIsImFzc2lnbiIsInByb2Nlc3NOb3RpZmljYXRpb24iLCJwcm9jZXNzTWVzc2FnZSIsIl9lbmNvZGluZyIsImlzTm90aWZpY2F0aW9uIiwiX2VyciIsInN0cmVhbSIsInJlYWQiLCJ3cml0ZSIsIm1pZGRsZXdhcmUiLCJjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUiLCJoYW5kbGVycyIsImNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlIiwiX2VuZCIsIm9yaWdpbmFsSWQiLCJuZXdJZCIsImNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUiLCJsb2dnZXIiLCJkZWJ1ZyIsImNyZWF0ZUFzeW5jTWlkZGxld2FyZSIsImFzeW5jTWlkZGxld2FyZSIsInJlc29sdmVOZXh0UHJvbWlzZSIsIm5leHRQcm9taXNlIiwiUHJvbWlzZSIsInJldHVybkhhbmRsZXJDYWxsYmFjayIsIm5leHRXYXNDYWxsZWQiLCJhc3luY05leHQiLCJydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrIiwib3duS2V5cyQxIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfb2JqZWN0U3ByZWFkJDEiLCJmb3JFYWNoIiwia2V5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIkpSUENFbmdpbmUiLCJfbWlkZGxld2FyZSIsIl9ydW5BbGxNaWRkbGV3YXJlIiwibWlkZGxld2FyZVN0YWNrIiwicmV0dXJuSGFuZGxlcnMiLCJpc0NvbXBsZXRlIiwiX3J1bk1pZGRsZXdhcmUiLCJyZXZlcnNlIiwicmV0dXJuSGFuZGxlciIsIl9ydW5SZXR1cm5IYW5kbGVycyIsIl9jaGVja0ZvckNvbXBsZXRpb24iLCJoYW5kbGUiLCJfaGFuZGxlQmF0Y2giLCJfaGFuZGxlIiwiX3Byb21pc2VIYW5kbGUiLCJhc01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlRXJyb3IiLCJoYW5kbGVyQ2FsbGJhY2siLCJyZXFzIiwicmVzcG9uc2VzIiwiYWxsIiwibWFwIiwiY2FsbGVyUmVxIiwianNvbnJwYyIsIl9wcm9jZXNzUmVxdWVzdCIsIl9lcnJvciIsIm1lcmdlTWlkZGxld2FyZSIsImVuZ2luZSIsImNyZWF0ZUVuZ2luZVN0cmVhbSIsIm9wdHMiLCJvbiIsIlN1YnN0cmVhbSIsInBhcmVudCIsIl9wYXJlbnQiLCJjaHVuayIsImNhbGxiYWNrIiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiLCJJR05PUkVfU1VCU1RSRUFNIiwiU3ltYm9sIiwiT2JqZWN0TXVsdGlwbGV4IiwiX3N1YnN0cmVhbXMiLCJjcmVhdGVTdHJlYW0iLCJzdWJzdHJlYW0iLCJhbnlTdHJlYW1FbmQiLCJkZXN0cm95IiwiaWdub3JlU3RyZWFtIiwiY29uc29sZSIsIndhcm4iLCJfY2IiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwic2V0dXBNdWx0aXBsZXgiLCJtdXgiLCJnZXRTdHJlYW0iLCJzdHJlYW1IZWxwZXIiLCJQb3N0TWVzc2FnZVN0cmVhbSIsImRhdGFPYmoiLCJkYXRhT2JqRGF0YSIsInBhcmFtcyIsImRhdGFPYmpEYXRhUGFyYW0iLCJfb3JpZ2luIiwibG9jYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   URLWithHashParams: () => (/* binding */ URLWithHashParams),\n/* harmony export */   base64toJSON: () => (/* binding */ base64toJSON),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   jsonToBase64: () => (/* binding */ jsonToBase64),\n/* harmony export */   keccak: () => (/* binding */ keccak),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   safeatob: () => (/* binding */ safeatob),\n/* harmony export */   safebtoa: () => (/* binding */ safebtoa)\n/* harmony export */ });\n/* harmony import */ var randombytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! randombytes */ \"(ssr)/../node_modules/randombytes/index.js\");\n/* harmony import */ var randombytes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(randombytes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/../node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! base64url */ \"(ssr)/../node_modules/base64url/index.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(base64url__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var keccak__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! keccak */ \"(ssr)/../node_modules/keccak/index.js\");\n/* harmony import */ var keccak__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(keccak__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst randomId = ()=>randombytes__WEBPACK_IMPORTED_MODULE_0___default()(32).toString(\"hex\");\nclass URLWithHashParams extends URL {\n    constructor(){\n        super(...arguments);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"hashParams\", new URLSearchParams());\n    }\n    toString() {\n        this.hash = this.hashParams.toString();\n        return super.toString.call(this);\n    }\n}\nconst base64url = (base64url__WEBPACK_IMPORTED_MODULE_2___default());\nfunction safebtoa(str) {\n    return base64url.encode(str);\n}\nfunction safeatob(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return base64url.decode(str);\n}\nconst keccak = (keccak__WEBPACK_IMPORTED_MODULE_3___default());\nfunction base64toJSON(b64str) {\n    return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n    return base64url.encode(JSON.stringify(json));\n}\nfunction keccak256(str) {\n    let input = str;\n    if (typeof str === \"string\" && str.slice(0, 2) === \"0x\" && str.length === 66) {\n        input = Buffer.from(str.slice(2), \"hex\");\n    }\n    const data = `0x${keccak(\"keccak256\").update(input).digest(\"hex\").padStart(64, \"0\")}`;\n    return data;\n}\n //# sourceMappingURL=openloginUtils.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi11dGlscy9kaXN0L29wZW5sb2dpblV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUM4QjtBQUMvQjtBQUNOO0FBRS9CLE1BQU1JLFdBQVcsSUFBTUosa0RBQVdBLENBQUMsSUFBSUssUUFBUSxDQUFDO0FBRWhELE1BQU1DLDBCQUEwQkM7SUFDOUJDLGFBQWM7UUFDWixLQUFLLElBQUlDO1FBQ1RSLDRFQUFlQSxDQUFDLElBQUksRUFBRSxjQUFjLElBQUlTO0lBQzFDO0lBQ0FMLFdBQVc7UUFDVCxJQUFJLENBQUNNLElBQUksR0FBRyxJQUFJLENBQUNDLFVBQVUsQ0FBQ1AsUUFBUTtRQUNwQyxPQUFPLEtBQUssQ0FBQ0EsU0FBU1EsSUFBSSxDQUFDLElBQUk7SUFDakM7QUFDRjtBQUVBLE1BQU1DLFlBQVlaLGtEQUFZQTtBQUM5QixTQUFTYSxTQUFTQyxHQUFHO0lBQ25CLE9BQU9GLFVBQVVHLE1BQU0sQ0FBQ0Q7QUFDMUI7QUFDQSxTQUFTRSxTQUFTRixHQUFHO0lBQ25CLDZFQUE2RTtJQUM3RSxPQUFPRixVQUFVSyxNQUFNLENBQUNIO0FBQzFCO0FBQ0EsTUFBTUksU0FBU2pCLCtDQUFTQTtBQUN4QixTQUFTa0IsYUFBYUMsTUFBTTtJQUMxQixPQUFPQyxLQUFLQyxLQUFLLENBQUNWLFVBQVVLLE1BQU0sQ0FBQ0c7QUFDckM7QUFDQSxTQUFTRyxhQUFhQyxJQUFJO0lBQ3hCLE9BQU9aLFVBQVVHLE1BQU0sQ0FBQ00sS0FBS0ksU0FBUyxDQUFDRDtBQUN6QztBQUNBLFNBQVNFLFVBQVVaLEdBQUc7SUFDcEIsSUFBSWEsUUFBUWI7SUFDWixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsSUFBSWMsS0FBSyxDQUFDLEdBQUcsT0FBTyxRQUFRZCxJQUFJZSxNQUFNLEtBQUssSUFBSTtRQUM1RUYsUUFBUUcsT0FBT0MsSUFBSSxDQUFDakIsSUFBSWMsS0FBSyxDQUFDLElBQUk7SUFDcEM7SUFDQSxNQUFNSSxPQUFPLENBQUMsRUFBRSxFQUFFZCxPQUFPLGFBQWFlLE1BQU0sQ0FBQ04sT0FBT08sTUFBTSxDQUFDLE9BQU9DLFFBQVEsQ0FBQyxJQUFJLEtBQUssQ0FBQztJQUNyRixPQUFPSDtBQUNUO0FBRXFILENBQ3JILDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLXV0aWxzL2Rpc3Qvb3BlbmxvZ2luVXRpbHMuZXNtLmpzPzczZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJhbmRvbWJ5dGVzIGZyb20gJ3JhbmRvbWJ5dGVzJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgYmFzZTY0dXJsTGliIGZyb20gJ2Jhc2U2NHVybCc7XG5pbXBvcnQga2VjY2FrTGliIGZyb20gJ2tlY2Nhayc7XG5cbmNvbnN0IHJhbmRvbUlkID0gKCkgPT4gcmFuZG9tYnl0ZXMoMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuXG5jbGFzcyBVUkxXaXRoSGFzaFBhcmFtcyBleHRlbmRzIFVSTCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzaFBhcmFtc1wiLCBuZXcgVVJMU2VhcmNoUGFyYW1zKCkpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaFBhcmFtcy50b1N0cmluZygpO1xuICAgIHJldHVybiBzdXBlci50b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9XG59XG5cbmNvbnN0IGJhc2U2NHVybCA9IGJhc2U2NHVybExpYjtcbmZ1bmN0aW9uIHNhZmVidG9hKHN0cikge1xuICByZXR1cm4gYmFzZTY0dXJsLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gc2FmZWF0b2Ioc3RyKSB7XG4gIC8vIEdvaW5nIGJhY2t3YXJkczogZnJvbSBieXRlc3RyZWFtLCB0byBwZXJjZW50LWVuY29kaW5nLCB0byBvcmlnaW5hbCBzdHJpbmcuXG4gIHJldHVybiBiYXNlNjR1cmwuZGVjb2RlKHN0cik7XG59XG5jb25zdCBrZWNjYWsgPSBrZWNjYWtMaWI7XG5mdW5jdGlvbiBiYXNlNjR0b0pTT04oYjY0c3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUoYjY0c3RyKSk7XG59XG5mdW5jdGlvbiBqc29uVG9CYXNlNjQoanNvbikge1xuICByZXR1cm4gYmFzZTY0dXJsLmVuY29kZShKU09OLnN0cmluZ2lmeShqc29uKSk7XG59XG5mdW5jdGlvbiBrZWNjYWsyNTYoc3RyKSB7XG4gIGxldCBpbnB1dCA9IHN0cjtcbiAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgc3RyLnNsaWNlKDAsIDIpID09PSBcIjB4XCIgJiYgc3RyLmxlbmd0aCA9PT0gNjYpIHtcbiAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKHN0ci5zbGljZSgyKSwgXCJoZXhcIik7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGAweCR7a2VjY2FrKFwia2VjY2FrMjU2XCIpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KFwiaGV4XCIpLnBhZFN0YXJ0KDY0LCBcIjBcIil9YDtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCB7IFVSTFdpdGhIYXNoUGFyYW1zLCBiYXNlNjR0b0pTT04sIGJhc2U2NHVybCwganNvblRvQmFzZTY0LCBrZWNjYWssIGtlY2NhazI1NiwgcmFuZG9tSWQsIHNhZmVhdG9iLCBzYWZlYnRvYSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbmxvZ2luVXRpbHMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbInJhbmRvbWJ5dGVzIiwiX2RlZmluZVByb3BlcnR5IiwiYmFzZTY0dXJsTGliIiwia2VjY2FrTGliIiwicmFuZG9tSWQiLCJ0b1N0cmluZyIsIlVSTFdpdGhIYXNoUGFyYW1zIiwiVVJMIiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJVUkxTZWFyY2hQYXJhbXMiLCJoYXNoIiwiaGFzaFBhcmFtcyIsImNhbGwiLCJiYXNlNjR1cmwiLCJzYWZlYnRvYSIsInN0ciIsImVuY29kZSIsInNhZmVhdG9iIiwiZGVjb2RlIiwia2VjY2FrIiwiYmFzZTY0dG9KU09OIiwiYjY0c3RyIiwiSlNPTiIsInBhcnNlIiwianNvblRvQmFzZTY0IiwianNvbiIsInN0cmluZ2lmeSIsImtlY2NhazI1NiIsImlucHV0Iiwic2xpY2UiLCJsZW5ndGgiLCJCdWZmZXIiLCJmcm9tIiwiZGF0YSIsInVwZGF0ZSIsImRpZ2VzdCIsInBhZFN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/bs58/index.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@toruslabs/solana-embed/node_modules/bs58/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(ssr)/../node_modules/base-x/src/index.js\");\nvar ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVc7QUFFZkMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/Zjk4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOlsiYmFzZXgiLCJyZXF1aXJlIiwiQUxQSEFCRVQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@toruslabs/solana-embed/node_modules/bs58/index.js\n");

/***/ })

};
;