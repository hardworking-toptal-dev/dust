"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micro-ftch";
exports.ids = ["vendor-chunks/micro-ftch"];
exports.modules = {

/***/ "(ssr)/../node_modules/micro-ftch/index.js":
/*!*******************************************!*\
  !*** ../node_modules/micro-ftch/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256){\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode){\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === \"text\" || type === \"json\") {\n        try {\n            let text = new TextDecoder(\"utf8\", {\n                fatal: true\n            }).decode(b);\n            if (type === \"text\") return text;\n            try {\n                return JSON.parse(text);\n            } catch (err) {\n                if (type === \"json\") throw err;\n                return text;\n            }\n        } catch (err) {\n            if (type === \"text\" || type === \"json\") throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = {\n        ...DEFAULT_OPT,\n        ..._options\n    };\n    const http = __webpack_require__(/*! http */ \"http\");\n    const https = __webpack_require__(/*! https */ \"https\");\n    const zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const { promisify } = __webpack_require__(/*! util */ \"util\");\n    const { resolve: urlResolve } = __webpack_require__(/*! url */ \"url\");\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || \"GET\",\n        headers: {\n            \"Accept-Encoding\": \"gzip, deflate, br\"\n        }\n    };\n    const compactFP = (s)=>s.replace(/:| /g, \"\").toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i)=>compactFP(i)).sort()\n        ].join();\n        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === \"json\") opts.headers[\"Content-Type\"] = \"application/json\";\n    if (options.data) {\n        if (!options.method) opts.method = \"POST\";\n        opts.body = options.type === \"json\" ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = {\n        ...opts.headers,\n        ...options.headers\n    };\n    if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n    const handleRes = async (res)=>{\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers[\"location\"]) {\n            if (options._redirectCount == 10) throw new Error(\"Request failed. Too much redirects.\");\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers[\"location\"]), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers[\"content-encoding\"];\n        if (encoding === \"br\") bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === \"gzip\" || encoding === \"deflate\") bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full) return {\n            headers: res.headers,\n            status,\n            body\n        };\n        return body;\n    };\n    return new Promise((resolve, reject)=>{\n        const handleError = async (err)=>{\n            if (err && err.code === \"DEPTH_ZERO_SELF_SIGNED_CERT\") {\n                try {\n                    await fetchNode(url, {\n                        ...options,\n                        sslAllowSelfSigned: true,\n                        sslPinnedCertificates: []\n                    });\n                } catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res)=>{\n            res.on(\"error\", handleError);\n            (async ()=>{\n                try {\n                    resolve(await handleRes(res));\n                } catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on(\"error\", handleError);\n        const pinned = options.sslPinnedCertificates?.map((i)=>compactFP(i));\n        const mfetchSecureConnect = (socket)=>{\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || \"\");\n            if (!fp256 && socket.isSessionReused()) return;\n            if (pinned.includes(fp256)) return;\n            req.emit(\"error\", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on(\"socket\", (socket)=>{\n                const hasListeners = socket.listeners(\"secureConnect\").map((i)=>(i.name || \"\").replace(\"bound \", \"\")).includes(\"mfetchSecureConnect\");\n                if (hasListeners) return;\n                socket.on(\"secureConnect\", mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive) req.setNoDelay(true);\n        if (opts.body) req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set([\n    \"Accept\",\n    \"Accept-Language\",\n    \"Content-Language\",\n    \"Content-Type\"\n].map((i)=>i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set([\n    \"Accept-Charset\",\n    \"Accept-Encoding\",\n    \"Access-Control-Request-Headers\",\n    \"Access-Control-Request-Method\",\n    \"Connection\",\n    \"Content-Length\",\n    \"Cookie\",\n    \"Cookie2\",\n    \"Date\",\n    \"DNT\",\n    \"Expect\",\n    \"Host\",\n    \"Keep-Alive\",\n    \"Origin\",\n    \"Referer\",\n    \"TE\",\n    \"Trailer\",\n    \"Transfer-Encoding\",\n    \"Upgrade\",\n    \"Via\"\n].map((i)=>i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = {\n        ...DEFAULT_OPT,\n        ..._options\n    };\n    const headers = new Headers();\n    if (options.type === \"json\") headers.set(\"Content-Type\", \"application/json\");\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set(\"Authorization\", `Basic ${auth}`);\n        parsed.username = \"\";\n        parsed.password = \"\";\n    }\n    url = \"\" + parsed;\n    for(let k in options.headers){\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n    }\n    let opts = {\n        headers,\n        redirect: options.redirect ? \"follow\" : \"manual\"\n    };\n    if (!options.referrer) opts.referrerPolicy = \"no-referrer\";\n    if (options.cors) opts.mode = \"cors\";\n    if (options.data) {\n        if (!options.method) opts.method = \"POST\";\n        opts.body = options.type === \"json\" ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full) return {\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        body\n    };\n    return body;\n}\nconst IS_NODE = !!(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports[\"default\"] = fetchUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL21pY3JvLWZ0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ2pFLE1BQU1JLGNBQWNOLE9BQU9PLE1BQU0sQ0FBQztJQUM5QkMsVUFBVTtJQUNWQyxrQkFBa0I7SUFDbEJDLFNBQVMsQ0FBQztJQUNWQyxNQUFNO0lBQ05DLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDLG9CQUFvQjtJQUNwQkMsZ0JBQWdCO0FBQ3BCO0FBQ0EsTUFBTVgseUJBQXlCWTtJQUMzQkMsWUFBWUMsR0FBRyxFQUFFQyxjQUFjLENBQUU7UUFDN0IsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0MsY0FBYyxHQUFHQTtJQUMxQjtBQUNKO0FBQ0FsQix3QkFBd0IsR0FBR0c7QUFDM0IsTUFBTUQsK0JBQStCYTtJQUNqQ0MsWUFBWUcsVUFBVSxDQUFFO1FBQ3BCLEtBQUssQ0FBQyxDQUFDLDZCQUE2QixFQUFFQSxXQUFXLENBQUM7UUFDbEQsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3RCO0FBQ0o7QUFDQW5CLDhCQUE4QixHQUFHRTtBQUNqQyxTQUFTa0IsV0FBV0MsQ0FBQyxFQUFFQyxJQUFJO0lBQ3ZCLElBQUksQ0FBQ0EsUUFBUUEsU0FBUyxVQUFVQSxTQUFTLFFBQVE7UUFDN0MsSUFBSTtZQUNBLElBQUlDLE9BQU8sSUFBSUMsWUFBWSxRQUFRO2dCQUFFQyxPQUFPO1lBQUssR0FBR0MsTUFBTSxDQUFDTDtZQUMzRCxJQUFJQyxTQUFTLFFBQ1QsT0FBT0M7WUFDWCxJQUFJO2dCQUNBLE9BQU9JLEtBQUtDLEtBQUssQ0FBQ0w7WUFDdEIsRUFDQSxPQUFPTSxLQUFLO2dCQUNSLElBQUlQLFNBQVMsUUFDVCxNQUFNTztnQkFDVixPQUFPTjtZQUNYO1FBQ0osRUFDQSxPQUFPTSxLQUFLO1lBQ1Is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RztJQUMxQixJQUFJcEYsUUFBUXZCLElBQUksRUFDWmlDLEtBQUsyRSxJQUFJLEdBQUc7SUFDaEIsSUFBSXJGLFFBQVE0QixJQUFJLEVBQUU7UUFDZCxJQUFJLENBQUM1QixRQUFRVyxNQUFNLEVBQ2ZELEtBQUtDLE1BQU0sR0FBRztRQUNsQkQsS0FBS21CLElBQUksR0FBRzdCLFFBQVFaLElBQUksS0FBSyxTQUFTSyxLQUFLcUMsU0FBUyxDQUFDOUIsUUFBUTRCLElBQUksSUFBSTVCLFFBQVE0QixJQUFJO0lBQ3JGO0lBQ0EsTUFBTUssTUFBTSxNQUFNcUQsTUFBTXhGLEtBQUtZO0lBQzdCLElBQUlWLFFBQVEzQixnQkFBZ0IsSUFBSTRELElBQUlDLE1BQU0sS0FBS2xDLFFBQVEzQixnQkFBZ0IsRUFDbkUsTUFBTSxJQUFJTCx1QkFBdUJpRSxJQUFJQyxNQUFNO0lBQy9DLE1BQU1MLE9BQU8zQyxXQUFXLElBQUlxRyxXQUFXLE1BQU10RCxJQUFJdUQsV0FBVyxLQUFLeEYsUUFBUVosSUFBSTtJQUM3RSxJQUFJWSxRQUFRekIsSUFBSSxFQUNaLE9BQU87UUFBRUQsU0FBU1YsT0FBTzZILFdBQVcsQ0FBQ3hELElBQUkzRCxPQUFPLENBQUNvSCxPQUFPO1FBQUt4RCxRQUFRRCxJQUFJQyxNQUFNO1FBQUVMO0lBQUs7SUFDMUYsT0FBT0E7QUFDWDtBQUNBLE1BQU04RCxVQUFVLENBQUMsQ0FBRSxRQUFPQyxXQUFXLFlBQ2pDQSxRQUFRQyxRQUFRLElBQ2hCRCxRQUFRQyxRQUFRLENBQUNDLElBQUksSUFDckJGLFFBQVFDLFFBQVEsQ0FBQ0UsRUFBRTtBQUN2QixTQUFTQyxTQUFTbEcsR0FBRyxFQUFFRSxPQUFPO0lBQzFCLE1BQU1pRyxLQUFLTixVQUFVOUYsWUFBWTRFO0lBQ2pDLE9BQU93QixHQUFHbkcsS0FBS0U7QUFDbkI7QUFDQWxDLGtCQUFlLEdBQUdrSSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcz9jMDdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkU3RhdHVzQ29kZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2VydEVycm9yID0gdm9pZCAwO1xuY29uc3QgREVGQVVMVF9PUFQgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWRpcmVjdDogdHJ1ZSxcbiAgICBleHBlY3RTdGF0dXNDb2RlOiAyMDAsXG4gICAgaGVhZGVyczoge30sXG4gICAgZnVsbDogZmFsc2UsXG4gICAga2VlcEFsaXZlOiB0cnVlLFxuICAgIGNvcnM6IGZhbHNlLFxuICAgIHJlZmVycmVyOiBmYWxzZSxcbiAgICBzc2xBbGxvd1NlbGZTaWduZWQ6IGZhbHNlLFxuICAgIF9yZWRpcmVjdENvdW50OiAwLFxufSk7XG5jbGFzcyBJbnZhbGlkQ2VydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZywgZmluZ2VycHJpbnQyNTYpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maW5nZXJwcmludDI1NiA9IGZpbmdlcnByaW50MjU2O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENlcnRFcnJvciA9IEludmFsaWRDZXJ0RXJyb3I7XG5jbGFzcyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIoYFJlcXVlc3QgRmFpbGVkLiBTdGF0dXMgQ29kZTogJHtzdGF0dXNDb2RlfWApO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFN0YXR1c0NvZGVFcnJvciA9IEludmFsaWRTdGF0dXNDb2RlRXJyb3I7XG5mdW5jdGlvbiBkZXRlY3RUeXBlKGIsIHR5cGUpIHtcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdqc29uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShiKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnanNvbicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdqc29uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG5sZXQgYWdlbnRzID0ge307XG5mdW5jdGlvbiBmZXRjaE5vZGUodXJsLCBfb3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zID0geyAuLi5ERUZBVUxUX09QVCwgLi4uX29wdGlvbnMgfTtcbiAgICBjb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbiAgICBjb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuICAgIGNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG4gICAgY29uc3QgeyByZXNvbHZlOiB1cmxSZXNvbHZlIH0gPSByZXF1aXJlKCd1cmwnKTtcbiAgICBjb25zdCBpc1NlY3VyZSA9ICEhL15odHRwcy8udGVzdCh1cmwpO1xuICAgIGxldCBvcHRzID0ge1xuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInIH0sXG4gICAgfTtcbiAgICBjb25zdCBjb21wYWN0RlAgPSAocykgPT4gcy5yZXBsYWNlKC86fCAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbnN0IGFnZW50T3B0ID0ge1xuICAgICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgICAga2VlcEFsaXZlTXNlY3M6IDMwICogMTAwMCxcbiAgICAgICAgICAgIG1heEZyZWVTb2NrZXRzOiAxMDI0LFxuICAgICAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnM6IDEwMjQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFnZW50S2V5ID0gW1xuICAgICAgICAgICAgaXNTZWN1cmUsXG4gICAgICAgICAgICBpc1NlY3VyZSAmJiBvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcz8ubWFwKChpKSA9PiBjb21wYWN0RlAoaSkpLnNvcnQoKSxcbiAgICAgICAgXS5qb2luKCk7XG4gICAgICAgIG9wdHMuYWdlbnQgPVxuICAgICAgICAgICAgYWdlbnRzW2FnZW50S2V5XSB8fCAoYWdlbnRzW2FnZW50S2V5XSA9IG5ldyAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLkFnZW50KGFnZW50T3B0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdqc29uJylcbiAgICAgICAgb3B0cy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXRob2QpXG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgb3B0cy5ib2R5ID0gb3B0aW9ucy50eXBlID09PSAnanNvbicgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpIDogb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBvcHRzLmhlYWRlcnMgPSB7IC4uLm9wdHMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgaWYgKG9wdGlvbnMuc3NsQWxsb3dTZWxmU2lnbmVkKVxuICAgICAgICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZVJlcyA9IGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0ICYmIDMwMCA8PSBzdGF0dXMgJiYgc3RhdHVzIDwgNDAwICYmIHJlcy5oZWFkZXJzWydsb2NhdGlvbiddKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5fcmVkaXJlY3RDb3VudCA9PSAxMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkLiBUb28gbXVjaCByZWRpcmVjdHMuJyk7XG4gICAgICAgICAgICBvcHRpb25zLl9yZWRpcmVjdENvdW50ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmV0Y2hOb2RlKHVybFJlc29sdmUodXJsLCByZXMuaGVhZGVyc1snbG9jYXRpb24nXSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUgJiYgc3RhdHVzICE9PSBvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZiA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlcylcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGNodW5rKTtcbiAgICAgICAgbGV0IGJ5dGVzID0gQnVmZmVyLmNvbmNhdChidWYpO1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2JyJylcbiAgICAgICAgICAgIGJ5dGVzID0gYXdhaXQgcHJvbWlzaWZ5KHpsaWIuYnJvdGxpRGVjb21wcmVzcykoYnl0ZXMpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdnemlwJyB8fCBlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKVxuICAgICAgICAgICAgYnl0ZXMgPSBhd2FpdCBwcm9taXNpZnkoemxpYi51bnppcCkoYnl0ZXMpO1xuICAgICAgICBjb25zdCBib2R5ID0gZGV0ZWN0VHlwZShieXRlcywgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHJlcy5oZWFkZXJzLCBzdGF0dXMsIGJvZHkgfTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdERVBUSF9aRVJPX1NFTEZfU0lHTkVEX0NFUlQnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2hOb2RlKHVybCwgeyAuLi5vcHRpb25zLCBzc2xBbGxvd1NlbGZTaWduZWQ6IHRydWUsIHNzbFBpbm5lZENlcnRpZmljYXRlczogW10gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUuZmluZ2VycHJpbnQyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBJbnZhbGlkQ2VydEVycm9yKGBTZWxmLXNpZ25lZCBTU0wgY2VydGlmaWNhdGU6ICR7ZS5maW5nZXJwcmludDI1Nn1gLCBlLmZpbmdlcnByaW50MjU2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXEgPSAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QodXJsLCBvcHRzLCAocmVzKSA9PiB7XG4gICAgICAgICAgICByZXMub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IGhhbmRsZVJlcyhyZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgIGNvbnN0IHBpbm5lZCA9IG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzPy5tYXAoKGkpID0+IGNvbXBhY3RGUChpKSk7XG4gICAgICAgIGNvbnN0IG1mZXRjaFNlY3VyZUNvbm5lY3QgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcDI1NiA9IGNvbXBhY3RGUChzb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk/LmZpbmdlcnByaW50MjU2IHx8ICcnKTtcbiAgICAgICAgICAgIGlmICghZnAyNTYgJiYgc29ja2V0LmlzU2Vzc2lvblJldXNlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwaW5uZWQuaW5jbHVkZXMoZnAyNTYpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJlcS5lbWl0KCdlcnJvcicsIG5ldyBJbnZhbGlkQ2VydEVycm9yKGBJbnZhbGlkIFNTTCBjZXJ0aWZpY2F0ZTogJHtmcDI1Nn0gRXhwZWN0ZWQ6ICR7cGlubmVkfWAsIGZwMjU2KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxLmFib3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcykge1xuICAgICAgICAgICAgcmVxLm9uKCdzb2NrZXQnLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTGlzdGVuZXJzID0gc29ja2V0XG4gICAgICAgICAgICAgICAgICAgIC5saXN0ZW5lcnMoJ3NlY3VyZUNvbm5lY3QnKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChpKSA9PiAoaS5uYW1lIHx8ICcnKS5yZXBsYWNlKCdib3VuZCAnLCAnJykpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcygnbWZldGNoU2VjdXJlQ29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oJ3NlY3VyZUNvbm5lY3QnLCBtZmV0Y2hTZWN1cmVDb25uZWN0LmJpbmQobnVsbCwgc29ja2V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUpXG4gICAgICAgICAgICByZXEuc2V0Tm9EZWxheSh0cnVlKTtcbiAgICAgICAgaWYgKG9wdHMuYm9keSlcbiAgICAgICAgICAgIHJlcS53cml0ZShvcHRzLmJvZHkpO1xuICAgICAgICByZXEuZW5kKCk7XG4gICAgfSk7XG59XG5jb25zdCBTQUZFX0hFQURFUlMgPSBuZXcgU2V0KFsnQWNjZXB0JywgJ0FjY2VwdC1MYW5ndWFnZScsICdDb250ZW50LUxhbmd1YWdlJywgJ0NvbnRlbnQtVHlwZSddLm1hcCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpKSk7XG5jb25zdCBGT1JCSURERU5fSEVBREVSUyA9IG5ldyBTZXQoWydBY2NlcHQtQ2hhcnNldCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJywgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kJyxcbiAgICAnQ29ubmVjdGlvbicsICdDb250ZW50LUxlbmd0aCcsICdDb29raWUnLCAnQ29va2llMicsICdEYXRlJywgJ0ROVCcsICdFeHBlY3QnLCAnSG9zdCcsICdLZWVwLUFsaXZlJywgJ09yaWdpbicsICdSZWZlcmVyJywgJ1RFJywgJ1RyYWlsZXInLFxuICAgICdUcmFuc2Zlci1FbmNvZGluZycsICdVcGdyYWRlJywgJ1ZpYSddLm1hcCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpKSk7XG5hc3luYyBmdW5jdGlvbiBmZXRjaEJyb3dzZXIodXJsLCBfb3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zID0geyAuLi5ERUZBVUxUX09QVCwgLi4uX29wdGlvbnMgfTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnanNvbicpXG4gICAgICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGxldCBwYXJzZWQgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHBhcnNlZC51c2VybmFtZSkge1xuICAgICAgICBjb25zdCBhdXRoID0gYnRvYShgJHtwYXJzZWQudXNlcm5hbWV9OiR7cGFyc2VkLnBhc3N3b3JkfWApO1xuICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2F1dGh9YCk7XG4gICAgICAgIHBhcnNlZC51c2VybmFtZSA9ICcnO1xuICAgICAgICBwYXJzZWQucGFzc3dvcmQgPSAnJztcbiAgICB9XG4gICAgdXJsID0gJycgKyBwYXJzZWQ7XG4gICAgZm9yIChsZXQgayBpbiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGsudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFNBRkVfSEVBREVSUy5oYXMobmFtZSkgfHwgKG9wdGlvbnMuY29ycyAmJiAhRk9SQklEREVOX0hFQURFUlMuaGFzKG5hbWUpKSlcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KGssIG9wdGlvbnMuaGVhZGVyc1trXSk7XG4gICAgfVxuICAgIGxldCBvcHRzID0geyBoZWFkZXJzLCByZWRpcmVjdDogb3B0aW9ucy5yZWRpcmVjdCA/ICdmb2xsb3cnIDogJ21hbnVhbCcgfTtcbiAgICBpZiAoIW9wdGlvbnMucmVmZXJyZXIpXG4gICAgICAgIG9wdHMucmVmZXJyZXJQb2xpY3kgPSAnbm8tcmVmZXJyZXInO1xuICAgIGlmIChvcHRpb25zLmNvcnMpXG4gICAgICAgIG9wdHMubW9kZSA9ICdjb3JzJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXRob2QpXG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgb3B0cy5ib2R5ID0gb3B0aW9ucy50eXBlID09PSAnanNvbicgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpIDogb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdHMpO1xuICAgIGlmIChvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUgJiYgcmVzLnN0YXR1cyAhPT0gb3B0aW9ucy5leHBlY3RTdGF0dXNDb2RlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXR1c0NvZGVFcnJvcihyZXMuc3RhdHVzKTtcbiAgICBjb25zdCBib2R5ID0gZGV0ZWN0VHlwZShuZXcgVWludDhBcnJheShhd2FpdCByZXMuYXJyYXlCdWZmZXIoKSksIG9wdGlvbnMudHlwZSk7XG4gICAgaWYgKG9wdGlvbnMuZnVsbClcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlcy5oZWFkZXJzLmVudHJpZXMoKSksIHN0YXR1czogcmVzLnN0YXR1cywgYm9keSB9O1xuICAgIHJldHVybiBib2R5O1xufVxuY29uc3QgSVNfTk9ERSA9ICEhKHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucyAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMudjgpO1xuZnVuY3Rpb24gZmV0Y2hVcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm4gPSBJU19OT0RFID8gZmV0Y2hOb2RlIDogZmV0Y2hCcm93c2VyO1xuICAgIHJldHVybiBmbih1cmwsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hVcmw7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkU3RhdHVzQ29kZUVycm9yIiwiSW52YWxpZENlcnRFcnJvciIsIkRFRkFVTFRfT1BUIiwiZnJlZXplIiwicmVkaXJlY3QiLCJleHBlY3RTdGF0dXNDb2RlIiwiaGVhZGVycyIsImZ1bGwiLCJrZWVwQWxpdmUiLCJjb3JzIiwicmVmZXJyZXIiLCJzc2xBbGxvd1NlbGZTaWduZWQiLCJfcmVkaXJlY3RDb3VudCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtc2ciLCJmaW5nZXJwcmludDI1NiIsInN0YXR1c0NvZGUiLCJkZXRlY3RUeXBlIiwiYiIsInR5cGUiLCJ0ZXh0IiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsIkpTT04iLCJwYXJzZSIsImVyciIsImFnZW50cyIsImZldGNoTm9kZSIsInVybCIsIl9vcHRpb25zIiwib3B0aW9ucyIsImh0dHAiLCJyZXF1aXJlIiwiaHR0cHMiLCJ6bGliIiwicHJvbWlzaWZ5IiwicmVzb2x2ZSIsInVybFJlc29sdmUiLCJpc1NlY3VyZSIsInRlc3QiLCJvcHRzIiwibWV0aG9kIiwiY29tcGFjdEZQIiwicyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImFnZW50T3B0Iiwia2VlcEFsaXZlTXNlY3MiLCJtYXhGcmVlU29ja2V0cyIsIm1heENhY2hlZFNlc3Npb25zIiwiYWdlbnRLZXkiLCJzc2xQaW5uZWRDZXJ0aWZpY2F0ZXMiLCJtYXAiLCJpIiwic29ydCIsImpvaW4iLCJhZ2VudCIsIkFnZW50IiwiZGF0YSIsImJvZHkiLCJzdHJpbmdpZnkiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJoYW5kbGVSZXMiLCJyZXMiLCJzdGF0dXMiLCJyZXN1bWUiLCJidWYiLCJjaHVuayIsInB1c2giLCJieXRlcyIsIkJ1ZmZlciIsImNvbmNhdCIsImVuY29kaW5nIiwiYnJvdGxpRGVjb21wcmVzcyIsInVuemlwIiwiUHJvbWlzZSIsInJlamVjdCIsImhhbmRsZUVycm9yIiwiY29kZSIsImUiLCJyZXEiLCJyZXF1ZXN0Iiwib24iLCJlcnJvciIsInBpbm5lZCIsIm1mZXRjaFNlY3VyZUNvbm5lY3QiLCJzb2NrZXQiLCJmcDI1NiIsImdldFBlZXJDZXJ0aWZpY2F0ZSIsImlzU2Vzc2lvblJldXNlZCIsImluY2x1ZGVzIiwiZW1pdCIsImFib3J0IiwiaGFzTGlzdGVuZXJzIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmQiLCJzZXROb0RlbGF5Iiwid3JpdGUiLCJlbmQiLCJTQUZFX0hFQURFUlMiLCJTZXQiLCJGT1JCSURERU5fSEVBREVSUyIsImZldGNoQnJvd3NlciIsIkhlYWRlcnMiLCJzZXQiLCJwYXJzZWQiLCJVUkwiLCJ1c2VybmFtZSIsImF1dGgiLCJidG9hIiwicGFzc3dvcmQiLCJrIiwiaGFzIiwicmVmZXJyZXJQb2xpY3kiLCJtb2RlIiwiZmV0Y2giLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJJU19OT0RFIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsInY4IiwiZmV0Y2hVcmwiLCJmbiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/micro-ftch/index.js\n");

/***/ })

};
;