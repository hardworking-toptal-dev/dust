"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/../node_modules/jotai/esm/react.mjs":
/*!*******************************************!*\
  !*** ../node_modules/jotai/esm/react.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/../node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozt1R0FDMEk7QUFDN0U7QUFFN0QsTUFBTVcsNkJBQWVWLG9EQUFhQSxDQUNoQyxLQUFLO0FBRVAsTUFBTVcsV0FBVyxDQUFDQztJQUNoQixNQUFNQyxRQUFRWixpREFBVUEsQ0FBQ1M7SUFDekIsT0FBTyxDQUFDRSxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRQyxLQUFLLEtBQUtBLFNBQVNMLDhEQUFlQTtBQUMvRTtBQUNBLE1BQU1NLFdBQVcsQ0FBQyxFQUNoQkMsUUFBUSxFQUNSRixLQUFLLEVBQ047SUFDQyxNQUFNRyxXQUFXZCw2Q0FBTUE7SUFDdkIsSUFBSSxDQUFDVyxTQUFTLENBQUNHLFNBQVNDLE9BQU8sRUFBRTtRQUMvQkQsU0FBU0MsT0FBTyxHQUFHUiwwREFBV0E7SUFDaEM7SUFDQSxxQkFBT04sb0RBQWFBLENBQ2xCTyxhQUFhSSxRQUFRLEVBQ3JCO1FBQ0VJLE9BQU9MLFNBQVNHLFNBQVNDLE9BQU87SUFDbEMsR0FDQUY7QUFFSjtBQUVBLE1BQU1JLGdCQUFnQixDQUFDQyxJQUFNLE9BQVFBLENBQUFBLEtBQUssT0FBTyxLQUFLLElBQUlBLEVBQUVDLElBQUksTUFBTTtBQUN0RSxNQUFNQyxNQUFNdkIsc0NBQWdCLElBQUssRUFBQ3dCO0lBQ2hDLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxXQUFXO1FBQ2hDLE1BQU1EO0lBQ1IsT0FBTyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssYUFBYTtRQUN6QyxPQUFPRCxRQUFRTCxLQUFLO0lBQ3RCLE9BQU8sSUFBSUssUUFBUUMsTUFBTSxLQUFLLFlBQVk7UUFDeEMsTUFBTUQsUUFBUUUsTUFBTTtJQUN0QixPQUFPO1FBQ0xGLFFBQVFDLE1BQU0sR0FBRztRQUNqQkQsUUFBUUYsSUFBSSxDQUNWLENBQUNLO1lBQ0NILFFBQVFDLE1BQU0sR0FBRztZQUNqQkQsUUFBUUwsS0FBSyxHQUFHUTtRQUNsQixHQUNBLENBQUNDO1lBQ0NKLFFBQVFDLE1BQU0sR0FBRztZQUNqQkQsUUFBUUUsTUFBTSxHQUFHRTtRQUNuQjtRQUVGLE1BQU1KO0lBQ1I7QUFDRjtBQUNBLFNBQVNLLGFBQWFDLElBQUksRUFBRWpCLE9BQU87SUFDakMsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTSxDQUFDLENBQUNrQixrQkFBa0JDLGtCQUFrQkMsZ0JBQWdCLEVBQUVDLFNBQVMsR0FBRzdCLGlEQUFVQSxDQUNsRixDQUFDOEI7UUFDQyxNQUFNQyxZQUFZdEIsTUFBTXVCLEdBQUcsQ0FBQ1A7UUFDNUIsSUFBSVEsT0FBT0MsRUFBRSxDQUFDSixJQUFJLENBQUMsRUFBRSxFQUFFQyxjQUFjRCxJQUFJLENBQUMsRUFBRSxLQUFLckIsU0FBU3FCLElBQUksQ0FBQyxFQUFFLEtBQUtMLE1BQU07WUFDMUUsT0FBT0s7UUFDVDtRQUNBLE9BQU87WUFBQ0M7WUFBV3RCO1lBQU9nQjtTQUFLO0lBQ2pDLEdBQ0EsS0FBSyxHQUNMLElBQU07WUFBQ2hCLE1BQU11QixHQUFHLENBQUNQO1lBQU9oQjtZQUFPZ0I7U0FBSztJQUV0QyxJQUFJWCxRQUFRWTtJQUNaLElBQUlDLHFCQUFxQmxCLFNBQVNtQixvQkFBb0JILE1BQU07UUFDMURJO1FBQ0FmLFFBQVFMLE1BQU11QixHQUFHLENBQUNQO0lBQ3BCO0lBQ0EsTUFBTVUsUUFBUTNCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVEyQixLQUFLO0lBQ3REbEMsZ0RBQVNBLENBQUM7UUFDUixNQUFNbUMsUUFBUTNCLE1BQU00QixHQUFHLENBQUNaLE1BQU07WUFDNUIsSUFBSSxPQUFPVSxVQUFVLFVBQVU7Z0JBQzdCRyxXQUFXVCxVQUFVTTtnQkFDckI7WUFDRjtZQUNBTjtRQUNGO1FBQ0FBO1FBQ0EsT0FBT087SUFDVCxHQUFHO1FBQUMzQjtRQUFPZ0I7UUFBTVU7S0FBTTtJQUN2QmpDLG9EQUFhQSxDQUFDWTtJQUNkLE9BQU9DLGNBQWNELFNBQVNJLElBQUlKLFNBQVNBO0FBQzdDO0FBRUEsU0FBU3lCLFdBQVdkLElBQUksRUFBRWpCLE9BQU87SUFDL0IsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTWdDLFVBQVVyQyxrREFBV0EsQ0FDekIsQ0FBQyxHQUFHc0M7UUFDRixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGdCQUFnQixDQUFFLFlBQVdoQixJQUFHLEdBQUk7WUFDNUYsTUFBTSxJQUFJbUIsTUFBTTtRQUNsQjtRQUNBLE9BQU9uQyxNQUFNb0MsR0FBRyxDQUFDcEIsU0FBU2dCO0lBQzVCLEdBQ0E7UUFBQ2hDO1FBQU9nQjtLQUFLO0lBRWYsT0FBT2U7QUFDVDtBQUVBLFNBQVNNLFFBQVFyQixJQUFJLEVBQUVqQixPQUFPO0lBQzVCLE9BQU87UUFDTGdCLGFBQWFDLE1BQU1qQjtRQUNuQix1RUFBdUU7UUFDdkUrQixXQUFXZCxNQUFNakI7S0FDbEI7QUFDSDtBQUVpRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcz8yODhkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdEV4cG9ydHMsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlUmVmLCBjcmVhdGVFbGVtZW50LCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIHVzZURlYnVnVmFsdWUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFN0b3JlLCBjcmVhdGVTdG9yZSB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEnO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFxuICB2b2lkIDBcbik7XG5jb25zdCB1c2VTdG9yZSA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmUpIHx8IHN0b3JlIHx8IGdldERlZmF1bHRTdG9yZSgpO1xufTtcbmNvbnN0IFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIHN0b3JlXG59KSA9PiB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlUmVmKCk7XG4gIGlmICghc3RvcmUgJiYgIXN0b3JlUmVmLmN1cnJlbnQpIHtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICBTdG9yZUNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHN0b3JlIHx8IHN0b3JlUmVmLmN1cnJlbnRcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59O1xuXG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpID0+IHR5cGVvZiAoeCA9PSBudWxsID8gdm9pZCAwIDogeC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgdXNlID0gUmVhY3RFeHBvcnRzLnVzZSB8fCAoKHByb21pc2UpID0+IHtcbiAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgIHRocm93IHByb21pc2U7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gIH0gZWxzZSB7XG4gICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAodikgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgfSxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59KTtcbmZ1bmN0aW9uIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUob3B0aW9ucyk7XG4gIGNvbnN0IFtbdmFsdWVGcm9tUmVkdWNlciwgc3RvcmVGcm9tUmVkdWNlciwgYXRvbUZyb21SZWR1Y2VyXSwgcmVyZW5kZXJdID0gdXNlUmVkdWNlcihcbiAgICAocHJldikgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICAgICAgaWYgKE9iamVjdC5pcyhwcmV2WzBdLCBuZXh0VmFsdWUpICYmIHByZXZbMV0gPT09IHN0b3JlICYmIHByZXZbMl0gPT09IGF0b20pIHtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25leHRWYWx1ZSwgc3RvcmUsIGF0b21dO1xuICAgIH0sXG4gICAgdm9pZCAwLFxuICAgICgpID0+IFtzdG9yZS5nZXQoYXRvbSksIHN0b3JlLCBhdG9tXVxuICApO1xuICBsZXQgdmFsdWUgPSB2YWx1ZUZyb21SZWR1Y2VyO1xuICBpZiAoc3RvcmVGcm9tUmVkdWNlciAhPT0gc3RvcmUgfHwgYXRvbUZyb21SZWR1Y2VyICE9PSBhdG9tKSB7XG4gICAgcmVyZW5kZXIoKTtcbiAgICB2YWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgfVxuICBjb25zdCBkZWxheSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVsYXk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWIoYXRvbSwgKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzZXRUaW1lb3V0KHJlcmVuZGVyLCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgfSk7XG4gICAgcmVyZW5kZXIoKTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH0sIFtzdG9yZSwgYXRvbSwgZGVsYXldKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiBpc1Byb21pc2VMaWtlKHZhbHVlKSA/IHVzZSh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUob3B0aW9ucyk7XG4gIGNvbnN0IHNldEF0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ3cml0ZVwiIGluIGF0b20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCB3cml0YWJsZSBhdG9tXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3JlLnNldChhdG9tLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIFtzdG9yZSwgYXRvbV1cbiAgKTtcbiAgcmV0dXJuIHNldEF0b207XG59XG5cbmZ1bmN0aW9uIHVzZUF0b20oYXRvbSwgb3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSxcbiAgICAvLyBXZSBkbyB3cm9uZyB0eXBlIGFzc2VydGlvbiBoZXJlLCB3aGljaCByZXN1bHRzIGluIHRocm93aW5nIGFuIGVycm9yLlxuICAgIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucylcbiAgXTtcbn1cblxuZXhwb3J0IHsgUHJvdmlkZXIsIHVzZUF0b20sIHVzZUF0b21WYWx1ZSwgdXNlU2V0QXRvbSwgdXNlU3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdEV4cG9ydHMiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWR1Y2VyIiwidXNlRWZmZWN0IiwidXNlRGVidWdWYWx1ZSIsInVzZUNhbGxiYWNrIiwiZ2V0RGVmYXVsdFN0b3JlIiwiY3JlYXRlU3RvcmUiLCJTdG9yZUNvbnRleHQiLCJ1c2VTdG9yZSIsIm9wdGlvbnMiLCJzdG9yZSIsIlByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdG9yZVJlZiIsImN1cnJlbnQiLCJ2YWx1ZSIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsInVzZSIsInByb21pc2UiLCJzdGF0dXMiLCJyZWFzb24iLCJ2IiwiZSIsInVzZUF0b21WYWx1ZSIsImF0b20iLCJ2YWx1ZUZyb21SZWR1Y2VyIiwic3RvcmVGcm9tUmVkdWNlciIsImF0b21Gcm9tUmVkdWNlciIsInJlcmVuZGVyIiwicHJldiIsIm5leHRWYWx1ZSIsImdldCIsIk9iamVjdCIsImlzIiwiZGVsYXkiLCJ1bnN1YiIsInN1YiIsInNldFRpbWVvdXQiLCJ1c2VTZXRBdG9tIiwic2V0QXRvbSIsImFyZ3MiLCJlbnYiLCJNT0RFIiwiRXJyb3IiLCJzZXQiLCJ1c2VBdG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/jotai/esm/vanilla.mjs":
/*!*********************************************!*\
  !*** ../node_modules/jotai/esm/vanilla.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString: ()=>key\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = defaultRead;\n        config.write = defaultWrite;\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nfunction defaultRead(get) {\n    return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n    return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nconst isSelfAtom = (atom, a)=>atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom)=>\"init\" in atom;\nconst isActuallyWritableAtom = (atom)=>!!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel)=>{\n    cancelPromiseMap.set(promise, cancel);\n    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next)=>{\n    const cancel = cancelPromiseMap.get(promise);\n    if (cancel) {\n        cancelPromiseMap.delete(promise);\n        cancel(next);\n    }\n};\nconst resolvePromise = (promise, value)=>{\n    promise.status = \"fulfilled\";\n    promise.value = value;\n};\nconst rejectPromise = (promise, e)=>{\n    promise.status = \"rejected\";\n    promise.reason = e;\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b)=>!!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b)=>!!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a)=>!!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b)=>\"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState)=>{\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    return atomState.v;\n};\nconst createStore$1 = ()=>{\n    const atomStateMap = /* @__PURE__ */ new WeakMap();\n    const mountedMap = /* @__PURE__ */ new WeakMap();\n    const pendingStack = [];\n    const pendingMap = /* @__PURE__ */ new WeakMap();\n    let devListenersRev2;\n    let mountedAtoms;\n    if (( false ? 0 : void 0) !== \"production\") {\n        devListenersRev2 = /* @__PURE__ */ new Set();\n        mountedAtoms = /* @__PURE__ */ new Set();\n    }\n    const getAtomState = (atom)=>atomStateMap.get(atom);\n    const addPendingDependent = (atom, atomState)=>{\n        atomState.d.forEach((_, a)=>{\n            if (!pendingMap.has(a)) {\n                const aState = getAtomState(a);\n                pendingMap.set(a, [\n                    aState,\n                    /* @__PURE__ */ new Set()\n                ]);\n                if (aState) {\n                    addPendingDependent(a, aState);\n                }\n            }\n            pendingMap.get(a)[1].add(atom);\n        });\n    };\n    const setAtomState = (atom, atomState)=>{\n        var _a;\n        if (( false ? 0 : void 0) !== \"production\") {\n            Object.freeze(atomState);\n        }\n        const prevAtomState = getAtomState(atom);\n        atomStateMap.set(atom, atomState);\n        (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n        if (!pendingMap.has(atom)) {\n            pendingMap.set(atom, [\n                prevAtomState,\n                /* @__PURE__ */ new Set()\n            ]);\n            addPendingDependent(atom, atomState);\n        }\n        if (hasPromiseAtomValue(prevAtomState)) {\n            const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n            if (prevAtomState.v !== next) {\n                cancelPromise(prevAtomState.v, next);\n            }\n        }\n    };\n    const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies)=>{\n        const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n        let changed = false;\n        nextDependencies.forEach((aState, a)=>{\n            if (!aState && isSelfAtom(atom, a)) {\n                aState = nextAtomState;\n            }\n            if (aState) {\n                dependencies.set(a, aState);\n                if (nextAtomState.d.get(a) !== aState) {\n                    changed = true;\n                }\n            } else if (( false ? 0 : void 0) !== \"production\") {\n                console.warn(\"[Bug] atom state not found\");\n            }\n        });\n        if (changed || nextAtomState.d.size !== dependencies.size) {\n            nextAtomState.d = dependencies;\n        }\n    };\n    const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            v: value\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n        }\n        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n            if (prevAtomState.d === nextAtomState.d) {\n                return prevAtomState;\n            } else {\n                nextAtomState.v = prevAtomState.v;\n            }\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{\n        if (isPromiseLike(valueOrPromise)) {\n            let continuePromise;\n            const updatePromiseDependencies = ()=>{\n                const prevAtomState = getAtomState(atom);\n                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n                    return;\n                }\n                const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n                    mountDependencies(atom, nextAtomState, prevAtomState.d);\n                }\n            };\n            const promise = new Promise((resolve, reject)=>{\n                let settled = false;\n                valueOrPromise.then((v)=>{\n                    if (!settled) {\n                        settled = true;\n                        resolvePromise(promise, v);\n                        resolve(v);\n                        updatePromiseDependencies();\n                    }\n                }, (e)=>{\n                    if (!settled) {\n                        settled = true;\n                        rejectPromise(promise, e);\n                        reject(e);\n                        updatePromiseDependencies();\n                    }\n                });\n                continuePromise = (next)=>{\n                    if (!settled) {\n                        settled = true;\n                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));\n                        resolve(next);\n                    }\n                };\n            });\n            promise.orig = valueOrPromise;\n            promise.status = \"pending\";\n            registerCancelPromise(promise, (next)=>{\n                if (next) {\n                    continuePromise(next);\n                }\n                abortPromise == null ? void 0 : abortPromise();\n            });\n            return setAtomValue(atom, promise, nextDependencies, true);\n        }\n        return setAtomValue(atom, valueOrPromise, nextDependencies);\n    };\n    const setAtomError = (atom, error, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            e: error\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const readAtomState = (atom, force)=>{\n        const atomState = getAtomState(atom);\n        if (!(force == null ? void 0 : force(atom)) && atomState) {\n            if (mountedMap.has(atom)) {\n                return atomState;\n            }\n            if (Array.from(atomState.d).every(([a, s])=>{\n                if (a === atom) {\n                    return true;\n                }\n                const aState = readAtomState(a, force);\n                return aState === s || isEqualAtomValue(aState, s);\n            })) {\n                return atomState;\n            }\n        }\n        const nextDependencies = /* @__PURE__ */ new Map();\n        let isSync = true;\n        const getter = (a)=>{\n            if (isSelfAtom(atom, a)) {\n                const aState2 = getAtomState(a);\n                if (aState2) {\n                    nextDependencies.set(a, aState2);\n                    return returnAtomValue(aState2);\n                }\n                if (hasInitialValue(a)) {\n                    nextDependencies.set(a, void 0);\n                    return a.init;\n                }\n                throw new Error(\"no atom init\");\n            }\n            const aState = readAtomState(a, force);\n            nextDependencies.set(a, aState);\n            return returnAtomValue(aState);\n        };\n        let controller;\n        let setSelf;\n        const options = {\n            get signal () {\n                if (!controller) {\n                    controller = new AbortController();\n                }\n                return controller.signal;\n            },\n            get setSelf () {\n                if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                    console.warn(\"setSelf function cannot be used with read-only atom\");\n                }\n                if (!setSelf && isActuallyWritableAtom(atom)) {\n                    setSelf = (...args)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                            console.warn(\"setSelf function cannot be called in sync\");\n                        }\n                        if (!isSync) {\n                            return writeAtom(atom, ...args);\n                        }\n                    };\n                }\n                return setSelf;\n            }\n        };\n        try {\n            const valueOrPromise = atom.read(getter, options);\n            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());\n        } catch (error) {\n            return setAtomError(atom, error, nextDependencies);\n        } finally{\n            isSync = false;\n        }\n    };\n    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));\n    const recomputeDependents = (atom)=>{\n        const getDependents = (a)=>{\n            var _a, _b;\n            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n            (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent)=>{\n                dependents.add(dependent);\n            });\n            return dependents;\n        };\n        const topsortedAtoms = new Array();\n        const markedAtoms = /* @__PURE__ */ new Set();\n        const visit = (n)=>{\n            if (markedAtoms.has(n)) {\n                return;\n            }\n            markedAtoms.add(n);\n            for (const m of getDependents(n)){\n                if (n !== m) {\n                    visit(m);\n                }\n            }\n            topsortedAtoms.push(n);\n        };\n        visit(atom);\n        const changedAtoms = /* @__PURE__ */ new Set([\n            atom\n        ]);\n        const isMarked = (a)=>markedAtoms.has(a);\n        for(let i = topsortedAtoms.length - 1; i >= 0; --i){\n            const a = topsortedAtoms[i];\n            const prevAtomState = getAtomState(a);\n            if (!prevAtomState) {\n                continue;\n            }\n            let hasChangedDeps = false;\n            for (const dep of prevAtomState.d.keys()){\n                if (dep !== a && changedAtoms.has(dep)) {\n                    hasChangedDeps = true;\n                    break;\n                }\n            }\n            if (hasChangedDeps) {\n                const nextAtomState = readAtomState(a, isMarked);\n                addPendingDependent(a, nextAtomState);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    changedAtoms.add(a);\n                }\n            }\n            markedAtoms.delete(a);\n        }\n    };\n    const writeAtomState = (atom, ...args)=>{\n        const getter = (a)=>returnAtomValue(readAtomState(a));\n        const setter = (a, ...args2)=>{\n            const isSync = pendingStack.length > 0;\n            if (!isSync) {\n                pendingStack.push(/* @__PURE__ */ new Set([\n                    a\n                ]));\n            }\n            let r;\n            if (isSelfAtom(atom, a)) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                const prevAtomState = getAtomState(a);\n                const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    recomputeDependents(a);\n                }\n            } else {\n                r = writeAtomState(a, ...args2);\n            }\n            if (!isSync) {\n                const flushed = flushPending(pendingStack.pop());\n                if (( false ? 0 : void 0) !== \"production\") {\n                    devListenersRev2.forEach((l)=>l({\n                            type: \"async-write\",\n                            flushed\n                        }));\n                }\n            }\n            return r;\n        };\n        const result = atom.write(getter, setter, ...args);\n        return result;\n    };\n    const writeAtom = (atom, ...args)=>{\n        pendingStack.push(/* @__PURE__ */ new Set([\n            atom\n        ]));\n        const result = writeAtomState(atom, ...args);\n        const flushed = flushPending(pendingStack.pop());\n        if (( false ? 0 : void 0) !== \"production\") {\n            devListenersRev2.forEach((l)=>l({\n                    type: \"write\",\n                    flushed\n                }));\n        }\n        return result;\n    };\n    const mountAtom = (atom, initialDependent, onMountQueue)=>{\n        var _a;\n        const existingMount = mountedMap.get(atom);\n        if (existingMount) {\n            if (initialDependent) {\n                existingMount.t.add(initialDependent);\n            }\n            return existingMount;\n        }\n        const queue = onMountQueue || [];\n        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{\n            if (a !== atom) {\n                mountAtom(a, atom, queue);\n            }\n        });\n        readAtomState(atom);\n        const mounted = {\n            t: new Set(initialDependent && [\n                initialDependent\n            ]),\n            l: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.add(atom);\n        }\n        if (isActuallyWritableAtom(atom) && atom.onMount) {\n            const { onMount } = atom;\n            queue.push(()=>{\n                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));\n                if (onUnmount) {\n                    mounted.u = onUnmount;\n                }\n            });\n        }\n        if (!onMountQueue) {\n            queue.forEach((f)=>f());\n        }\n        return mounted;\n    };\n    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n    const tryUnmountAtom = (atom, mounted)=>{\n        if (!canUnmountAtom(atom, mounted)) {\n            return;\n        }\n        const onUnmount = mounted.u;\n        if (onUnmount) {\n            onUnmount();\n        }\n        mountedMap.delete(atom);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.delete(atom);\n        }\n        const atomState = getAtomState(atom);\n        if (atomState) {\n            if (hasPromiseAtomValue(atomState)) {\n                cancelPromise(atomState.v);\n            }\n            atomState.d.forEach((_, a)=>{\n                if (a !== atom) {\n                    const mountedDep = mountedMap.get(a);\n                    if (mountedDep) {\n                        mountedDep.t.delete(atom);\n                        tryUnmountAtom(a, mountedDep);\n                    }\n                }\n            });\n        } else if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[Bug] could not find atom state to unmount\", atom);\n        }\n    };\n    const mountDependencies = (atom, atomState, prevDependencies)=>{\n        const depSet = new Set(atomState.d.keys());\n        const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{\n            if (depSet.has(a)) {\n                depSet.delete(a);\n                return;\n            }\n            maybeUnmountAtomSet.add(a);\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.delete(atom);\n            }\n        });\n        depSet.forEach((a)=>{\n            mountAtom(a, atom);\n        });\n        maybeUnmountAtomSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                tryUnmountAtom(a, mounted);\n            }\n        });\n    };\n    const flushPending = (pendingAtoms)=>{\n        let flushed;\n        if (( false ? 0 : void 0) !== \"production\") {\n            flushed = /* @__PURE__ */ new Set();\n        }\n        const pending = [];\n        const collectPending = (pendingAtom)=>{\n            var _a;\n            if (!pendingMap.has(pendingAtom)) {\n                return;\n            }\n            const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n            pendingMap.delete(pendingAtom);\n            pending.push([\n                pendingAtom,\n                prevAtomState\n            ]);\n            dependents.forEach(collectPending);\n            (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a)=>collectPending(a));\n        };\n        pendingAtoms.forEach(collectPending);\n        pending.forEach(([atom, prevAtomState])=>{\n            const atomState = getAtomState(atom);\n            if (!atomState) {\n                if (( false ? 0 : void 0) !== \"production\") {\n                    console.warn(\"[Bug] no atom state to flush\");\n                }\n                return;\n            }\n            if (atomState !== prevAtomState) {\n                const mounted = mountedMap.get(atom);\n                if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n                    mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n                }\n                if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?\n                (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n                    mounted.l.forEach((listener)=>listener());\n                    if (( false ? 0 : void 0) !== \"production\") {\n                        flushed.add(atom);\n                    }\n                }\n            }\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            return flushed;\n        }\n    };\n    const subscribeAtom = (atom, listener)=>{\n        const mounted = mountAtom(atom);\n        const flushed = flushPending([\n            atom\n        ]);\n        const listeners = mounted.l;\n        listeners.add(listener);\n        if (( false ? 0 : void 0) !== \"production\") {\n            devListenersRev2.forEach((l)=>l({\n                    type: \"sub\",\n                    flushed\n                }));\n        }\n        return ()=>{\n            listeners.delete(listener);\n            tryUnmountAtom(atom, mounted);\n            if (( false ? 0 : void 0) !== \"production\") {\n                devListenersRev2.forEach((l)=>l({\n                        type: \"unsub\"\n                    }));\n            }\n        };\n    };\n    if (( false ? 0 : void 0) !== \"production\") {\n        return {\n            get: readAtom,\n            set: writeAtom,\n            sub: subscribeAtom,\n            // store dev methods (these are tentative and subject to change without notice)\n            dev_subscribe_store: (l)=>{\n                devListenersRev2.add(l);\n                return ()=>{\n                    devListenersRev2.delete(l);\n                };\n            },\n            dev_get_mounted_atoms: ()=>mountedAtoms.values(),\n            dev_get_atom_state: (a)=>atomStateMap.get(a),\n            dev_get_mounted: (a)=>mountedMap.get(a),\n            dev_restore_atoms: (values)=>{\n                pendingStack.push(/* @__PURE__ */ new Set());\n                for (const [atom, valueOrPromise] of values){\n                    if (hasInitialValue(atom)) {\n                        setAtomValueOrPromise(atom, valueOrPromise);\n                        recomputeDependents(atom);\n                    }\n                }\n                const flushed = flushPending(pendingStack.pop());\n                devListenersRev2.forEach((l)=>l({\n                        type: \"restore\",\n                        flushed\n                    }));\n            }\n        };\n    }\n    return {\n        get: readAtom,\n        set: writeAtom,\n        sub: subscribeAtom\n    };\n};\nlet defaultStore;\nconst getDefaultStore$1 = ()=>{\n    if (!defaultStore) {\n        defaultStore = createStore$1();\n        if (( false ? 0 : void 0) !== \"production\") {\n            globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n            if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n                console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n            }\n        }\n    }\n    return defaultStore;\n};\nSymbol(( false ? 0 : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\");\nconst createStore = createStore$1;\nconst getDefaultStore = getDefaultStore$1;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFJQSxXQUFXO0FBQ2YsU0FBU0MsS0FBS0MsSUFBSSxFQUFFQyxLQUFLO0lBQ3ZCLE1BQU1DLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRUosU0FBUyxDQUFDO0lBQy9CLE1BQU1LLFNBQVM7UUFDYkMsVUFBVSxJQUFNRjtJQUNsQjtJQUNBLElBQUksT0FBT0YsU0FBUyxZQUFZO1FBQzlCRyxPQUFPSCxJQUFJLEdBQUdBO0lBQ2hCLE9BQU87UUFDTEcsT0FBT0UsSUFBSSxHQUFHTDtRQUNkRyxPQUFPSCxJQUFJLEdBQUdNO1FBQ2RILE9BQU9GLEtBQUssR0FBR007SUFDakI7SUFDQSxJQUFJTixPQUFPO1FBQ1RFLE9BQU9GLEtBQUssR0FBR0E7SUFDakI7SUFDQSxPQUFPRTtBQUNUO0FBQ0EsU0FBU0csWUFBWUUsR0FBRztJQUN0QixPQUFPQSxJQUFJLElBQUk7QUFDakI7QUFDQSxTQUFTRCxhQUFhQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUNqQyxPQUFPRCxJQUNMLElBQUksRUFDSixPQUFPQyxRQUFRLGFBQWFBLElBQUlGLElBQUksSUFBSSxLQUFLRTtBQUVqRDtBQUVBLE1BQU1DLGFBQWEsQ0FBQ1osTUFBTWEsSUFBTWIsS0FBS2MsV0FBVyxHQUFHZCxLQUFLYyxXQUFXLENBQUNELEtBQUtBLE1BQU1iO0FBQy9FLE1BQU1lLGtCQUFrQixDQUFDZixPQUFTLFVBQVVBO0FBQzVDLE1BQU1nQix5QkFBeUIsQ0FBQ2hCLE9BQVMsQ0FBQyxDQUFDQSxLQUFLRSxLQUFLO0FBQ3JELE1BQU1lLG1CQUFtQixhQUFhLEdBQUcsSUFBSUM7QUFDN0MsTUFBTUMsd0JBQXdCLENBQUNDLFNBQVNDO0lBQ3RDSixpQkFBaUJQLEdBQUcsQ0FBQ1UsU0FBU0M7SUFDOUJELFFBQVFFLEtBQUssQ0FBQyxLQUNkLEdBQUdDLE9BQU8sQ0FBQyxJQUFNTixpQkFBaUJPLE1BQU0sQ0FBQ0o7QUFDM0M7QUFDQSxNQUFNSyxnQkFBZ0IsQ0FBQ0wsU0FBU007SUFDOUIsTUFBTUwsU0FBU0osaUJBQWlCUixHQUFHLENBQUNXO0lBQ3BDLElBQUlDLFFBQVE7UUFDVkosaUJBQWlCTyxNQUFNLENBQUNKO1FBQ3hCQyxPQUFPSztJQUNUO0FBQ0Y7QUFDQSxNQUFNQyxpQkFBaUIsQ0FBQ1AsU0FBU1E7SUFDL0JSLFFBQVFTLE1BQU0sR0FBRztJQUNqQlQsUUFBUVEsS0FBSyxHQUFHQTtBQUNsQjtBQUNBLE1BQU1FLGdCQUFnQixDQUFDVixTQUFTVztJQUM5QlgsUUFBUVMsTUFBTSxHQUFHO0lBQ2pCVCxRQUFRWSxNQUFNLEdBQUdEO0FBQ25CO0FBQ0EsTUFBTUUsZ0JBQWdCLENBQUNDLElBQU0sT0FBUUEsQ0FBQUEsS0FBSyxPQUFPLEtBQUssSUFBSUEsRUFBRUMsSUFBSSxNQUFNO0FBQ3RFLE1BQU1DLG1CQUFtQixDQUFDdkIsR0FBR3dCLElBQU0sQ0FBQyxDQUFDeEIsS0FBSyxPQUFPQSxLQUFLLE9BQU93QixLQUFLQyxPQUFPQyxFQUFFLENBQUMxQixFQUFFMkIsQ0FBQyxFQUFFSCxFQUFFRyxDQUFDO0FBQ3BGLE1BQU1DLG1CQUFtQixDQUFDNUIsR0FBR3dCLElBQU0sQ0FBQyxDQUFDeEIsS0FBSyxPQUFPQSxLQUFLLE9BQU93QixLQUFLQyxPQUFPQyxFQUFFLENBQUMxQixFQUFFa0IsQ0FBQyxFQUFFTSxFQUFFTixDQUFDO0FBQ3BGLE1BQU1XLHNCQUFzQixDQUFDN0IsSUFBTSxDQUFDLENBQUNBLEtBQUssT0FBT0EsS0FBS0EsRUFBRTJCLENBQUMsWUFBWUc7QUFDckUsTUFBTUMsMEJBQTBCLENBQUMvQixHQUFHd0IsSUFBTSxPQUFPeEIsS0FBSyxPQUFPd0IsS0FBS3hCLEVBQUUyQixDQUFDLENBQUNLLElBQUksSUFBSWhDLEVBQUUyQixDQUFDLENBQUNLLElBQUksS0FBS1IsRUFBRUcsQ0FBQyxDQUFDSyxJQUFJO0FBQ25HLE1BQU1DLGtCQUFrQixDQUFDQztJQUN2QixJQUFJLE9BQU9BLFdBQVc7UUFDcEIsTUFBTUEsVUFBVWhCLENBQUM7SUFDbkI7SUFDQSxPQUFPZ0IsVUFBVVAsQ0FBQztBQUNwQjtBQUNBLE1BQU1RLGdCQUFnQjtJQUNwQixNQUFNQyxlQUFlLGFBQWEsR0FBRyxJQUFJL0I7SUFDekMsTUFBTWdDLGFBQWEsYUFBYSxHQUFHLElBQUloQztJQUN2QyxNQUFNaUMsZUFBZSxFQUFFO0lBQ3ZCLE1BQU1DLGFBQWEsYUFBYSxHQUFHLElBQUlsQztJQUN2QyxJQUFJbUM7SUFDSixJQUFJQztJQUNKLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztRQUN0RUQsbUJBQW1CLGFBQWEsR0FBRyxJQUFJSTtRQUN2Q0gsZUFBZSxhQUFhLEdBQUcsSUFBSUc7SUFDckM7SUFDQSxNQUFNQyxlQUFlLENBQUMxRCxPQUFTaUQsYUFBYXhDLEdBQUcsQ0FBQ1Q7SUFDaEQsTUFBTTJELHNCQUFzQixDQUFDM0QsTUFBTStDO1FBQ2pDQSxVQUFVYSxDQUFDLENBQUNDLE9BQU8sQ0FBQyxDQUFDQyxHQUFHakQ7WUFDdEIsSUFBSSxDQUFDdUMsV0FBV1csR0FBRyxDQUFDbEQsSUFBSTtnQkFDdEIsTUFBTW1ELFNBQVNOLGFBQWE3QztnQkFDNUJ1QyxXQUFXMUMsR0FBRyxDQUFDRyxHQUFHO29CQUFDbUQ7b0JBQVEsYUFBYSxHQUFHLElBQUlQO2lCQUFNO2dCQUNyRCxJQUFJTyxRQUFRO29CQUNWTCxvQkFBb0I5QyxHQUFHbUQ7Z0JBQ3pCO1lBQ0Y7WUFDQVosV0FBVzNDLEdBQUcsQ0FBQ0ksRUFBRSxDQUFDLEVBQUUsQ0FBQ29ELEdBQUcsQ0FBQ2pFO1FBQzNCO0lBQ0Y7SUFDQSxNQUFNa0UsZUFBZSxDQUFDbEUsTUFBTStDO1FBQzFCLElBQUlvQjtRQUNKLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztZQUN0RTdCLE9BQU84QixNQUFNLENBQUNyQjtRQUNoQjtRQUNBLE1BQU1zQixnQkFBZ0JYLGFBQWExRDtRQUNuQ2lELGFBQWF2QyxHQUFHLENBQUNWLE1BQU0rQztRQUN0Qm9CLENBQUFBLEtBQUtoQixZQUFZLENBQUNBLGFBQWFtQixNQUFNLEdBQUcsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJSCxHQUFHRixHQUFHLENBQUNqRTtRQUN2RSxJQUFJLENBQUNvRCxXQUFXVyxHQUFHLENBQUMvRCxPQUFPO1lBQ3pCb0QsV0FBVzFDLEdBQUcsQ0FBQ1YsTUFBTTtnQkFBQ3FFO2dCQUFlLGFBQWEsR0FBRyxJQUFJWjthQUFNO1lBQy9ERSxvQkFBb0IzRCxNQUFNK0M7UUFDNUI7UUFDQSxJQUFJTCxvQkFBb0IyQixnQkFBZ0I7WUFDdEMsTUFBTTNDLE9BQU8sT0FBT3FCLFlBQVlBLFVBQVVQLENBQUMsWUFBWUcsVUFBVUksVUFBVVAsQ0FBQyxHQUFHRyxRQUFRNEIsT0FBTyxDQUFDeEIsVUFBVVAsQ0FBQyxJQUFJRyxRQUFRNkIsTUFBTSxDQUFDekIsVUFBVWhCLENBQUM7WUFDeEksSUFBSXNDLGNBQWM3QixDQUFDLEtBQUtkLE1BQU07Z0JBQzVCRCxjQUFjNEMsY0FBYzdCLENBQUMsRUFBRWQ7WUFDakM7UUFDRjtJQUNGO0lBQ0EsTUFBTStDLHFCQUFxQixDQUFDekUsTUFBTTBFLGVBQWVDLGtCQUFrQkM7UUFDakUsTUFBTUMsZUFBZSxJQUFJQyxJQUN2QkYsMkJBQTJCRixjQUFjZCxDQUFDLEdBQUc7UUFFL0MsSUFBSW1CLFVBQVU7UUFDZEosaUJBQWlCZCxPQUFPLENBQUMsQ0FBQ0csUUFBUW5EO1lBQ2hDLElBQUksQ0FBQ21ELFVBQVVwRCxXQUFXWixNQUFNYSxJQUFJO2dCQUNsQ21ELFNBQVNVO1lBQ1g7WUFDQSxJQUFJVixRQUFRO2dCQUNWYSxhQUFhbkUsR0FBRyxDQUFDRyxHQUFHbUQ7Z0JBQ3BCLElBQUlVLGNBQWNkLENBQUMsQ0FBQ25ELEdBQUcsQ0FBQ0ksT0FBT21ELFFBQVE7b0JBQ3JDZSxVQUFVO2dCQUNaO1lBQ0YsT0FBTyxJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7Z0JBQzdFQyxRQUFRQyxJQUFJLENBQUM7WUFDZjtRQUNGO1FBQ0EsSUFBSUYsV0FBV0wsY0FBY2QsQ0FBQyxDQUFDc0IsSUFBSSxLQUFLTCxhQUFhSyxJQUFJLEVBQUU7WUFDekRSLGNBQWNkLENBQUMsR0FBR2lCO1FBQ3BCO0lBQ0Y7SUFDQSxNQUFNTSxlQUFlLENBQUNuRixNQUFNNEIsT0FBTytDLGtCQUFrQkM7UUFDbkQsTUFBTVAsZ0JBQWdCWCxhQUFhMUQ7UUFDbkMsTUFBTTBFLGdCQUFnQjtZQUNwQmQsR0FBRyxDQUFDUyxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWNULENBQUMsS0FBSyxhQUFhLEdBQUcsSUFBSWtCO1lBQzdFdEMsR0FBR1o7UUFDTDtRQUNBLElBQUkrQyxrQkFBa0I7WUFDcEJGLG1CQUNFekUsTUFDQTBFLGVBQ0FDLGtCQUNBQztRQUVKO1FBQ0EsSUFBSXhDLGlCQUFpQmlDLGVBQWVLLGtCQUFrQkwsY0FBY1QsQ0FBQyxLQUFLYyxjQUFjZCxDQUFDLEVBQUU7WUFDekYsT0FBT1M7UUFDVDtRQUNBLElBQUkzQixvQkFBb0IyQixrQkFBa0IzQixvQkFBb0JnQyxrQkFBa0I5Qix3QkFBd0J5QixlQUFlSyxnQkFBZ0I7WUFDckksSUFBSUwsY0FBY1QsQ0FBQyxLQUFLYyxjQUFjZCxDQUFDLEVBQUU7Z0JBQ3ZDLE9BQU9TO1lBQ1QsT0FBTztnQkFDTEssY0FBY2xDLENBQUMsR0FBRzZCLGNBQWM3QixDQUFDO1lBQ25DO1FBQ0Y7UUFDQTBCLGFBQWFsRSxNQUFNMEU7UUFDbkIsT0FBT0E7SUFDVDtJQUNBLE1BQU1VLHdCQUF3QixDQUFDcEYsTUFBTXFGLGdCQUFnQlYsa0JBQWtCVztRQUNyRSxJQUFJckQsY0FBY29ELGlCQUFpQjtZQUNqQyxJQUFJRTtZQUNKLE1BQU1DLDRCQUE0QjtnQkFDaEMsTUFBTW5CLGdCQUFnQlgsYUFBYTFEO2dCQUNuQyxJQUFJLENBQUMwQyxvQkFBb0IyQixrQkFBa0JBLGNBQWM3QixDQUFDLEtBQUtwQixTQUFTO29CQUN0RTtnQkFDRjtnQkFDQSxNQUFNc0QsZ0JBQWdCUyxhQUNwQm5GLE1BQ0FvQixTQUNBdUQ7Z0JBRUYsSUFBSXpCLFdBQVdhLEdBQUcsQ0FBQy9ELFNBQVNxRSxjQUFjVCxDQUFDLEtBQUtjLGNBQWNkLENBQUMsRUFBRTtvQkFDL0Q2QixrQkFBa0J6RixNQUFNMEUsZUFBZUwsY0FBY1QsQ0FBQztnQkFDeEQ7WUFDRjtZQUNBLE1BQU14QyxVQUFVLElBQUl1QixRQUFRLENBQUM0QixTQUFTQztnQkFDcEMsSUFBSWtCLFVBQVU7Z0JBQ2RMLGVBQWVsRCxJQUFJLENBQ2pCLENBQUNLO29CQUNDLElBQUksQ0FBQ2tELFNBQVM7d0JBQ1pBLFVBQVU7d0JBQ1YvRCxlQUFlUCxTQUFTb0I7d0JBQ3hCK0IsUUFBUS9CO3dCQUNSZ0Q7b0JBQ0Y7Z0JBQ0YsR0FDQSxDQUFDekQ7b0JBQ0MsSUFBSSxDQUFDMkQsU0FBUzt3QkFDWkEsVUFBVTt3QkFDVjVELGNBQWNWLFNBQVNXO3dCQUN2QnlDLE9BQU96Qzt3QkFDUHlEO29CQUNGO2dCQUNGO2dCQUVGRCxrQkFBa0IsQ0FBQzdEO29CQUNqQixJQUFJLENBQUNnRSxTQUFTO3dCQUNaQSxVQUFVO3dCQUNWaEUsS0FBS1MsSUFBSSxDQUNQLENBQUNLLElBQU1iLGVBQWVQLFNBQVNvQixJQUMvQixDQUFDVCxJQUFNRCxjQUFjVixTQUFTVzt3QkFFaEN3QyxRQUFRN0M7b0JBQ1Y7Z0JBQ0Y7WUFDRjtZQUNBTixRQUFReUIsSUFBSSxHQUFHd0M7WUFDZmpFLFFBQVFTLE1BQU0sR0FBRztZQUNqQlYsc0JBQXNCQyxTQUFTLENBQUNNO2dCQUM5QixJQUFJQSxNQUFNO29CQUNSNkQsZ0JBQWdCN0Q7Z0JBQ2xCO2dCQUNBNEQsZ0JBQWdCLE9BQU8sS0FBSyxJQUFJQTtZQUNsQztZQUNBLE9BQU9ILGFBQWFuRixNQUFNb0IsU0FBU3VELGtCQUFrQjtRQUN2RDtRQUNBLE9BQU9RLGFBQWFuRixNQUFNcUYsZ0JBQWdCVjtJQUM1QztJQUNBLE1BQU1nQixlQUFlLENBQUMzRixNQUFNNEYsT0FBT2pCO1FBQ2pDLE1BQU1OLGdCQUFnQlgsYUFBYTFEO1FBQ25DLE1BQU0wRSxnQkFBZ0I7WUFDcEJkLEdBQUcsQ0FBQ1MsaUJBQWlCLE9BQU8sS0FBSyxJQUFJQSxjQUFjVCxDQUFDLEtBQUssYUFBYSxHQUFHLElBQUlrQjtZQUM3RS9DLEdBQUc2RDtRQUNMO1FBQ0EsSUFBSWpCLGtCQUFrQjtZQUNwQkYsbUJBQW1CekUsTUFBTTBFLGVBQWVDO1FBQzFDO1FBQ0EsSUFBSWxDLGlCQUFpQjRCLGVBQWVLLGtCQUFrQkwsY0FBY1QsQ0FBQyxLQUFLYyxjQUFjZCxDQUFDLEVBQUU7WUFDekYsT0FBT1M7UUFDVDtRQUNBSCxhQUFhbEUsTUFBTTBFO1FBQ25CLE9BQU9BO0lBQ1Q7SUFDQSxNQUFNbUIsZ0JBQWdCLENBQUM3RixNQUFNOEY7UUFDM0IsTUFBTS9DLFlBQVlXLGFBQWExRDtRQUMvQixJQUFJLENBQUU4RixDQUFBQSxTQUFTLE9BQU8sS0FBSyxJQUFJQSxNQUFNOUYsS0FBSSxLQUFNK0MsV0FBVztZQUN4RCxJQUFJRyxXQUFXYSxHQUFHLENBQUMvRCxPQUFPO2dCQUN4QixPQUFPK0M7WUFDVDtZQUNBLElBQUlnRCxNQUFNQyxJQUFJLENBQUNqRCxVQUFVYSxDQUFDLEVBQUVxQyxLQUFLLENBQUMsQ0FBQyxDQUFDcEYsR0FBR3FGLEVBQUU7Z0JBQ3ZDLElBQUlyRixNQUFNYixNQUFNO29CQUNkLE9BQU87Z0JBQ1Q7Z0JBQ0EsTUFBTWdFLFNBQVM2QixjQUFjaEYsR0FBR2lGO2dCQUNoQyxPQUFPOUIsV0FBV2tDLEtBQUs5RCxpQkFBaUI0QixRQUFRa0M7WUFDbEQsSUFBSTtnQkFDRixPQUFPbkQ7WUFDVDtRQUNGO1FBQ0EsTUFBTTRCLG1CQUFtQixhQUFhLEdBQUcsSUFBSUc7UUFDN0MsSUFBSXFCLFNBQVM7UUFDYixNQUFNQyxTQUFTLENBQUN2RjtZQUNkLElBQUlELFdBQVdaLE1BQU1hLElBQUk7Z0JBQ3ZCLE1BQU13RixVQUFVM0MsYUFBYTdDO2dCQUM3QixJQUFJd0YsU0FBUztvQkFDWDFCLGlCQUFpQmpFLEdBQUcsQ0FBQ0csR0FBR3dGO29CQUN4QixPQUFPdkQsZ0JBQWdCdUQ7Z0JBQ3pCO2dCQUNBLElBQUl0RixnQkFBZ0JGLElBQUk7b0JBQ3RCOEQsaUJBQWlCakUsR0FBRyxDQUFDRyxHQUFHLEtBQUs7b0JBQzdCLE9BQU9BLEVBQUVQLElBQUk7Z0JBQ2Y7Z0JBQ0EsTUFBTSxJQUFJZ0csTUFBTTtZQUNsQjtZQUNBLE1BQU10QyxTQUFTNkIsY0FBY2hGLEdBQUdpRjtZQUNoQ25CLGlCQUFpQmpFLEdBQUcsQ0FBQ0csR0FBR21EO1lBQ3hCLE9BQU9sQixnQkFBZ0JrQjtRQUN6QjtRQUNBLElBQUl1QztRQUNKLElBQUlDO1FBQ0osTUFBTUMsVUFBVTtZQUNkLElBQUlDLFVBQVM7Z0JBQ1gsSUFBSSxDQUFDSCxZQUFZO29CQUNmQSxhQUFhLElBQUlJO2dCQUNuQjtnQkFDQSxPQUFPSixXQUFXRyxNQUFNO1lBQzFCO1lBQ0EsSUFBSUYsV0FBVTtnQkFDWixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGdCQUFnQixDQUFDeEYsdUJBQXVCaEIsT0FBTztvQkFDdkdnRixRQUFRQyxJQUFJLENBQUM7Z0JBQ2Y7Z0JBQ0EsSUFBSSxDQUFDdUIsV0FBV3hGLHVCQUF1QmhCLE9BQU87b0JBQzVDd0csVUFBVSxDQUFDLEdBQUdJO3dCQUNaLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCVCxRQUFROzRCQUNoRm5CLFFBQVFDLElBQUksQ0FBQzt3QkFDZjt3QkFDQSxJQUFJLENBQUNrQixRQUFROzRCQUNYLE9BQU9VLFVBQVU3RyxTQUFTNEc7d0JBQzVCO29CQUNGO2dCQUNGO2dCQUNBLE9BQU9KO1lBQ1Q7UUFDRjtRQUNBLElBQUk7WUFDRixNQUFNbkIsaUJBQWlCckYsS0FBS0MsSUFBSSxDQUFDbUcsUUFBUUs7WUFDekMsT0FBT3JCLHNCQUNMcEYsTUFDQXFGLGdCQUNBVixrQkFDQSxJQUFNNEIsY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV08sS0FBSztRQUV4RCxFQUFFLE9BQU9sQixPQUFPO1lBQ2QsT0FBT0QsYUFBYTNGLE1BQU00RixPQUFPakI7UUFDbkMsU0FBVTtZQUNSd0IsU0FBUztRQUNYO0lBQ0Y7SUFDQSxNQUFNWSxXQUFXLENBQUMvRyxPQUFTOEMsZ0JBQWdCK0MsY0FBYzdGO0lBQ3pELE1BQU1nSCxzQkFBc0IsQ0FBQ2hIO1FBQzNCLE1BQU1pSCxnQkFBZ0IsQ0FBQ3BHO1lBQ3JCLElBQUlzRCxJQUFJK0M7WUFDUixNQUFNQyxhQUFhLElBQUkxRCxJQUFJLENBQUNVLEtBQUtqQixXQUFXekMsR0FBRyxDQUFDSSxFQUFDLEtBQU0sT0FBTyxLQUFLLElBQUlzRCxHQUFHaUQsQ0FBQztZQUMxRUYsQ0FBQUEsS0FBSzlELFdBQVczQyxHQUFHLENBQUNJLEVBQUMsS0FBTSxPQUFPLEtBQUssSUFBSXFHLEVBQUUsQ0FBQyxFQUFFLENBQUNyRCxPQUFPLENBQUMsQ0FBQ3dEO2dCQUN6REYsV0FBV2xELEdBQUcsQ0FBQ29EO1lBQ2pCO1lBQ0EsT0FBT0Y7UUFDVDtRQUNBLE1BQU1HLGlCQUFpQixJQUFJdkI7UUFDM0IsTUFBTXdCLGNBQWMsYUFBYSxHQUFHLElBQUk5RDtRQUN4QyxNQUFNK0QsUUFBUSxDQUFDQztZQUNiLElBQUlGLFlBQVl4RCxHQUFHLENBQUMwRCxJQUFJO2dCQUN0QjtZQUNGO1lBQ0FGLFlBQVl0RCxHQUFHLENBQUN3RDtZQUNoQixLQUFLLE1BQU1DLEtBQUtULGNBQWNRLEdBQUk7Z0JBQ2hDLElBQUlBLE1BQU1DLEdBQUc7b0JBQ1hGLE1BQU1FO2dCQUNSO1lBQ0Y7WUFDQUosZUFBZUssSUFBSSxDQUFDRjtRQUN0QjtRQUNBRCxNQUFNeEg7UUFDTixNQUFNNEgsZUFBZSxhQUFhLEdBQUcsSUFBSW5FLElBQUk7WUFBQ3pEO1NBQUs7UUFDbkQsTUFBTTZILFdBQVcsQ0FBQ2hILElBQU0wRyxZQUFZeEQsR0FBRyxDQUFDbEQ7UUFDeEMsSUFBSyxJQUFJaUgsSUFBSVIsZUFBZWhELE1BQU0sR0FBRyxHQUFHd0QsS0FBSyxHQUFHLEVBQUVBLEVBQUc7WUFDbkQsTUFBTWpILElBQUl5RyxjQUFjLENBQUNRLEVBQUU7WUFDM0IsTUFBTXpELGdCQUFnQlgsYUFBYTdDO1lBQ25DLElBQUksQ0FBQ3dELGVBQWU7Z0JBQ2xCO1lBQ0Y7WUFDQSxJQUFJMEQsaUJBQWlCO1lBQ3JCLEtBQUssTUFBTUMsT0FBTzNELGNBQWNULENBQUMsQ0FBQ3FFLElBQUksR0FBSTtnQkFDeEMsSUFBSUQsUUFBUW5ILEtBQUsrRyxhQUFhN0QsR0FBRyxDQUFDaUUsTUFBTTtvQkFDdENELGlCQUFpQjtvQkFDakI7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlBLGdCQUFnQjtnQkFDbEIsTUFBTXJELGdCQUFnQm1CLGNBQWNoRixHQUFHZ0g7Z0JBQ3ZDbEUsb0JBQW9COUMsR0FBRzZEO2dCQUN2QixJQUFJLENBQUN0QyxpQkFBaUJpQyxlQUFlSyxnQkFBZ0I7b0JBQ25Ea0QsYUFBYTNELEdBQUcsQ0FBQ3BEO2dCQUNuQjtZQUNGO1lBQ0EwRyxZQUFZL0YsTUFBTSxDQUFDWDtRQUNyQjtJQUNGO0lBQ0EsTUFBTXFILGlCQUFpQixDQUFDbEksTUFBTSxHQUFHNEc7UUFDL0IsTUFBTVIsU0FBUyxDQUFDdkYsSUFBTWlDLGdCQUFnQitDLGNBQWNoRjtRQUNwRCxNQUFNc0gsU0FBUyxDQUFDdEgsR0FBRyxHQUFHdUg7WUFDcEIsTUFBTWpDLFNBQVNoRCxhQUFhbUIsTUFBTSxHQUFHO1lBQ3JDLElBQUksQ0FBQzZCLFFBQVE7Z0JBQ1hoRCxhQUFhd0UsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJbEUsSUFBSTtvQkFBQzVDO2lCQUFFO1lBQy9DO1lBQ0EsSUFBSXdIO1lBQ0osSUFBSXpILFdBQVdaLE1BQU1hLElBQUk7Z0JBQ3ZCLElBQUksQ0FBQ0UsZ0JBQWdCRixJQUFJO29CQUN2QixNQUFNLElBQUl5RixNQUFNO2dCQUNsQjtnQkFDQSxNQUFNakMsZ0JBQWdCWCxhQUFhN0M7Z0JBQ25DLE1BQU02RCxnQkFBZ0JVLHNCQUFzQnZFLEdBQUd1SCxLQUFLLENBQUMsRUFBRTtnQkFDdkQsSUFBSSxDQUFDaEcsaUJBQWlCaUMsZUFBZUssZ0JBQWdCO29CQUNuRHNDLG9CQUFvQm5HO2dCQUN0QjtZQUNGLE9BQU87Z0JBQ0x3SCxJQUFJSCxlQUFlckgsTUFBTXVIO1lBQzNCO1lBQ0EsSUFBSSxDQUFDakMsUUFBUTtnQkFDWCxNQUFNbUMsVUFBVUMsYUFBYXBGLGFBQWFxRixHQUFHO2dCQUM3QyxJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7b0JBQ3RFbkYsaUJBQWlCUSxPQUFPLENBQ3RCLENBQUM0RSxJQUFNQSxFQUFFOzRCQUFFQyxNQUFNOzRCQUFlSjt3QkFBUTtnQkFFNUM7WUFDRjtZQUNBLE9BQU9EO1FBQ1Q7UUFDQSxNQUFNTSxTQUFTM0ksS0FBS0UsS0FBSyxDQUFDa0csUUFBUStCLFdBQVd2QjtRQUM3QyxPQUFPK0I7SUFDVDtJQUNBLE1BQU05QixZQUFZLENBQUM3RyxNQUFNLEdBQUc0RztRQUMxQnpELGFBQWF3RSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUlsRSxJQUFJO1lBQUN6RDtTQUFLO1FBQ2hELE1BQU0ySSxTQUFTVCxlQUFlbEksU0FBUzRHO1FBQ3ZDLE1BQU0wQixVQUFVQyxhQUFhcEYsYUFBYXFGLEdBQUc7UUFDN0MsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxjQUFjO1lBQ3RFbkYsaUJBQWlCUSxPQUFPLENBQUMsQ0FBQzRFLElBQU1BLEVBQUU7b0JBQUVDLE1BQU07b0JBQVNKO2dCQUFRO1FBQzdEO1FBQ0EsT0FBT0s7SUFDVDtJQUNBLE1BQU1DLFlBQVksQ0FBQzVJLE1BQU02SSxrQkFBa0JDO1FBQ3pDLElBQUkzRTtRQUNKLE1BQU00RSxnQkFBZ0I3RixXQUFXekMsR0FBRyxDQUFDVDtRQUNyQyxJQUFJK0ksZUFBZTtZQUNqQixJQUFJRixrQkFBa0I7Z0JBQ3BCRSxjQUFjM0IsQ0FBQyxDQUFDbkQsR0FBRyxDQUFDNEU7WUFDdEI7WUFDQSxPQUFPRTtRQUNUO1FBQ0EsTUFBTUMsUUFBUUYsZ0JBQWdCLEVBQUU7UUFDL0IzRSxDQUFBQSxLQUFLVCxhQUFhMUQsS0FBSSxLQUFNLE9BQU8sS0FBSyxJQUFJbUUsR0FBR1AsQ0FBQyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsR0FBR2pEO1lBQzVELElBQUlBLE1BQU1iLE1BQU07Z0JBQ2Q0SSxVQUFVL0gsR0FBR2IsTUFBTWdKO1lBQ3JCO1FBQ0Y7UUFDQW5ELGNBQWM3RjtRQUNkLE1BQU1pSixVQUFVO1lBQ2Q3QixHQUFHLElBQUkzRCxJQUFJb0Ysb0JBQW9CO2dCQUFDQTthQUFpQjtZQUNqREosR0FBRyxhQUFhLEdBQUcsSUFBSWhGO1FBQ3pCO1FBQ0FQLFdBQVd4QyxHQUFHLENBQUNWLE1BQU1pSjtRQUNyQixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7WUFDdEUzRixhQUFhVyxHQUFHLENBQUNqRTtRQUNuQjtRQUNBLElBQUlnQix1QkFBdUJoQixTQUFTQSxLQUFLa0osT0FBTyxFQUFFO1lBQ2hELE1BQU0sRUFBRUEsT0FBTyxFQUFFLEdBQUdsSjtZQUNwQmdKLE1BQU1yQixJQUFJLENBQUM7Z0JBQ1QsTUFBTXdCLFlBQVlELFFBQVEsQ0FBQyxHQUFHdEMsT0FBU0MsVUFBVTdHLFNBQVM0RztnQkFDMUQsSUFBSXVDLFdBQVc7b0JBQ2JGLFFBQVFHLENBQUMsR0FBR0Q7Z0JBQ2Q7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDTCxjQUFjO1lBQ2pCRSxNQUFNbkYsT0FBTyxDQUFDLENBQUN3RixJQUFNQTtRQUN2QjtRQUNBLE9BQU9KO0lBQ1Q7SUFDQSxNQUFNSyxpQkFBaUIsQ0FBQ3RKLE1BQU1pSixVQUFZLENBQUNBLFFBQVFSLENBQUMsQ0FBQ3ZELElBQUksSUFBSyxFQUFDK0QsUUFBUTdCLENBQUMsQ0FBQ2xDLElBQUksSUFBSStELFFBQVE3QixDQUFDLENBQUNsQyxJQUFJLEtBQUssS0FBSytELFFBQVE3QixDQUFDLENBQUNyRCxHQUFHLENBQUMvRCxLQUFJO0lBQzNILE1BQU11SixpQkFBaUIsQ0FBQ3ZKLE1BQU1pSjtRQUM1QixJQUFJLENBQUNLLGVBQWV0SixNQUFNaUosVUFBVTtZQUNsQztRQUNGO1FBQ0EsTUFBTUUsWUFBWUYsUUFBUUcsQ0FBQztRQUMzQixJQUFJRCxXQUFXO1lBQ2JBO1FBQ0Y7UUFDQWpHLFdBQVcxQixNQUFNLENBQUN4QjtRQUNsQixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7WUFDdEVzRCxhQUFhOUIsTUFBTSxDQUFDeEI7UUFDdEI7UUFDQSxNQUFNK0MsWUFBWVcsYUFBYTFEO1FBQy9CLElBQUkrQyxXQUFXO1lBQ2IsSUFBSUwsb0JBQW9CSyxZQUFZO2dCQUNsQ3RCLGNBQWNzQixVQUFVUCxDQUFDO1lBQzNCO1lBQ0FPLFVBQVVhLENBQUMsQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLEdBQUdqRDtnQkFDdEIsSUFBSUEsTUFBTWIsTUFBTTtvQkFDZCxNQUFNd0osYUFBYXRHLFdBQVd6QyxHQUFHLENBQUNJO29CQUNsQyxJQUFJMkksWUFBWTt3QkFDZEEsV0FBV3BDLENBQUMsQ0FBQzVGLE1BQU0sQ0FBQ3hCO3dCQUNwQnVKLGVBQWUxSSxHQUFHMkk7b0JBQ3BCO2dCQUNGO1lBQ0Y7UUFDRixPQUFPLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztZQUM3RXhFLFFBQVFDLElBQUksQ0FBQyw4Q0FBOENqRjtRQUM3RDtJQUNGO0lBQ0EsTUFBTXlGLG9CQUFvQixDQUFDekYsTUFBTStDLFdBQVcwRztRQUMxQyxNQUFNQyxTQUFTLElBQUlqRyxJQUFJVixVQUFVYSxDQUFDLENBQUNxRSxJQUFJO1FBQ3ZDLE1BQU0wQixzQkFBc0IsYUFBYSxHQUFHLElBQUlsRztRQUNoRGdHLG9CQUFvQixPQUFPLEtBQUssSUFBSUEsaUJBQWlCNUYsT0FBTyxDQUFDLENBQUNDLEdBQUdqRDtZQUMvRCxJQUFJNkksT0FBTzNGLEdBQUcsQ0FBQ2xELElBQUk7Z0JBQ2pCNkksT0FBT2xJLE1BQU0sQ0FBQ1g7Z0JBQ2Q7WUFDRjtZQUNBOEksb0JBQW9CMUYsR0FBRyxDQUFDcEQ7WUFDeEIsTUFBTW9JLFVBQVUvRixXQUFXekMsR0FBRyxDQUFDSTtZQUMvQixJQUFJb0ksU0FBUztnQkFDWEEsUUFBUTdCLENBQUMsQ0FBQzVGLE1BQU0sQ0FBQ3hCO1lBQ25CO1FBQ0Y7UUFDQTBKLE9BQU83RixPQUFPLENBQUMsQ0FBQ2hEO1lBQ2QrSCxVQUFVL0gsR0FBR2I7UUFDZjtRQUNBMkosb0JBQW9COUYsT0FBTyxDQUFDLENBQUNoRDtZQUMzQixNQUFNb0ksVUFBVS9GLFdBQVd6QyxHQUFHLENBQUNJO1lBQy9CLElBQUlvSSxTQUFTO2dCQUNYTSxlQUFlMUksR0FBR29JO1lBQ3BCO1FBQ0Y7SUFDRjtJQUNBLE1BQU1WLGVBQWUsQ0FBQ3FCO1FBQ3BCLElBQUl0QjtRQUNKLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztZQUN0RUEsVUFBVSxhQUFhLEdBQUcsSUFBSTdFO1FBQ2hDO1FBQ0EsTUFBTW9HLFVBQVUsRUFBRTtRQUNsQixNQUFNQyxpQkFBaUIsQ0FBQ0M7WUFDdEIsSUFBSTVGO1lBQ0osSUFBSSxDQUFDZixXQUFXVyxHQUFHLENBQUNnRyxjQUFjO2dCQUNoQztZQUNGO1lBQ0EsTUFBTSxDQUFDMUYsZUFBZThDLFdBQVcsR0FBRy9ELFdBQVczQyxHQUFHLENBQUNzSjtZQUNuRDNHLFdBQVc1QixNQUFNLENBQUN1STtZQUNsQkYsUUFBUWxDLElBQUksQ0FBQztnQkFBQ29DO2dCQUFhMUY7YUFBYztZQUN6QzhDLFdBQVd0RCxPQUFPLENBQUNpRztZQUNsQjNGLENBQUFBLEtBQUtULGFBQWFxRyxZQUFXLEtBQU0sT0FBTyxLQUFLLElBQUk1RixHQUFHUCxDQUFDLENBQUNDLE9BQU8sQ0FBQyxDQUFDQyxHQUFHakQsSUFBTWlKLGVBQWVqSjtRQUM1RjtRQUNBK0ksYUFBYS9GLE9BQU8sQ0FBQ2lHO1FBQ3JCRCxRQUFRaEcsT0FBTyxDQUFDLENBQUMsQ0FBQzdELE1BQU1xRSxjQUFjO1lBQ3BDLE1BQU10QixZQUFZVyxhQUFhMUQ7WUFDL0IsSUFBSSxDQUFDK0MsV0FBVztnQkFDZCxJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7b0JBQ3RFaUMsUUFBUUMsSUFBSSxDQUFDO2dCQUNmO2dCQUNBO1lBQ0Y7WUFDQSxJQUFJbEMsY0FBY3NCLGVBQWU7Z0JBQy9CLE1BQU00RSxVQUFVL0YsV0FBV3pDLEdBQUcsQ0FBQ1Q7Z0JBQy9CLElBQUlpSixXQUFXbEcsVUFBVWEsQ0FBQyxLQUFNUyxDQUFBQSxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWNULENBQUMsR0FBRztvQkFDakY2QixrQkFBa0J6RixNQUFNK0MsV0FBV3NCLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBY1QsQ0FBQztnQkFDckY7Z0JBQ0EsSUFBSXFGLFdBQVcsQ0FDZix3REFBd0Q7Z0JBQ3ZELEVBQUN2RyxvQkFBb0IyQixrQkFBbUJqQyxDQUFBQSxpQkFBaUJpQyxlQUFldEIsY0FBY04saUJBQWlCNEIsZUFBZXRCLFVBQVMsQ0FBQyxHQUFJO29CQUNuSWtHLFFBQVFSLENBQUMsQ0FBQzVFLE9BQU8sQ0FBQyxDQUFDbUcsV0FBYUE7b0JBQ2hDLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYzt3QkFDdEUxQixRQUFRckUsR0FBRyxDQUFDakU7b0JBQ2Q7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxjQUFjO1lBQ3RFLE9BQU9zSTtRQUNUO0lBQ0Y7SUFDQSxNQUFNMkIsZ0JBQWdCLENBQUNqSyxNQUFNZ0s7UUFDM0IsTUFBTWYsVUFBVUwsVUFBVTVJO1FBQzFCLE1BQU1zSSxVQUFVQyxhQUFhO1lBQUN2STtTQUFLO1FBQ25DLE1BQU1rSyxZQUFZakIsUUFBUVIsQ0FBQztRQUMzQnlCLFVBQVVqRyxHQUFHLENBQUMrRjtRQUNkLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztZQUN0RTNHLGlCQUFpQlEsT0FBTyxDQUN0QixDQUFDNEUsSUFBTUEsRUFBRTtvQkFBRUMsTUFBTTtvQkFBT0o7Z0JBQVE7UUFFcEM7UUFDQSxPQUFPO1lBQ0w0QixVQUFVMUksTUFBTSxDQUFDd0k7WUFDakJULGVBQWV2SixNQUFNaUo7WUFDckIsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxjQUFjO2dCQUN0RTVGLGlCQUFpQlEsT0FBTyxDQUFDLENBQUM0RSxJQUFNQSxFQUFFO3dCQUFFQyxNQUFNO29CQUFRO1lBQ3BEO1FBQ0Y7SUFDRjtJQUNBLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztRQUN0RSxPQUFPO1lBQ0xqSSxLQUFLc0c7WUFDTHJHLEtBQUttRztZQUNMc0QsS0FBS0Y7WUFDTCwrRUFBK0U7WUFDL0VHLHFCQUFxQixDQUFDM0I7Z0JBQ3BCcEYsaUJBQWlCWSxHQUFHLENBQUN3RTtnQkFDckIsT0FBTztvQkFDTHBGLGlCQUFpQjdCLE1BQU0sQ0FBQ2lIO2dCQUMxQjtZQUNGO1lBQ0E0Qix1QkFBdUIsSUFBTS9HLGFBQWFnSCxNQUFNO1lBQ2hEQyxvQkFBb0IsQ0FBQzFKLElBQU1vQyxhQUFheEMsR0FBRyxDQUFDSTtZQUM1QzJKLGlCQUFpQixDQUFDM0osSUFBTXFDLFdBQVd6QyxHQUFHLENBQUNJO1lBQ3ZDNEosbUJBQW1CLENBQUNIO2dCQUNsQm5ILGFBQWF3RSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUlsRTtnQkFDdEMsS0FBSyxNQUFNLENBQUN6RCxNQUFNcUYsZUFBZSxJQUFJaUYsT0FBUTtvQkFDM0MsSUFBSXZKLGdCQUFnQmYsT0FBTzt3QkFDekJvRixzQkFBc0JwRixNQUFNcUY7d0JBQzVCMkIsb0JBQW9CaEg7b0JBQ3RCO2dCQUNGO2dCQUNBLE1BQU1zSSxVQUFVQyxhQUFhcEYsYUFBYXFGLEdBQUc7Z0JBQzdDbkYsaUJBQWlCUSxPQUFPLENBQ3RCLENBQUM0RSxJQUFNQSxFQUFFO3dCQUFFQyxNQUFNO3dCQUFXSjtvQkFBUTtZQUV4QztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0w3SCxLQUFLc0c7UUFDTHJHLEtBQUttRztRQUNMc0QsS0FBS0Y7SUFDUDtBQUNGO0FBQ0EsSUFBSVM7QUFDSixNQUFNQyxvQkFBb0I7SUFDeEIsSUFBSSxDQUFDRCxjQUFjO1FBQ2pCQSxlQUFlMUg7UUFDZixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7WUFDdEU0SCxXQUFXQyx1QkFBdUIsSUFBS0QsQ0FBQUEsV0FBV0MsdUJBQXVCLEdBQUdILFlBQVc7WUFDdkYsSUFBSUUsV0FBV0MsdUJBQXVCLEtBQUtILGNBQWM7Z0JBQ3ZEMUYsUUFBUUMsSUFBSSxDQUNWO1lBRUo7UUFDRjtJQUNGO0lBQ0EsT0FBT3lGO0FBQ1Q7QUFFQUksT0FDRSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxlQUFlLHFCQUFxQjtBQUc1RixNQUFNQyxjQUFjL0g7QUFDcEIsTUFBTWdJLGtCQUFrQkw7QUFFc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhLm1qcz82OWM0Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBrZXlDb3VudCA9IDA7XG5mdW5jdGlvbiBhdG9tKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IGtleSA9IGBhdG9tJHsrK2tleUNvdW50fWA7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0b1N0cmluZzogKCkgPT4ga2V5XG4gIH07XG4gIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZmlnLnJlYWQgPSByZWFkO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5pbml0ID0gcmVhZDtcbiAgICBjb25maWcucmVhZCA9IGRlZmF1bHRSZWFkO1xuICAgIGNvbmZpZy53cml0ZSA9IGRlZmF1bHRXcml0ZTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlYWQoZ2V0KSB7XG4gIHJldHVybiBnZXQodGhpcyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0V3JpdGUoZ2V0LCBzZXQsIGFyZykge1xuICByZXR1cm4gc2V0KFxuICAgIHRoaXMsXG4gICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgKTtcbn1cblxuY29uc3QgaXNTZWxmQXRvbSA9IChhdG9tLCBhKSA9PiBhdG9tLnVuc3RhYmxlX2lzID8gYXRvbS51bnN0YWJsZV9pcyhhKSA6IGEgPT09IGF0b207XG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuY29uc3QgY2FuY2VsUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJDYW5jZWxQcm9taXNlID0gKHByb21pc2UsIGNhbmNlbCkgPT4ge1xuICBjYW5jZWxQcm9taXNlTWFwLnNldChwcm9taXNlLCBjYW5jZWwpO1xuICBwcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgfSkuZmluYWxseSgoKSA9PiBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKSk7XG59O1xuY29uc3QgY2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBuZXh0KSA9PiB7XG4gIGNvbnN0IGNhbmNlbCA9IGNhbmNlbFByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoY2FuY2VsKSB7XG4gICAgY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSk7XG4gICAgY2FuY2VsKG5leHQpO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZVByb21pc2UgPSAocHJvbWlzZSwgdmFsdWUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICBwcm9taXNlLnZhbHVlID0gdmFsdWU7XG59O1xuY29uc3QgcmVqZWN0UHJvbWlzZSA9IChwcm9taXNlLCBlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICBwcm9taXNlLnJlYXNvbiA9IGU7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzRXF1YWxBdG9tVmFsdWUgPSAoYSwgYikgPT4gISFhICYmIFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBPYmplY3QuaXMoYS52LCBiLnYpO1xuY29uc3QgaXNFcXVhbEF0b21FcnJvciA9IChhLCBiKSA9PiAhIWEgJiYgXCJlXCIgaW4gYSAmJiBcImVcIiBpbiBiICYmIE9iamVjdC5pcyhhLmUsIGIuZSk7XG5jb25zdCBoYXNQcm9taXNlQXRvbVZhbHVlID0gKGEpID0+ICEhYSAmJiBcInZcIiBpbiBhICYmIGEudiBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZSA9IChhLCBiKSA9PiBcInZcIiBpbiBhICYmIFwidlwiIGluIGIgJiYgYS52Lm9yaWcgJiYgYS52Lm9yaWcgPT09IGIudi5vcmlnO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgcmV0dXJuIGF0b21TdGF0ZS52O1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlJDEgPSAoKSA9PiB7XG4gIGNvbnN0IGF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBtb3VudGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHBlbmRpbmdTdGFjayA9IFtdO1xuICBjb25zdCBwZW5kaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGxldCBkZXZMaXN0ZW5lcnNSZXYyO1xuICBsZXQgbW91bnRlZEF0b21zO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBkZXZMaXN0ZW5lcnNSZXYyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBtb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICBjb25zdCBhZGRQZW5kaW5nRGVwZW5kZW50ID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGlmICghcGVuZGluZ01hcC5oYXMoYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBwZW5kaW5nTWFwLnNldChhLCBbYVN0YXRlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXSk7XG4gICAgICAgIGlmIChhU3RhdGUpIHtcbiAgICAgICAgICBhZGRQZW5kaW5nRGVwZW5kZW50KGEsIGFTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdNYXAuZ2V0KGEpWzFdLmFkZChhdG9tKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVN0YXRlID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgKF9hID0gcGVuZGluZ1N0YWNrW3BlbmRpbmdTdGFjay5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFkZChhdG9tKTtcbiAgICBpZiAoIXBlbmRpbmdNYXAuaGFzKGF0b20pKSB7XG4gICAgICBwZW5kaW5nTWFwLnNldChhdG9tLCBbcHJldkF0b21TdGF0ZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKV0pO1xuICAgICAgYWRkUGVuZGluZ0RlcGVuZGVudChhdG9tLCBhdG9tU3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSkge1xuICAgICAgY29uc3QgbmV4dCA9IFwidlwiIGluIGF0b21TdGF0ZSA/IGF0b21TdGF0ZS52IGluc3RhbmNlb2YgUHJvbWlzZSA/IGF0b21TdGF0ZS52IDogUHJvbWlzZS5yZXNvbHZlKGF0b21TdGF0ZS52KSA6IFByb21pc2UucmVqZWN0KGF0b21TdGF0ZS5lKTtcbiAgICAgIGlmIChwcmV2QXRvbVN0YXRlLnYgIT09IG5leHQpIHtcbiAgICAgICAgY2FuY2VsUHJvbWlzZShwcmV2QXRvbVN0YXRlLnYsIG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlRGVwZW5kZW5jaWVzID0gKGF0b20sIG5leHRBdG9tU3RhdGUsIG5leHREZXBlbmRlbmNpZXMsIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBNYXAoXG4gICAgICBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMgPyBuZXh0QXRvbVN0YXRlLmQgOiBudWxsXG4gICAgKTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIG5leHREZXBlbmRlbmNpZXMuZm9yRWFjaCgoYVN0YXRlLCBhKSA9PiB7XG4gICAgICBpZiAoIWFTdGF0ZSAmJiBpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGFTdGF0ZSA9IG5leHRBdG9tU3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYVN0YXRlKSB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRBdG9tU3RhdGUuZC5nZXQoYSkgIT09IGFTdGF0ZSkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGF0b20gc3RhdGUgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkIHx8IG5leHRBdG9tU3RhdGUuZC5zaXplICE9PSBkZXBlbmRlbmNpZXMuc2l6ZSkge1xuICAgICAgbmV4dEF0b21TdGF0ZS5kID0gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVZhbHVlID0gKGF0b20sIHZhbHVlLCBuZXh0RGVwZW5kZW5jaWVzLCBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgdjogdmFsdWVcbiAgICB9O1xuICAgIGlmIChuZXh0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoXG4gICAgICAgIGF0b20sXG4gICAgICAgIG5leHRBdG9tU3RhdGUsXG4gICAgICAgIG5leHREZXBlbmRlbmNpZXMsXG4gICAgICAgIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkgJiYgcHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiBoYXNQcm9taXNlQXRvbVZhbHVlKG5leHRBdG9tU3RhdGUpICYmIGlzRXF1YWxQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICBpZiAocHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0QXRvbVN0YXRlLnYgPSBwcmV2QXRvbVN0YXRlLnY7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEF0b21TdGF0ZShhdG9tLCBuZXh0QXRvbVN0YXRlKTtcbiAgICByZXR1cm4gbmV4dEF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVZhbHVlT3JQcm9taXNlID0gKGF0b20sIHZhbHVlT3JQcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzLCBhYm9ydFByb21pc2UpID0+IHtcbiAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZU9yUHJvbWlzZSkpIHtcbiAgICAgIGxldCBjb250aW51ZVByb21pc2U7XG4gICAgICBjb25zdCB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgICAgICBpZiAoIWhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgfHwgcHJldkF0b21TdGF0ZS52ICE9PSBwcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSBzZXRBdG9tVmFsdWUoXG4gICAgICAgICAgYXRvbSxcbiAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pICYmIHByZXZBdG9tU3RhdGUuZCAhPT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgcHJldkF0b21TdGF0ZS5kKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBzZXR0bGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlT3JQcm9taXNlLnRoZW4oXG4gICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgdik7XG4gICAgICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgICAgICAgIHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlamVjdFByb21pc2UocHJvbWlzZSwgZSk7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWVQcm9taXNlID0gKG5leHQpID0+IHtcbiAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dC50aGVuKFxuICAgICAgICAgICAgICAodikgPT4gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgdiksXG4gICAgICAgICAgICAgIChlKSA9PiByZWplY3RQcm9taXNlKHByb21pc2UsIGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHByb21pc2Uub3JpZyA9IHZhbHVlT3JQcm9taXNlO1xuICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgIHJlZ2lzdGVyQ2FuY2VsUHJvbWlzZShwcm9taXNlLCAobmV4dCkgPT4ge1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIGNvbnRpbnVlUHJvbWlzZShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydFByb21pc2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0UHJvbWlzZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2V0QXRvbVZhbHVlKGF0b20sIHByb21pc2UsIG5leHREZXBlbmRlbmNpZXMsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0QXRvbVZhbHVlKGF0b20sIHZhbHVlT3JQcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbUVycm9yID0gKGF0b20sIGVycm9yLCBuZXh0RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0ge1xuICAgICAgZDogKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGU6IGVycm9yXG4gICAgfTtcbiAgICBpZiAobmV4dERlcGVuZGVuY2llcykge1xuICAgICAgdXBkYXRlRGVwZW5kZW5jaWVzKGF0b20sIG5leHRBdG9tU3RhdGUsIG5leHREZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICBpZiAoaXNFcXVhbEF0b21FcnJvcihwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSAmJiBwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgfVxuICAgIHNldEF0b21TdGF0ZShhdG9tLCBuZXh0QXRvbVN0YXRlKTtcbiAgICByZXR1cm4gbmV4dEF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3QgcmVhZEF0b21TdGF0ZSA9IChhdG9tLCBmb3JjZSkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoIShmb3JjZSA9PSBudWxsID8gdm9pZCAwIDogZm9yY2UoYXRvbSkpICYmIGF0b21TdGF0ZSkge1xuICAgICAgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuZnJvbShhdG9tU3RhdGUuZCkuZXZlcnkoKFthLCBzXSkgPT4ge1xuICAgICAgICBpZiAoYSA9PT0gYXRvbSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFTdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSwgZm9yY2UpO1xuICAgICAgICByZXR1cm4gYVN0YXRlID09PSBzIHx8IGlzRXF1YWxBdG9tVmFsdWUoYVN0YXRlLCBzKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHREZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiB7XG4gICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBjb25zdCBhU3RhdGUyID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBpZiAoYVN0YXRlMikge1xuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZTIpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIHZvaWQgMCk7XG4gICAgICAgICAgcmV0dXJuIGEuaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhdG9tIGluaXRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEsIGZvcmNlKTtcbiAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZSk7XG4gICAgfTtcbiAgICBsZXQgY29udHJvbGxlcjtcbiAgICBsZXQgc2V0U2VsZjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gICAgICB9LFxuICAgICAgZ2V0IHNldFNlbGYoKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgd2l0aCByZWFkLW9ubHkgYXRvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldFNlbGYgJiYgaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIHNldFNlbGYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3luYykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgaW4gc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0U2VsZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZU9yUHJvbWlzZSA9IGF0b20ucmVhZChnZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZU9yUHJvbWlzZShcbiAgICAgICAgYXRvbSxcbiAgICAgICAgdmFsdWVPclByb21pc2UsXG4gICAgICAgIG5leHREZXBlbmRlbmNpZXMsXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHNldEF0b21FcnJvcihhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAoYXRvbSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoYXRvbSkpO1xuICBjb25zdCByZWNvbXB1dGVEZXBlbmRlbnRzID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBnZXREZXBlbmRlbnRzID0gKGEpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBkZXBlbmRlbnRzID0gbmV3IFNldCgoX2EgPSBtb3VudGVkTWFwLmdldChhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnQpO1xuICAgICAgKF9iID0gcGVuZGluZ01hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYlsxXS5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgZGVwZW5kZW50cy5hZGQoZGVwZW5kZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlcGVuZGVudHM7XG4gICAgfTtcbiAgICBjb25zdCB0b3Bzb3J0ZWRBdG9tcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IG1hcmtlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdCA9IChuKSA9PiB7XG4gICAgICBpZiAobWFya2VkQXRvbXMuaGFzKG4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmFkZChuKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBnZXREZXBlbmRlbnRzKG4pKSB7XG4gICAgICAgIGlmIChuICE9PSBtKSB7XG4gICAgICAgICAgdmlzaXQobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcHNvcnRlZEF0b21zLnB1c2gobik7XG4gICAgfTtcbiAgICB2aXNpdChhdG9tKTtcbiAgICBjb25zdCBjaGFuZ2VkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYXRvbV0pO1xuICAgIGNvbnN0IGlzTWFya2VkID0gKGEpID0+IG1hcmtlZEF0b21zLmhhcyhhKTtcbiAgICBmb3IgKGxldCBpID0gdG9wc29ydGVkQXRvbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGEgPSB0b3Bzb3J0ZWRBdG9tc1tpXTtcbiAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICBpZiAoIXByZXZBdG9tU3RhdGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgaGFzQ2hhbmdlZERlcHMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHByZXZBdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGRlcCAhPT0gYSAmJiBjaGFuZ2VkQXRvbXMuaGFzKGRlcCkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gcmVhZEF0b21TdGF0ZShhLCBpc01hcmtlZCk7XG4gICAgICAgIGFkZFBlbmRpbmdEZXBlbmRlbnQoYSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgICAgIGlmICghaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmRlbGV0ZShhKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbVN0YXRlID0gKGF0b20sIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoYSkpO1xuICAgIGNvbnN0IHNldHRlciA9IChhLCAuLi5hcmdzMikgPT4ge1xuICAgICAgY29uc3QgaXNTeW5jID0gcGVuZGluZ1N0YWNrLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICBwZW5kaW5nU3RhY2sucHVzaCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYV0pKTtcbiAgICAgIH1cbiAgICAgIGxldCByO1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlT3JQcm9taXNlKGEsIGFyZ3MyWzBdKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHdyaXRlQXRvbVN0YXRlKGEsIC4uLmFyZ3MyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcocGVuZGluZ1N0YWNrLnBvcCgpKTtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcImFzeW5jLXdyaXRlXCIsIGZsdXNoZWQgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF0b20ud3JpdGUoZ2V0dGVyLCBzZXR0ZXIsIC4uLmFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgcGVuZGluZ1N0YWNrLnB1c2goLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2F0b21dKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZyhwZW5kaW5nU3RhY2sucG9wKCkpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5mb3JFYWNoKChsKSA9PiBsKHsgdHlwZTogXCJ3cml0ZVwiLCBmbHVzaGVkIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29uc3QgbW91bnRBdG9tID0gKGF0b20sIGluaXRpYWxEZXBlbmRlbnQsIG9uTW91bnRRdWV1ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBleGlzdGluZ01vdW50ID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKGV4aXN0aW5nTW91bnQpIHtcbiAgICAgIGlmIChpbml0aWFsRGVwZW5kZW50KSB7XG4gICAgICAgIGV4aXN0aW5nTW91bnQudC5hZGQoaW5pdGlhbERlcGVuZGVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3RpbmdNb3VudDtcbiAgICB9XG4gICAgY29uc3QgcXVldWUgPSBvbk1vdW50UXVldWUgfHwgW107XG4gICAgKF9hID0gZ2V0QXRvbVN0YXRlKGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZC5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICBtb3VudEF0b20oYSwgYXRvbSwgcXVldWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlYWRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbW91bnRlZCA9IHtcbiAgICAgIHQ6IG5ldyBTZXQoaW5pdGlhbERlcGVuZGVudCAmJiBbaW5pdGlhbERlcGVuZGVudF0pLFxuICAgICAgbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgbW91bnRlZE1hcC5zZXQoYXRvbSwgbW91bnRlZCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuYWRkKGF0b20pO1xuICAgIH1cbiAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgIGNvbnN0IHsgb25Nb3VudCB9ID0gYXRvbTtcbiAgICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgICBjb25zdCBvblVubW91bnQgPSBvbk1vdW50KCguLi5hcmdzKSA9PiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncykpO1xuICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgbW91bnRlZC51ID0gb25Vbm1vdW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvbk1vdW50UXVldWUpIHtcbiAgICAgIHF1ZXVlLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9O1xuICBjb25zdCBjYW5Vbm1vdW50QXRvbSA9IChhdG9tLCBtb3VudGVkKSA9PiAhbW91bnRlZC5sLnNpemUgJiYgKCFtb3VudGVkLnQuc2l6ZSB8fCBtb3VudGVkLnQuc2l6ZSA9PT0gMSAmJiBtb3VudGVkLnQuaGFzKGF0b20pKTtcbiAgY29uc3QgdHJ5VW5tb3VudEF0b20gPSAoYXRvbSwgbW91bnRlZCkgPT4ge1xuICAgIGlmICghY2FuVW5tb3VudEF0b20oYXRvbSwgbW91bnRlZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gbW91bnRlZC51O1xuICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgIG9uVW5tb3VudCgpO1xuICAgIH1cbiAgICBtb3VudGVkTWFwLmRlbGV0ZShhdG9tKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIG1vdW50ZWRBdG9tcy5kZWxldGUoYXRvbSk7XG4gICAgfVxuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShhdG9tU3RhdGUpKSB7XG4gICAgICAgIGNhbmNlbFByb21pc2UoYXRvbVN0YXRlLnYpO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICAgIGNvbnN0IG1vdW50ZWREZXAgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgICAgICBpZiAobW91bnRlZERlcCkge1xuICAgICAgICAgICAgbW91bnRlZERlcC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgICAgIHRyeVVubW91bnRBdG9tKGEsIG1vdW50ZWREZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gY291bGQgbm90IGZpbmQgYXRvbSBzdGF0ZSB0byB1bm1vdW50XCIsIGF0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnREZXBlbmRlbmNpZXMgPSAoYXRvbSwgYXRvbVN0YXRlLCBwcmV2RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwU2V0ID0gbmV3IFNldChhdG9tU3RhdGUuZC5rZXlzKCkpO1xuICAgIGNvbnN0IG1heWJlVW5tb3VudEF0b21TZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHByZXZEZXBlbmRlbmNpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZEZXBlbmRlbmNpZXMuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGRlcFNldC5oYXMoYSkpIHtcbiAgICAgICAgZGVwU2V0LmRlbGV0ZShhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF5YmVVbm1vdW50QXRvbVNldC5hZGQoYSk7XG4gICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICBtb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlcFNldC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBtb3VudEF0b20oYSwgYXRvbSk7XG4gICAgfSk7XG4gICAgbWF5YmVVbm1vdW50QXRvbVNldC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICB0cnlVbm1vdW50QXRvbShhLCBtb3VudGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZmx1c2hQZW5kaW5nID0gKHBlbmRpbmdBdG9tcykgPT4ge1xuICAgIGxldCBmbHVzaGVkO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZmx1c2hlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBjb2xsZWN0UGVuZGluZyA9IChwZW5kaW5nQXRvbSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhwZW5kaW5nQXRvbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgW3ByZXZBdG9tU3RhdGUsIGRlcGVuZGVudHNdID0gcGVuZGluZ01hcC5nZXQocGVuZGluZ0F0b20pO1xuICAgICAgcGVuZGluZ01hcC5kZWxldGUocGVuZGluZ0F0b20pO1xuICAgICAgcGVuZGluZy5wdXNoKFtwZW5kaW5nQXRvbSwgcHJldkF0b21TdGF0ZV0pO1xuICAgICAgZGVwZW5kZW50cy5mb3JFYWNoKGNvbGxlY3RQZW5kaW5nKTtcbiAgICAgIChfYSA9IGdldEF0b21TdGF0ZShwZW5kaW5nQXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kLmZvckVhY2goKF8sIGEpID0+IGNvbGxlY3RQZW5kaW5nKGEpKTtcbiAgICB9O1xuICAgIHBlbmRpbmdBdG9tcy5mb3JFYWNoKGNvbGxlY3RQZW5kaW5nKTtcbiAgICBwZW5kaW5nLmZvckVhY2goKFthdG9tLCBwcmV2QXRvbVN0YXRlXSkgPT4ge1xuICAgICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgICAgaWYgKCFhdG9tU3RhdGUpIHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gbm8gYXRvbSBzdGF0ZSB0byBmbHVzaFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYXRvbVN0YXRlICE9PSBwcmV2QXRvbVN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgYXRvbVN0YXRlLmQgIT09IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpKSB7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYXRvbSwgYXRvbVN0YXRlLCBwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3VudGVkICYmICEvLyBUT0RPIFRoaXMgc2VlbXMgcHJldHR5IGhhY2t5LiBIb3BlIHRvIGZpeCBpdC5cbiAgICAgICAgLy8gTWF5YmUgd2UgY291bGQgYG1vdW50RGVwZW5kZW5jaWVzYCBpbiBgc2V0QXRvbVN0YXRlYD9cbiAgICAgICAgKCFoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpICYmIChpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIGF0b21TdGF0ZSkgfHwgaXNFcXVhbEF0b21FcnJvcihwcmV2QXRvbVN0YXRlLCBhdG9tU3RhdGUpKSkpIHtcbiAgICAgICAgICBtb3VudGVkLmwuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmx1c2hlZC5hZGQoYXRvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmx1c2hlZDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gbW91bnRBdG9tKGF0b20pO1xuICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoW2F0b21dKTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBtb3VudGVkLmw7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBkZXZMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJzdWJcIiwgZmx1c2hlZCB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgdHJ5VW5tb3VudEF0b20oYXRvbSwgbW91bnRlZCk7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5mb3JFYWNoKChsKSA9PiBsKHsgdHlwZTogXCJ1bnN1YlwiIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiByZWFkQXRvbSxcbiAgICAgIHNldDogd3JpdGVBdG9tLFxuICAgICAgc3ViOiBzdWJzY3JpYmVBdG9tLFxuICAgICAgLy8gc3RvcmUgZGV2IG1ldGhvZHMgKHRoZXNlIGFyZSB0ZW50YXRpdmUgYW5kIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlKVxuICAgICAgZGV2X3N1YnNjcmliZV9zdG9yZTogKGwpID0+IHtcbiAgICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5hZGQobCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5kZWxldGUobCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGV2X2dldF9tb3VudGVkX2F0b21zOiAoKSA9PiBtb3VudGVkQXRvbXMudmFsdWVzKCksXG4gICAgICBkZXZfZ2V0X2F0b21fc3RhdGU6IChhKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGEpLFxuICAgICAgZGV2X2dldF9tb3VudGVkOiAoYSkgPT4gbW91bnRlZE1hcC5nZXQoYSksXG4gICAgICBkZXZfcmVzdG9yZV9hdG9tczogKHZhbHVlcykgPT4ge1xuICAgICAgICBwZW5kaW5nU3RhY2sucHVzaCgvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVPclByb21pc2VdIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICAgIHNldEF0b21WYWx1ZU9yUHJvbWlzZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKHBlbmRpbmdTdGFjay5wb3AoKSk7XG4gICAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwicmVzdG9yZVwiLCBmbHVzaGVkIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldDogcmVhZEF0b20sXG4gICAgc2V0OiB3cml0ZUF0b20sXG4gICAgc3ViOiBzdWJzY3JpYmVBdG9tXG4gIH07XG59O1xubGV0IGRlZmF1bHRTdG9yZTtcbmNvbnN0IGdldERlZmF1bHRTdG9yZSQxID0gKCkgPT4ge1xuICBpZiAoIWRlZmF1bHRTdG9yZSkge1xuICAgIGRlZmF1bHRTdG9yZSA9IGNyZWF0ZVN0b3JlJDEoKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gfHwgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gPSBkZWZhdWx0U3RvcmUpO1xuICAgICAgaWYgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gIT09IGRlZmF1bHRTdG9yZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSBKb3RhaSBpbnN0YW5jZXMuIEl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIHdpdGggdGhlIGRlZmF1bHQgc3RvcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvZGlzY3Vzc2lvbnMvMjA0NFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0U3RvcmU7XG59O1xuXG5TeW1ib2woXG4gIChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiID8gXCJDT05USU5VRV9QUk9NSVNFXCIgOiBcIlwiXG4pO1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IGNyZWF0ZVN0b3JlJDE7XG5jb25zdCBnZXREZWZhdWx0U3RvcmUgPSBnZXREZWZhdWx0U3RvcmUkMTtcblxuZXhwb3J0IHsgYXRvbSwgY3JlYXRlU3RvcmUsIGdldERlZmF1bHRTdG9yZSB9O1xuIl0sIm5hbWVzIjpbImtleUNvdW50IiwiYXRvbSIsInJlYWQiLCJ3cml0ZSIsImtleSIsImNvbmZpZyIsInRvU3RyaW5nIiwiaW5pdCIsImRlZmF1bHRSZWFkIiwiZGVmYXVsdFdyaXRlIiwiZ2V0Iiwic2V0IiwiYXJnIiwiaXNTZWxmQXRvbSIsImEiLCJ1bnN0YWJsZV9pcyIsImhhc0luaXRpYWxWYWx1ZSIsImlzQWN0dWFsbHlXcml0YWJsZUF0b20iLCJjYW5jZWxQcm9taXNlTWFwIiwiV2Vha01hcCIsInJlZ2lzdGVyQ2FuY2VsUHJvbWlzZSIsInByb21pc2UiLCJjYW5jZWwiLCJjYXRjaCIsImZpbmFsbHkiLCJkZWxldGUiLCJjYW5jZWxQcm9taXNlIiwibmV4dCIsInJlc29sdmVQcm9taXNlIiwidmFsdWUiLCJzdGF0dXMiLCJyZWplY3RQcm9taXNlIiwiZSIsInJlYXNvbiIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsImlzRXF1YWxBdG9tVmFsdWUiLCJiIiwiT2JqZWN0IiwiaXMiLCJ2IiwiaXNFcXVhbEF0b21FcnJvciIsImhhc1Byb21pc2VBdG9tVmFsdWUiLCJQcm9taXNlIiwiaXNFcXVhbFByb21pc2VBdG9tVmFsdWUiLCJvcmlnIiwicmV0dXJuQXRvbVZhbHVlIiwiYXRvbVN0YXRlIiwiY3JlYXRlU3RvcmUkMSIsImF0b21TdGF0ZU1hcCIsIm1vdW50ZWRNYXAiLCJwZW5kaW5nU3RhY2siLCJwZW5kaW5nTWFwIiwiZGV2TGlzdGVuZXJzUmV2MiIsIm1vdW50ZWRBdG9tcyIsImVudiIsIk1PREUiLCJTZXQiLCJnZXRBdG9tU3RhdGUiLCJhZGRQZW5kaW5nRGVwZW5kZW50IiwiZCIsImZvckVhY2giLCJfIiwiaGFzIiwiYVN0YXRlIiwiYWRkIiwic2V0QXRvbVN0YXRlIiwiX2EiLCJmcmVlemUiLCJwcmV2QXRvbVN0YXRlIiwibGVuZ3RoIiwicmVzb2x2ZSIsInJlamVjdCIsInVwZGF0ZURlcGVuZGVuY2llcyIsIm5leHRBdG9tU3RhdGUiLCJuZXh0RGVwZW5kZW5jaWVzIiwia2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwiTWFwIiwiY2hhbmdlZCIsImNvbnNvbGUiLCJ3YXJuIiwic2l6ZSIsInNldEF0b21WYWx1ZSIsInNldEF0b21WYWx1ZU9yUHJvbWlzZSIsInZhbHVlT3JQcm9taXNlIiwiYWJvcnRQcm9taXNlIiwiY29udGludWVQcm9taXNlIiwidXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyIsIm1vdW50RGVwZW5kZW5jaWVzIiwic2V0dGxlZCIsInNldEF0b21FcnJvciIsImVycm9yIiwicmVhZEF0b21TdGF0ZSIsImZvcmNlIiwiQXJyYXkiLCJmcm9tIiwiZXZlcnkiLCJzIiwiaXNTeW5jIiwiZ2V0dGVyIiwiYVN0YXRlMiIsIkVycm9yIiwiY29udHJvbGxlciIsInNldFNlbGYiLCJvcHRpb25zIiwic2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwiYXJncyIsIndyaXRlQXRvbSIsImFib3J0IiwicmVhZEF0b20iLCJyZWNvbXB1dGVEZXBlbmRlbnRzIiwiZ2V0RGVwZW5kZW50cyIsIl9iIiwiZGVwZW5kZW50cyIsInQiLCJkZXBlbmRlbnQiLCJ0b3Bzb3J0ZWRBdG9tcyIsIm1hcmtlZEF0b21zIiwidmlzaXQiLCJuIiwibSIsInB1c2giLCJjaGFuZ2VkQXRvbXMiLCJpc01hcmtlZCIsImkiLCJoYXNDaGFuZ2VkRGVwcyIsImRlcCIsImtleXMiLCJ3cml0ZUF0b21TdGF0ZSIsInNldHRlciIsImFyZ3MyIiwiciIsImZsdXNoZWQiLCJmbHVzaFBlbmRpbmciLCJwb3AiLCJsIiwidHlwZSIsInJlc3VsdCIsIm1vdW50QXRvbSIsImluaXRpYWxEZXBlbmRlbnQiLCJvbk1vdW50UXVldWUiLCJleGlzdGluZ01vdW50IiwicXVldWUiLCJtb3VudGVkIiwib25Nb3VudCIsIm9uVW5tb3VudCIsInUiLCJmIiwiY2FuVW5tb3VudEF0b20iLCJ0cnlVbm1vdW50QXRvbSIsIm1vdW50ZWREZXAiLCJwcmV2RGVwZW5kZW5jaWVzIiwiZGVwU2V0IiwibWF5YmVVbm1vdW50QXRvbVNldCIsInBlbmRpbmdBdG9tcyIsInBlbmRpbmciLCJjb2xsZWN0UGVuZGluZyIsInBlbmRpbmdBdG9tIiwibGlzdGVuZXIiLCJzdWJzY3JpYmVBdG9tIiwibGlzdGVuZXJzIiwic3ViIiwiZGV2X3N1YnNjcmliZV9zdG9yZSIsImRldl9nZXRfbW91bnRlZF9hdG9tcyIsInZhbHVlcyIsImRldl9nZXRfYXRvbV9zdGF0ZSIsImRldl9nZXRfbW91bnRlZCIsImRldl9yZXN0b3JlX2F0b21zIiwiZGVmYXVsdFN0b3JlIiwiZ2V0RGVmYXVsdFN0b3JlJDEiLCJnbG9iYWxUaGlzIiwiX19KT1RBSV9ERUZBVUxUX1NUT1JFX18iLCJTeW1ib2wiLCJjcmVhdGVTdG9yZSIsImdldERlZmF1bHRTdG9yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/jotai/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/jotai/esm/vanilla/utils.mjs":
/*!***************************************************!*\
  !*** ../node_modules/jotai/esm/vanilla/utils.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RESET: () => (/* binding */ RESET),\n/* harmony export */   atomFamily: () => (/* binding */ atomFamily),\n/* harmony export */   atomWithDefault: () => (/* binding */ atomWithDefault),\n/* harmony export */   atomWithLazy: () => (/* binding */ atomWithLazy),\n/* harmony export */   atomWithObservable: () => (/* binding */ atomWithObservable),\n/* harmony export */   atomWithReducer: () => (/* binding */ atomWithReducer),\n/* harmony export */   atomWithRefresh: () => (/* binding */ atomWithRefresh),\n/* harmony export */   atomWithReset: () => (/* binding */ atomWithReset),\n/* harmony export */   atomWithStorage: () => (/* binding */ atomWithStorage),\n/* harmony export */   createJSONStorage: () => (/* binding */ createJSONStorage),\n/* harmony export */   freezeAtom: () => (/* binding */ freezeAtom),\n/* harmony export */   freezeAtomCreator: () => (/* binding */ freezeAtomCreator),\n/* harmony export */   loadable: () => (/* binding */ loadable),\n/* harmony export */   selectAtom: () => (/* binding */ selectAtom),\n/* harmony export */   splitAtom: () => (/* binding */ splitAtom),\n/* harmony export */   unstable_withStorageValidator: () => (/* binding */ withStorageValidator),\n/* harmony export */   unwrap: () => (/* binding */ unwrap)\n/* harmony export */ });\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/../node_modules/jotai/esm/vanilla.mjs\");\n\nconst RESET = Symbol(( false ? 0 : void 0) !== \"production\" ? \"RESET\" : \"\");\nfunction atomWithReset(initialValue) {\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(initialValue, (get, set, update)=>{\n        const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n        set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    });\n    return anAtom;\n}\nfunction atomWithReducer(initialValue, reducer) {\n    return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(initialValue, function(get, set, action) {\n        set(this, reducer(get(this), action));\n    });\n}\nfunction atomFamily(initializeAtom, areEqual) {\n    let shouldRemove = null;\n    const atoms = /* @__PURE__ */ new Map();\n    const createAtom = (param)=>{\n        let item;\n        if (areEqual === void 0) {\n            item = atoms.get(param);\n        } else {\n            for (const [key, value] of atoms){\n                if (areEqual(key, param)) {\n                    item = value;\n                    break;\n                }\n            }\n        }\n        if (item !== void 0) {\n            if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n                createAtom.remove(param);\n            } else {\n                return item[0];\n            }\n        }\n        const newAtom = initializeAtom(param);\n        atoms.set(param, [\n            newAtom,\n            Date.now()\n        ]);\n        return newAtom;\n    };\n    createAtom.remove = (param)=>{\n        if (areEqual === void 0) {\n            atoms.delete(param);\n        } else {\n            for (const [key] of atoms){\n                if (areEqual(key, param)) {\n                    atoms.delete(key);\n                    break;\n                }\n            }\n        }\n    };\n    createAtom.setShouldRemove = (fn)=>{\n        shouldRemove = fn;\n        if (!shouldRemove) return;\n        for (const [key, value] of atoms){\n            if (shouldRemove(value[1], key)) {\n                atoms.delete(key);\n            }\n        }\n    };\n    return createAtom;\n}\nconst getCached$2 = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3)=>{\n    const cache2 = getCached$2(()=>/* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n    const cache3 = getCached$2(()=>/* @__PURE__ */ new WeakMap(), cache2, dep2);\n    return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n    return memo3(()=>{\n        const EMPTY = Symbol();\n        const selectValue = ([value, prevSlice])=>{\n            if (prevSlice === EMPTY) {\n                return selector(value);\n            }\n            const slice = selector(value, prevSlice);\n            return equalityFn(prevSlice, slice) ? prevSlice : slice;\n        };\n        const derivedAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n            const prev = get(derivedAtom);\n            const value = get(anAtom);\n            return selectValue([\n                value,\n                prev\n            ]);\n        });\n        derivedAtom.init = EMPTY;\n        return derivedAtom;\n    }, anAtom, selector, equalityFn);\n}\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (obj)=>{\n    if (typeof obj !== \"object\" || obj === null) return;\n    Object.freeze(obj);\n    const propNames = Object.getOwnPropertyNames(obj);\n    for (const name of propNames){\n        const value = obj[name];\n        deepFreeze(value);\n    }\n    return obj;\n};\nfunction freezeAtom(anAtom) {\n    if (frozenAtoms.has(anAtom)) {\n        return anAtom;\n    }\n    frozenAtoms.add(anAtom);\n    const origRead = anAtom.read;\n    anAtom.read = function(get, options) {\n        return deepFreeze(origRead.call(this, get, options));\n    };\n    if (\"write\" in anAtom) {\n        const origWrite = anAtom.write;\n        anAtom.write = function(get, set, ...args) {\n            return origWrite.call(this, get, (...setArgs)=>{\n                if (setArgs[0] === anAtom) {\n                    setArgs[1] = deepFreeze(setArgs[1]);\n                }\n                return set(...setArgs);\n            }, ...args);\n        };\n    }\n    return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n    if (( false ? 0 : void 0) !== \"production\") {\n        console.warn(\"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\");\n    }\n    return (...args)=>freezeAtom(createAtom(...args));\n}\nconst getCached$1 = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2)=>{\n    const cache2 = getCached$1(()=>/* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n    return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2)=>!!atom2.write;\nconst isFunction = (x)=>typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n    return memo2$1(()=>{\n        const mappingCache = /* @__PURE__ */ new WeakMap();\n        const getMapping = (arr, prev)=>{\n            let mapping = mappingCache.get(arr);\n            if (mapping) {\n                return mapping;\n            }\n            const prevMapping = prev && mappingCache.get(prev);\n            const atomList = [];\n            const keyList = [];\n            arr.forEach((item, index)=>{\n                const key = keyExtractor ? keyExtractor(item) : index;\n                keyList[index] = key;\n                const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n                if (cachedAtom) {\n                    atomList[index] = cachedAtom;\n                    return;\n                }\n                const read = (get)=>{\n                    const prev2 = get(mappingAtom);\n                    const currArr = get(arrAtom);\n                    const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n                    const index2 = mapping2.keyList.indexOf(key);\n                    if (index2 < 0 || index2 >= currArr.length) {\n                        const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n                        if (prevItem) {\n                            return prevItem;\n                        }\n                        throw new Error(\"splitAtom: index out of bounds for read\");\n                    }\n                    return currArr[index2];\n                };\n                const write = (get, set, update)=>{\n                    const prev2 = get(mappingAtom);\n                    const arr2 = get(arrAtom);\n                    const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n                    const index2 = mapping2.keyList.indexOf(key);\n                    if (index2 < 0 || index2 >= arr2.length) {\n                        throw new Error(\"splitAtom: index out of bounds for write\");\n                    }\n                    const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n                    if (!Object.is(arr2[index2], nextItem)) {\n                        set(arrAtom, [\n                            ...arr2.slice(0, index2),\n                            nextItem,\n                            ...arr2.slice(index2 + 1)\n                        ]);\n                    }\n                };\n                atomList[index] = isWritable(arrAtom) ? (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(read, write) : (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(read);\n            });\n            if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i)=>x === keyList[i])) {\n                mapping = prevMapping;\n            } else {\n                mapping = {\n                    arr,\n                    atomList,\n                    keyList\n                };\n            }\n            mappingCache.set(arr, mapping);\n            return mapping;\n        };\n        const mappingAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n            const prev = get(mappingAtom);\n            const arr = get(arrAtom);\n            const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n            return mapping;\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            mappingAtom.debugPrivate = true;\n        }\n        mappingAtom.init = void 0;\n        const splittedAtom = isWritable(arrAtom) ? (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(mappingAtom).atomList, (get, set, action)=>{\n            switch(action.type){\n                case \"remove\":\n                    {\n                        const index = get(splittedAtom).indexOf(action.atom);\n                        if (index >= 0) {\n                            const arr = get(arrAtom);\n                            set(arrAtom, [\n                                ...arr.slice(0, index),\n                                ...arr.slice(index + 1)\n                            ]);\n                        }\n                        break;\n                    }\n                case \"insert\":\n                    {\n                        const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n                        if (index >= 0) {\n                            const arr = get(arrAtom);\n                            set(arrAtom, [\n                                ...arr.slice(0, index),\n                                action.value,\n                                ...arr.slice(index)\n                            ]);\n                        }\n                        break;\n                    }\n                case \"move\":\n                    {\n                        const index1 = get(splittedAtom).indexOf(action.atom);\n                        const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n                        if (index1 >= 0 && index2 >= 0) {\n                            const arr = get(arrAtom);\n                            if (index1 < index2) {\n                                set(arrAtom, [\n                                    ...arr.slice(0, index1),\n                                    ...arr.slice(index1 + 1, index2),\n                                    arr[index1],\n                                    ...arr.slice(index2)\n                                ]);\n                            } else {\n                                set(arrAtom, [\n                                    ...arr.slice(0, index2),\n                                    arr[index1],\n                                    ...arr.slice(index2, index1),\n                                    ...arr.slice(index1 + 1)\n                                ]);\n                            }\n                        }\n                        break;\n                    }\n            }\n        }) : (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(mappingAtom).atomList);\n        return splittedAtom;\n    }, arrAtom, keyExtractor || cacheKeyForEmptyKeyExtractor);\n}\nfunction atomWithDefault(getDefault) {\n    const EMPTY = Symbol();\n    const overwrittenAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(EMPTY);\n    if (( false ? 0 : void 0) !== \"production\") {\n        overwrittenAtom.debugPrivate = true;\n    }\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, options)=>{\n        const overwritten = get(overwrittenAtom);\n        if (overwritten !== EMPTY) {\n            return overwritten;\n        }\n        return getDefault(get, options);\n    }, (get, set, update)=>{\n        if (update === RESET) {\n            set(overwrittenAtom, EMPTY);\n        } else if (typeof update === \"function\") {\n            const prevValue = get(anAtom);\n            set(overwrittenAtom, update(prevValue));\n        } else {\n            set(overwrittenAtom, update);\n        }\n    });\n    return anAtom;\n}\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n    return (unknownStorage)=>{\n        const storage = {\n            ...unknownStorage,\n            getItem: (key, initialValue)=>{\n                const validate = (value2)=>{\n                    if (!validator(value2)) {\n                        return initialValue;\n                    }\n                    return value2;\n                };\n                const value = unknownStorage.getItem(key, initialValue);\n                if (isPromiseLike(value)) {\n                    return value.then(validate);\n                }\n                return validate(value);\n            }\n        };\n        return storage;\n    };\n}\nfunction createJSONStorage(getStringStorage = ()=>{\n    try {\n        return window.localStorage;\n    } catch (e) {\n        if (( false ? 0 : void 0) !== \"production\") {\n            if (false) {}\n        }\n        return void 0;\n    }\n}, options) {\n    var _a;\n    let lastStr;\n    let lastValue;\n    const storage = {\n        getItem: (key, initialValue)=>{\n            var _a2, _b;\n            const parse = (str2)=>{\n                str2 = str2 || \"\";\n                if (lastStr !== str2) {\n                    try {\n                        lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n                    } catch (e) {\n                        return initialValue;\n                    }\n                    lastStr = str2;\n                }\n                return lastValue;\n            };\n            const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n            if (isPromiseLike(str)) {\n                return str.then(parse);\n            }\n            return parse(str);\n        },\n        setItem: (key, newValue)=>{\n            var _a2;\n            return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(key, JSON.stringify(newValue, options == null ? void 0 : options.replacer));\n        },\n        removeItem: (key)=>{\n            var _a2;\n            return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n        }\n    };\n    const createHandleSubscribe = (subscriber2)=>(key, callback, initialValue)=>subscriber2(key, (v)=>{\n                let newValue;\n                try {\n                    newValue = JSON.parse(v || \"\");\n                } catch (e) {\n                    newValue = initialValue;\n                }\n                callback(newValue);\n            });\n    let subscriber;\n    try {\n        subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n    } catch (e) {}\n    if (!subscriber && \"undefined\" !== \"undefined\" && 0 && 0) {}\n    if (subscriber) {\n        storage.subscribe = createHandleSubscribe(subscriber);\n    }\n    return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n    const getOnInit = options == null ? void 0 : options.getOnInit;\n    const baseAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(getOnInit ? storage.getItem(key, initialValue) : initialValue);\n    if (( false ? 0 : void 0) !== \"production\") {\n        baseAtom.debugPrivate = true;\n    }\n    baseAtom.onMount = (setAtom)=>{\n        setAtom(storage.getItem(key, initialValue));\n        let unsub;\n        if (storage.subscribe) {\n            unsub = storage.subscribe(key, setAtom, initialValue);\n        }\n        return unsub;\n    };\n    const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(baseAtom), (get, set, update)=>{\n        const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n        if (nextValue === RESET) {\n            set(baseAtom, initialValue);\n            return storage.removeItem(key);\n        }\n        if (nextValue instanceof Promise) {\n            return nextValue.then((resolvedValue)=>{\n                set(baseAtom, resolvedValue);\n                return storage.setItem(key, resolvedValue);\n            });\n        }\n        set(baseAtom, nextValue);\n        return storage.setItem(key, nextValue);\n    });\n    return anAtom;\n}\nfunction atomWithObservable(getObservable, options) {\n    const returnResultData = (result)=>{\n        if (\"e\" in result) {\n            throw result.e;\n        }\n        return result.d;\n    };\n    const observableResultAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n        var _a;\n        let observable = getObservable(get);\n        const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n        if (itself) {\n            observable = itself;\n        }\n        let resolve;\n        const makePending = ()=>new Promise((r)=>{\n                resolve = r;\n            });\n        const initialResult = options && \"initialValue\" in options ? {\n            d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n        } : makePending();\n        let setResult;\n        let lastResult;\n        const listener = (result)=>{\n            lastResult = result;\n            resolve == null ? void 0 : resolve(result);\n            setResult == null ? void 0 : setResult(result);\n        };\n        let subscription;\n        let timer;\n        const isNotMounted = ()=>!setResult;\n        const start = ()=>{\n            if (subscription) {\n                clearTimeout(timer);\n                subscription.unsubscribe();\n            }\n            subscription = observable.subscribe({\n                next: (d)=>listener({\n                        d\n                    }),\n                error: (e)=>listener({\n                        e\n                    }),\n                complete: ()=>{}\n            });\n            if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n                timer = setTimeout(()=>{\n                    if (subscription) {\n                        subscription.unsubscribe();\n                        subscription = void 0;\n                    }\n                }, options.unstable_timeout);\n            }\n        };\n        start();\n        const resultAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(lastResult || initialResult);\n        if (( false ? 0 : void 0) !== \"production\") {\n            resultAtom.debugPrivate = true;\n        }\n        resultAtom.onMount = (update)=>{\n            setResult = update;\n            if (lastResult) {\n                update(lastResult);\n            }\n            if (subscription) {\n                clearTimeout(timer);\n            } else {\n                start();\n            }\n            return ()=>{\n                setResult = void 0;\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = void 0;\n                }\n            };\n        };\n        return [\n            resultAtom,\n            observable,\n            makePending,\n            start,\n            isNotMounted\n        ];\n    });\n    if (( false ? 0 : void 0) !== \"production\") {\n        observableResultAtom.debugPrivate = true;\n    }\n    const observableAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n        const [resultAtom] = get(observableResultAtom);\n        const result = get(resultAtom);\n        if (result instanceof Promise) {\n            return result.then(returnResultData);\n        }\n        return returnResultData(result);\n    }, (get, set, data)=>{\n        const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n        if (\"next\" in observable) {\n            if (isNotMounted()) {\n                set(resultAtom, makePending());\n                start();\n            }\n            observable.next(data);\n        } else {\n            throw new Error(\"observable is not subject\");\n        }\n    });\n    return observableAtom;\n}\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1)=>(cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromise$1 = (x)=>x instanceof Promise;\nconst LOADING = {\n    state: \"loading\"\n};\nfunction loadable(anAtom) {\n    return memo1(()=>{\n        const loadableCache = /* @__PURE__ */ new WeakMap();\n        const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n        if (( false ? 0 : void 0) !== \"production\") {\n            refreshAtom.debugPrivate = true;\n        }\n        const derivedAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, { setSelf })=>{\n            get(refreshAtom);\n            let value;\n            try {\n                value = get(anAtom);\n            } catch (error) {\n                return {\n                    state: \"hasError\",\n                    error\n                };\n            }\n            if (!isPromise$1(value)) {\n                return {\n                    state: \"hasData\",\n                    data: value\n                };\n            }\n            const promise = value;\n            const cached1 = loadableCache.get(promise);\n            if (cached1) {\n                return cached1;\n            }\n            if (promise.status === \"fulfilled\") {\n                loadableCache.set(promise, {\n                    state: \"hasData\",\n                    data: promise.value\n                });\n            } else if (promise.status === \"rejected\") {\n                loadableCache.set(promise, {\n                    state: \"hasError\",\n                    error: promise.reason\n                });\n            } else {\n                promise.then((data)=>{\n                    loadableCache.set(promise, {\n                        state: \"hasData\",\n                        data\n                    });\n                }, (error)=>{\n                    loadableCache.set(promise, {\n                        state: \"hasError\",\n                        error\n                    });\n                }).finally(setSelf);\n            }\n            const cached2 = loadableCache.get(promise);\n            if (cached2) {\n                return cached2;\n            }\n            loadableCache.set(promise, LOADING);\n            return LOADING;\n        }, (_get, set)=>{\n            set(refreshAtom, (c)=>c + 1);\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            derivedAtom.debugPrivate = true;\n        }\n        return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>get(derivedAtom));\n    }, anAtom);\n}\nconst getCached = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2)=>{\n    const cache2 = getCached(()=>/* @__PURE__ */ new WeakMap(), cache1, dep1);\n    return getCached(create, cache2, dep2);\n};\nconst isPromise = (x)=>x instanceof Promise;\nconst defaultFallback = ()=>void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n    return memo2(()=>{\n        const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n        const promiseResultCache = /* @__PURE__ */ new WeakMap();\n        const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n        if (( false ? 0 : void 0) !== \"production\") {\n            refreshAtom.debugPrivate = true;\n        }\n        const promiseAndValueAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, { setSelf })=>{\n            get(refreshAtom);\n            const prev = get(promiseAndValueAtom);\n            const promise = get(anAtom);\n            if (!isPromise(promise)) {\n                return {\n                    v: promise\n                };\n            }\n            if (promise !== (prev == null ? void 0 : prev.p)) {\n                if (promise.status === \"fulfilled\") {\n                    promiseResultCache.set(promise, promise.value);\n                } else if (promise.status === \"rejected\") {\n                    promiseErrorCache.set(promise, promise.reason);\n                } else {\n                    promise.then((v)=>promiseResultCache.set(promise, v), (e)=>promiseErrorCache.set(promise, e)).finally(setSelf);\n                }\n            }\n            if (promiseErrorCache.has(promise)) {\n                throw promiseErrorCache.get(promise);\n            }\n            if (promiseResultCache.has(promise)) {\n                return {\n                    p: promise,\n                    v: promiseResultCache.get(promise)\n                };\n            }\n            if (prev && \"v\" in prev) {\n                return {\n                    p: promise,\n                    f: fallback(prev.v),\n                    v: prev.v\n                };\n            }\n            return {\n                p: promise,\n                f: fallback()\n            };\n        }, (_get, set)=>{\n            set(refreshAtom, (c)=>c + 1);\n        });\n        promiseAndValueAtom.init = void 0;\n        if (( false ? 0 : void 0) !== \"production\") {\n            promiseAndValueAtom.debugPrivate = true;\n        }\n        return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get)=>{\n            const state = get(promiseAndValueAtom);\n            if (\"f\" in state) {\n                return state.f;\n            }\n            return state.v;\n        }, (_get, set, ...args)=>set(anAtom, ...args));\n    }, anAtom, fallback);\n}\nfunction atomWithRefresh(read, write) {\n    const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n    if (( false ? 0 : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n    }\n    return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get, options)=>{\n        get(refreshAtom);\n        return read(get, options);\n    }, (get, set, ...args)=>{\n        if (args.length === 0) {\n            set(refreshAtom, (c)=>c + 1);\n        } else if (write) {\n            return write(get, set, ...args);\n        }\n    });\n}\nfunction atomWithLazy(makeInitial) {\n    const a = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(void 0);\n    delete a.init;\n    Object.defineProperty(a, \"init\", {\n        get () {\n            return makeInitial();\n        }\n    });\n    return a;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFFckMsTUFBTUMsUUFBUUMsT0FDWixDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxlQUFlLFVBQVU7QUFHakYsU0FBU0csY0FBY0MsWUFBWTtJQUNqQyxNQUFNQyxTQUFTUCxtREFBSUEsQ0FDakJNLGNBQ0EsQ0FBQ0UsS0FBS0MsS0FBS0M7UUFDVCxNQUFNQyxZQUFZLE9BQU9ELFdBQVcsYUFBYUEsT0FBT0YsSUFBSUQsV0FBV0c7UUFDdkVELElBQUlGLFFBQVFJLGNBQWNWLFFBQVFLLGVBQWVLO0lBQ25EO0lBRUYsT0FBT0o7QUFDVDtBQUVBLFNBQVNLLGdCQUFnQk4sWUFBWSxFQUFFTyxPQUFPO0lBQzVDLE9BQU9iLG1EQUFJQSxDQUFDTSxjQUFjLFNBQVNFLEdBQUcsRUFBRUMsR0FBRyxFQUFFSyxNQUFNO1FBQ2pETCxJQUFJLElBQUksRUFBRUksUUFBUUwsSUFBSSxJQUFJLEdBQUdNO0lBQy9CO0FBQ0Y7QUFFQSxTQUFTQyxXQUFXQyxjQUFjLEVBQUVDLFFBQVE7SUFDMUMsSUFBSUMsZUFBZTtJQUNuQixNQUFNQyxRQUFRLGFBQWEsR0FBRyxJQUFJQztJQUNsQyxNQUFNQyxhQUFhLENBQUNDO1FBQ2xCLElBQUlDO1FBQ0osSUFBSU4sYUFBYSxLQUFLLEdBQUc7WUFDdkJNLE9BQU9KLE1BQU1YLEdBQUcsQ0FBQ2M7UUFDbkIsT0FBTztZQUNMLEtBQUssTUFBTSxDQUFDRSxLQUFLQyxNQUFNLElBQUlOLE1BQU87Z0JBQ2hDLElBQUlGLFNBQVNPLEtBQUtGLFFBQVE7b0JBQ3hCQyxPQUFPRTtvQkFDUDtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJRixTQUFTLEtBQUssR0FBRztZQUNuQixJQUFJTCxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWFLLElBQUksQ0FBQyxFQUFFLEVB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R2tFO1FBQ1osSUFBSUEsS0FBS2dDLE1BQU0sS0FBSyxHQUFHO1lBQ3JCbEcsSUFBSXdNLGFBQWEsQ0FBQy9LLElBQU1BLElBQUk7UUFDOUIsT0FBTyxJQUFJd0MsT0FBTztZQUNoQixPQUFPQSxNQUFNbEUsS0FBS0MsUUFBUWtFO1FBQzVCO0lBQ0Y7QUFFSjtBQUVBLFNBQVM0SixhQUFhQyxXQUFXO0lBQy9CLE1BQU1DLElBQUl6TyxtREFBSUEsQ0FBQyxLQUFLO0lBQ3BCLE9BQU95TyxFQUFFL0ssSUFBSTtJQUNiUixPQUFPd0wsY0FBYyxDQUFDRCxHQUFHLFFBQVE7UUFDL0JqTztZQUNFLE9BQU9nTztRQUNUO0lBQ0Y7SUFDQSxPQUFPQztBQUNUO0FBRW9TIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vdmFuaWxsYS91dGlscy5tanM/ZjBlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhdG9tIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XG5cbmNvbnN0IFJFU0VUID0gU3ltYm9sKFxuICAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiUkVTRVRcIiA6IFwiXCJcbik7XG5cbmZ1bmN0aW9uIGF0b21XaXRoUmVzZXQoaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGFuQXRvbSA9IGF0b20oXG4gICAgaW5pdGlhbFZhbHVlLFxuICAgIChnZXQsIHNldCwgdXBkYXRlKSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0eXBlb2YgdXBkYXRlID09PSBcImZ1bmN0aW9uXCIgPyB1cGRhdGUoZ2V0KGFuQXRvbSkpIDogdXBkYXRlO1xuICAgICAgc2V0KGFuQXRvbSwgbmV4dFZhbHVlID09PSBSRVNFVCA/IGluaXRpYWxWYWx1ZSA6IG5leHRWYWx1ZSk7XG4gICAgfVxuICApO1xuICByZXR1cm4gYW5BdG9tO1xufVxuXG5mdW5jdGlvbiBhdG9tV2l0aFJlZHVjZXIoaW5pdGlhbFZhbHVlLCByZWR1Y2VyKSB7XG4gIHJldHVybiBhdG9tKGluaXRpYWxWYWx1ZSwgZnVuY3Rpb24oZ2V0LCBzZXQsIGFjdGlvbikge1xuICAgIHNldCh0aGlzLCByZWR1Y2VyKGdldCh0aGlzKSwgYWN0aW9uKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhdG9tRmFtaWx5KGluaXRpYWxpemVBdG9tLCBhcmVFcXVhbCkge1xuICBsZXQgc2hvdWxkUmVtb3ZlID0gbnVsbDtcbiAgY29uc3QgYXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjcmVhdGVBdG9tID0gKHBhcmFtKSA9PiB7XG4gICAgbGV0IGl0ZW07XG4gICAgaWYgKGFyZUVxdWFsID09PSB2b2lkIDApIHtcbiAgICAgIGl0ZW0gPSBhdG9tcy5nZXQocGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhdG9tcykge1xuICAgICAgICBpZiAoYXJlRXF1YWwoa2V5LCBwYXJhbSkpIHtcbiAgICAgICAgICBpdGVtID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHNob3VsZFJlbW92ZSA9PSBudWxsID8gdm9pZCAwIDogc2hvdWxkUmVtb3ZlKGl0ZW1bMV0sIHBhcmFtKSkge1xuICAgICAgICBjcmVhdGVBdG9tLnJlbW92ZShwYXJhbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXRlbVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3QXRvbSA9IGluaXRpYWxpemVBdG9tKHBhcmFtKTtcbiAgICBhdG9tcy5zZXQocGFyYW0sIFtuZXdBdG9tLCBEYXRlLm5vdygpXSk7XG4gICAgcmV0dXJuIG5ld0F0b207XG4gIH07XG4gIGNyZWF0ZUF0b20ucmVtb3ZlID0gKHBhcmFtKSA9PiB7XG4gICAgaWYgKGFyZUVxdWFsID09PSB2b2lkIDApIHtcbiAgICAgIGF0b21zLmRlbGV0ZShwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgYXRvbXMpIHtcbiAgICAgICAgaWYgKGFyZUVxdWFsKGtleSwgcGFyYW0pKSB7XG4gICAgICAgICAgYXRvbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNyZWF0ZUF0b20uc2V0U2hvdWxkUmVtb3ZlID0gKGZuKSA9PiB7XG4gICAgc2hvdWxkUmVtb3ZlID0gZm47XG4gICAgaWYgKCFzaG91bGRSZW1vdmUpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhdG9tcykge1xuICAgICAgaWYgKHNob3VsZFJlbW92ZSh2YWx1ZVsxXSwga2V5KSkge1xuICAgICAgICBhdG9tcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBjcmVhdGVBdG9tO1xufVxuXG5jb25zdCBnZXRDYWNoZWQkMiA9IChjLCBtLCBrKSA9PiAobS5oYXMoaykgPyBtIDogbS5zZXQoaywgYygpKSkuZ2V0KGspO1xuY29uc3QgY2FjaGUxJDMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1lbW8zID0gKGNyZWF0ZSwgZGVwMSwgZGVwMiwgZGVwMykgPT4ge1xuICBjb25zdCBjYWNoZTIgPSBnZXRDYWNoZWQkMigoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2FjaGUxJDMsIGRlcDEpO1xuICBjb25zdCBjYWNoZTMgPSBnZXRDYWNoZWQkMigoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2FjaGUyLCBkZXAyKTtcbiAgcmV0dXJuIGdldENhY2hlZCQyKGNyZWF0ZSwgY2FjaGUzLCBkZXAzKTtcbn07XG5mdW5jdGlvbiBzZWxlY3RBdG9tKGFuQXRvbSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4gPSBPYmplY3QuaXMpIHtcbiAgcmV0dXJuIG1lbW8zKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IEVNUFRZID0gU3ltYm9sKCk7XG4gICAgICBjb25zdCBzZWxlY3RWYWx1ZSA9IChbdmFsdWUsIHByZXZTbGljZV0pID0+IHtcbiAgICAgICAgaWYgKHByZXZTbGljZSA9PT0gRU1QVFkpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWNlID0gc2VsZWN0b3IodmFsdWUsIHByZXZTbGljZSk7XG4gICAgICAgIHJldHVybiBlcXVhbGl0eUZuKHByZXZTbGljZSwgc2xpY2UpID8gcHJldlNsaWNlIDogc2xpY2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVyaXZlZEF0b20gPSBhdG9tKChnZXQpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IGdldChkZXJpdmVkQXRvbSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KGFuQXRvbSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RWYWx1ZShbdmFsdWUsIHByZXZdKTtcbiAgICAgIH0pO1xuICAgICAgZGVyaXZlZEF0b20uaW5pdCA9IEVNUFRZO1xuICAgICAgcmV0dXJuIGRlcml2ZWRBdG9tO1xuICAgIH0sXG4gICAgYW5BdG9tLFxuICAgIHNlbGVjdG9yLFxuICAgIGVxdWFsaXR5Rm5cbiAgKTtcbn1cblxuY29uc3QgZnJvemVuQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmNvbnN0IGRlZXBGcmVlemUgPSAob2JqKSA9PiB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuO1xuICBPYmplY3QuZnJlZXplKG9iaik7XG4gIGNvbnN0IHByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBwcm9wTmFtZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcbiAgICBkZWVwRnJlZXplKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbmZ1bmN0aW9uIGZyZWV6ZUF0b20oYW5BdG9tKSB7XG4gIGlmIChmcm96ZW5BdG9tcy5oYXMoYW5BdG9tKSkge1xuICAgIHJldHVybiBhbkF0b207XG4gIH1cbiAgZnJvemVuQXRvbXMuYWRkKGFuQXRvbSk7XG4gIGNvbnN0IG9yaWdSZWFkID0gYW5BdG9tLnJlYWQ7XG4gIGFuQXRvbS5yZWFkID0gZnVuY3Rpb24oZ2V0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlZXBGcmVlemUob3JpZ1JlYWQuY2FsbCh0aGlzLCBnZXQsIG9wdGlvbnMpKTtcbiAgfTtcbiAgaWYgKFwid3JpdGVcIiBpbiBhbkF0b20pIHtcbiAgICBjb25zdCBvcmlnV3JpdGUgPSBhbkF0b20ud3JpdGU7XG4gICAgYW5BdG9tLndyaXRlID0gZnVuY3Rpb24oZ2V0LCBzZXQsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBvcmlnV3JpdGUuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZ2V0LFxuICAgICAgICAoLi4uc2V0QXJncykgPT4ge1xuICAgICAgICAgIGlmIChzZXRBcmdzWzBdID09PSBhbkF0b20pIHtcbiAgICAgICAgICAgIHNldEFyZ3NbMV0gPSBkZWVwRnJlZXplKHNldEFyZ3NbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2V0KC4uLnNldEFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAuLi5hcmdzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFuQXRvbTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZUF0b21DcmVhdG9yKGNyZWF0ZUF0b20pIHtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbREVQUkVDQVRFRF0gZnJlZXplQXRvbUNyZWF0b3IgaXMgZGVwcmVjYXRlZCwgZGVmaW5lIGl0IG9uIHVzZXJzIGVuZFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gKC4uLmFyZ3MpID0+IGZyZWV6ZUF0b20oY3JlYXRlQXRvbSguLi5hcmdzKSk7XG59XG5cbmNvbnN0IGdldENhY2hlZCQxID0gKGMsIG0sIGspID0+IChtLmhhcyhrKSA/IG0gOiBtLnNldChrLCBjKCkpKS5nZXQoayk7XG5jb25zdCBjYWNoZTEkMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbWVtbzIkMSA9IChjcmVhdGUsIGRlcDEsIGRlcDIpID0+IHtcbiAgY29uc3QgY2FjaGUyID0gZ2V0Q2FjaGVkJDEoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNhY2hlMSQyLCBkZXAxKTtcbiAgcmV0dXJuIGdldENhY2hlZCQxKGNyZWF0ZSwgY2FjaGUyLCBkZXAyKTtcbn07XG5jb25zdCBjYWNoZUtleUZvckVtcHR5S2V5RXh0cmFjdG9yID0ge307XG5jb25zdCBpc1dyaXRhYmxlID0gKGF0b20yKSA9PiAhIWF0b20yLndyaXRlO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gc3BsaXRBdG9tKGFyckF0b20sIGtleUV4dHJhY3Rvcikge1xuICByZXR1cm4gbWVtbzIkMShcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBtYXBwaW5nQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvbnN0IGdldE1hcHBpbmcgPSAoYXJyLCBwcmV2KSA9PiB7XG4gICAgICAgIGxldCBtYXBwaW5nID0gbWFwcGluZ0NhY2hlLmdldChhcnIpO1xuICAgICAgICBpZiAobWFwcGluZykge1xuICAgICAgICAgIHJldHVybiBtYXBwaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZNYXBwaW5nID0gcHJldiAmJiBtYXBwaW5nQ2FjaGUuZ2V0KHByZXYpO1xuICAgICAgICBjb25zdCBhdG9tTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBrZXlMaXN0ID0gW107XG4gICAgICAgIGFyci5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleUV4dHJhY3RvciA/IGtleUV4dHJhY3RvcihpdGVtKSA6IGluZGV4O1xuICAgICAgICAgIGtleUxpc3RbaW5kZXhdID0ga2V5O1xuICAgICAgICAgIGNvbnN0IGNhY2hlZEF0b20gPSBwcmV2TWFwcGluZyAmJiBwcmV2TWFwcGluZy5hdG9tTGlzdFtwcmV2TWFwcGluZy5rZXlMaXN0LmluZGV4T2Yoa2V5KV07XG4gICAgICAgICAgaWYgKGNhY2hlZEF0b20pIHtcbiAgICAgICAgICAgIGF0b21MaXN0W2luZGV4XSA9IGNhY2hlZEF0b207XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlYWQgPSAoZ2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2MiA9IGdldChtYXBwaW5nQXRvbSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyQXJyID0gZ2V0KGFyckF0b20pO1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZzIgPSBnZXRNYXBwaW5nKGN1cnJBcnIsIHByZXYyID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Mi5hcnIpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXgyID0gbWFwcGluZzIua2V5TGlzdC5pbmRleE9mKGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyIDwgMCB8fCBpbmRleDIgPj0gY3VyckFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldkl0ZW0gPSBhcnJbZ2V0TWFwcGluZyhhcnIpLmtleUxpc3QuaW5kZXhPZihrZXkpXTtcbiAgICAgICAgICAgICAgaWYgKHByZXZJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZJdGVtO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0QXRvbTogaW5kZXggb3V0IG9mIGJvdW5kcyBmb3IgcmVhZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyQXJyW2luZGV4Ml07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCB3cml0ZSA9IChnZXQsIHNldCwgdXBkYXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2MiA9IGdldChtYXBwaW5nQXRvbSk7XG4gICAgICAgICAgICBjb25zdCBhcnIyID0gZ2V0KGFyckF0b20pO1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZzIgPSBnZXRNYXBwaW5nKGFycjIsIHByZXYyID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Mi5hcnIpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXgyID0gbWFwcGluZzIua2V5TGlzdC5pbmRleE9mKGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyIDwgMCB8fCBpbmRleDIgPj0gYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXRBdG9tOiBpbmRleCBvdXQgb2YgYm91bmRzIGZvciB3cml0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRJdGVtID0gaXNGdW5jdGlvbih1cGRhdGUpID8gdXBkYXRlKGFycjJbaW5kZXgyXSkgOiB1cGRhdGU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5pcyhhcnIyW2luZGV4Ml0sIG5leHRJdGVtKSkge1xuICAgICAgICAgICAgICBzZXQoYXJyQXRvbSwgW1xuICAgICAgICAgICAgICAgIC4uLmFycjIuc2xpY2UoMCwgaW5kZXgyKSxcbiAgICAgICAgICAgICAgICBuZXh0SXRlbSxcbiAgICAgICAgICAgICAgICAuLi5hcnIyLnNsaWNlKGluZGV4MiArIDEpXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXRvbUxpc3RbaW5kZXhdID0gaXNXcml0YWJsZShhcnJBdG9tKSA/IGF0b20ocmVhZCwgd3JpdGUpIDogYXRvbShyZWFkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmV2TWFwcGluZyAmJiBwcmV2TWFwcGluZy5rZXlMaXN0Lmxlbmd0aCA9PT0ga2V5TGlzdC5sZW5ndGggJiYgcHJldk1hcHBpbmcua2V5TGlzdC5ldmVyeSgoeCwgaSkgPT4geCA9PT0ga2V5TGlzdFtpXSkpIHtcbiAgICAgICAgICBtYXBwaW5nID0gcHJldk1hcHBpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHsgYXJyLCBhdG9tTGlzdCwga2V5TGlzdCB9O1xuICAgICAgICB9XG4gICAgICAgIG1hcHBpbmdDYWNoZS5zZXQoYXJyLCBtYXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmc7XG4gICAgICB9O1xuICAgICAgY29uc3QgbWFwcGluZ0F0b20gPSBhdG9tKChnZXQpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IGdldChtYXBwaW5nQXRvbSk7XG4gICAgICAgIGNvbnN0IGFyciA9IGdldChhcnJBdG9tKTtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoYXJyLCBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2LmFycik7XG4gICAgICAgIHJldHVybiBtYXBwaW5nO1xuICAgICAgfSk7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgbWFwcGluZ0F0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG1hcHBpbmdBdG9tLmluaXQgPSB2b2lkIDA7XG4gICAgICBjb25zdCBzcGxpdHRlZEF0b20gPSBpc1dyaXRhYmxlKGFyckF0b20pID8gYXRvbShcbiAgICAgICAgKGdldCkgPT4gZ2V0KG1hcHBpbmdBdG9tKS5hdG9tTGlzdCxcbiAgICAgICAgKGdldCwgc2V0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXQoc3BsaXR0ZWRBdG9tKS5pbmRleE9mKGFjdGlvbi5hdG9tKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBnZXQoYXJyQXRvbSk7XG4gICAgICAgICAgICAgICAgc2V0KGFyckF0b20sIFtcbiAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImluc2VydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWN0aW9uLmJlZm9yZSA/IGdldChzcGxpdHRlZEF0b20pLmluZGV4T2YoYWN0aW9uLmJlZm9yZSkgOiBnZXQoc3BsaXR0ZWRBdG9tKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gZ2V0KGFyckF0b20pO1xuICAgICAgICAgICAgICAgIHNldChhcnJBdG9tLCBbXG4gICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKGluZGV4KVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1vdmVcIjoge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleDEgPSBnZXQoc3BsaXR0ZWRBdG9tKS5pbmRleE9mKGFjdGlvbi5hdG9tKTtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXgyID0gYWN0aW9uLmJlZm9yZSA/IGdldChzcGxpdHRlZEF0b20pLmluZGV4T2YoYWN0aW9uLmJlZm9yZSkgOiBnZXQoc3BsaXR0ZWRBdG9tKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChpbmRleDEgPj0gMCAmJiBpbmRleDIgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IGdldChhcnJBdG9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXgxIDwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgICBzZXQoYXJyQXRvbSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoMCwgaW5kZXgxKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKGluZGV4MSArIDEsIGluZGV4MiksXG4gICAgICAgICAgICAgICAgICAgIGFycltpbmRleDFdLFxuICAgICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoaW5kZXgyKVxuICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNldChhcnJBdG9tLCBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZSgwLCBpbmRleDIpLFxuICAgICAgICAgICAgICAgICAgICBhcnJbaW5kZXgxXSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKGluZGV4MiwgaW5kZXgxKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKGluZGV4MSArIDEpXG4gICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApIDogYXRvbSgoZ2V0KSA9PiBnZXQobWFwcGluZ0F0b20pLmF0b21MaXN0KTtcbiAgICAgIHJldHVybiBzcGxpdHRlZEF0b207XG4gICAgfSxcbiAgICBhcnJBdG9tLFxuICAgIGtleUV4dHJhY3RvciB8fCBjYWNoZUtleUZvckVtcHR5S2V5RXh0cmFjdG9yXG4gICk7XG59XG5cbmZ1bmN0aW9uIGF0b21XaXRoRGVmYXVsdChnZXREZWZhdWx0KSB7XG4gIGNvbnN0IEVNUFRZID0gU3ltYm9sKCk7XG4gIGNvbnN0IG92ZXJ3cml0dGVuQXRvbSA9IGF0b20oRU1QVFkpO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBvdmVyd3JpdHRlbkF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBhbkF0b20gPSBhdG9tKFxuICAgIChnZXQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG92ZXJ3cml0dGVuID0gZ2V0KG92ZXJ3cml0dGVuQXRvbSk7XG4gICAgICBpZiAob3ZlcndyaXR0ZW4gIT09IEVNUFRZKSB7XG4gICAgICAgIHJldHVybiBvdmVyd3JpdHRlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXREZWZhdWx0KGdldCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICAoZ2V0LCBzZXQsIHVwZGF0ZSkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZSA9PT0gUkVTRVQpIHtcbiAgICAgICAgc2V0KG92ZXJ3cml0dGVuQXRvbSwgRU1QVFkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gZ2V0KGFuQXRvbSk7XG4gICAgICAgIHNldChvdmVyd3JpdHRlbkF0b20sIHVwZGF0ZShwcmV2VmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldChvdmVyd3JpdHRlbkF0b20sIHVwZGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICApO1xuICByZXR1cm4gYW5BdG9tO1xufVxuXG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpID0+IHR5cGVvZiAoeCA9PSBudWxsID8gdm9pZCAwIDogeC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gd2l0aFN0b3JhZ2VWYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gIHJldHVybiAodW5rbm93blN0b3JhZ2UpID0+IHtcbiAgICBjb25zdCBzdG9yYWdlID0ge1xuICAgICAgLi4udW5rbm93blN0b3JhZ2UsXG4gICAgICBnZXRJdGVtOiAoa2V5LCBpbml0aWFsVmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUyKSA9PiB7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0b3IodmFsdWUyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlMjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB1bmtub3duU3RvcmFnZS5nZXRJdGVtKGtleSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnRoZW4odmFsaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc3RvcmFnZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUpTT05TdG9yYWdlKGdldFN0cmluZ1N0b3JhZ2UgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufSwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGxldCBsYXN0U3RyO1xuICBsZXQgbGFzdFZhbHVlO1xuICBjb25zdCBzdG9yYWdlID0ge1xuICAgIGdldEl0ZW06IChrZXksIGluaXRpYWxWYWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICBjb25zdCBwYXJzZSA9IChzdHIyKSA9PiB7XG4gICAgICAgIHN0cjIgPSBzdHIyIHx8IFwiXCI7XG4gICAgICAgIGlmIChsYXN0U3RyICE9PSBzdHIyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IEpTT04ucGFyc2Uoc3RyMiwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXZpdmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0U3RyID0gc3RyMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdFZhbHVlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0ciA9IChfYiA9IChfYTIgPSBnZXRTdHJpbmdTdG9yYWdlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0SXRlbShrZXkpKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgICAgaWYgKGlzUHJvbWlzZUxpa2Uoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnRoZW4ocGFyc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlKHN0cik7XG4gICAgfSxcbiAgICBzZXRJdGVtOiAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gZ2V0U3RyaW5nU3RvcmFnZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNldEl0ZW0oXG4gICAgICAgIGtleSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmVwbGFjZXIpXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gZ2V0U3RyaW5nU3RvcmFnZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUhhbmRsZVN1YnNjcmliZSA9IChzdWJzY3JpYmVyMikgPT4gKGtleSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkgPT4gc3Vic2NyaWJlcjIoa2V5LCAodikgPT4ge1xuICAgIGxldCBuZXdWYWx1ZTtcbiAgICB0cnkge1xuICAgICAgbmV3VmFsdWUgPSBKU09OLnBhcnNlKHYgfHwgXCJcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGNhbGxiYWNrKG5ld1ZhbHVlKTtcbiAgfSk7XG4gIGxldCBzdWJzY3JpYmVyO1xuICB0cnkge1xuICAgIHN1YnNjcmliZXIgPSAoX2EgPSBnZXRTdHJpbmdTdG9yYWdlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICBpZiAoIXN1YnNjcmliZXIgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB3aW5kb3cuU3RvcmFnZSkge1xuICAgIHN1YnNjcmliZXIgPSAoa2V5LCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKCEoZ2V0U3RyaW5nU3RvcmFnZSgpIGluc3RhbmNlb2Ygd2luZG93LlN0b3JhZ2UpKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yYWdlRXZlbnRDYWxsYmFjayA9IChlKSA9PiB7XG4gICAgICAgIGlmIChlLnN0b3JhZ2VBcmVhID09PSBnZXRTdHJpbmdTdG9yYWdlKCkgJiYgZS5rZXkgPT09IGtleSkge1xuICAgICAgICAgIGNhbGxiYWNrKGUubmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIHN0b3JhZ2VFdmVudENhbGxiYWNrKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBzdG9yYWdlRXZlbnRDYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICBzdG9yYWdlLnN1YnNjcmliZSA9IGNyZWF0ZUhhbmRsZVN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgfVxuICByZXR1cm4gc3RvcmFnZTtcbn1cbmNvbnN0IGRlZmF1bHRTdG9yYWdlID0gY3JlYXRlSlNPTlN0b3JhZ2UoKTtcbmZ1bmN0aW9uIGF0b21XaXRoU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgc3RvcmFnZSA9IGRlZmF1bHRTdG9yYWdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGdldE9uSW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0T25Jbml0O1xuICBjb25zdCBiYXNlQXRvbSA9IGF0b20oXG4gICAgZ2V0T25Jbml0ID8gc3RvcmFnZS5nZXRJdGVtKGtleSwgaW5pdGlhbFZhbHVlKSA6IGluaXRpYWxWYWx1ZVxuICApO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBiYXNlQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICB9XG4gIGJhc2VBdG9tLm9uTW91bnQgPSAoc2V0QXRvbSkgPT4ge1xuICAgIHNldEF0b20oc3RvcmFnZS5nZXRJdGVtKGtleSwgaW5pdGlhbFZhbHVlKSk7XG4gICAgbGV0IHVuc3ViO1xuICAgIGlmIChzdG9yYWdlLnN1YnNjcmliZSkge1xuICAgICAgdW5zdWIgPSBzdG9yYWdlLnN1YnNjcmliZShrZXksIHNldEF0b20sIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB1bnN1YjtcbiAgfTtcbiAgY29uc3QgYW5BdG9tID0gYXRvbShcbiAgICAoZ2V0KSA9PiBnZXQoYmFzZUF0b20pLFxuICAgIChnZXQsIHNldCwgdXBkYXRlKSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0eXBlb2YgdXBkYXRlID09PSBcImZ1bmN0aW9uXCIgPyB1cGRhdGUoZ2V0KGJhc2VBdG9tKSkgOiB1cGRhdGU7XG4gICAgICBpZiAobmV4dFZhbHVlID09PSBSRVNFVCkge1xuICAgICAgICBzZXQoYmFzZUF0b20sIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBuZXh0VmFsdWUudGhlbigocmVzb2x2ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgIHNldChiYXNlQXRvbSwgcmVzb2x2ZWRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHJlc29sdmVkVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNldChiYXNlQXRvbSwgbmV4dFZhbHVlKTtcbiAgICAgIHJldHVybiBzdG9yYWdlLnNldEl0ZW0oa2V5LCBuZXh0VmFsdWUpO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGFuQXRvbTtcbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhPYnNlcnZhYmxlKGdldE9ic2VydmFibGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmV0dXJuUmVzdWx0RGF0YSA9IChyZXN1bHQpID0+IHtcbiAgICBpZiAoXCJlXCIgaW4gcmVzdWx0KSB7XG4gICAgICB0aHJvdyByZXN1bHQuZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5kO1xuICB9O1xuICBjb25zdCBvYnNlcnZhYmxlUmVzdWx0QXRvbSA9IGF0b20oKGdldCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb2JzZXJ2YWJsZSA9IGdldE9ic2VydmFibGUoZ2V0KTtcbiAgICBjb25zdCBpdHNlbGYgPSAoX2EgPSBvYnNlcnZhYmxlW1N5bWJvbC5vYnNlcnZhYmxlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob2JzZXJ2YWJsZSk7XG4gICAgaWYgKGl0c2VsZikge1xuICAgICAgb2JzZXJ2YWJsZSA9IGl0c2VsZjtcbiAgICB9XG4gICAgbGV0IHJlc29sdmU7XG4gICAgY29uc3QgbWFrZVBlbmRpbmcgPSAoKSA9PiBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHI7XG4gICAgfSk7XG4gICAgY29uc3QgaW5pdGlhbFJlc3VsdCA9IG9wdGlvbnMgJiYgXCJpbml0aWFsVmFsdWVcIiBpbiBvcHRpb25zID8ge1xuICAgICAgZDogdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxWYWx1ZSgpIDogb3B0aW9ucy5pbml0aWFsVmFsdWVcbiAgICB9IDogbWFrZVBlbmRpbmcoKTtcbiAgICBsZXQgc2V0UmVzdWx0O1xuICAgIGxldCBsYXN0UmVzdWx0O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHJlc3VsdCkgPT4ge1xuICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIHJlc29sdmUgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc29sdmUocmVzdWx0KTtcbiAgICAgIHNldFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogc2V0UmVzdWx0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBsZXQgc3Vic2NyaXB0aW9uO1xuICAgIGxldCB0aW1lcjtcbiAgICBjb25zdCBpc05vdE1vdW50ZWQgPSAoKSA9PiAhc2V0UmVzdWx0O1xuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKGQpID0+IGxpc3RlbmVyKHsgZCB9KSxcbiAgICAgICAgZXJyb3I6IChlKSA9PiBsaXN0ZW5lcih7IGUgfSksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTm90TW91bnRlZCgpICYmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVuc3RhYmxlX3RpbWVvdXQpKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLnVuc3RhYmxlX3RpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgc3RhcnQoKTtcbiAgICBjb25zdCByZXN1bHRBdG9tID0gYXRvbShsYXN0UmVzdWx0IHx8IGluaXRpYWxSZXN1bHQpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVzdWx0QXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXN1bHRBdG9tLm9uTW91bnQgPSAodXBkYXRlKSA9PiB7XG4gICAgICBzZXRSZXN1bHQgPSB1cGRhdGU7XG4gICAgICBpZiAobGFzdFJlc3VsdCkge1xuICAgICAgICB1cGRhdGUobGFzdFJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2V0UmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFtyZXN1bHRBdG9tLCBvYnNlcnZhYmxlLCBtYWtlUGVuZGluZywgc3RhcnQsIGlzTm90TW91bnRlZF07XG4gIH0pO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBvYnNlcnZhYmxlUmVzdWx0QXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICB9XG4gIGNvbnN0IG9ic2VydmFibGVBdG9tID0gYXRvbShcbiAgICAoZ2V0KSA9PiB7XG4gICAgICBjb25zdCBbcmVzdWx0QXRvbV0gPSBnZXQob2JzZXJ2YWJsZVJlc3VsdEF0b20pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0KHJlc3VsdEF0b20pO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKHJldHVyblJlc3VsdERhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVyblJlc3VsdERhdGEocmVzdWx0KTtcbiAgICB9LFxuICAgIChnZXQsIHNldCwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgW3Jlc3VsdEF0b20sIG9ic2VydmFibGUsIG1ha2VQZW5kaW5nLCBzdGFydCwgaXNOb3RNb3VudGVkXSA9IGdldChvYnNlcnZhYmxlUmVzdWx0QXRvbSk7XG4gICAgICBpZiAoXCJuZXh0XCIgaW4gb2JzZXJ2YWJsZSkge1xuICAgICAgICBpZiAoaXNOb3RNb3VudGVkKCkpIHtcbiAgICAgICAgICBzZXQocmVzdWx0QXRvbSwgbWFrZVBlbmRpbmcoKSk7XG4gICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZhYmxlLm5leHQoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYnNlcnZhYmxlIGlzIG5vdCBzdWJqZWN0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIG9ic2VydmFibGVBdG9tO1xufVxuXG5jb25zdCBjYWNoZTEkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbWVtbzEgPSAoY3JlYXRlLCBkZXAxKSA9PiAoY2FjaGUxJDEuaGFzKGRlcDEpID8gY2FjaGUxJDEgOiBjYWNoZTEkMS5zZXQoZGVwMSwgY3JlYXRlKCkpKS5nZXQoZGVwMSk7XG5jb25zdCBpc1Byb21pc2UkMSA9ICh4KSA9PiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcbmNvbnN0IExPQURJTkcgPSB7IHN0YXRlOiBcImxvYWRpbmdcIiB9O1xuZnVuY3Rpb24gbG9hZGFibGUoYW5BdG9tKSB7XG4gIHJldHVybiBtZW1vMSgoKSA9PiB7XG4gICAgY29uc3QgbG9hZGFibGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHJlZnJlc2hBdG9tID0gYXRvbSgwKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlZnJlc2hBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRlcml2ZWRBdG9tID0gYXRvbShcbiAgICAgIChnZXQsIHsgc2V0U2VsZiB9KSA9PiB7XG4gICAgICAgIGdldChyZWZyZXNoQXRvbSk7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IGdldChhbkF0b20pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcImhhc0Vycm9yXCIsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Byb21pc2UkMSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJoYXNEYXRhXCIsIGRhdGE6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCBjYWNoZWQxID0gbG9hZGFibGVDYWNoZS5nZXQocHJvbWlzZSk7XG4gICAgICAgIGlmIChjYWNoZWQxKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgbG9hZGFibGVDYWNoZS5zZXQocHJvbWlzZSwgeyBzdGF0ZTogXCJoYXNEYXRhXCIsIGRhdGE6IHByb21pc2UudmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgIGxvYWRhYmxlQ2FjaGUuc2V0KHByb21pc2UsIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImhhc0Vycm9yXCIsXG4gICAgICAgICAgICBlcnJvcjogcHJvbWlzZS5yZWFzb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBsb2FkYWJsZUNhY2hlLnNldChwcm9taXNlLCB7IHN0YXRlOiBcImhhc0RhdGFcIiwgZGF0YSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgbG9hZGFibGVDYWNoZS5zZXQocHJvbWlzZSwgeyBzdGF0ZTogXCJoYXNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLmZpbmFsbHkoc2V0U2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVkMiA9IGxvYWRhYmxlQ2FjaGUuZ2V0KHByb21pc2UpO1xuICAgICAgICBpZiAoY2FjaGVkMikge1xuICAgICAgICAgIHJldHVybiBjYWNoZWQyO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRhYmxlQ2FjaGUuc2V0KHByb21pc2UsIExPQURJTkcpO1xuICAgICAgICByZXR1cm4gTE9BRElORztcbiAgICAgIH0sXG4gICAgICAoX2dldCwgc2V0KSA9PiB7XG4gICAgICAgIHNldChyZWZyZXNoQXRvbSwgKGMpID0+IGMgKyAxKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZGVyaXZlZEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0b20oKGdldCkgPT4gZ2V0KGRlcml2ZWRBdG9tKSk7XG4gIH0sIGFuQXRvbSk7XG59XG5cbmNvbnN0IGdldENhY2hlZCA9IChjLCBtLCBrKSA9PiAobS5oYXMoaykgPyBtIDogbS5zZXQoaywgYygpKSkuZ2V0KGspO1xuY29uc3QgY2FjaGUxID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtZW1vMiA9IChjcmVhdGUsIGRlcDEsIGRlcDIpID0+IHtcbiAgY29uc3QgY2FjaGUyID0gZ2V0Q2FjaGVkKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBjYWNoZTEsIGRlcDEpO1xuICByZXR1cm4gZ2V0Q2FjaGVkKGNyZWF0ZSwgY2FjaGUyLCBkZXAyKTtcbn07XG5jb25zdCBpc1Byb21pc2UgPSAoeCkgPT4geCBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSAoKSA9PiB2b2lkIDA7XG5mdW5jdGlvbiB1bndyYXAoYW5BdG9tLCBmYWxsYmFjayA9IGRlZmF1bHRGYWxsYmFjaykge1xuICByZXR1cm4gbWVtbzIoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvbWlzZUVycm9yQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvbnN0IHByb21pc2VSZXN1bHRDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgY29uc3QgcmVmcmVzaEF0b20gPSBhdG9tKDApO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHJlZnJlc2hBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9taXNlQW5kVmFsdWVBdG9tID0gYXRvbShcbiAgICAgICAgKGdldCwgeyBzZXRTZWxmIH0pID0+IHtcbiAgICAgICAgICBnZXQocmVmcmVzaEF0b20pO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXQocHJvbWlzZUFuZFZhbHVlQXRvbSk7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGdldChhbkF0b20pO1xuICAgICAgICAgIGlmICghaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2OiBwcm9taXNlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9taXNlICE9PSAocHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldi5wKSkge1xuICAgICAgICAgICAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICAgIHByb21pc2VSZXN1bHRDYWNoZS5zZXQocHJvbWlzZSwgcHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZUVycm9yQ2FjaGUuc2V0KHByb21pc2UsIHByb21pc2UucmVhc29uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgICAgICAgICAodikgPT4gcHJvbWlzZVJlc3VsdENhY2hlLnNldChwcm9taXNlLCB2KSxcbiAgICAgICAgICAgICAgICAoZSkgPT4gcHJvbWlzZUVycm9yQ2FjaGUuc2V0KHByb21pc2UsIGUpXG4gICAgICAgICAgICAgICkuZmluYWxseShzZXRTZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb21pc2VFcnJvckNhY2hlLmhhcyhwcm9taXNlKSkge1xuICAgICAgICAgICAgdGhyb3cgcHJvbWlzZUVycm9yQ2FjaGUuZ2V0KHByb21pc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvbWlzZVJlc3VsdENhY2hlLmhhcyhwcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcDogcHJvbWlzZSxcbiAgICAgICAgICAgICAgdjogcHJvbWlzZVJlc3VsdENhY2hlLmdldChwcm9taXNlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXYgJiYgXCJ2XCIgaW4gcHJldikge1xuICAgICAgICAgICAgcmV0dXJuIHsgcDogcHJvbWlzZSwgZjogZmFsbGJhY2socHJldi52KSwgdjogcHJldi52IH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHA6IHByb21pc2UsIGY6IGZhbGxiYWNrKCkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgKF9nZXQsIHNldCkgPT4ge1xuICAgICAgICAgIHNldChyZWZyZXNoQXRvbSwgKGMpID0+IGMgKyAxKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHByb21pc2VBbmRWYWx1ZUF0b20uaW5pdCA9IHZvaWQgMDtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBwcm9taXNlQW5kVmFsdWVBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXRvbShcbiAgICAgICAgKGdldCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KHByb21pc2VBbmRWYWx1ZUF0b20pO1xuICAgICAgICAgIGlmIChcImZcIiBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGF0ZS52O1xuICAgICAgICB9LFxuICAgICAgICAoX2dldCwgc2V0LCAuLi5hcmdzKSA9PiBzZXQoYW5BdG9tLCAuLi5hcmdzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFuQXRvbSxcbiAgICBmYWxsYmFja1xuICApO1xufVxuXG5mdW5jdGlvbiBhdG9tV2l0aFJlZnJlc2gocmVhZCwgd3JpdGUpIHtcbiAgY29uc3QgcmVmcmVzaEF0b20gPSBhdG9tKDApO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZWZyZXNoQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBhdG9tKFxuICAgIChnZXQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGdldChyZWZyZXNoQXRvbSk7XG4gICAgICByZXR1cm4gcmVhZChnZXQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgKGdldCwgc2V0LCAuLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2V0KHJlZnJlc2hBdG9tLCAoYykgPT4gYyArIDEpO1xuICAgICAgfSBlbHNlIGlmICh3cml0ZSkge1xuICAgICAgICByZXR1cm4gd3JpdGUoZ2V0LCBzZXQsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhMYXp5KG1ha2VJbml0aWFsKSB7XG4gIGNvbnN0IGEgPSBhdG9tKHZvaWQgMCk7XG4gIGRlbGV0ZSBhLmluaXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImluaXRcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBtYWtlSW5pdGlhbCgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG5leHBvcnQgeyBSRVNFVCwgYXRvbUZhbWlseSwgYXRvbVdpdGhEZWZhdWx0LCBhdG9tV2l0aExhenksIGF0b21XaXRoT2JzZXJ2YWJsZSwgYXRvbVdpdGhSZWR1Y2VyLCBhdG9tV2l0aFJlZnJlc2gsIGF0b21XaXRoUmVzZXQsIGF0b21XaXRoU3RvcmFnZSwgY3JlYXRlSlNPTlN0b3JhZ2UsIGZyZWV6ZUF0b20sIGZyZWV6ZUF0b21DcmVhdG9yLCBsb2FkYWJsZSwgc2VsZWN0QXRvbSwgc3BsaXRBdG9tLCB3aXRoU3RvcmFnZVZhbGlkYXRvciBhcyB1bnN0YWJsZV93aXRoU3RvcmFnZVZhbGlkYXRvciwgdW53cmFwIH07XG4iXSwibmFtZXMiOlsiYXRvbSIsIlJFU0VUIiwiU3ltYm9sIiwiZW52IiwiTU9ERSIsImF0b21XaXRoUmVzZXQiLCJpbml0aWFsVmFsdWUiLCJhbkF0b20iLCJnZXQiLCJzZXQiLCJ1cGRhdGUiLCJuZXh0VmFsdWUiLCJhdG9tV2l0aFJlZHVjZXIiLCJyZWR1Y2VyIiwiYWN0aW9uIiwiYXRvbUZhbWlseSIsImluaXRpYWxpemVBdG9tIiwiYXJlRXF1YWwiLCJzaG91bGRSZW1vdmUiLCJhdG9tcyIsIk1hcCIsImNyZWF0ZUF0b20iLCJwYXJhbSIsIml0ZW0iLCJrZXkiLCJ2YWx1ZSIsInJlbW92ZSIsIm5ld0F0b20iLCJEYXRlIiwibm93IiwiZGVsZXRlIiwic2V0U2hvdWxkUmVtb3ZlIiwiZm4iLCJnZXRDYWNoZWQkMiIsImMiLCJtIiwiayIsImhhcyIsImNhY2hlMSQzIiwiV2Vha01hcCIsIm1lbW8zIiwiY3JlYXRlIiwiZGVwMSIsImRlcDIiLCJkZXAzIiwiY2FjaGUyIiwiY2FjaGUzIiwic2VsZWN0QXRvbSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsIk9iamVjdCIsImlzIiwiRU1QVFkiLCJzZWxlY3RWYWx1ZSIsInByZXZTbGljZSIsInNsaWNlIiwiZGVyaXZlZEF0b20iLCJwcmV2IiwiaW5pdCIsImZyb3plbkF0b21zIiwiV2Vha1NldCIsImRlZXBGcmVlemUiLCJvYmoiLCJmcmVlemUiLCJwcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibmFtZSIsImZyZWV6ZUF0b20iLCJhZGQiLCJvcmlnUmVhZCIsInJlYWQiLCJvcHRpb25zIiwiY2FsbCIsIm9yaWdXcml0ZSIsIndyaXRlIiwiYXJncyIsInNldEFyZ3MiLCJmcmVlemVBdG9tQ3JlYXRvciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0Q2FjaGVkJDEiLCJjYWNoZTEkMiIsIm1lbW8yJDEiLCJjYWNoZUtleUZvckVtcHR5S2V5RXh0cmFjdG9yIiwiaXNXcml0YWJsZSIsImF0b20yIiwiaXNGdW5jdGlvbiIsIngiLCJzcGxpdEF0b20iLCJhcnJBdG9tIiwia2V5RXh0cmFjdG9yIiwibWFwcGluZ0NhY2hlIiwiZ2V0TWFwcGluZyIsImFyciIsIm1hcHBpbmciLCJwcmV2TWFwcGluZyIsImF0b21MaXN0Iiwia2V5TGlzdCIsImZvckVhY2giLCJpbmRleCIsImNhY2hlZEF0b20iLCJpbmRleE9mIiwicHJldjIiLCJtYXBwaW5nQXRvbSIsImN1cnJBcnIiLCJtYXBwaW5nMiIsImluZGV4MiIsImxlbmd0aCIsInByZXZJdGVtIiwiRXJyb3IiLCJhcnIyIiwibmV4dEl0ZW0iLCJldmVyeSIsImkiLCJkZWJ1Z1ByaXZhdGUiLCJzcGxpdHRlZEF0b20iLCJ0eXBlIiwiYmVmb3JlIiwiaW5kZXgxIiwiYXRvbVdpdGhEZWZhdWx0IiwiZ2V0RGVmYXVsdCIsIm92ZXJ3cml0dGVuQXRvbSIsIm92ZXJ3cml0dGVuIiwicHJldlZhbHVlIiwiaXNQcm9taXNlTGlrZSIsInRoZW4iLCJ3aXRoU3RvcmFnZVZhbGlkYXRvciIsInZhbGlkYXRvciIsInVua25vd25TdG9yYWdlIiwic3RvcmFnZSIsImdldEl0ZW0iLCJ2YWxpZGF0ZSIsInZhbHVlMiIsImNyZWF0ZUpTT05TdG9yYWdlIiwiZ2V0U3RyaW5nU3RvcmFnZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImUiLCJfYSIsImxhc3RTdHIiLCJsYXN0VmFsdWUiLCJfYTIiLCJfYiIsInBhcnNlIiwic3RyMiIsIkpTT04iLCJyZXZpdmVyIiwic3RyIiwic2V0SXRlbSIsIm5ld1ZhbHVlIiwic3RyaW5naWZ5IiwicmVwbGFjZXIiLCJyZW1vdmVJdGVtIiwiY3JlYXRlSGFuZGxlU3Vic2NyaWJlIiwic3Vic2NyaWJlcjIiLCJjYWxsYmFjayIsInYiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIlN0b3JhZ2UiLCJzdG9yYWdlRXZlbnRDYWxsYmFjayIsInN0b3JhZ2VBcmVhIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHRTdG9yYWdlIiwiYXRvbVdpdGhTdG9yYWdlIiwiZ2V0T25Jbml0IiwiYmFzZUF0b20iLCJvbk1vdW50Iiwic2V0QXRvbSIsInVuc3ViIiwiUHJvbWlzZSIsInJlc29sdmVkVmFsdWUiLCJhdG9tV2l0aE9ic2VydmFibGUiLCJnZXRPYnNlcnZhYmxlIiwicmV0dXJuUmVzdWx0RGF0YSIsInJlc3VsdCIsImQiLCJvYnNlcnZhYmxlUmVzdWx0QXRvbSIsIm9ic2VydmFibGUiLCJpdHNlbGYiLCJyZXNvbHZlIiwibWFrZVBlbmRpbmciLCJyIiwiaW5pdGlhbFJlc3VsdCIsInNldFJlc3VsdCIsImxhc3RSZXN1bHQiLCJsaXN0ZW5lciIsInN1YnNjcmlwdGlvbiIsInRpbWVyIiwiaXNOb3RNb3VudGVkIiwic3RhcnQiLCJjbGVhclRpbWVvdXQiLCJ1bnN1YnNjcmliZSIsIm5leHQiLCJlcnJvciIsImNvbXBsZXRlIiwidW5zdGFibGVfdGltZW91dCIsInNldFRpbWVvdXQiLCJyZXN1bHRBdG9tIiwib2JzZXJ2YWJsZUF0b20iLCJkYXRhIiwiY2FjaGUxJDEiLCJtZW1vMSIsImlzUHJvbWlzZSQxIiwiTE9BRElORyIsInN0YXRlIiwibG9hZGFibGUiLCJsb2FkYWJsZUNhY2hlIiwicmVmcmVzaEF0b20iLCJzZXRTZWxmIiwicHJvbWlzZSIsImNhY2hlZDEiLCJzdGF0dXMiLCJyZWFzb24iLCJmaW5hbGx5IiwiY2FjaGVkMiIsIl9nZXQiLCJnZXRDYWNoZWQiLCJjYWNoZTEiLCJtZW1vMiIsImlzUHJvbWlzZSIsImRlZmF1bHRGYWxsYmFjayIsInVud3JhcCIsImZhbGxiYWNrIiwicHJvbWlzZUVycm9yQ2FjaGUiLCJwcm9taXNlUmVzdWx0Q2FjaGUiLCJwcm9taXNlQW5kVmFsdWVBdG9tIiwicCIsImYiLCJhdG9tV2l0aFJlZnJlc2giLCJhdG9tV2l0aExhenkiLCJtYWtlSW5pdGlhbCIsImEiLCJkZWZpbmVQcm9wZXJ0eSIsInVuc3RhYmxlX3dpdGhTdG9yYWdlVmFsaWRhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/jotai/esm/vanilla/utils.mjs\n");

/***/ })

};
;