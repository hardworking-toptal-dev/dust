"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/safe-stable-stringify";
exports.ids = ["vendor-chunks/safe-stable-stringify"];
exports.modules = {

/***/ "(ssr)/../node_modules/safe-stable-stringify/index.js":
/*!******************************************************!*\
  !*** ../node_modules/safe-stable-stringify/index.js ***!
  \******************************************************/
/***/ ((module, exports) => {

eval("\nconst { hasOwnProperty } = Object.prototype;\nconst stringify = configure();\n// @ts-expect-error\nstringify.configure = configure;\n// @ts-expect-error\nstringify.stringify = stringify;\n// @ts-expect-error\nstringify.default = stringify;\n// @ts-expect-error used for named export\nexports.stringify = stringify;\n// @ts-expect-error used for named export\nexports.configure = configure;\nmodule.exports = stringify;\n// eslint-disable-next-line no-control-regex\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/;\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape(str) {\n    // Some magic numbers that worked out fine while benchmarking with v8 8.0\n    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n        return `\"${str}\"`;\n    }\n    return JSON.stringify(str);\n}\nfunction insertSort(array) {\n    // Insertion sort is very efficient for small input sizes but it has a bad\n    // worst case complexity. Thus, use native array sort for bigger values.\n    if (array.length > 2e2) {\n        return array.sort();\n    }\n    for(let i = 1; i < array.length; i++){\n        const currentValue = array[i];\n        let position = i;\n        while(position !== 0 && array[position - 1] > currentValue){\n            array[position] = array[position - 1];\n            position--;\n        }\n        array[position] = currentValue;\n    }\n    return array;\n}\nconst typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;\nfunction isTypedArrayWithEntries(value) {\n    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;\n}\nfunction stringifyTypedArray(array, separator, maximumBreadth) {\n    if (array.length < maximumBreadth) {\n        maximumBreadth = array.length;\n    }\n    const whitespace = separator === \",\" ? \"\" : \" \";\n    let res = `\"0\":${whitespace}${array[0]}`;\n    for(let i = 1; i < maximumBreadth; i++){\n        res += `${separator}\"${i}\":${whitespace}${array[i]}`;\n    }\n    return res;\n}\nfunction getCircularValueOption(options) {\n    if (hasOwnProperty.call(options, \"circularValue\")) {\n        const circularValue = options.circularValue;\n        if (typeof circularValue === \"string\") {\n            return `\"${circularValue}\"`;\n        }\n        if (circularValue == null) {\n            return circularValue;\n        }\n        if (circularValue === Error || circularValue === TypeError) {\n            return {\n                toString () {\n                    throw new TypeError(\"Converting circular structure to JSON\");\n                }\n            };\n        }\n        throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined');\n    }\n    return '\"[Circular]\"';\n}\nfunction getBooleanOption(options, key) {\n    let value;\n    if (hasOwnProperty.call(options, key)) {\n        value = options[key];\n        if (typeof value !== \"boolean\") {\n            throw new TypeError(`The \"${key}\" argument must be of type boolean`);\n        }\n    }\n    return value === undefined ? true : value;\n}\nfunction getPositiveIntegerOption(options, key) {\n    let value;\n    if (hasOwnProperty.call(options, key)) {\n        value = options[key];\n        if (typeof value !== \"number\") {\n            throw new TypeError(`The \"${key}\" argument must be of type number`);\n        }\n        if (!Number.isInteger(value)) {\n            throw new TypeError(`The \"${key}\" argument must be an integer`);\n        }\n        if (value < 1) {\n            throw new RangeError(`The \"${key}\" argument must be >= 1`);\n        }\n    }\n    return value === undefined ? Infinity : value;\n}\nfunction getItemCount(number) {\n    if (number === 1) {\n        return \"1 item\";\n    }\n    return `${number} items`;\n}\nfunction getUniqueReplacerSet(replacerArray) {\n    const replacerSet = new Set();\n    for (const value of replacerArray){\n        if (typeof value === \"string\" || typeof value === \"number\") {\n            replacerSet.add(String(value));\n        }\n    }\n    return replacerSet;\n}\nfunction getStrictOption(options) {\n    if (hasOwnProperty.call(options, \"strict\")) {\n        const value = options.strict;\n        if (typeof value !== \"boolean\") {\n            throw new TypeError('The \"strict\" argument must be of type boolean');\n        }\n        if (value) {\n            return (value)=>{\n                let message = `Object can not safely be stringified. Received type ${typeof value}`;\n                if (typeof value !== \"function\") message += ` (${value.toString()})`;\n                throw new Error(message);\n            };\n        }\n    }\n}\nfunction configure(options) {\n    options = {\n        ...options\n    };\n    const fail = getStrictOption(options);\n    if (fail) {\n        if (options.bigint === undefined) {\n            options.bigint = false;\n        }\n        if (!(\"circularValue\" in options)) {\n            options.circularValue = Error;\n        }\n    }\n    const circularValue = getCircularValueOption(options);\n    const bigint = getBooleanOption(options, \"bigint\");\n    const deterministic = getBooleanOption(options, \"deterministic\");\n    const maximumDepth = getPositiveIntegerOption(options, \"maximumDepth\");\n    const maximumBreadth = getPositiveIntegerOption(options, \"maximumBreadth\");\n    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {\n        let value = parent[key];\n        if (typeof value === \"object\" && value !== null && typeof value.toJSON === \"function\") {\n            value = value.toJSON(key);\n        }\n        value = replacer.call(parent, key, value);\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    let res = \"\";\n                    let join = \",\";\n                    const originalIndentation = indentation;\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        if (spacer !== \"\") {\n                            indentation += spacer;\n                            res += `\\n${indentation}`;\n                            join = `,\\n${indentation}`;\n                        }\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += join;\n                        }\n                        const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        if (spacer !== \"\") {\n                            res += `\\n${originalIndentation}`;\n                        }\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    let keys = Object.keys(value);\n                    const keyLength = keys.length;\n                    if (keyLength === 0) {\n                        return \"{}\";\n                    }\n                    if (maximumDepth < stack.length + 1) {\n                        return '\"[Object]\"';\n                    }\n                    let whitespace = \"\";\n                    let separator = \"\";\n                    if (spacer !== \"\") {\n                        indentation += spacer;\n                        join = `,\\n${indentation}`;\n                        whitespace = \" \";\n                    }\n                    const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n                    if (deterministic && !isTypedArrayWithEntries(value)) {\n                        keys = insertSort(keys);\n                    }\n                    stack.push(value);\n                    for(let i = 0; i < maximumPropertiesToStringify; i++){\n                        const key = keys[i];\n                        const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;\n                            separator = join;\n                        }\n                    }\n                    if (keyLength > maximumBreadth) {\n                        const removedKeys = keyLength - maximumBreadth;\n                        res += `${separator}\"...\":${whitespace}\"${getItemCount(removedKeys)} not stringified\"`;\n                        separator = join;\n                    }\n                    if (spacer !== \"\" && separator.length > 1) {\n                        res = `\\n${indentation}${res}\\n${originalIndentation}`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {\n        if (typeof value === \"object\" && value !== null && typeof value.toJSON === \"function\") {\n            value = value.toJSON(key);\n        }\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    const originalIndentation = indentation;\n                    let res = \"\";\n                    let join = \",\";\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        if (spacer !== \"\") {\n                            indentation += spacer;\n                            res += `\\n${indentation}`;\n                            join = `,\\n${indentation}`;\n                        }\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += join;\n                        }\n                        const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        if (spacer !== \"\") {\n                            res += `\\n${originalIndentation}`;\n                        }\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    stack.push(value);\n                    let whitespace = \"\";\n                    if (spacer !== \"\") {\n                        indentation += spacer;\n                        join = `,\\n${indentation}`;\n                        whitespace = \" \";\n                    }\n                    let separator = \"\";\n                    for (const key of replacer){\n                        const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;\n                            separator = join;\n                        }\n                    }\n                    if (spacer !== \"\" && separator.length > 1) {\n                        res = `\\n${indentation}${res}\\n${originalIndentation}`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringifyIndent(key, value, stack, spacer, indentation) {\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (typeof value.toJSON === \"function\") {\n                        value = value.toJSON(key);\n                        // Prevent calling `toJSON` again.\n                        if (typeof value !== \"object\") {\n                            return stringifyIndent(key, value, stack, spacer, indentation);\n                        }\n                        if (value === null) {\n                            return \"null\";\n                        }\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    const originalIndentation = indentation;\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        indentation += spacer;\n                        let res = `\\n${indentation}`;\n                        const join = `,\\n${indentation}`;\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += join;\n                        }\n                        const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        res += `\\n${originalIndentation}`;\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    let keys = Object.keys(value);\n                    const keyLength = keys.length;\n                    if (keyLength === 0) {\n                        return \"{}\";\n                    }\n                    if (maximumDepth < stack.length + 1) {\n                        return '\"[Object]\"';\n                    }\n                    indentation += spacer;\n                    const join = `,\\n${indentation}`;\n                    let res = \"\";\n                    let separator = \"\";\n                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n                    if (isTypedArrayWithEntries(value)) {\n                        res += stringifyTypedArray(value, join, maximumBreadth);\n                        keys = keys.slice(value.length);\n                        maximumPropertiesToStringify -= value.length;\n                        separator = join;\n                    }\n                    if (deterministic) {\n                        keys = insertSort(keys);\n                    }\n                    stack.push(value);\n                    for(let i = 0; i < maximumPropertiesToStringify; i++){\n                        const key = keys[i];\n                        const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}: ${tmp}`;\n                            separator = join;\n                        }\n                    }\n                    if (keyLength > maximumBreadth) {\n                        const removedKeys = keyLength - maximumBreadth;\n                        res += `${separator}\"...\": \"${getItemCount(removedKeys)} not stringified\"`;\n                        separator = join;\n                    }\n                    if (separator !== \"\") {\n                        res = `\\n${indentation}${res}\\n${originalIndentation}`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringifySimple(key, value, stack) {\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (typeof value.toJSON === \"function\") {\n                        value = value.toJSON(key);\n                        // Prevent calling `toJSON` again\n                        if (typeof value !== \"object\") {\n                            return stringifySimple(key, value, stack);\n                        }\n                        if (value === null) {\n                            return \"null\";\n                        }\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    let res = \"\";\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifySimple(String(i), value[i], stack);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += \",\";\n                        }\n                        const tmp = stringifySimple(String(i), value[i], stack);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `,\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    let keys = Object.keys(value);\n                    const keyLength = keys.length;\n                    if (keyLength === 0) {\n                        return \"{}\";\n                    }\n                    if (maximumDepth < stack.length + 1) {\n                        return '\"[Object]\"';\n                    }\n                    let separator = \"\";\n                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n                    if (isTypedArrayWithEntries(value)) {\n                        res += stringifyTypedArray(value, \",\", maximumBreadth);\n                        keys = keys.slice(value.length);\n                        maximumPropertiesToStringify -= value.length;\n                        separator = \",\";\n                    }\n                    if (deterministic) {\n                        keys = insertSort(keys);\n                    }\n                    stack.push(value);\n                    for(let i = 0; i < maximumPropertiesToStringify; i++){\n                        const key = keys[i];\n                        const tmp = stringifySimple(key, value[key], stack);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}:${tmp}`;\n                            separator = \",\";\n                        }\n                    }\n                    if (keyLength > maximumBreadth) {\n                        const removedKeys = keyLength - maximumBreadth;\n                        res += `${separator}\"...\":\"${getItemCount(removedKeys)} not stringified\"`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringify(value, replacer, space) {\n        if (arguments.length > 1) {\n            let spacer = \"\";\n            if (typeof space === \"number\") {\n                spacer = \" \".repeat(Math.min(space, 10));\n            } else if (typeof space === \"string\") {\n                spacer = space.slice(0, 10);\n            }\n            if (replacer != null) {\n                if (typeof replacer === \"function\") {\n                    return stringifyFnReplacer(\"\", {\n                        \"\": value\n                    }, [], replacer, spacer, \"\");\n                }\n                if (Array.isArray(replacer)) {\n                    return stringifyArrayReplacer(\"\", value, [], getUniqueReplacerSet(replacer), spacer, \"\");\n                }\n            }\n            if (spacer.length !== 0) {\n                return stringifyIndent(\"\", value, [], spacer, \"\");\n            }\n        }\n        return stringifySimple(\"\", value, []);\n    }\n    return stringify;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NhZmUtc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsY0FBYyxFQUFFLEdBQUdDLE9BQU9DLFNBQVM7QUFFM0MsTUFBTUMsWUFBWUM7QUFFbEIsbUJBQW1CO0FBQ25CRCxVQUFVQyxTQUFTLEdBQUdBO0FBQ3RCLG1CQUFtQjtBQUNuQkQsVUFBVUEsU0FBUyxHQUFHQTtBQUV0QixtQkFBbUI7QUFDbkJBLFVBQVVFLE9BQU8sR0FBR0Y7QUFFcEIseUNBQXlDO0FBQ3pDRyxpQkFBaUIsR0FBR0g7QUFDcEIseUNBQXlDO0FBQ3pDRyxpQkFBaUIsR0FBR0Y7QUFFcEJHLE9BQU9ELE9BQU8sR0FBR0g7QUFFakIsNENBQTRDO0FBQzVDLE1BQU1LLDJCQUEyQjtBQUVqQyw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLFNBQVNDLFVBQVdDLEdBQUc7SUFDckIseUVBQXlFO0lBQ3pFLElBQUlBLElBQUlDLE1BQU0sR0FBRyxRQUFRLENBQUNILHlCQUF5QkksSUFBSSxDQUFDRixNQUFNO1FBQzVELE9BQU8sQ0FBQyxDQUFDLEVBQUVBLElBQUksQ0FBQyxDQUFDO0lBQ25CO0lBQ0EsT0FBT0csS0FBS1YsU0FBUyxDQUFDTztBQUN4QjtBQUVBLFNBQVNJLFdBQVlDLEtBQUs7SUFDeEIsMEVBQTBFO0lBQzFFLHdFQUF3RTtJQUN4RSxJQUFJQSxNQUFNSixNQUFNLEdBQUcsS0FBSztRQUN0QixPQUFPSSxNQUFNQyxJQUFJO0lBQ25CO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLE1BQU1KLE1BQU0sRUFBRU0sSUFBSztRQUNyQyxNQUFNQyxlQUFlSCxLQUFLLENBQUNFLEVBQUU7UUFDN0IsSUFBSUUsV0FBV0Y7UUFDZixNQUFPRSxhQUFhLEtBQUtKLEtBQUssQ0FBQ0ksV0FBVyxFQUFFLEdBQUdELGFBQWM7WUFDM0RILEtBQUssQ0FBQ0ksU0FBUyxHQUFHSixLQUFLLENB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b2R1bGVzL3NhZmUtc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcz84MmI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlXG5cbmNvbnN0IHN0cmluZ2lmeSA9IGNvbmZpZ3VyZSgpXG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbnN0cmluZ2lmeS5jb25maWd1cmUgPSBjb25maWd1cmVcbi8vIEB0cy1leHBlY3QtZXJyb3JcbnN0cmluZ2lmeS5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcblxuLy8gQHRzLWV4cGVjdC1lcnJvclxuc3RyaW5naWZ5LmRlZmF1bHQgPSBzdHJpbmdpZnlcblxuLy8gQHRzLWV4cGVjdC1lcnJvciB1c2VkIGZvciBuYW1lZCBleHBvcnRcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG4vLyBAdHMtZXhwZWN0LWVycm9yIHVzZWQgZm9yIG5hbWVkIGV4cG9ydFxuZXhwb3J0cy5jb25maWd1cmUgPSBjb25maWd1cmVcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx1MDAwMC1cXHUwMDFmXFx1MDAyMlxcdTAwNWNcXHVkODAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRiZmZdKD8hW1xcdWRjMDAtXFx1ZGZmZl0pfCg/OlteXFx1ZDgwMC1cXHVkYmZmXXxeKVtcXHVkYzAwLVxcdWRmZmZdL1xuXG4vLyBFc2NhcGUgQzAgY29udHJvbCBjaGFyYWN0ZXJzLCBkb3VibGUgcXVvdGVzLCB0aGUgYmFja3NsYXNoIGFuZCBldmVyeSBjb2RlXG4vLyB1bml0IHdpdGggYSBudW1lcmljIHZhbHVlIGluIHRoZSBpbmNsdXNpdmUgcmFuZ2UgMHhEODAwIHRvIDB4REZGRi5cbmZ1bmN0aW9uIHN0ckVzY2FwZSAoc3RyKSB7XG4gIC8vIFNvbWUgbWFnaWMgbnVtYmVycyB0aGF0IHdvcmtlZCBvdXQgZmluZSB3aGlsZSBiZW5jaG1hcmtpbmcgd2l0aCB2OCA4LjBcbiAgaWYgKHN0ci5sZW5ndGggPCA1MDAwICYmICFzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGBcIiR7c3RyfVwiYFxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpXG59XG5cbmZ1bmN0aW9uIGluc2VydFNvcnQgKGFycmF5KSB7XG4gIC8vIEluc2VydGlvbiBzb3J0IGlzIHZlcnkgZWZmaWNpZW50IGZvciBzbWFsbCBpbnB1dCBzaXplcyBidXQgaXQgaGFzIGEgYmFkXG4gIC8vIHdvcnN0IGNhc2UgY29tcGxleGl0eS4gVGh1cywgdXNlIG5hdGl2ZSBhcnJheSBzb3J0IGZvciBiaWdnZXIgdmFsdWVzLlxuICBpZiAoYXJyYXkubGVuZ3RoID4gMmUyKSB7XG4gICAgcmV0dXJuIGFycmF5LnNvcnQoKVxuICB9XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBhcnJheVtpXVxuICAgIGxldCBwb3NpdGlvbiA9IGlcbiAgICB3aGlsZSAocG9zaXRpb24gIT09IDAgJiYgYXJyYXlbcG9zaXRpb24gLSAxXSA+IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgYXJyYXlbcG9zaXRpb25dID0gYXJyYXlbcG9zaXRpb24gLSAxXVxuICAgICAgcG9zaXRpb24tLVxuICAgIH1cbiAgICBhcnJheVtwb3NpdGlvbl0gPSBjdXJyZW50VmFsdWVcbiAgfVxuICByZXR1cm4gYXJyYXlcbn1cblxuY29uc3QgdHlwZWRBcnJheVByb3RvdHlwZUdldFN5bWJvbFRvU3RyaW5nVGFnID1cbiAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoXG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoXG4gICAgICAgIG5ldyBJbnQ4QXJyYXkoKVxuICAgICAgKVxuICAgICksXG4gICAgU3ltYm9sLnRvU3RyaW5nVGFnXG4gICkuZ2V0XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZWRBcnJheVByb3RvdHlwZUdldFN5bWJvbFRvU3RyaW5nVGFnLmNhbGwodmFsdWUpICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoICE9PSAwXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVR5cGVkQXJyYXkgKGFycmF5LCBzZXBhcmF0b3IsIG1heGltdW1CcmVhZHRoKSB7XG4gIGlmIChhcnJheS5sZW5ndGggPCBtYXhpbXVtQnJlYWR0aCkge1xuICAgIG1heGltdW1CcmVhZHRoID0gYXJyYXkubGVuZ3RoXG4gIH1cbiAgY29uc3Qgd2hpdGVzcGFjZSA9IHNlcGFyYXRvciA9PT0gJywnID8gJycgOiAnICdcbiAgbGV0IHJlcyA9IGBcIjBcIjoke3doaXRlc3BhY2V9JHthcnJheVswXX1gXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWF4aW11bUJyZWFkdGg7IGkrKykge1xuICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9XCIke2l9XCI6JHt3aGl0ZXNwYWNlfSR7YXJyYXlbaV19YFxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0Q2lyY3VsYXJWYWx1ZU9wdGlvbiAob3B0aW9ucykge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnY2lyY3VsYXJWYWx1ZScpKSB7XG4gICAgY29uc3QgY2lyY3VsYXJWYWx1ZSA9IG9wdGlvbnMuY2lyY3VsYXJWYWx1ZVxuICAgIGlmICh0eXBlb2YgY2lyY3VsYXJWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBgXCIke2NpcmN1bGFyVmFsdWV9XCJgXG4gICAgfVxuICAgIGlmIChjaXJjdWxhclZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgfVxuICAgIGlmIChjaXJjdWxhclZhbHVlID09PSBFcnJvciB8fCBjaXJjdWxhclZhbHVlID09PSBUeXBlRXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJjaXJjdWxhclZhbHVlXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciB0aGUgdmFsdWUgbnVsbCBvciB1bmRlZmluZWQnKVxuICB9XG4gIHJldHVybiAnXCJbQ2lyY3VsYXJdXCInXG59XG5cbmZ1bmN0aW9uIGdldEJvb2xlYW5PcHRpb24gKG9wdGlvbnMsIGtleSkge1xuICBsZXQgdmFsdWVcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywga2V5KSkge1xuICAgIHZhbHVlID0gb3B0aW9uc1trZXldXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke2tleX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbmApXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aXZlSW50ZWdlck9wdGlvbiAob3B0aW9ucywga2V5KSB7XG4gIGxldCB2YWx1ZVxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBrZXkpKSB7XG4gICAgdmFsdWUgPSBvcHRpb25zW2tleV1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtrZXl9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcmApXG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7a2V5fVwiIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlcmApXG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgXCIke2tleX1cIiBhcmd1bWVudCBtdXN0IGJlID49IDFgKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZ2V0SXRlbUNvdW50IChudW1iZXIpIHtcbiAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgIHJldHVybiAnMSBpdGVtJ1xuICB9XG4gIHJldHVybiBgJHtudW1iZXJ9IGl0ZW1zYFxufVxuXG5mdW5jdGlvbiBnZXRVbmlxdWVSZXBsYWNlclNldCAocmVwbGFjZXJBcnJheSkge1xuICBjb25zdCByZXBsYWNlclNldCA9IG5ldyBTZXQoKVxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHJlcGxhY2VyQXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXBsYWNlclNldC5hZGQoU3RyaW5nKHZhbHVlKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2VyU2V0XG59XG5cbmZ1bmN0aW9uIGdldFN0cmljdE9wdGlvbiAob3B0aW9ucykge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc3RyaWN0JykpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc3RyaWN0XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbicpXG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBPYmplY3QgY2FuIG5vdCBzYWZlbHkgYmUgc3RyaW5naWZpZWQuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgdmFsdWV9YFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSBtZXNzYWdlICs9IGAgKCR7dmFsdWUudG9TdHJpbmcoKX0pYFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uZmlndXJlIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfVxuICBjb25zdCBmYWlsID0gZ2V0U3RyaWN0T3B0aW9uKG9wdGlvbnMpXG4gIGlmIChmYWlsKSB7XG4gICAgaWYgKG9wdGlvbnMuYmlnaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuYmlnaW50ID0gZmFsc2VcbiAgICB9XG4gICAgaWYgKCEoJ2NpcmN1bGFyVmFsdWUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmNpcmN1bGFyVmFsdWUgPSBFcnJvclxuICAgIH1cbiAgfVxuICBjb25zdCBjaXJjdWxhclZhbHVlID0gZ2V0Q2lyY3VsYXJWYWx1ZU9wdGlvbihvcHRpb25zKVxuICBjb25zdCBiaWdpbnQgPSBnZXRCb29sZWFuT3B0aW9uKG9wdGlvbnMsICdiaWdpbnQnKVxuICBjb25zdCBkZXRlcm1pbmlzdGljID0gZ2V0Qm9vbGVhbk9wdGlvbihvcHRpb25zLCAnZGV0ZXJtaW5pc3RpYycpXG4gIGNvbnN0IG1heGltdW1EZXB0aCA9IGdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihvcHRpb25zLCAnbWF4aW11bURlcHRoJylcbiAgY29uc3QgbWF4aW11bUJyZWFkdGggPSBnZXRQb3NpdGl2ZUludGVnZXJPcHRpb24ob3B0aW9ucywgJ21heGltdW1CcmVhZHRoJylcblxuICBmdW5jdGlvbiBzdHJpbmdpZnlGblJlcGxhY2VyIChrZXksIHBhcmVudCwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKSB7XG4gICAgbGV0IHZhbHVlID0gcGFyZW50W2tleV1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSlcbiAgICB9XG4gICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCB2YWx1ZSlcblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gc3RyRXNjYXBlKHZhbHVlKVxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzID0gJydcbiAgICAgICAgbGV0IGpvaW4gPSAnLCdcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdbXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJbQXJyYXldXCInXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHNwYWNlclxuICAgICAgICAgICAgcmVzICs9IGBcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICAgIGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgIGZvciAoOyBpIDwgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlGblJlcGxhY2VyKFN0cmluZyhpKSwgdmFsdWUsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgICAgcmVzICs9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5Rm5SZXBsYWNlcihTdHJpbmcoaSksIHZhbHVlLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAtIDEgPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSB2YWx1ZS5sZW5ndGggLSBtYXhpbXVtQnJlYWR0aCAtIDFcbiAgICAgICAgICAgIHJlcyArPSBgJHtqb2lufVwiLi4uICR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgcmV0dXJuIGBbJHtyZXN9XWBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAgIGlmIChrZXlMZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJ3t9J1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgcmV0dXJuICdcIltPYmplY3RdXCInXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdoaXRlc3BhY2UgPSAnJ1xuICAgICAgICBsZXQgc2VwYXJhdG9yID0gJydcbiAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICB3aGl0ZXNwYWNlID0gJyAnXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKGtleUxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgIGlmIChkZXRlcm1pbmlzdGljICYmICFpc1R5cGVkQXJyYXlXaXRoRW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICBrZXlzID0gaW5zZXJ0U29ydChrZXlzKVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeTsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUZuUmVwbGFjZXIoa2V5LCB2YWx1ZSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3N0ckVzY2FwZShrZXkpfToke3doaXRlc3BhY2V9JHt0bXB9YFxuICAgICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TGVuZ3RoID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IGtleUxlbmd0aCAtIG1heGltdW1CcmVhZHRoXG4gICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn1cIi4uLlwiOiR7d2hpdGVzcGFjZX1cIiR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGFjZXIgIT09ICcnICYmIHNlcGFyYXRvci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmVzID0gYFxcbiR7aW5kZW50YXRpb259JHtyZXN9XFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICByZXR1cm4gYHske3Jlc319YFxuICAgICAgfVxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBmYWlsID8gZmFpbCh2YWx1ZSkgOiAnbnVsbCdcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBpZiAoYmlnaW50KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhaWwgPyBmYWlsKHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5UmVwbGFjZXIgKGtleSwgdmFsdWUsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSlcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHN0ckVzY2FwZSh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uXG4gICAgICAgIGxldCByZXMgPSAnJ1xuICAgICAgICBsZXQgam9pbiA9ICcsJ1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnW10nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiW0FycmF5XVwiJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgICBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4odmFsdWUubGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5QXJyYXlSZXBsYWNlcihTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggLSAxID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gdmFsdWUubGVuZ3RoIC0gbWF4aW11bUJyZWFkdGggLSAxXG4gICAgICAgICAgICByZXMgKz0gYCR7am9pbn1cIi4uLiAke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHJldHVybiBgWyR7cmVzfV1gXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgbGV0IHdoaXRlc3BhY2UgPSAnJ1xuICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IHNwYWNlclxuICAgICAgICAgIGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgIHdoaXRlc3BhY2UgPSAnICdcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VwYXJhdG9yID0gJydcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVwbGFjZXIpIHtcbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKGtleSwgdmFsdWVba2V5XSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3N0ckVzY2FwZShrZXkpfToke3doaXRlc3BhY2V9JHt0bXB9YFxuICAgICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BhY2VyICE9PSAnJyAmJiBzZXBhcmF0b3IubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudGF0aW9ufSR7cmVzfVxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgcmV0dXJuIGB7JHtyZXN9fWBcbiAgICAgIH1cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogZmFpbCA/IGZhaWwodmFsdWUpIDogJ251bGwnXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgaWYgKGJpZ2ludCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWlsID8gZmFpbCh2YWx1ZSkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlJbmRlbnQgKGtleSwgdmFsdWUsIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzdHJFc2NhcGUodmFsdWUpXG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSlcbiAgICAgICAgICAvLyBQcmV2ZW50IGNhbGxpbmcgYHRvSlNPTmAgYWdhaW4uXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlJbmRlbnQoa2V5LCB2YWx1ZSwgc3RhY2ssIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGNpcmN1bGFyVmFsdWVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGVudGF0aW9uID0gaW5kZW50YXRpb25cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIltBcnJheV1cIidcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICBsZXQgcmVzID0gYFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgIGNvbnN0IGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgIGNvbnN0IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUluZGVudChTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgICAgcmVzICs9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5SW5kZW50KFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggLSAxID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gdmFsdWUubGVuZ3RoIC0gbWF4aW11bUJyZWFkdGggLSAxXG4gICAgICAgICAgICByZXMgKz0gYCR7am9pbn1cIi4uLiAke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXMgKz0gYFxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICByZXR1cm4gYFske3Jlc31dYFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICAgaWYgKGtleUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAne30nXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICByZXR1cm4gJ1wiW09iamVjdF1cIidcbiAgICAgICAgfVxuICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgY29uc3Qgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgIGxldCByZXMgPSAnJ1xuICAgICAgICBsZXQgc2VwYXJhdG9yID0gJydcbiAgICAgICAgbGV0IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbihrZXlMZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICBpZiAoaXNUeXBlZEFycmF5V2l0aEVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmeVR5cGVkQXJyYXkodmFsdWUsIGpvaW4sIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGtleXMgPSBrZXlzLnNsaWNlKHZhbHVlLmxlbmd0aClcbiAgICAgICAgICBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5IC09IHZhbHVlLmxlbmd0aFxuICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZXJtaW5pc3RpYykge1xuICAgICAgICAgIGtleXMgPSBpbnNlcnRTb3J0KGtleXMpXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5SW5kZW50KGtleSwgdmFsdWVba2V5XSwgc3RhY2ssIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfSR7c3RyRXNjYXBlKGtleSl9OiAke3RtcH1gXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMZW5ndGggPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0ga2V5TGVuZ3RoIC0gbWF4aW11bUJyZWFkdGhcbiAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfVwiLi4uXCI6IFwiJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvciAhPT0gJycpIHtcbiAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnRhdGlvbn0ke3Jlc31cXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgIHJldHVybiBgeyR7cmVzfX1gXG4gICAgICB9XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IGZhaWwgPyBmYWlsKHZhbHVlKSA6ICdudWxsJ1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgIGlmIChiaWdpbnQpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFpbCA/IGZhaWwodmFsdWUpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U2ltcGxlIChrZXksIHZhbHVlLCBzdGFjaykge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gc3RyRXNjYXBlKHZhbHVlKVxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgICAgICAgLy8gUHJldmVudCBjYWxsaW5nIGB0b0pTT05gIGFnYWluXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlTaW1wbGUoa2V5LCB2YWx1ZSwgc3RhY2spXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGNpcmN1bGFyVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXMgPSAnJ1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnW10nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiW0FycmF5XVwiJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICAgIGNvbnN0IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeVNpbXBsZShTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaylcbiAgICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgICAgcmVzICs9ICcsJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlTaW1wbGUoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2spXG4gICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAtIDEgPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSB2YWx1ZS5sZW5ndGggLSBtYXhpbXVtQnJlYWR0aCAtIDFcbiAgICAgICAgICAgIHJlcyArPSBgLFwiLi4uICR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgcmV0dXJuIGBbJHtyZXN9XWBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAgIGlmIChrZXlMZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJ3t9J1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgcmV0dXJuICdcIltPYmplY3RdXCInXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGxldCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4oa2V5TGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgaWYgKGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlUeXBlZEFycmF5KHZhbHVlLCAnLCcsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGtleXMgPSBrZXlzLnNsaWNlKHZhbHVlLmxlbmd0aClcbiAgICAgICAgICBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5IC09IHZhbHVlLmxlbmd0aFxuICAgICAgICAgIHNlcGFyYXRvciA9ICcsJ1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRlcm1pbmlzdGljKSB7XG4gICAgICAgICAga2V5cyA9IGluc2VydFNvcnQoa2V5cylcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnk7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlTaW1wbGUoa2V5LCB2YWx1ZVtrZXldLCBzdGFjaylcbiAgICAgICAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtzdHJFc2NhcGUoa2V5KX06JHt0bXB9YFxuICAgICAgICAgICAgc2VwYXJhdG9yID0gJywnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMZW5ndGggPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0ga2V5TGVuZ3RoIC0gbWF4aW11bUJyZWFkdGhcbiAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfVwiLi4uXCI6XCIke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgIHJldHVybiBgeyR7cmVzfX1gXG4gICAgICB9XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IGZhaWwgPyBmYWlsKHZhbHVlKSA6ICdudWxsJ1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgIGlmIChiaWdpbnQpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFpbCA/IGZhaWwodmFsdWUpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgc3BhY2VyID0gJydcbiAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNwYWNlciA9ICcgJy5yZXBlYXQoTWF0aC5taW4oc3BhY2UsIDEwKSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzcGFjZXIgPSBzcGFjZS5zbGljZSgwLCAxMClcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsYWNlciAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5Rm5SZXBsYWNlcignJywgeyAnJzogdmFsdWUgfSwgW10sIHJlcGxhY2VyLCBzcGFjZXIsICcnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKCcnLCB2YWx1ZSwgW10sIGdldFVuaXF1ZVJlcGxhY2VyU2V0KHJlcGxhY2VyKSwgc3BhY2VyLCAnJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNwYWNlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUluZGVudCgnJywgdmFsdWUsIFtdLCBzcGFjZXIsICcnKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5U2ltcGxlKCcnLCB2YWx1ZSwgW10pXG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5XG59XG4iXSwibmFtZXMiOlsiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJzdHJpbmdpZnkiLCJjb25maWd1cmUiLCJkZWZhdWx0IiwiZXhwb3J0cyIsIm1vZHVsZSIsInN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCIsInN0ckVzY2FwZSIsInN0ciIsImxlbmd0aCIsInRlc3QiLCJKU09OIiwiaW5zZXJ0U29ydCIsImFycmF5Iiwic29ydCIsImkiLCJjdXJyZW50VmFsdWUiLCJwb3NpdGlvbiIsInR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldFByb3RvdHlwZU9mIiwiSW50OEFycmF5IiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJnZXQiLCJpc1R5cGVkQXJyYXlXaXRoRW50cmllcyIsInZhbHVlIiwiY2FsbCIsInVuZGVmaW5lZCIsInN0cmluZ2lmeVR5cGVkQXJyYXkiLCJzZXBhcmF0b3IiLCJtYXhpbXVtQnJlYWR0aCIsIndoaXRlc3BhY2UiLCJyZXMiLCJnZXRDaXJjdWxhclZhbHVlT3B0aW9uIiwib3B0aW9ucyIsImNpcmN1bGFyVmFsdWUiLCJFcnJvciIsIlR5cGVFcnJvciIsInRvU3RyaW5nIiwiZ2V0Qm9vbGVhbk9wdGlvbiIsImtleSIsImdldFBvc2l0aXZlSW50ZWdlck9wdGlvbiIsIk51bWJlciIsImlzSW50ZWdlciIsIlJhbmdlRXJyb3IiLCJJbmZpbml0eSIsImdldEl0ZW1Db3VudCIsIm51bWJlciIsImdldFVuaXF1ZVJlcGxhY2VyU2V0IiwicmVwbGFjZXJBcnJheSIsInJlcGxhY2VyU2V0IiwiU2V0IiwiYWRkIiwiU3RyaW5nIiwiZ2V0U3RyaWN0T3B0aW9uIiwic3RyaWN0IiwibWVzc2FnZSIsImZhaWwiLCJiaWdpbnQiLCJkZXRlcm1pbmlzdGljIiwibWF4aW11bURlcHRoIiwic3RyaW5naWZ5Rm5SZXBsYWNlciIsInBhcmVudCIsInN0YWNrIiwicmVwbGFjZXIiLCJzcGFjZXIiLCJpbmRlbnRhdGlvbiIsInRvSlNPTiIsImluZGV4T2YiLCJqb2luIiwib3JpZ2luYWxJbmRlbnRhdGlvbiIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkiLCJNYXRoIiwibWluIiwidG1wIiwicmVtb3ZlZEtleXMiLCJwb3AiLCJrZXlzIiwia2V5TGVuZ3RoIiwibWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSIsImlzRmluaXRlIiwic3RyaW5naWZ5QXJyYXlSZXBsYWNlciIsInN0cmluZ2lmeUluZGVudCIsInNsaWNlIiwic3RyaW5naWZ5U2ltcGxlIiwic3BhY2UiLCJhcmd1bWVudHMiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/safe-stable-stringify/index.js\n");

/***/ })

};
;