"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile";
exports.ids = ["vendor-chunks/@solana-mobile"];
exports.modules = {

/***/ "(ssr)/../node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transact: () => (/* binding */ transact)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol */ \"(ssr)/../node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/bs58/index.js\");\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction fromUint8Array(byteArray) {\n    return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction getPayloadFromTransaction(transaction) {\n    const serializedTransaction = \"version\" in transaction ? transaction.serialize() : transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n    });\n    const payload = fromUint8Array(serializedTransaction);\n    return payload;\n}\nfunction getTransactionFromWireMessage(byteArray) {\n    const numSignatures = byteArray[0];\n    const messageOffset = numSignatures * _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SIGNATURE_LENGTH_IN_BYTES + 1;\n    const version = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));\n    if (version === \"legacy\") {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(byteArray);\n    } else {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(byteArray);\n    }\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const augmentedCallback = (wallet)=>{\n            const augmentedAPI = new Proxy({}, {\n                get (target, p) {\n                    if (target[p] == null) {\n                        switch(p){\n                            case \"signAndSendTransactions\":\n                                target[p] = function(_a) {\n                                    var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a, rest = __rest(_a, [\n                                        \"minContextSlot\",\n                                        \"commitment\",\n                                        \"skipPreflight\",\n                                        \"maxRetries\",\n                                        \"waitForCommitmentToSendNextTransaction\",\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const options = {\n                                            min_context_slot: minContextSlot,\n                                            commitment: commitment,\n                                            skip_preflight: skipPreflight,\n                                            max_retries: maxRetries,\n                                            wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction\n                                        };\n                                        const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), Object.values(options).some((element)=>element != null) ? {\n                                            options: options\n                                        } : null), {\n                                            payloads\n                                        }));\n                                        const signatures = base64EncodedSignatures.map(toUint8Array).map(bs58__WEBPACK_IMPORTED_MODULE_2__.encode);\n                                        return signatures;\n                                    });\n                                };\n                                break;\n                            case \"signMessages\":\n                                target[p] = function(_a) {\n                                    var { payloads } = _a, rest = __rest(_a, [\n                                        \"payloads\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const base64EncodedPayloads = payloads.map(fromUint8Array);\n                                        const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), {\n                                            payloads: base64EncodedPayloads\n                                        }));\n                                        const signedMessages = base64EncodedSignedMessages.map(toUint8Array);\n                                        return signedMessages;\n                                    });\n                                };\n                                break;\n                            case \"signTransactions\":\n                                target[p] = function(_a) {\n                                    var { transactions } = _a, rest = __rest(_a, [\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), {\n                                            payloads\n                                        }));\n                                        const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array);\n                                        const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);\n                                        return signedTransactions;\n                                    });\n                                };\n                                break;\n                            default:\n                                {\n                                    target[p] = wallet[p];\n                                    break;\n                                }\n                        }\n                    }\n                    return target[p];\n                },\n                defineProperty () {\n                    return false;\n                },\n                deleteProperty () {\n                    return false;\n                }\n            });\n            return callback(augmentedAPI);\n        };\n        return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transact)(augmentedCallback, config);\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlIO0FBQzFCO0FBQy9EO0FBRXhCOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTTyxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBRUEsU0FBU1csVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFL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cUNBQWU7b0NBQzdELE9BQU92RCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO3dDQUNuQyxNQUFNK0QsV0FBV0YsYUFBYWhDLEdBQUcsQ0FBQ0c7d0NBQ2xDLE1BQU0sRUFBRThDLGlCQUFpQkksaUNBQWlDLEVBQUUsR0FBRyxNQUFNaEMsT0FBT2lDLGdCQUFnQixDQUFDNUYsT0FBT2lGLE1BQU0sQ0FBQ2pGLE9BQU9pRixNQUFNLENBQUMsQ0FBQyxHQUFHVixPQUFPOzRDQUFFQzt3Q0FBUzt3Q0FDL0ksTUFBTXFCLHVCQUF1QkYsa0NBQWtDckQsR0FBRyxDQUFDTDt3Q0FDbkUsTUFBTTZELHFCQUFxQkQscUJBQXFCdkQsR0FBRyxDQUFDVTt3Q0FDcEQsT0FBTzhDO29DQUNYO2dDQUNKO2dDQUNBOzRCQUNKO2dDQUFTO29DQUNML0IsTUFBTSxDQUFDaEUsRUFBRSxHQUFHNEQsTUFBTSxDQUFDNUQsRUFBRTtvQ0FDckI7Z0NBQ0o7d0JBQ0o7b0JBQ0o7b0JBQ0EsT0FBT2dFLE1BQU0sQ0FBQ2hFLEVBQUU7Z0JBQ3BCO2dCQUNBZ0c7b0JBQ0ksT0FBTztnQkFDWDtnQkFDQUM7b0JBQ0ksT0FBTztnQkFDWDtZQUNKO1lBQ0EsT0FBT3hDLFNBQVNJO1FBQ3BCO1FBQ0EsT0FBTyxNQUFNbkUsdUZBQVVBLENBQUNpRSxtQkFBbUJEO0lBQy9DO0FBQ0o7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMvbGliL2VzbS9pbmRleC5qcz85OGRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlcnNpb25lZE1lc3NhZ2UsIFRyYW5zYWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyB0cmFuc2FjdCBhcyB0cmFuc2FjdCQxIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBmcm9tVWludDhBcnJheShieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5jYWxsKG51bGwsIC4uLmJ5dGVBcnJheSkpO1xufVxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSAndmVyc2lvbicgaW4gdHJhbnNhY3Rpb25cbiAgICAgICAgPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICAgICAgICA6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGZyb21VaW50OEFycmF5KHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZShieXRlQXJyYXkpIHtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gYnl0ZUFycmF5WzBdO1xuICAgIGNvbnN0IG1lc3NhZ2VPZmZzZXQgPSBudW1TaWduYXR1cmVzICogU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyArIDE7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihieXRlQXJyYXkuc2xpY2UobWVzc2FnZU9mZnNldCwgYnl0ZUFycmF5Lmxlbmd0aCkpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShieXRlQXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKGJ5dGVBcnJheSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNhY3QoY2FsbGJhY2ssIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGF1Z21lbnRlZENhbGxiYWNrID0gKHdhbGxldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXVnbWVudGVkQVBJID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25BbmRTZW5kVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBtaW5Db250ZXh0U2xvdCwgY29tbWl0bWVudCwgc2tpcFByZWZsaWdodCwgbWF4UmV0cmllcywgd2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9ucyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm1pbkNvbnRleHRTbG90XCIsIFwiY29tbWl0bWVudFwiLCBcInNraXBQcmVmbGlnaHRcIiwgXCJtYXhSZXRyaWVzXCIsIFwid2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb25cIiwgXCJ0cmFuc2FjdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRyYW5zYWN0aW9ucy5tYXAoZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluX2NvbnRleHRfc2xvdDogbWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfcHJlZmxpZ2h0OiBza2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfcmV0cmllczogbWF4UmV0cmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdF9mb3JfY29tbWl0bWVudF90b19zZW5kX25leHRfdHJhbnNhY3Rpb246IHdhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZXM6IGJhc2U2NEVuY29kZWRTaWduYXR1cmVzIH0gPSB5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCAoT2JqZWN0LnZhbHVlcyhvcHRpb25zKS5zb21lKGVsZW1lbnQgPT4gZWxlbWVudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgb3B0aW9uczogb3B0aW9ucyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMubWFwKHRvVWludDhBcnJheSkubWFwKGJzNTguZW5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduTWVzc2FnZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IHBheWxvYWRzIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wicGF5bG9hZHNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjRFbmNvZGVkUGF5bG9hZHMgPSBwYXlsb2Fkcy5tYXAoZnJvbVVpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkU2lnbmVkTWVzc2FnZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkczogYmFzZTY0RW5jb2RlZFBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlcyA9IGJhc2U2NEVuY29kZWRTaWduZWRNZXNzYWdlcy5tYXAodG9VaW50OEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnblRyYW5zYWN0aW9ucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgdHJhbnNhY3Rpb25zIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widHJhbnNhY3Rpb25zXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0cmFuc2FjdGlvbnMubWFwKGdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMgfSA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIHsgcGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVkVHJhbnNhY3Rpb25zID0gYmFzZTY0RW5jb2RlZENvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IGNvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcChnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IHdhbGxldFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYXVnbWVudGVkQVBJKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRyYW5zYWN0JDEoYXVnbWVudGVkQ2FsbGJhY2ssIGNvbmZpZyk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHRyYW5zYWN0IH07XG4iXSwibmFtZXMiOlsiVmVyc2lvbmVkTWVzc2FnZSIsIlRyYW5zYWN0aW9uIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwidHJhbnNhY3QiLCJ0cmFuc2FjdCQxIiwiYnM1OCIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJmcm9tVWludDhBcnJheSIsImJ5dGVBcnJheSIsIndpbmRvdyIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b1VpbnQ4QXJyYXkiLCJiYXNlNjRFbmNvZGVkQnl0ZUFycmF5IiwiVWludDhBcnJheSIsImF0b2IiLCJzcGxpdCIsIm1hcCIsImMiLCJjaGFyQ29kZUF0IiwiZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwic2VyaWFsaXplIiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJ2ZXJpZnlTaWduYXR1cmVzIiwicGF5bG9hZCIsImdldFRyYW5zYWN0aW9uRnJvbVdpcmVNZXNzYWdlIiwibnVtU2lnbmF0dXJlcyIsIm1lc3NhZ2VPZmZzZXQiLCJ2ZXJzaW9uIiwiZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbiIsInNsaWNlIiwiZnJvbSIsImRlc2VyaWFsaXplIiwiY2FsbGJhY2siLCJjb25maWciLCJhdWdtZW50ZWRDYWxsYmFjayIsIndhbGxldCIsImF1Z21lbnRlZEFQSSIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwiX2EiLCJtaW5Db250ZXh0U2xvdCIsImNvbW1pdG1lbnQiLCJza2lwUHJlZmxpZ2h0IiwibWF4UmV0cmllcyIsIndhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25zIiwicmVzdCIsInBheWxvYWRzIiwib3B0aW9ucyIsIm1pbl9jb250ZXh0X3Nsb3QiLCJza2lwX3ByZWZsaWdodCIsIm1heF9yZXRyaWVzIiwid2FpdF9mb3JfY29tbWl0bWVudF90b19zZW5kX25leHRfdHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwiYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9ucyIsImFzc2lnbiIsInZhbHVlcyIsInNvbWUiLCJlbGVtZW50IiwiZW5jb2RlIiwiYmFzZTY0RW5jb2RlZFBheWxvYWRzIiwic2lnbmVkX3BheWxvYWRzIiwiYmFzZTY0RW5jb2RlZFNpZ25lZE1lc3NhZ2VzIiwic2lnbk1lc3NhZ2VzIiwic2lnbmVkTWVzc2FnZXMiLCJiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMiLCJzaWduVHJhbnNhY3Rpb25zIiwiY29tcGlsZWRUcmFuc2FjdGlvbnMiLCJzaWduZWRUcmFuc2FjdGlvbnMiLCJkZWZpbmVQcm9wZXJ0eSIsImRlbGV0ZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: () => (/* binding */ SolanaCloneAuthorization),\n/* harmony export */   SolanaMobileWalletAdapterError: () => (/* binding */ SolanaMobileWalletAdapterError),\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: () => (/* binding */ SolanaMobileWalletAdapterErrorCode),\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: () => (/* binding */ SolanaMobileWalletAdapterProtocolError),\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: () => (/* binding */ SolanaMobileWalletAdapterProtocolErrorCode),\n/* harmony export */   SolanaSignInWithSolana: () => (/* binding */ SolanaSignInWithSolana),\n/* harmony export */   SolanaSignTransactions: () => (/* binding */ SolanaSignTransactions),\n/* harmony export */   transact: () => (/* binding */ transact)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: \"ERROR_ASSOCIATION_PORT_OUT_OF_RANGE\",\n    ERROR_FORBIDDEN_WALLET_BASE_URL: \"ERROR_FORBIDDEN_WALLET_BASE_URL\",\n    ERROR_SECURE_CONTEXT_REQUIRED: \"ERROR_SECURE_CONTEXT_REQUIRED\",\n    ERROR_SESSION_CLOSED: \"ERROR_SESSION_CLOSED\",\n    ERROR_SESSION_TIMEOUT: \"ERROR_SESSION_TIMEOUT\",\n    ERROR_WALLET_NOT_FOUND: \"ERROR_WALLET_NOT_FOUND\",\n    ERROR_INVALID_PROTOCOL_VERSION: \"ERROR_INVALID_PROTOCOL_VERSION\"\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args){\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaMobileWalletAdapterError\";\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args){\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = \"SolanaMobileWalletAdapterProtocolError\";\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const publicKeyBuffer = yield crypto.subtle.exportKey(\"raw\", ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({\n            hash: \"SHA-256\",\n            name: \"ECDSA\"\n        }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\nfunction encode(input) {\n    return window.btoa(input);\n}\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64(payload) {\n    return encode(createSIWSMessage(payload));\n}\n// optional features\nconst SolanaSignTransactions = \"solana:signTransactions\";\nconst SolanaCloneAuthorization = \"solana:cloneAuthorization\";\nconst SolanaSignInWithSolana = \"solana:signInWithSolana\";\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */ function createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get (target, p) {\n            if (target[p] == null) {\n                target[p] = function(inputParams) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === \"authorize\" && params.sign_in_payload && !result.sign_in_result) {\n                            result[\"sign_in_result\"] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty () {\n            return false;\n        },\n        deleteProperty () {\n            return false;\n        }\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */ function handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName.toString().replace(/[A-Z]/g, (letter)=>`_${letter.toLowerCase()}`).toLowerCase();\n    switch(methodName){\n        case \"authorize\":\n            {\n                let { chain } = params;\n                if (protocolVersion === \"legacy\") {\n                    switch(chain){\n                        case \"solana:testnet\":\n                            {\n                                chain = \"testnet\";\n                                break;\n                            }\n                        case \"solana:devnet\":\n                            {\n                                chain = \"devnet\";\n                                break;\n                            }\n                        case \"solana:mainnet\":\n                            {\n                                chain = \"mainnet-beta\";\n                                break;\n                            }\n                        default:\n                            {\n                                chain = params.cluster;\n                            }\n                    }\n                    params.cluster = chain;\n                } else {\n                    switch(chain){\n                        case \"testnet\":\n                        case \"devnet\":\n                            {\n                                chain = `solana:${chain}`;\n                                break;\n                            }\n                        case \"mainnet-beta\":\n                            {\n                                chain = \"solana:mainnet\";\n                                break;\n                            }\n                    }\n                    params.chain = chain;\n                }\n            }\n        case \"reauthorize\":\n            {\n                const { auth_token, identity } = params;\n                if (auth_token) {\n                    switch(protocolVersion){\n                        case \"legacy\":\n                            {\n                                method = \"reauthorize\";\n                                params = {\n                                    auth_token: auth_token,\n                                    identity: identity\n                                };\n                                break;\n                            }\n                        default:\n                            {\n                                method = \"authorize\";\n                                break;\n                            }\n                    }\n                }\n                break;\n            }\n    }\n    return {\n        method,\n        params\n    };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */ function handleMobileWalletResponse(method, response, protocolVersion) {\n    switch(method){\n        case \"getCapabilities\":\n            {\n                const capabilities = response;\n                switch(protocolVersion){\n                    case \"legacy\":\n                        {\n                            const features = [\n                                SolanaSignTransactions\n                            ];\n                            if (capabilities.supports_clone_authorization === true) {\n                                features.push(SolanaCloneAuthorization);\n                            }\n                            return Object.assign(Object.assign({}, capabilities), {\n                                features: features\n                            });\n                        }\n                    case \"v1\":\n                        {\n                            return Object.assign(Object.assign({}, capabilities), {\n                                supports_sign_and_send_transactions: true,\n                                supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization)\n                            });\n                        }\n                }\n            }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function*() {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), {\n            domain,\n            address\n        }));\n        const signMessageResult = yield protocolRequestHandler(\"sign_messages\", {\n            addresses: [\n                address\n            ],\n            payloads: [\n                siwsMessage\n            ]\n        });\n        const signInResult = {\n            address: address,\n            signed_message: siwsMessage,\n            signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)\n        };\n        return signInResult;\n    });\n}\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error(\"Outbound sequence number overflow. The maximum sequence number is 32-bytes.\");\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: \"AES-GCM\",\n        tagLength: 128\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder(\"utf-8\");\n    }\n    return _utf8Decoder;\n}\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield crypto.subtle.generateKey({\n            name: \"ECDSA\",\n            namedCurve: \"P-256\"\n        }, false, [\n            \"sign\"\n        ]);\n    });\n}\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield crypto.subtle.generateKey({\n            name: \"ECDH\",\n            namedCurve: \"P-256\"\n        }, false, [\n            \"deriveKey\",\n            \"deriveBits\"\n        ]);\n    });\n}\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, \"error\")) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\nfunction parseHelloRsp(payloadBuffer, associationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey(\"raw\", associationPublicKey),\n            crypto.subtle.importKey(\"raw\", payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), {\n                name: \"ECDH\",\n                namedCurve: \"P-256\"\n            }, false, [])\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({\n            name: \"ECDH\",\n            public: walletPublicKey\n        }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey(\"raw\", sharedSecret, \"HKDF\", false, [\n            \"deriveKey\"\n        ]);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array()\n        }, ecdhSecretKey, {\n            name: \"AES-GCM\",\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return aesKeyMaterialVal;\n    });\n}\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = \"legacy\";\n        if (Object.hasOwnProperty.call(jsonProperties, \"v\")) {\n            switch(jsonProperties.v){\n                case 1:\n                case \"1\":\n                case \"v1\":\n                    protocolVersion = \"v1\";\n                    break;\n                case \"legacy\":\n                    protocolVersion = \"legacy\";\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return {\n            protocol_version: protocolVersion\n        };\n    });\n}\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, {\n            port\n        });\n    }\n    return port;\n}\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = \"\";\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for(let ii = 0; ii < len; ii++){\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m)=>({\n            \"/\": \"_\",\n            \"+\": \"-\",\n            \"=\": \".\"\n        })[m]);\n}\nconst INTENT_NAME = \"solana-wallet\";\nfunction getPathParts(pathString) {\n    return pathString// Strip leading and trailing slashes\n    .replace(/(^\\/+|\\/+$)/g, \"\")// Return an array of directories\n    .split(\"/\");\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        } catch (_a) {} // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== \"https:\") {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Base URLs supplied by wallets must be valid `https` URLs\");\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith(\"/\") ? methodPathname : [\n        ...getPathParts(baseUrl.pathname),\n        ...getPathParts(methodPathname)\n    ].join(\"/\");\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = [\n    \"v1\"\n]) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey(\"raw\", associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL(\"v1/associate/local\", associationURLBase);\n        url.searchParams.set(\"association\", getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set(\"port\", `${associationPort}`);\n        protocolVersions.forEach((version)=>{\n            url.searchParams.set(\"v\", version);\n        });\n        return url;\n    });\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf(\"Firefox/\") !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject)=>{\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener(\"blur\", handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener(\"blur\", handleBlur);\n        const timeoutId = setTimeout(()=>{\n            cleanup();\n            reject();\n        }, 2000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement(\"iframe\");\n        _frame.style.display = \"none\";\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        if (associationUrl.protocol === \"https:\") {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        } else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch(browser){\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        break;\n                    case Browser.Other:\n                        {\n                            const detectionPromise = getDetectionPromise();\n                            window.location.assign(associationUrl);\n                            yield detectionPromise;\n                            break;\n                        }\n                    default:\n                        assertUnreachable(browser);\n                }\n            } catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, \"Found no installed wallet that supports the mobile wallet protocol.\");\n            }\n        }\n        return randomAssociationPort;\n    });\n}\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */ retryDelayScheduleMs: [\n        150,\n        150,\n        200,\n        500,\n        500,\n        750,\n        750,\n        1000\n    ],\n    timeoutMs: 30000\n};\nconst WEBSOCKET_PROTOCOL = \"com.solana.mobilewalletadapter.v1\";\nfunction assertSecureContext() {\n    if (true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, \"The mobile wallet adapter protocol must be used in a secure context (`https`).\");\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    } catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Invalid base URL supplied by wallet\");\n    }\n    if (url.protocol !== \"https:\") {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Base URLs supplied by wallets must be valid `https` URLs\");\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (()=>{\n            const schedule = [\n                ...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs\n            ];\n            return ()=>schedule.length > 1 ? schedule.shift() : schedule[0];\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = {\n            __type: \"disconnected\"\n        };\n        return new Promise((resolve, reject)=>{\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = ()=>__awaiter(this, void 0, void 0, function*() {\n                    if (state.__type !== \"connecting\") {\n                        console.warn(\"Expected adapter state to be `connecting` at the moment the websocket opens. \" + `Got \\`${state.__type}\\`.`);\n                        return;\n                    }\n                    const { associationKeypair } = state;\n                    socket.removeEventListener(\"open\", handleOpen);\n                    const ecdhKeypair = yield generateECDHKeypair();\n                    socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                    state = {\n                        __type: \"hello_req_sent\",\n                        associationPublicKey: associationKeypair.publicKey,\n                        ecdhPrivateKey: ecdhKeypair.privateKey\n                    };\n                });\n            const handleClose = (evt)=>{\n                if (evt.wasClean) {\n                    state = {\n                        __type: \"disconnected\"\n                    };\n                } else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, {\n                        closeEvent: evt\n                    }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt)=>__awaiter(this, void 0, void 0, function*() {\n                    disposeSocket();\n                    if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket on port ${sessionPort}.`));\n                    } else {\n                        yield new Promise((resolve)=>{\n                            const retryDelayMs = getNextRetryDelayMs();\n                            retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                        });\n                        attemptSocketConnection();\n                    }\n                });\n            const handleMessage = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                    const responseBuffer = yield evt.data.arrayBuffer();\n                    switch(state.__type){\n                        case \"connected\":\n                            try {\n                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                    throw new Error(\"Encrypted message has invalid sequence number\");\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                responsePromise.resolve(jsonRpcMessage.result);\n                            } catch (e) {\n                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    responsePromise.reject(e);\n                                } else {\n                                    throw e;\n                                }\n                            }\n                            break;\n                        case \"hello_req_sent\":\n                            {\n                                const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                                const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                                const sessionProperties = sessionPropertiesBuffer.byteLength !== 0 ? yield (()=>__awaiter(this, void 0, void 0, function*() {\n                                        const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                        const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                        if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                            throw new Error(\"Encrypted message has invalid sequence number\");\n                                        }\n                                        lastKnownInboundSequenceNumber = sequenceNumber;\n                                        return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                    }))() : {\n                                    protocol_version: \"legacy\"\n                                };\n                                state = {\n                                    __type: \"connected\",\n                                    sharedSecret,\n                                    sessionProperties\n                                };\n                                const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params)=>__awaiter(this, void 0, void 0, function*() {\n                                        const id = nextJsonRpcMessageId++;\n                                        socket.send((yield encryptJsonRpcMessage({\n                                            id,\n                                            jsonrpc: \"2.0\",\n                                            method,\n                                            params: params !== null && params !== void 0 ? params : {}\n                                        }, sharedSecret)));\n                                        return new Promise((resolve, reject)=>{\n                                            jsonRpcResponsePromises[id] = {\n                                                resolve (result) {\n                                                    switch(method){\n                                                        case \"authorize\":\n                                                        case \"reauthorize\":\n                                                            {\n                                                                const { wallet_uri_base } = result;\n                                                                if (wallet_uri_base != null) {\n                                                                    try {\n                                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                                    } catch (e) {\n                                                                        reject(e);\n                                                                        return;\n                                                                    }\n                                                                }\n                                                                break;\n                                                            }\n                                                    }\n                                                    resolve(result);\n                                                },\n                                                reject\n                                            };\n                                        });\n                                    }));\n                                try {\n                                    resolve((yield callback(wallet)));\n                                } catch (e) {\n                                    reject(e);\n                                } finally{\n                                    disposeSocket();\n                                    socket.close();\n                                }\n                                break;\n                            }\n                    }\n                });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = ()=>{\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = {\n                    __type: \"connecting\",\n                    associationKeypair\n                };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [\n                    WEBSOCKET_PROTOCOL\n                ]);\n                socket.addEventListener(\"open\", handleOpen);\n                socket.addEventListener(\"close\", handleClose);\n                socket.addEventListener(\"error\", handleError);\n                socket.addEventListener(\"message\", handleMessage);\n                disposeSocket = ()=>{\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"close\", handleClose);\n                    socket.removeEventListener(\"error\", handleError);\n                    socket.removeEventListener(\"message\", handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1RTtBQUV2RSwrRUFBK0U7QUFDL0UsTUFBTUMscUNBQXFDO0lBQ3ZDQyxxQ0FBcUM7SUFDckNDLGlDQUFpQztJQUNqQ0MsK0JBQStCO0lBQy9CQyxzQkFBc0I7SUFDdEJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxnQ0FBZ0M7QUFDcEM7QUFDQSxNQUFNQyx1Q0FBdUNDO0lBQ3pDQyxZQUFZLEdBQUdDLElBQUksQ0FBRTtRQUNqQixNQUFNLENBQUNDLE1BQU1DLFNBQVNDLEtBQUssR0FBR0g7UUFDOUIsS0FBSyxDQUFDRTtRQUNOLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0UsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQSwrRUFBK0U7QUFDL0UsTUFBTUMsNkNBQTZDO0lBQy9DLDhFQUE4RTtJQUM5RUMsNEJBQTRCLENBQUM7SUFDN0JDLHdCQUF3QixDQUFDO0lBQ3pCQyxrQkFBa0IsQ0FBQztJQUNuQkMscUJBQXFCLENBQUM7SUFDdEJDLHlCQUF5QixDQUFDO0lBQzFCQyw2QkFBNkIsQ0FBQztBQUNsQztBQUNBLE1BQU1DLCtDQUErQ2Q7SUFDakRDLFlBQVksR0FBR0MsSUFBSSxDQUFFO1FBQ2pCLE1BQU0sQ0FBQ2Esa0JBQWtCWixNQUFNQyxTQUFTQyxLQUFLLEdBQUdIO1FBQ2hELEtBQUssQ0FBQ0U7UUFDTixJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNFLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNVLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNULElBQUksR0FBRztJQUNoQjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLFNBQVNV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QVdrRTtnQkFDMUM7WUFDSjtZQUNBRDtRQUNKO0lBQ0o7QUFDSjtBQUVzUCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanM/NTg3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwnO1xuXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlID0ge1xuICAgIEVSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFOiAnRVJST1JfQVNTT0NJQVRJT05fUE9SVF9PVVRfT0ZfUkFOR0UnLFxuICAgIEVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkw6ICdFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMJyxcbiAgICBFUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRDogJ0VSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVEJyxcbiAgICBFUlJPUl9TRVNTSU9OX0NMT1NFRDogJ0VSUk9SX1NFU1NJT05fQ0xPU0VEJyxcbiAgICBFUlJPUl9TRVNTSU9OX1RJTUVPVVQ6ICdFUlJPUl9TRVNTSU9OX1RJTUVPVVQnLFxuICAgIEVSUk9SX1dBTExFVF9OT1RfRk9VTkQ6ICdFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EJyxcbiAgICBFUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT046ICdFUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04nLFxufTtcbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IFtjb2RlLCBtZXNzYWdlLCBkYXRhXSA9IGFyZ3M7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJztcbiAgICB9XG59XG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvckNvZGUgPSB7XG4gICAgLy8gS2VlcCB0aGVzZSBpbiBzeW5jIHdpdGggYG1vYmlsZXdhbGxldGFkYXB0ZXIvY29tbW9uL1Byb3RvY29sQ29udHJhY3QuamF2YWAuXG4gICAgRVJST1JfQVVUSE9SSVpBVElPTl9GQUlMRUQ6IC0xLFxuICAgIEVSUk9SX0lOVkFMSURfUEFZTE9BRFM6IC0yLFxuICAgIEVSUk9SX05PVF9TSUdORUQ6IC0zLFxuICAgIEVSUk9SX05PVF9TVUJNSVRURUQ6IC00LFxuICAgIEVSUk9SX1RPT19NQU5ZX1BBWUxPQURTOiAtNSxcbiAgICBFUlJPUl9BVFRFU1RfT1JJR0lOX0FORFJPSUQ6IC0xMDAsXG59O1xuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBbanNvblJwY01lc3NhZ2VJZCwgY29kZSwgbWVzc2FnZSwgZGF0YV0gPSBhcmdzO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5qc29uUnBjTWVzc2FnZUlkID0ganNvblJwY01lc3NhZ2VJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yJztcbiAgICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVIZWxsb1JlcShlY2RoUHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXJQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0geWllbGQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGVjZGhQdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLnNpZ24oeyBoYXNoOiAnU0hBLTI1NicsIG5hbWU6ICdFQ0RTQScgfSwgYXNzb2NpYXRpb25LZXlwYWlyUHJpdmF0ZUtleSwgcHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgVWludDhBcnJheShwdWJsaWNLZXlCdWZmZXIuYnl0ZUxlbmd0aCArIHNpZ25hdHVyZUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlciksIDApO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQnVmZmVyKSwgcHVibGljS2V5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgIHJldHVybiB3aW5kb3cuYnRvYShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNJV1NNZXNzYWdlKHBheWxvYWQpIHtcbiAgICByZXR1cm4gY3JlYXRlU2lnbkluTWVzc2FnZVRleHQocGF5bG9hZCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTSVdTTWVzc2FnZUJhc2U2NChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGVuY29kZShjcmVhdGVTSVdTTWVzc2FnZShwYXlsb2FkKSk7XG59XG5cbi8vIG9wdGlvbmFsIGZlYXR1cmVzXG5jb25zdCBTb2xhbmFTaWduVHJhbnNhY3Rpb25zID0gJ3NvbGFuYTpzaWduVHJhbnNhY3Rpb25zJztcbmNvbnN0IFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbiA9ICdzb2xhbmE6Y2xvbmVBdXRob3JpemF0aW9uJztcbmNvbnN0IFNvbGFuYVNpZ25JbldpdGhTb2xhbmEgPSAnc29sYW5hOnNpZ25JbldpdGhTb2xhbmEnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTW9iaWxlV2FsbGV0fSBwcm94eSB0aGF0IGhhbmRsZXMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYW5kIEFQSSB0byBSUEMgY29udmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEBwYXJhbSBwcm90b2NvbFJlcXVlc3RIYW5kbGVyIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBzZW5kaW5nIHRoZSBSUEMgcmVxdWVzdCB0byB0aGUgd2FsbGV0IGVuZHBvaW50LlxuICogQHJldHVybnMgYSB7QGxpbmsgTW9iaWxlV2FsbGV0fSBwcm94eVxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2JpbGVXYWxsZXRQcm94eShwcm90b2NvbFZlcnNpb24sIHByb3RvY29sUmVxdWVzdEhhbmRsZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGdldCh0YXJnZXQsIHApIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRbcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChpbnB1dFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtZXRob2QsIHBhcmFtcyB9ID0gaGFuZGxlTW9iaWxlV2FsbGV0UmVxdWVzdChwLCBpbnB1dFBhcmFtcywgcHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb3RvY29sUmVxdWVzdEhhbmRsZXIobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3QgdHJpZWQgdG8gc2lnbiBpbiBidXQgdGhlIHdhbGxldCBkaWQgbm90IHJldHVybiBhIHNpZ24gaW4gcmVzdWx0LCBmYWxsYmFjayBvbiBtZXNzYWdlIHNpZ25pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdhdXRob3JpemUnICYmIHBhcmFtcy5zaWduX2luX3BheWxvYWQgJiYgIXJlc3VsdC5zaWduX2luX3Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnc2lnbl9pbl9yZXN1bHQnXSA9IHlpZWxkIHNpZ25JbkZhbGxiYWNrKHBhcmFtcy5zaWduX2luX3BheWxvYWQsIHJlc3VsdCwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTW9iaWxlV2FsbGV0UmVzcG9uc2UocCwgcmVzdWx0LCBwcm90b2NvbFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBIYW5kbGVzIGFsbCB7QGxpbmsgTW9iaWxlV2FsbGV0fSBBUEkgcmVxdWVzdHMgYW5kIGRldGVybWluZXMgdGhlIGNvcnJlY3QgTVdBIFJQQyBtZXRob2QgYW5kIHBhcmFtcyB0byBjYWxsLlxuICogVGhpcyBoYW5kbGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgQHByb3RvY29sVmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSB0aGUgbmFtZSBvZiB7QGxpbmsgTW9iaWxlV2FsbGV0fSBtZXRob2QgdGhhdCB3YXMgY2FsbGVkXG4gKiBAcGFyYW0gbWV0aG9kUGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICogQHBhcmFtIHByb3RvY29sVmVyc2lvbiB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbiB1c2UgZm9yIHRoaXMgc2Vzc2lvbi9yZXF1ZXN0XG4gKiBAcmV0dXJucyB0aGUgUlBDIHJlcXVlc3QgbWV0aG9kIGFuZCBwYXJhbXMgdGhhdCBzaG91bGQgYmUgc2VudCB0byB0aGUgd2FsbGV0IGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vYmlsZVdhbGxldFJlcXVlc3QobWV0aG9kTmFtZSwgbWV0aG9kUGFyYW1zLCBwcm90b2NvbFZlcnNpb24pIHtcbiAgICBsZXQgcGFyYW1zID0gbWV0aG9kUGFyYW1zO1xuICAgIGxldCBtZXRob2QgPSBtZXRob2ROYW1lXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC5yZXBsYWNlKC9bQS1aXS9nLCAobGV0dGVyKSA9PiBgXyR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9YClcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoIChtZXRob2ROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgIGxldCB7IGNoYWluIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29sYW5hOnRlc3RuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9ICd0ZXN0bmV0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTpkZXZuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9ICdkZXZuZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29sYW5hOm1haW5uZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9ICdtYWlubmV0LWJldGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSBwYXJhbXMuY2x1c3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuY2x1c3RlciA9IGNoYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFpbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXN0bmV0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGV2bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSBgc29sYW5hOiR7Y2hhaW59YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21haW5uZXQtYmV0YSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ3NvbGFuYTptYWlubmV0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jaGFpbiA9IGNoYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRoX3Rva2VuLCBpZGVudGl0eSB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgaWYgKGF1dGhfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWdhY3knOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSAncmVhdXRob3JpemUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyBhdXRoX3Rva2VuOiBhdXRoX3Rva2VuLCBpZGVudGl0eTogaWRlbnRpdHkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdhdXRob3JpemUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtZXRob2QsIHBhcmFtcyB9O1xufVxuLyoqXG4gKiBIYW5kbGVzIGFsbCB7QGxpbmsgTW9iaWxlV2FsbGV0fSBBUEkgcmVzcG9uc2VzIGFuZCBtb2RpZmllcyB0aGUgcmVzcG9uc2UgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBpZiBuZWVkZWRcbiAqXG4gKiBAcGFyYW0gbWV0aG9kIHRoZSB7QGxpbmsgTW9iaWxlV2FsbGV0fSBtZXRob2QgdGhhdCB3YXMgY2FsbGVkXG4gKiBAcGFyYW0gcmVzcG9uc2UgdGhlIG9yaWdpbmFsIHJlc3BvbnNlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSBtZXRob2QgY2FsbFxuICogQHBhcmFtIHByb3RvY29sVmVyc2lvbiB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbiB1c2UgZm9yIHRoaXMgc2Vzc2lvbi9yZXF1ZXN0XG4gKiBAcmV0dXJucyB0aGUgcG9zc2libHkgbW9kaWZpZWQgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9iaWxlV2FsbGV0UmVzcG9uc2UobWV0aG9kLCByZXNwb25zZSwgcHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSAnZ2V0Q2FwYWJpbGl0aWVzJzoge1xuICAgICAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBzd2l0Y2ggKHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBbU29sYW5hU2lnblRyYW5zYWN0aW9uc107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMuc3VwcG9ydHNfY2xvbmVfYXV0aG9yaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhcGFiaWxpdGllcyksIHsgZmVhdHVyZXM6IGZlYXR1cmVzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd2MSc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FwYWJpbGl0aWVzKSwgeyBzdXBwb3J0c19zaWduX2FuZF9zZW5kX3RyYW5zYWN0aW9uczogdHJ1ZSwgc3VwcG9ydHNfY2xvbmVfYXV0aG9yaXphdGlvbjogY2FwYWJpbGl0aWVzLmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbikgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIHNpZ25JbkZhbGxiYWNrKHNpZ25JblBheWxvYWQsIGF1dGhvcml6YXRpb25SZXN1bHQsIHByb3RvY29sUmVxdWVzdEhhbmRsZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZG9tYWluID0gKF9hID0gc2lnbkluUGF5bG9hZC5kb21haW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50c1swXS5hZGRyZXNzO1xuICAgICAgICBjb25zdCBzaXdzTWVzc2FnZSA9IGNyZWF0ZVNJV1NNZXNzYWdlQmFzZTY0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2lnbkluUGF5bG9hZCksIHsgZG9tYWluLCBhZGRyZXNzIH0pKTtcbiAgICAgICAgY29uc3Qgc2lnbk1lc3NhZ2VSZXN1bHQgPSB5aWVsZCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKCdzaWduX21lc3NhZ2VzJywge1xuICAgICAgICAgICAgYWRkcmVzc2VzOiBbYWRkcmVzc10sXG4gICAgICAgICAgICBwYXlsb2FkczogW3Npd3NNZXNzYWdlXVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbkluUmVzdWx0ID0ge1xuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIHNpZ25lZF9tZXNzYWdlOiBzaXdzTWVzc2FnZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbk1lc3NhZ2VSZXN1bHQuc2lnbmVkX3BheWxvYWRzWzBdLnNsaWNlKHNpd3NNZXNzYWdlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNpZ25JblJlc3VsdDtcbiAgICB9KTtcbn1cblxuY29uc3QgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTID0gNDtcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlTnVtYmVyVmVjdG9yKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgaWYgKHNlcXVlbmNlTnVtYmVyID49IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRib3VuZCBzZXF1ZW5jZSBudW1iZXIgb3ZlcmZsb3cuIFRoZSBtYXhpbXVtIHNlcXVlbmNlIG51bWJlciBpcyAzMi1ieXRlcy4nKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IEFycmF5QnVmZmVyKFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhieXRlQXJyYXkpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIHNlcXVlbmNlTnVtYmVyLCAvKiBsaXR0bGVFbmRpYW4gKi8gZmFsc2UpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlQXJyYXkpO1xufVxuXG5jb25zdCBJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMgPSAxMjtcbmNvbnN0IEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMgPSA2NTtcbmZ1bmN0aW9uIGVuY3J5cHRNZXNzYWdlKHBsYWludGV4dCwgc2VxdWVuY2VOdW1iZXIsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gY3JlYXRlU2VxdWVuY2VOdW1iZXJWZWN0b3Ioc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IG5ldyBVaW50OEFycmF5KElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0geWllbGQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlclZlY3RvciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpLCBzaGFyZWRTZWNyZXQsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwbGFpbnRleHQpKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgVWludDhBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvci5ieXRlTGVuZ3RoICsgaW5pdGlhbGl6YXRpb25WZWN0b3IuYnl0ZUxlbmd0aCArIGNpcGhlcnRleHQuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShzZXF1ZW5jZU51bWJlclZlY3RvciksIDApO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoaW5pdGlhbGl6YXRpb25WZWN0b3IpLCBzZXF1ZW5jZU51bWJlclZlY3Rvci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpLCBzZXF1ZW5jZU51bWJlclZlY3Rvci5ieXRlTGVuZ3RoICsgaW5pdGlhbGl6YXRpb25WZWN0b3IuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gbWVzc2FnZS5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IG1lc3NhZ2Uuc2xpY2UoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTLCBTRVFVRU5DRV9OVU1CRVJfQllURVMgKyBJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbWVzc2FnZS5zbGljZShTRVFVRU5DRV9OVU1CRVJfQllURVMgKyBJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHRCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyVmVjdG9yLCBpbml0aWFsaXphdGlvblZlY3RvciksIHNoYXJlZFNlY3JldCwgY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IGdldFV0ZjhEZWNvZGVyKCkuZGVjb2RlKHBsYWludGV4dEJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXIsIGluaXRpYWxpemF0aW9uVmVjdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkaXRpb25hbERhdGE6IHNlcXVlbmNlTnVtYmVyLFxuICAgICAgICBpdjogaW5pdGlhbGl6YXRpb25WZWN0b3IsXG4gICAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgICAgdGFnTGVuZ3RoOiAxMjgsIC8vIDE2IGJ5dGUgdGFnID0+IDEyOCBiaXRzXG4gICAgfTtcbn1cbmxldCBfdXRmOERlY29kZXI7XG5mdW5jdGlvbiBnZXRVdGY4RGVjb2RlcigpIHtcbiAgICBpZiAoX3V0ZjhEZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3V0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgIH1cbiAgICByZXR1cm4gX3V0ZjhEZWNvZGVyO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUFzc29jaWF0aW9uS2V5cGFpcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnRUNEU0EnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnc2lnbiddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRUNESEtleXBhaXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0VDREgnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZGVyaXZlS2V5JywgJ2Rlcml2ZUJpdHMnXSAvKiBrZXlVc2FnZXMgKi8pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0SnNvblJwY01lc3NhZ2UoanNvblJwY01lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IEpTT04uc3RyaW5naWZ5KGpzb25ScGNNZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBqc29uUnBjTWVzc2FnZS5pZDtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRNZXNzYWdlKHBsYWludGV4dCwgc2VxdWVuY2VOdW1iZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0SnNvblJwY01lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0geWllbGQgZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSBKU09OLnBhcnNlKHBsYWludGV4dCk7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChqc29uUnBjTWVzc2FnZSwgJ2Vycm9yJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcihqc29uUnBjTWVzc2FnZS5pZCwganNvblJwY01lc3NhZ2UuZXJyb3IuY29kZSwganNvblJwY01lc3NhZ2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25ScGNNZXNzYWdlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlbGxvUnNwKHBheWxvYWRCdWZmZXIsIC8vIFRoZSBYOS42Mi1lbmNvZGVkIHdhbGxldCBlbmRwb2ludCBlcGhlbWVyYWwgRUNESCBwdWJsaWMga2V5cG9pbnQuXG5hc3NvY2lhdGlvblB1YmxpY0tleSwgZWNkaFByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBbYXNzb2NpYXRpb25QdWJsaWNLZXlCdWZmZXIsIHdhbGxldFB1YmxpY0tleV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpLFxuICAgICAgICAgICAgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHBheWxvYWRCdWZmZXIuc2xpY2UoMCwgRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyksIHsgbmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbXSAvKiBrZXlVc2FnZXMgKi8pLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHsgbmFtZTogJ0VDREgnLCBwdWJsaWM6IHdhbGxldFB1YmxpY0tleSB9LCBlY2RoUHJpdmF0ZUtleSwgMjU2KTtcbiAgICAgICAgY29uc3QgZWNkaFNlY3JldEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBzaGFyZWRTZWNyZXQsICdIS0RGJywgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZGVyaXZlS2V5J10gLyoga2V5VXNhZ2VzICovKTtcbiAgICAgICAgY29uc3QgYWVzS2V5TWF0ZXJpYWxWYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgICAgICBzYWx0OiBuZXcgVWludDhBcnJheShhc3NvY2lhdGlvblB1YmxpY0tleUJ1ZmZlciksXG4gICAgICAgICAgICBpbmZvOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9LCBlY2RoU2VjcmV0S2V5LCB7IG5hbWU6ICdBRVMtR0NNJywgbGVuZ3RoOiAxMjggfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgICAgICByZXR1cm4gYWVzS2V5TWF0ZXJpYWxWYWw7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vzc2lvblByb3BzKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IHlpZWxkIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIGNvbnN0IGpzb25Qcm9wZXJ0aWVzID0gSlNPTi5wYXJzZShwbGFpbnRleHQpO1xuICAgICAgICBsZXQgcHJvdG9jb2xWZXJzaW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChqc29uUHJvcGVydGllcywgJ3YnKSkge1xuICAgICAgICAgICAgc3dpdGNoIChqc29uUHJvcGVydGllcy52KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3YxJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gJ3YxJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04sIGBVbmtub3duL3Vuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7anNvblByb3BlcnRpZXMudn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHByb3RvY29sX3ZlcnNpb246IHByb3RvY29sVmVyc2lvblxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tQXNzb2NpYXRpb25Qb3J0KCkge1xuICAgIHJldHVybiBhc3NlcnRBc3NvY2lhdGlvblBvcnQoNDkxNTIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoNjU1MzUgLSA0OTE1MiArIDEpKSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBc3NvY2lhdGlvblBvcnQocG9ydCkge1xuICAgIGlmIChwb3J0IDwgNDkxNTIgfHwgcG9ydCA+IDY1NTM1KSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRSwgYEFzc29jaWF0aW9uIHBvcnQgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiA0OTE1MiBhbmQgNjU1MzUuICR7cG9ydH0gZ2l2ZW4uYCwgeyBwb3J0IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9ydDtcbn1cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk0NTg5OTYvODAyMDQ3XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGJ1ZmZlcikge1xuICAgIGxldCBiaW5hcnkgPSAnJztcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2lpXSk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYnRvYShiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKHVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmcpIHtcbiAgICByZXR1cm4gdW5zYWZlQmFzZTY0RW5jb2RlZFN0cmluZy5yZXBsYWNlKC9bLys9XS9nLCAobSkgPT4gKHtcbiAgICAgICAgJy8nOiAnXycsXG4gICAgICAgICcrJzogJy0nLFxuICAgICAgICAnPSc6ICcuJyxcbiAgICB9W21dKSk7XG59XG5cbmNvbnN0IElOVEVOVF9OQU1FID0gJ3NvbGFuYS13YWxsZXQnO1xuZnVuY3Rpb24gZ2V0UGF0aFBhcnRzKHBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gKHBhdGhTdHJpbmdcbiAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgICAucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCAnJylcbiAgICAgICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIGRpcmVjdG9yaWVzXG4gICAgICAgIC5zcGxpdCgnLycpKTtcbn1cbmZ1bmN0aW9uIGdldEludGVudFVSTChtZXRob2RQYXRobmFtZSwgaW50ZW50VXJsQmFzZSkge1xuICAgIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgICBpZiAoaW50ZW50VXJsQmFzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFzZVVybCA9IG5ldyBVUkwoaW50ZW50VXJsQmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICBpZiAoKGJhc2VVcmwgPT09IG51bGwgfHwgYmFzZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFzZVVybC5wcm90b2NvbCkgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFzZVVybCB8fCAoYmFzZVVybCA9IG5ldyBVUkwoYCR7SU5URU5UX05BTUV9Oi9gKSk7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBtZXRob2RQYXRobmFtZS5zdGFydHNXaXRoKCcvJylcbiAgICAgICAgPyAvLyBNZXRob2QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gUmVwbGFjZSBpdCB3aG9sZXNhbGUuXG4gICAgICAgICAgICBtZXRob2RQYXRobmFtZVxuICAgICAgICA6IC8vIE1ldGhvZCBpcyBhIHJlbGF0aXZlIHBhdGguIE1lcmdlIGl0IHdpdGggdGhlIGV4aXN0aW5nIG9uZS5cbiAgICAgICAgICAgIFsuLi5nZXRQYXRoUGFydHMoYmFzZVVybC5wYXRobmFtZSksIC4uLmdldFBhdGhQYXJ0cyhtZXRob2RQYXRobmFtZSldLmpvaW4oJy8nKTtcbiAgICByZXR1cm4gbmV3IFVSTChwYXRobmFtZSwgYmFzZVVybCk7XG59XG5mdW5jdGlvbiBnZXRBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCBwdXRhdGl2ZVBvcnQsIGFzc29jaWF0aW9uVVJMQmFzZSwgcHJvdG9jb2xWZXJzaW9ucyA9IFsndjEnXSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uUG9ydCA9IGFzc2VydEFzc29jaWF0aW9uUG9ydChwdXRhdGl2ZVBvcnQpO1xuICAgICAgICBjb25zdCBleHBvcnRlZEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBhc3NvY2lhdGlvblB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGV4cG9ydGVkS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0SW50ZW50VVJMKCd2MS9hc3NvY2lhdGUvbG9jYWwnLCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYXNzb2NpYXRpb24nLCBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKGVuY29kZWRLZXkpKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3BvcnQnLCBgJHthc3NvY2lhdGlvblBvcnR9YCk7XG4gICAgICAgIHByb3RvY29sVmVyc2lvbnMuZm9yRWFjaCgodmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3YnLCB2ZXJzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSk7XG59XG5cbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IEJyb3dzZXIgPSB7XG4gICAgRmlyZWZveDogMCxcbiAgICBPdGhlcjogMSxcbn07XG5mdW5jdGlvbiBhc3NlcnRVbnJlYWNoYWJsZSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBnZXRCcm93c2VyKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gvJykgIT09IC0xID8gQnJvd3Nlci5GaXJlZm94IDogQnJvd3Nlci5PdGhlcjtcbn1cbmZ1bmN0aW9uIGdldERldGVjdGlvblByb21pc2UoKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBvdGhlcnMgc2lsZW50bHkgZmFpbCBpZiBhIGN1c3RvbSBwcm90b2NvbCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIC8vIEZvciB0aGVzZSwgd2Ugd2FpdCB0byBzZWUgaWYgdGhlIGJyb3dzZXIgaXMgbmF2aWdhdGVkIGF3YXkgZnJvbSBpblxuICAgIC8vIGEgcmVhc29uYWJsZSBhbW91bnQgb2YgdGltZSAoaWUuIHRoZSBuYXRpdmUgd2FsbGV0IG9wZW5lZCkuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cik7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sIDIwMDApO1xuICAgIH0pO1xufVxubGV0IF9mcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUodXJsKSB7XG4gICAgaWYgKF9mcmFtZSA9PSBudWxsKSB7XG4gICAgICAgIF9mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBfZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfZnJhbWUpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIF9mcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0U2Vzc2lvbihhc3NvY2lhdGlvblB1YmxpY0tleSwgYXNzb2NpYXRpb25VUkxCYXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmFuZG9tQXNzb2NpYXRpb25Qb3J0ID0gZ2V0UmFuZG9tQXNzb2NpYXRpb25Qb3J0KCk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uVXJsID0geWllbGQgZ2V0QXNzb2NpYXRlQW5kcm9pZEludGVudFVSTChhc3NvY2lhdGlvblB1YmxpY0tleSwgcmFuZG9tQXNzb2NpYXRpb25Qb3J0LCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICBpZiAoYXNzb2NpYXRpb25VcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGlzIGFuIEFuZHJvaWQgJ0FwcCBMaW5rJyBvciBpT1MgJ1VuaXZlcnNhbCBMaW5rJy5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSByZWd1bGFyIHdlYiBVUkxzIHRoYXQgYXJlIGRlc2lnbmVkIHRvIGxhdW5jaCBhbiBhcHAgaWYgaXRcbiAgICAgICAgICAgIC8vIGlzIGluc3RhbGxlZCBvciBsb2FkIHRoZSBhY3R1YWwgdGFyZ2V0IHdlYnBhZ2UgaWYgbm90LlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhc3NvY2lhdGlvblVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGhhcyBhIGN1c3RvbSBwcm90b2NvbCAoZWcuIGBzb2xhbmEtd2FsbGV0OmApXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChicm93c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5GaXJlZm94OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZCBpbiBGaXJlZm94LCBpdCB0aHJvd3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGlzIGxpbmUsIGl0J3Mgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5PdGhlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0aW9uUHJvbWlzZSA9IGdldERldGVjdGlvblByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZGV0ZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShicm93c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9XQUxMRVRfTk9UX0ZPVU5ELCAnRm91bmQgbm8gaW5zdGFsbGVkIHdhbGxldCB0aGF0IHN1cHBvcnRzIHRoZSBtb2JpbGUgd2FsbGV0IHByb3RvY29sLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5kb21Bc3NvY2lhdGlvblBvcnQ7XG4gICAgfSk7XG59XG5cbmNvbnN0IFdFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRyA9IHtcbiAgICAvKipcbiAgICAgKiAzMDAgbWlsbGlzZWNvbmRzIGlzIGEgZ2VuZXJhbGx5IGFjY2VwdGVkIHRocmVzaG9sZCBmb3Igd2hhdCBzb21lb25lXG4gICAgICogd291bGQgY29uc2lkZXIgYW4gYWNjZXB0YWJsZSByZXNwb25zZSB0aW1lIGZvciBhIHVzZXIgaW50ZXJmYWNlXG4gICAgICogYWZ0ZXIgaGF2aW5nIHBlcmZvcm1lZCBhIGxvdy1hdHRlbnRpb24gdGFwcGluZyB0YXNrLiBXZSBzZXQgdGhlIGluaXRpYWxcbiAgICAgKiBpbnRlcnZhbCBhdCB3aGljaCB3ZSB3YWl0IGZvciB0aGUgd2FsbGV0IHRvIHNldCB1cCB0aGUgd2Vic29ja2V0IGF0XG4gICAgICogaGFsZiB0aGlzLCBhcyBwZXIgdGhlIE55cXVpc3QgZnJlcXVlbmN5LCB3aXRoIGEgcHJvZ3Jlc3NpdmUgYmFja29mZlxuICAgICAqIHNlcXVlbmNlIGZyb20gdGhlcmUuIFRoZSB0b3RhbCB3YWl0IHRpbWUgaXMgMzBzLCB3aGljaCBhbGxvd3MgZm9yIHRoZVxuICAgICAqIHVzZXIgdG8gYmUgcHJlc2VudGVkIHdpdGggYSBkaXNhbWJpZ3VhdGlvbiBkaWFsb2csIHNlbGVjdCBhIHdhbGxldCwgYW5kXG4gICAgICogZm9yIHRoZSB3YWxsZXQgYXBwIHRvIHN1YnNlcXVlbnRseSBzdGFydC5cbiAgICAgKi9cbiAgICByZXRyeURlbGF5U2NoZWR1bGVNczogWzE1MCwgMTUwLCAyMDAsIDUwMCwgNTAwLCA3NTAsIDc1MCwgMTAwMF0sXG4gICAgdGltZW91dE1zOiAzMDAwMCxcbn07XG5jb25zdCBXRUJTT0NLRVRfUFJPVE9DT0wgPSAnY29tLnNvbGFuYS5tb2JpbGV3YWxsZXRhZGFwdGVyLnYxJztcbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUNvbnRleHQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVELCAnVGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciBwcm90b2NvbCBtdXN0IGJlIHVzZWQgaW4gYSBzZWN1cmUgY29udGV4dCAoYGh0dHBzYCkuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRVcmlCYXNlKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHdhbGxldFVyaUJhc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdJbnZhbGlkIGJhc2UgVVJMIHN1cHBsaWVkIGJ5IHdhbGxldCcpO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5KTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIoMCwgLyogbGl0dGxlRW5kaWFuICovIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHRyYW5zYWN0KGNhbGxiYWNrLCBjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBhc3NlcnRTZWN1cmVDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25Qb3J0ID0geWllbGQgc3RhcnRTZXNzaW9uKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5iYXNlVXJpKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzOi8vbG9jYWxob3N0OiR7c2Vzc2lvblBvcnR9L3NvbGFuYS13YWxsZXRgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBzdGF0ZSA9IHsgX190eXBlOiAnZGlzY29ubmVjdGVkJyB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBqc29uUnBjUmVzcG9uc2VQcm9taXNlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlT3BlbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuX190eXBlICE9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeHBlY3RlZCBhZGFwdGVyIHN0YXRlIHRvIGJlIGBjb25uZWN0aW5nYCBhdCB0aGUgbW9tZW50IHRoZSB3ZWJzb2NrZXQgb3BlbnMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEdvdCBcXGAke3N0YXRlLl9fdHlwZX1cXGAuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhc3NvY2lhdGlvbktleXBhaXIgfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IG9uIHBvcnQgJHtzZXNzaW9uUG9ydH0uYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5RGVsYXlNcyA9IGdldE5leHRSZXRyeURlbGF5TXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5V2FpdFRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0U29ja2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUJ1ZmZlciA9IHlpZWxkIGV2dC5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5fX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSByZXNwb25zZUJ1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uUnBjTWVzc2FnZSA9IHlpZWxkIGRlY3J5cHRKc29uUnBjTWVzc2FnZShyZXNwb25zZUJ1ZmZlciwgc3RhdGUuc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2pzb25ScGNNZXNzYWdlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShqc29uUnBjTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVsbG9fcmVxX3NlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSB5aWVsZCBwYXJzZUhlbGxvUnNwKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5hc3NvY2lhdGlvblB1YmxpY0tleSwgc3RhdGUuZWNkaFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIgPSByZXNwb25zZUJ1ZmZlci5zbGljZShFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geWllbGQgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBzZXNzaW9uUHJvcGVydGllc0J1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciAhPT0gKGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTZXNzaW9uUHJvcHMoc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCkgOiB7IHByb3RvY29sX3ZlcnNpb246ICdsZWdhY3knIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGVkJywgc2hhcmVkU2VjcmV0LCBzZXNzaW9uUHJvcGVydGllcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkoc2Vzc2lvblByb3BlcnRpZXMucHJvdG9jb2xfdmVyc2lvbiwgKG1ldGhvZCwgcGFyYW1zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0SnNvblJwY01lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHlpZWxkIGVuY3J5cHRKc29uUnBjTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZFNlY3JldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0aG9yaXplJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdhbGxldF91cmlfYmFzZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldF91cmlfYmFzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRfdXJpX2Jhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHlpZWxkIGNhbGxiYWNrKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2VTb2NrZXQ7XG4gICAgICAgICAgICBsZXQgcmV0cnlXYWl0VGltZW91dElkO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2VTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGluZycsIGFzc29jaWF0aW9uS2V5cGFpciB9O1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldyBXZWJTb2NrZXQod2Vic29ja2V0VVJMLCBbV0VCU09DS0VUX1BST1RPQ09MXSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBoYW5kbGVDbG9zZSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyZXRyeVdhaXRUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBoYW5kbGVDbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24sIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZSwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yQ29kZSwgU29sYW5hU2lnbkluV2l0aFNvbGFuYSwgU29sYW5hU2lnblRyYW5zYWN0aW9ucywgdHJhbnNhY3QgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUiLCJFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRSIsIkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwiLCJFUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCIsIkVSUk9SX1NFU1NJT05fQ0xPU0VEIiwiRVJST1JfU0VTU0lPTl9USU1FT1VUIiwiRVJST1JfV0FMTEVUX05PVF9GT1VORCIsIkVSUk9SX0lOVkFMSURfUFJPVE9DT0xfVkVSU0lPTiIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiY29kZSIsIm1lc3NhZ2UiLCJkYXRhIiwibmFtZSIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yQ29kZSIsIkVSUk9SX0FVVEhPUklaQVRJT05fRkFJTEVEIiwiRVJST1JfSU5WQUxJRF9QQVlMT0FEUyIsIkVSUk9SX05PVF9TSUdORUQiLCJFUlJPUl9OT1RfU1VCTUlUVEVEIiwiRVJST1JfVE9PX01BTllfUEFZTE9BRFMiLCJFUlJPUl9BVFRFU1RfT1JJR0lOX0FORFJPSUQiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciIsImpzb25ScGNNZXNzYWdlSWQiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJjcmVhdGVIZWxsb1JlcSIsImVjZGhQdWJsaWNLZXkiLCJhc3NvY2lhdGlvbktleXBhaXJQcml2YXRlS2V5IiwicHVibGljS2V5QnVmZmVyIiwiY3J5cHRvIiwic3VidGxlIiwiZXhwb3J0S2V5Iiwic2lnbmF0dXJlQnVmZmVyIiwic2lnbiIsImhhc2giLCJyZXNwb25zZSIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwic2V0IiwiZW5jb2RlIiwiaW5wdXQiLCJ3aW5kb3ciLCJidG9hIiwiY3JlYXRlU0lXU01lc3NhZ2UiLCJwYXlsb2FkIiwiY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjQiLCJTb2xhbmFTaWduVHJhbnNhY3Rpb25zIiwiU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uIiwiU29sYW5hU2lnbkluV2l0aFNvbGFuYSIsImNyZWF0ZU1vYmlsZVdhbGxldFByb3h5IiwicHJvdG9jb2xWZXJzaW9uIiwicHJvdG9jb2xSZXF1ZXN0SGFuZGxlciIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicCIsImlucHV0UGFyYW1zIiwibWV0aG9kIiwicGFyYW1zIiwiaGFuZGxlTW9iaWxlV2FsbGV0UmVxdWVzdCIsInNpZ25faW5fcGF5bG9hZCIsInNpZ25faW5fcmVzdWx0Iiwic2lnbkluRmFsbGJhY2siLCJoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZSIsImRlZmluZVByb3BlcnR5IiwiZGVsZXRlUHJvcGVydHkiLCJtZXRob2ROYW1lIiwibWV0aG9kUGFyYW1zIiwidG9TdHJpbmciLCJyZXBsYWNlIiwibGV0dGVyIiwidG9Mb3dlckNhc2UiLCJjaGFpbiIsImNsdXN0ZXIiLCJhdXRoX3Rva2VuIiwiaWRlbnRpdHkiLCJjYXBhYmlsaXRpZXMiLCJmZWF0dXJlcyIsInN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb24iLCJwdXNoIiwiT2JqZWN0IiwiYXNzaWduIiwic3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnMiLCJpbmNsdWRlcyIsInNpZ25JblBheWxvYWQiLCJhdXRob3JpemF0aW9uUmVzdWx0IiwiX2EiLCJkb21haW4iLCJsb2NhdGlvbiIsImhvc3QiLCJhZGRyZXNzIiwiYWNjb3VudHMiLCJzaXdzTWVzc2FnZSIsInNpZ25NZXNzYWdlUmVzdWx0IiwiYWRkcmVzc2VzIiwicGF5bG9hZHMiLCJzaWduSW5SZXN1bHQiLCJzaWduZWRfbWVzc2FnZSIsInNpZ25hdHVyZSIsInNpZ25lZF9wYXlsb2FkcyIsInNsaWNlIiwibGVuZ3RoIiwiU0VRVUVOQ0VfTlVNQkVSX0JZVEVTIiwiY3JlYXRlU2VxdWVuY2VOdW1iZXJWZWN0b3IiLCJzZXF1ZW5jZU51bWJlciIsImJ5dGVBcnJheSIsIkFycmF5QnVmZmVyIiwidmlldyIsIkRhdGFWaWV3Iiwic2V0VWludDMyIiwiSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTIiwiRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyIsImVuY3J5cHRNZXNzYWdlIiwicGxhaW50ZXh0Iiwic2hhcmVkU2VjcmV0Iiwic2VxdWVuY2VOdW1iZXJWZWN0b3IiLCJpbml0aWFsaXphdGlvblZlY3RvciIsImdldFJhbmRvbVZhbHVlcyIsImNpcGhlcnRleHQiLCJlbmNyeXB0IiwiZ2V0QWxnb3JpdGhtUGFyYW1zIiwiVGV4dEVuY29kZXIiLCJkZWNyeXB0TWVzc2FnZSIsInBsYWludGV4dEJ1ZmZlciIsImRlY3J5cHQiLCJnZXRVdGY4RGVjb2RlciIsImRlY29kZSIsImFkZGl0aW9uYWxEYXRhIiwiaXYiLCJ0YWdMZW5ndGgiLCJfdXRmOERlY29kZXIiLCJ1bmRlZmluZWQiLCJUZXh0RGVjb2RlciIsImdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyIiwiZ2VuZXJhdGVLZXkiLCJuYW1lZEN1cnZlIiwiZ2VuZXJhdGVFQ0RIS2V5cGFpciIsImVuY3J5cHRKc29uUnBjTWVzc2FnZSIsImpzb25ScGNNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImlkIiwiZGVjcnlwdEpzb25ScGNNZXNzYWdlIiwicGFyc2UiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJlcnJvciIsInBhcnNlSGVsbG9Sc3AiLCJwYXlsb2FkQnVmZmVyIiwiYXNzb2NpYXRpb25QdWJsaWNLZXkiLCJlY2RoUHJpdmF0ZUtleSIsImFzc29jaWF0aW9uUHVibGljS2V5QnVmZmVyIiwid2FsbGV0UHVibGljS2V5IiwiYWxsIiwiaW1wb3J0S2V5IiwiZGVyaXZlQml0cyIsInB1YmxpYyIsImVjZGhTZWNyZXRLZXkiLCJhZXNLZXlNYXRlcmlhbFZhbCIsImRlcml2ZUtleSIsInNhbHQiLCJpbmZvIiwicGFyc2VTZXNzaW9uUHJvcHMiLCJqc29uUHJvcGVydGllcyIsInYiLCJwcm90b2NvbF92ZXJzaW9uIiwiZ2V0UmFuZG9tQXNzb2NpYXRpb25Qb3J0IiwiYXNzZXJ0QXNzb2NpYXRpb25Qb3J0IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicG9ydCIsImFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmciLCJidWZmZXIiLCJiaW5hcnkiLCJieXRlcyIsImxlbiIsImlpIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZCIsInVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmciLCJtIiwiSU5URU5UX05BTUUiLCJnZXRQYXRoUGFydHMiLCJwYXRoU3RyaW5nIiwic3BsaXQiLCJnZXRJbnRlbnRVUkwiLCJtZXRob2RQYXRobmFtZSIsImludGVudFVybEJhc2UiLCJiYXNlVXJsIiwiVVJMIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsInN0YXJ0c1dpdGgiLCJqb2luIiwiZ2V0QXNzb2NpYXRlQW5kcm9pZEludGVudFVSTCIsInB1dGF0aXZlUG9ydCIsImFzc29jaWF0aW9uVVJMQmFzZSIsInByb3RvY29sVmVyc2lvbnMiLCJhc3NvY2lhdGlvblBvcnQiLCJleHBvcnRlZEtleSIsImVuY29kZWRLZXkiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwidmVyc2lvbiIsIkJyb3dzZXIiLCJGaXJlZm94IiwiT3RoZXIiLCJhc3NlcnRVbnJlYWNoYWJsZSIsIngiLCJnZXRCcm93c2VyIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImdldERldGVjdGlvblByb21pc2UiLCJjbGVhbnVwIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dElkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZUJsdXIiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsIl9mcmFtZSIsImxhdW5jaFVybFRocm91Z2hIaWRkZW5GcmFtZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnRXaW5kb3ciLCJocmVmIiwic3RhcnRTZXNzaW9uIiwicmFuZG9tQXNzb2NpYXRpb25Qb3J0IiwiYXNzb2NpYXRpb25VcmwiLCJicm93c2VyIiwiZGV0ZWN0aW9uUHJvbWlzZSIsIldFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRyIsInJldHJ5RGVsYXlTY2hlZHVsZU1zIiwidGltZW91dE1zIiwiV0VCU09DS0VUX1BST1RPQ09MIiwiYXNzZXJ0U2VjdXJlQ29udGV4dCIsImlzU2VjdXJlQ29udGV4dCIsImFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkiLCJ3YWxsZXRVcmlCYXNlIiwiZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5IiwiZ2V0VWludDMyIiwidHJhbnNhY3QiLCJjYWxsYmFjayIsImNvbmZpZyIsImFzc29jaWF0aW9uS2V5cGFpciIsInNlc3Npb25Qb3J0IiwicHVibGljS2V5IiwiYmFzZVVyaSIsIndlYnNvY2tldFVSTCIsImNvbm5lY3Rpb25TdGFydFRpbWUiLCJnZXROZXh0UmV0cnlEZWxheU1zIiwic2NoZWR1bGUiLCJzaGlmdCIsIm5leHRKc29uUnBjTWVzc2FnZUlkIiwibGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyIiwic3RhdGUiLCJfX3R5cGUiLCJzb2NrZXQiLCJqc29uUnBjUmVzcG9uc2VQcm9taXNlcyIsImhhbmRsZU9wZW4iLCJjb25zb2xlIiwid2FybiIsImVjZGhLZXlwYWlyIiwic2VuZCIsInByaXZhdGVLZXkiLCJoYW5kbGVDbG9zZSIsImV2dCIsIndhc0NsZWFuIiwicmVhc29uIiwiY2xvc2VFdmVudCIsImRpc3Bvc2VTb2NrZXQiLCJoYW5kbGVFcnJvciIsIl9ldnQiLCJEYXRlIiwibm93IiwicmV0cnlEZWxheU1zIiwicmV0cnlXYWl0VGltZW91dElkIiwiYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24iLCJoYW5kbGVNZXNzYWdlIiwicmVzcG9uc2VCdWZmZXIiLCJhcnJheUJ1ZmZlciIsInJlc3BvbnNlUHJvbWlzZSIsInNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyIiwic2Vzc2lvblByb3BlcnRpZXMiLCJ3YWxsZXQiLCJqc29ucnBjIiwid2FsbGV0X3VyaV9iYXNlIiwiY2xvc2UiLCJXZWJTb2NrZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaMobileWalletAdapter: () => (/* binding */ SolanaMobileWalletAdapter),\n/* harmony export */   SolanaMobileWalletAdapterWalletName: () => (/* binding */ SolanaMobileWalletAdapterWalletName),\n/* harmony export */   createDefaultAddressSelector: () => (/* binding */ createDefaultAddressSelector),\n/* harmony export */   createDefaultAuthorizationResultCache: () => (/* binding */ createDefaultAuthorizationResultCache),\n/* harmony export */   createDefaultWalletNotFoundHandler: () => (/* binding */ createDefaultWalletNotFoundHandler)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol-web3js */ \"(ssr)/../node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\");\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction getIsSupported() {\n    return  false && 0;\n}\nconst SolanaMobileWalletAdapterWalletName = \"Mobile Wallet Adapter\";\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction getPublicKeyFromAddress(address) {\n    const publicKeyByteArray = toUint8Array(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\nfunction isVersionedTransaction(transaction) {\n    return \"version\" in transaction;\n}\nclass SolanaMobileWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config){\n        var _a;\n        super();\n        this.supportedTransactionVersions = new Set(// FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        [\n            \"legacy\",\n            0\n        ]);\n        this.name = SolanaMobileWalletAdapterWalletName;\n        this.url = \"https://solanamobile.com/wallets\";\n        this.icon = \"data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==\";\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */ this._connectionGeneration = 0;\n        this._readyState = getIsSupported() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : config.cluster;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult)=>{\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress(this._selectedAddress);\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed) {\n            this.emit(\"readyStateChange\", this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed);\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                return yield callback();\n            } catch (e) {\n                this.emit(\"error\", e);\n                throw e;\n            }\n        });\n    }\n    /** @deprecated Use `autoConnect()` instead. */ autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.autoConnect();\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                        if (cachedAuthorizationResult) {\n                            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                            this.handleAuthorizationResult(cachedAuthorizationResult);\n                        }\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        yield this.performAuthorization();\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        const authorizationResult = yield wallet.authorize({\n                            chain: this._chain,\n                            identity: this._appIdentity,\n                            sign_in_payload: signInPayload\n                        });\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        Promise.all([\n                            this._authorizationResultCache.set(authorizationResult),\n                            this.handleAuthorizationResult(authorizationResult)\n                        ]);\n                        return authorizationResult;\n                    }));\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const didPublicKeysChange = // Case 1: We started from having no authorization.\n            this._authorizationResult == null || // Case 2: The number of authorized accounts changed.\n            ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length || // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n            this._authorizationResult.accounts.some((account, ii)=>account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address })=>address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit(\"connect\", // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult)\n                ]);\n            } catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            this.emit(\"disconnect\");\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const config = walletUriBase ? {\n                baseUri: walletUriBase\n            } : undefined;\n            const currentConnectionGeneration = this._connectionGeneration;\n            try {\n                return yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transact)(callback, config);\n            } catch (e) {\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(()=>{}); // Never resolve.\n                }\n                if (e instanceof Error && e.name === \"SolanaMobileWalletAdapterError\" && e.code === \"ERROR_WALLET_NOT_FOUND\") {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.performReauthorization(wallet, authToken);\n                        const signedTransactions = yield wallet.signTransactions({\n                            transactions\n                        });\n                        return signedTransactions;\n                    }));\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken } = this.assertIsAuthorized();\n                    const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                function getTargetCommitment() {\n                                    let targetCommitment;\n                                    switch(connection.commitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetCommitment = connection.commitment;\n                                            break;\n                                        default:\n                                            targetCommitment = \"finalized\";\n                                    }\n                                    let targetPreflightCommitment;\n                                    switch(options === null || options === void 0 ? void 0 : options.preflightCommitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetPreflightCommitment = options.preflightCommitment;\n                                            break;\n                                        case undefined:\n                                            targetPreflightCommitment = targetCommitment;\n                                            break;\n                                        default:\n                                            targetPreflightCommitment = \"finalized\";\n                                    }\n                                    const preflightCommitmentScore = targetPreflightCommitment === \"finalized\" ? 2 : targetPreflightCommitment === \"confirmed\" ? 1 : 0;\n                                    const targetCommitmentScore = targetCommitment === \"finalized\" ? 2 : targetCommitment === \"confirmed\" ? 1 : 0;\n                                    return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n                                }\n                                const [capabilities, _1, _2] = yield Promise.all([\n                                    wallet.getCapabilities(),\n                                    this.performReauthorization(wallet, authToken),\n                                    isVersionedTransaction(transaction) ? null : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */ (()=>__awaiter(this, void 0, void 0, function*() {\n                                            var _a;\n                                            transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                            if (transaction.recentBlockhash == null) {\n                                                const { blockhash } = yield connection.getLatestBlockhash({\n                                                    commitment: getTargetCommitment()\n                                                });\n                                                transaction.recentBlockhash = blockhash;\n                                            }\n                                        }))()\n                                ]);\n                                if (capabilities.supports_sign_and_send_transactions) {\n                                    const signatures = yield wallet.signAndSendTransactions({\n                                        minContextSlot,\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    return signatures[0];\n                                } else {\n                                    const [signedTransaction] = yield wallet.signTransactions({\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    if (isVersionedTransaction(signedTransaction)) {\n                                        return yield connection.sendTransaction(signedTransaction);\n                                    } else {\n                                        const serializedTransaction = signedTransaction.serialize();\n                                        return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                                            preflightCommitment: getTargetCommitment()\n                                        }));\n                                    }\n                                }\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const [signedTransaction] = yield this.performSignTransactions([\n                        transaction\n                    ]);\n                    return signedTransaction;\n                }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const signedTransactions = yield this.performSignTransactions(transactions);\n                    return signedTransactions;\n                }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken, selectedAddress } = this.assertIsAuthorized();\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                yield this.performReauthorization(wallet, authToken);\n                                const [signedMessage] = yield wallet.signMessages({\n                                    addresses: [\n                                        selectedAddress\n                                    ],\n                                    payloads: [\n                                        message\n                                    ]\n                                });\n                                const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);\n                                return signature;\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n                            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n                        }));\n                        if (!authorizationResult.sign_in_result) {\n                            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                        }\n                        const signedInAddress = authorizationResult.sign_in_result.address;\n                        const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find((acc)=>acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                            address: signedInAddress\n                        }), {\n                            publicKey: toUint8Array(signedInAddress)\n                        });\n                        return {\n                            account: signedInAccount,\n                            signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                            signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                        };\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n}\nfunction createDefaultAddressSelector() {\n    return {\n        select (addresses) {\n            return __awaiter(this, void 0, void 0, function*() {\n                return addresses[0];\n            });\n        }\n    };\n}\nconst CACHE_KEY = \"SolanaMobileWalletAdapterDefaultAuthorizationCache\";\nfunction createDefaultAuthorizationResultCache() {\n    let storage;\n    try {\n        storage = window.localStorage;\n    // eslint-disable-next-line no-empty\n    } catch (_a) {}\n    return {\n        clear () {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.removeItem(CACHE_KEY);\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        },\n        get () {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        },\n        set (authorizationResult) {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        }\n    };\n}\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (false) {}\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return defaultWalletNotFoundHandler;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1hZGFwdGVyLW1vYmlsZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBeVM7QUFDN1A7QUFDb0M7QUFFaEY7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLFNBQVNZLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUVBLFNBQVNPLGFBQWFDLHNCQUFzQjtJQUN4QyxPQUFPLElBQUlDLFdBQVdDLE9BQ2pCQyxJQUFJLENBQUNILHdCQUNMSSxLQUFLLENBQUMsSUFDTkMsR0FB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RSxVQUFVLENBQUNKO2dCQUNuQixvQ0FBb0M7Z0JBQ3hDLEVBQ0EsT0FBTy9ILElBQUksQ0FBRTtZQUNqQjtRQUNKO1FBQ0FzQjtZQUNJLE9BQU9sRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUNuQyxJQUFJLENBQUM2SyxTQUFTO29CQUNWO2dCQUNKO2dCQUNBLElBQUk7b0JBQ0EsT0FBT0csS0FBS0MsS0FBSyxDQUFDSixRQUFRSyxPQUFPLENBQUNQLGVBQWU1RDtnQkFDakQsb0NBQW9DO2dCQUN4QyxFQUNBLE9BQU9uRSxJQUFJLENBQUU7WUFDakI7UUFDSjtRQUNBa0QsS0FBSTNCLG1CQUFtQjtZQUNuQixPQUFPbkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDbkMsSUFBSSxDQUFDNkssU0FBUztvQkFDVjtnQkFDSjtnQkFDQSxJQUFJO29CQUNBQSxRQUFRTSxPQUFPLENBQUNSLFdBQVdLLEtBQUtJLFNBQVMsQ0FBQ2pIO2dCQUMxQyxvQ0FBb0M7Z0JBQ3hDLEVBQ0EsT0FBT3ZCLElBQUksQ0FBRTtZQUNqQjtRQUNKO0lBQ0o7QUFDSjtBQUVBLFNBQVN5SSw2QkFBNkJDLG1CQUFtQjtJQUNyRCxPQUFPdEwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDTDtBQUNKO0FBQ0EsU0FBU3VMO0lBQ0wsT0FBT0Y7QUFDWDtBQUVtTCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanM/NmJiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIsIFdhbGxldFJlYWR5U3RhdGUsIFdhbGxldFB1YmxpY0tleUVycm9yLCBXYWxsZXROb3RSZWFkeUVycm9yLCBXYWxsZXRDb25uZWN0aW9uRXJyb3IsIFdhbGxldERpc2Nvbm5lY3RlZEVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduTWVzc2FnZUVycm9yIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyB0cmFuc2FjdCB9IGZyb20gJ0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGdldElzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmlzU2VjdXJlQ29udGV4dCAmJlxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG59XG5cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lID0gJ01vYmlsZSBXYWxsZXQgQWRhcHRlcic7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZUFycmF5ID0gdG9VaW50OEFycmF5KGFkZHJlc3MpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVBcnJheSk7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuICd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbjtcbn1cbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IG5ldyBTZXQoXG4gICAgICAgIC8vIEZJWE1FKCMyNDQpOiBXZSBjYW4ndCBhY3R1YWxseSBrbm93IHdoYXQgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZCB1bnRpbCB3ZSBrbm93IHdoaWNoIHdhbGxldCB3ZSdyZSB0YWxraW5nIHRvLlxuICAgICAgICBbJ2xlZ2FjeScsIDBdKTtcbiAgICAgICAgdGhpcy5uYW1lID0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWU7XG4gICAgICAgIHRoaXMudXJsID0gJ2h0dHBzOi8vc29sYW5hbW9iaWxlLmNvbS93YWxsZXRzJztcbiAgICAgICAgdGhpcy5pY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5Qm1hV3hzUFNKdWIyNWxJaUJvWldsbmFIUTlJakk0SWlCM2FXUjBhRDBpTWpnaUlIWnBaWGRDYjNnOUlpMHpJREFnTWpnZ01qZ2lJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR2NnWm1sc2JEMGlJMFJEUWpoR1JpSStQSEJoZEdnZ1pEMGlUVEUzTGpRZ01UY3VORWd4TlhZeUxqUm9NaTQwZGkweUxqUmFiVEV1TWkwNUxqWm9MVEl1TkhZeUxqUm9NaTQwVmpjdU9Gb2lMejQ4Y0dGMGFDQmtQU0pOTWpFdU5pQXpWakJvTFRJdU5IWXphQzB6TGpaV01HZ3RNaTQwZGpOb0xUSXVOSFkyTGpaSU5DNDFZVEl1TVNBeUxqRWdNQ0F4SURFZ01DMDBMakpvTWk0M1ZqTklOQzQxUVRRdU5TQTBMalVnTUNBd0lEQWdNQ0EzTGpWV01qUm9NakV1Tm5ZdE5pNDJhQzB5TGpSMk5DNHlTREl1TkZZeE1TNDFZeTQxTGpNZ01TNHlMalFnTVM0NExqVm9OeTQxUVRZdU5pQTJMallnTUNBd0lEQWdNalFnT1ZZemFDMHlMalJhYlRBZ05TNDNZVFF1TWlBMExqSWdNQ0F4SURFdE9DNDBJREJXTlM0MGFEZ3VOSFl6TGpOYUlpOCtQQzluUGp3dmMzWm5QZz09JztcbiAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlcnkgdGltZSB0aGUgY29ubmVjdGlvbiBpcyByZWN5Y2xlZCBpbiBzb21lIHdheSAoZWcuIGBkaXNjb25uZWN0KClgIGlzIGNhbGxlZClcbiAgICAgICAgICogaW5jcmVtZW50IHRoaXMgYW5kIHVzZSBpdCB0byBtYWtlIHN1cmUgdGhhdCBgdHJhbnNhY3RgIGNhbGxzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgICAqICdnZW5lcmF0aW9uJyBkb24ndCBjb250aW51ZSB0byBkbyB3b3JrIGFuZCB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gZ2V0SXNTdXBwb3J0ZWQoKSA/IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUgOiBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkO1xuICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUgPSBjb25maWcuYXV0aG9yaXphdGlvblJlc3VsdENhY2hlO1xuICAgICAgICB0aGlzLl9hZGRyZXNzU2VsZWN0b3IgPSBjb25maWcuYWRkcmVzc1NlbGVjdG9yO1xuICAgICAgICB0aGlzLl9hcHBJZGVudGl0eSA9IGNvbmZpZy5hcHBJZGVudGl0eTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSAoX2EgPSBjb25maWcuY2hhaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5jbHVzdGVyO1xuICAgICAgICB0aGlzLl9vbldhbGxldE5vdEZvdW5kID0gY29uZmlnLm9uV2FsbGV0Tm90Rm91bmQ7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCkudGhlbigoYXV0aG9yaXphdGlvblJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBhIHByaW9yIGF1dGhvcml6YXRpb24gcmVzdWx0IGlzLCByaWdodCBub3csIHRoZSBiZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRpb24gdGhhdCBhIG1vYmlsZSB3YWxsZXQgaXMgaW5zdGFsbGVkLiBUaGVyZSBpcyBubyBBUElcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSB0byB0ZXN0IGZvciB3aGV0aGVyIHRoZSBhc3NvY2lhdGlvbiBVUkkgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdWJsaWNLZXkgPT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyh0aGlzLl9zZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXkgPyB0aGlzLl9wdWJsaWNLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpbmc7XG4gICAgfVxuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHlTdGF0ZUNoYW5nZScsICh0aGlzLl9yZWFkeVN0YXRlID0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5XaXRoR3VhcmQoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgYXV0b0Nvbm5lY3QoKWAgaW5zdGVhZC4gKi9cbiAgICBhdXRvQ29ubmVjdF9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuYXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybUF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtQXV0aG9yaXphdGlvbihzaWduSW5QYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IHRoaXMuX2NoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IHRoaXMuX2FwcElkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbl9pbl9wYXlsb2FkOiBzaWduSW5QYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGlkUHVibGljS2V5c0NoYW5nZSA9IFxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBXZSBzdGFydGVkIGZyb20gaGF2aW5nIG5vIGF1dGhvcml6YXRpb24uXG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDI6IFRoZSBudW1iZXIgb2YgYXV0aG9yaXplZCBhY2NvdW50cyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudHMubGVuZ3RoKSAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDM6IFRoZSBuZXcgbGlzdCBvZiBhZGRyZXNzZXMgaXNuJ3QgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgb2xkIGxpc3QsIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMuc29tZSgoYWNjb3VudCwgaWkpID0+IGFjY291bnQuYWRkcmVzcyAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50c1tpaV0uYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID0gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCk7XG4gICAgICAgICAgICBpZiAoZGlkUHVibGljS2V5c0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTZWxlY3RlZEFkZHJlc3MgPSB5aWVsZCB0aGlzLl9hZGRyZXNzU2VsZWN0b3Iuc2VsZWN0KGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMubWFwKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0ZWRBZGRyZXNzICE9PSB0aGlzLl9zZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzID0gbmV4dFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBqdXN0IHNldCBgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzYCwgYHRoaXMucHVibGljS2V5YCBpcyBkZWZpbml0ZWx5IG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aF90b2tlbjogYXV0aFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5fYXBwSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmNsZWFyKCk7IC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24rKztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zYWN0KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldFVyaUJhc2UgPSAoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FsbGV0X3VyaV9iYXNlO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gd2FsbGV0VXJpQmFzZSA/IHsgYmFzZVVyaTogd2FsbGV0VXJpQmFzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uID0gdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0cmFuc2FjdChjYWxsYmFjaywgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uICE9PSBjdXJyZW50Q29ubmVjdGlvbkdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKCkgPT4geyB9KTsgLy8gTmV2ZXIgcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgPT09ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3InICYmXG4gICAgICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gJ0VSUk9SX1dBTExFVF9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX29uV2FsbGV0Tm90Rm91bmQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRJc0F1dGhvcml6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCB8fCAhdGhpcy5fc2VsZWN0ZWRBZGRyZXNzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYXV0aF90b2tlbixcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogdGhpcy5fc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwZXJmb3JtU2lnblRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4gfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluQ29udGV4dFNsb3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbm5lY3Rpb24uY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2NvbmZpcm1lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvbW1pdG1lbnRTY29yZSA9IHRhcmdldENvbW1pdG1lbnQgPT09ICdmaW5hbGl6ZWQnID8gMiA6IHRhcmdldENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA8IHRhcmdldENvbW1pdG1lbnRTY29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NhcGFiaWxpdGllcywgXzEsIF8yXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuZ2V0Q2FwYWJpbGl0aWVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBVbmxpa2UgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucywgbGVnYWN5IGBUcmFuc2FjdGlvbmAgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1heSBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGBmZWVQYXllcmAgb3IgYHJlY2VudEJsb2NraGFzaGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBjb2RlIGV4aXN0cyB0byBwYXRjaCB0aGVtIHVwIGluIGNhc2UgdGhleSBhcmUgbWlzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8ICh0cmFuc2FjdGlvbi5mZWVQYXllciA9IChfYSA9IHRoaXMucHVibGljS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0geWllbGQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogZ2V0VGFyZ2V0Q29tbWl0bWVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCB0aGlzLnBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKFt0cmFuc2FjdGlvbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHRoaXMucGVyZm9ybVNpZ25UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkTWVzc2FnZV0gPSB5aWVsZCB3YWxsZXQuc2lnbk1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFtzZWxlY3RlZEFkZHJlc3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzOiBbbWVzc2FnZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZE1lc3NhZ2Uuc2xpY2UoLVNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25NZXNzYWdlRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduSW4oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtQXV0aG9yaXphdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGlucHV0KSwgeyBkb21haW46IChfYSA9IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC5kb21haW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ob3N0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduIGluIGZhaWxlZCwgbm8gc2lnbiBpbiByZXN1bHQgcmV0dXJuZWQgYnkgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BY2NvdW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2IgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmZpbmQoYWNjID0+IGFjYy5hZGRyZXNzID09IHNpZ25lZEluQWRkcmVzcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHNpZ25lZEluQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICB9KSwgeyBwdWJsaWNLZXk6IHRvVWludDhBcnJheShzaWduZWRJbkFkZHJlc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogc2lnbmVkSW5BY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkTWVzc2FnZTogdG9VaW50OEFycmF5KGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuc2lnbmVkX21lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b1VpbnQ4QXJyYXkoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0KGFkZHJlc3Nlcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuY29uc3QgQ0FDSEVfS0VZID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlJztcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUoKSB7XG4gICAgbGV0IHN0b3JhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yYWdlLmdldEl0ZW0oQ0FDSEVfS0VZKSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShhdXRob3JpemF0aW9uUmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcihtb2JpbGVXYWxsZXRBZGFwdGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKG1vYmlsZVdhbGxldEFkYXB0ZXIudXJsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcjtcbn1cblxuZXhwb3J0IHsgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUsIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IsIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUsIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIgfTtcbiJdLCJuYW1lcyI6WyJCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiLCJXYWxsZXRSZWFkeVN0YXRlIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0Q29ubmVjdGlvbkVycm9yIiwiV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIldhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduTWVzc2FnZUVycm9yIiwiUHVibGljS2V5IiwidHJhbnNhY3QiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJ0b1VpbnQ4QXJyYXkiLCJiYXNlNjRFbmNvZGVkQnl0ZUFycmF5IiwiVWludDhBcnJheSIsIndpbmRvdyIsImF0b2IiLCJzcGxpdCIsIm1hcCIsImMiLCJjaGFyQ29kZUF0IiwiZ2V0SXNTdXBwb3J0ZWQiLCJpc1NlY3VyZUNvbnRleHQiLCJkb2N1bWVudCIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSIsIlNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMiLCJnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyIsImFkZHJlc3MiLCJwdWJsaWNLZXlCeXRlQXJyYXkiLCJpc1ZlcnNpb25lZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJfYSIsInN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMiLCJTZXQiLCJuYW1lIiwidXJsIiwiaWNvbiIsIl9jb25uZWN0aW5nIiwiX2Nvbm5lY3Rpb25HZW5lcmF0aW9uIiwiX3JlYWR5U3RhdGUiLCJMb2FkYWJsZSIsIlVuc3VwcG9ydGVkIiwiX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZSIsImF1dGhvcml6YXRpb25SZXN1bHRDYWNoZSIsIl9hZGRyZXNzU2VsZWN0b3IiLCJhZGRyZXNzU2VsZWN0b3IiLCJfYXBwSWRlbnRpdHkiLCJhcHBJZGVudGl0eSIsIl9jaGFpbiIsImNoYWluIiwiY2x1c3RlciIsIl9vbldhbGxldE5vdEZvdW5kIiwib25XYWxsZXROb3RGb3VuZCIsImdldCIsImF1dGhvcml6YXRpb25SZXN1bHQiLCJkZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQiLCJwdWJsaWNLZXkiLCJfcHVibGljS2V5IiwiX3NlbGVjdGVkQWRkcmVzcyIsIkVycm9yIiwibWVzc2FnZSIsImNvbm5lY3RlZCIsIl9hdXRob3JpemF0aW9uUmVzdWx0IiwiY29ubmVjdGluZyIsInJlYWR5U3RhdGUiLCJJbnN0YWxsZWQiLCJlbWl0IiwicnVuV2l0aEd1YXJkIiwiY2FsbGJhY2siLCJhdXRvQ29ubmVjdF9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiYXV0b0Nvbm5lY3QiLCJjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0IiwiaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCIsImNvbm5lY3QiLCJwZXJmb3JtQXV0aG9yaXphdGlvbiIsInNpZ25JblBheWxvYWQiLCJ3YWxsZXQiLCJhdXRob3JpemUiLCJpZGVudGl0eSIsInNpZ25faW5fcGF5bG9hZCIsImFsbCIsInNldCIsImRpZFB1YmxpY0tleXNDaGFuZ2UiLCJhY2NvdW50cyIsImxlbmd0aCIsInNvbWUiLCJhY2NvdW50IiwiaWkiLCJuZXh0U2VsZWN0ZWRBZGRyZXNzIiwic2VsZWN0IiwicGVyZm9ybVJlYXV0aG9yaXphdGlvbiIsImF1dGhUb2tlbiIsImF1dGhfdG9rZW4iLCJkaXNjb25uZWN0IiwiY2xlYXIiLCJ3YWxsZXRVcmlCYXNlIiwid2FsbGV0X3VyaV9iYXNlIiwiYmFzZVVyaSIsInVuZGVmaW5lZCIsImN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbiIsImNvZGUiLCJhc3NlcnRJc0F1dGhvcml6ZWQiLCJzZWxlY3RlZEFkZHJlc3MiLCJwZXJmb3JtU2lnblRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsInNpZ25UcmFuc2FjdGlvbnMiLCJlcnJvciIsInNlbmRUcmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJvcHRpb25zIiwibWluQ29udGV4dFNsb3QiLCJnZXRUYXJnZXRDb21taXRtZW50IiwidGFyZ2V0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJ0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsInByZWZsaWdodENvbW1pdG1lbnRTY29yZSIsInRhcmdldENvbW1pdG1lbnRTY29yZSIsImNhcGFiaWxpdGllcyIsIl8xIiwiXzIiLCJnZXRDYXBhYmlsaXRpZXMiLCJmZWVQYXllciIsInJlY2VudEJsb2NraGFzaCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zIiwic2lnbmF0dXJlcyIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJPYmplY3QiLCJhc3NpZ24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJzaWduZWRNZXNzYWdlIiwic2lnbk1lc3NhZ2VzIiwiYWRkcmVzc2VzIiwicGF5bG9hZHMiLCJzaWduYXR1cmUiLCJzbGljZSIsInNpZ25JbiIsImlucHV0IiwiX2IiLCJkb21haW4iLCJsb2NhdGlvbiIsImhvc3QiLCJzaWduX2luX3Jlc3VsdCIsInNpZ25lZEluQWRkcmVzcyIsInNpZ25lZEluQWNjb3VudCIsImZpbmQiLCJhY2MiLCJzaWduZWRfbWVzc2FnZSIsImNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IiLCJDQUNIRV9LRVkiLCJjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlIiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJKU09OIiwicGFyc2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImRlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIiLCJtb2JpbGVXYWxsZXRBZGFwdGVyIiwiY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\n");

/***/ })

};
;