/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/borsh";
exports.ids = ["vendor-chunks/borsh"];
exports.modules = {

/***/ "(ssr)/../node_modules/borsh/lib/index.js":
/*!******************************************!*\
  !*** ../node_modules/borsh/lib/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\"));\nconst bs58_1 = __importDefault(__webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/borsh/node_modules/bs58/index.js\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(__webpack_require__(/*! text-encoding-utf-8 */ \"(ssr)/../node_modules/text-encoding-utf-8/lib/encoding.lib.js\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", {\n    fatal: true\n});\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message){\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor(){\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([\n                this.buf,\n                Buffer.alloc(INITIAL_LENGTH)\n            ]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH)\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array){\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function(...args) {\n        try {\n            return originalMethod.apply(this, args);\n        } catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\n                    \"ERR_BUFFER_OUT_OF_BOUNDS\",\n                    \"ERR_OUT_OF_RANGE\"\n                ].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf){\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        } catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for(let i = 0; i < len; ++i){\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        } else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for(let i = 0; i < fieldType[1]; i++){\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            } else {\n                writer.writeArray(value, (item)=>{\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        } else if (fieldType.kind !== undefined) {\n            switch(fieldType.kind){\n                case \"option\":\n                    {\n                        if (value === null || value === undefined) {\n                            writer.writeU8(0);\n                        } else {\n                            writer.writeU8(1);\n                            serializeField(schema, fieldName, value, fieldType.type, writer);\n                        }\n                        break;\n                    }\n                case \"map\":\n                    {\n                        writer.writeU32(value.size);\n                        value.forEach((val, key)=>{\n                            serializeField(schema, fieldName, key, fieldType.key, writer);\n                            serializeField(schema, fieldName, val, fieldType.value, writer);\n                        });\n                        break;\n                    }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        } else {\n            serializeStruct(schema, value, writer);\n        }\n    } catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType])=>{\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    } else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for(let idx = 0; idx < structSchema.values.length; ++idx){\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    } else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            } else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for(let i = 0; i < fieldType[1]; i++){\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            } else {\n                return reader.readArray(()=>deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for(let i = 0; i < length; i++){\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    } catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields){\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({\n            [fieldName]: fieldValue\n        });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2JvcnNoL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCSixPQUFPTyxjQUFjLENBQUNMLEdBQUdHLElBQUk7UUFBRUcsWUFBWTtRQUFNQyxLQUFLO1lBQWEsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUU7SUFBRTtBQUN0RixJQUFNLFNBQVNGLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlNLHFCQUFxQixJQUFLLElBQUksSUFBSSxDQUFDQSxrQkFBa0IsSUFBTVYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRVMsQ0FBQztJQUN6RlgsT0FBT08sY0FBYyxDQUFDTCxHQUFHLFdBQVc7UUFBRU0sWUFBWTtRQUFNSSxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU1QsQ0FBQyxFQUFFUyxDQUFDO0lBQ2RULENBQUMsQ0FBQyxVQUFVLEdBQUdTO0FBQ25CO0FBQ0EsSUFBSUUsYUFBYSxJQUFLLElBQUksSUFBSSxDQUFDQSxVQUFVLElBQUssU0FBVUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSTtJQUNqRixJQUFJQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVDLElBQUlILElBQUksSUFBSUgsU0FBU0UsU0FBUyxPQUFPQSxPQUFPakIsT0FBT3NCLHdCQUF3QixDQUFDUCxRQUFRQyxPQUFPQyxNQUFNTTtJQUMzSCxJQUFJ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QkFBcUI2RixNQUFNLEVBQUU0QixTQUFTLEVBQUUxRSxNQUFNLEVBQUU2RSxTQUFTekgsWUFBWTtJQUMxRSxNQUFNZ0gsU0FBUyxJQUFJUyxPQUFPN0U7SUFDMUIsT0FBT3lFLGtCQUFrQjNCLFFBQVE0QixXQUFXTjtBQUNoRDtBQUNBcEgsNEJBQTRCLEdBQUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9ib3JzaC9saWIvaW5kZXguanM/YjAzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlc2VyaWFsaXplVW5jaGVja2VkID0gZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5CaW5hcnlSZWFkZXIgPSBleHBvcnRzLkJpbmFyeVdyaXRlciA9IGV4cG9ydHMuQm9yc2hFcnJvciA9IGV4cG9ydHMuYmFzZURlY29kZSA9IGV4cG9ydHMuYmFzZUVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IGJzNThfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYnM1OFwiKSk7XG4vLyBUT0RPOiBNYWtlIHN1cmUgdGhpcyBwb2x5ZmlsbCBub3QgaW5jbHVkZWQgd2hlbiBub3QgcmVxdWlyZWRcbmNvbnN0IGVuY29kaW5nID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0ZXh0LWVuY29kaW5nLXV0Zi04XCIpKTtcbmNvbnN0IFJlc29sdmVkVGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwiZnVuY3Rpb25cIiA/IGVuY29kaW5nLlRleHREZWNvZGVyIDogVGV4dERlY29kZXI7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBSZXNvbHZlZFRleHREZWNvZGVyKFwidXRmLThcIiwgeyBmYXRhbDogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGJhc2VFbmNvZGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsIFwidXRmOFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJzNThfMS5kZWZhdWx0LmVuY29kZShCdWZmZXIuZnJvbSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbmZ1bmN0aW9uIGJhc2VEZWNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnM1OF8xLmRlZmF1bHQuZGVjb2RlKHZhbHVlKSk7XG59XG5leHBvcnRzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlO1xuY29uc3QgSU5JVElBTF9MRU5HVEggPSAxMDI0O1xuY2xhc3MgQm9yc2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZpZWxkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSkge1xuICAgICAgICB0aGlzLmZpZWxkUGF0aC5zcGxpY2UoMCwgMCwgZmllbGROYW1lKTtcbiAgICAgICAgLy8gTk9URTogTW9kaWZ5aW5nIG1lc3NhZ2UgZGlyZWN0bHkgYXMgamVzdCBkb2Vzbid0IHVzZSAudG9TdHJpbmcoKVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm9yaWdpbmFsTWVzc2FnZSArIFwiOiBcIiArIHRoaXMuZmllbGRQYXRoLmpvaW4oXCIuXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9yc2hFcnJvciA9IEJvcnNoRXJyb3I7XG4vLy8gQmluYXJ5IGVuY29kZXIuXG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvYyhJTklUSUFMX0xFTkdUSCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgbWF5YmVSZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGggPCAxNiArIHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmLCBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVVOCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDgodmFsdWUsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9XG4gICAgd3JpdGVVMTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQxNkxFKHZhbHVlLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIHdyaXRlVTMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSA0O1xuICAgIH1cbiAgICB3cml0ZVU2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDgpKSk7XG4gICAgfVxuICAgIHdyaXRlVTEyOCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDE2KSkpO1xuICAgIH1cbiAgICB3cml0ZVUyNTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCAzMikpKTtcbiAgICB9XG4gICAgd3JpdGVVNTEyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgNjQpKSk7XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAvLyBCdWZmZXIuZnJvbSBpcyBuZWVkZWQgYXMgdGhpcy5idWYuc3ViYXJyYXkgY2FuIHJldHVybiBwbGFpbiBVaW50OEFycmF5IGluIGJyb3dzZXJcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKSksXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHN0ciwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihiKTtcbiAgICB9XG4gICAgd3JpdGVGaXhlZEFycmF5KGFycmF5KSB7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20oYXJyYXkpKTtcbiAgICB9XG4gICAgd3JpdGVBcnJheShhcnJheSwgZm4pIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBhcnJheSkge1xuICAgICAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICAgICAgZm4oZWxlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeVdyaXRlciA9IEJpbmFyeVdyaXRlcjtcbmZ1bmN0aW9uIGhhbmRsaW5nUmFuZ2VFcnJvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IHByb3BlcnR5RGVzY3JpcHRvci52YWx1ZTtcbiAgICBwcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGlmIChbXCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFNcIiwgXCJFUlJfT1VUX09GX1JBTkdFXCJdLmluZGV4T2YoY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihcIlJlYWNoZWQgdGhlIGVuZCBvZiBidWZmZXIgd2hlbiBkZXNlcmlhbGl6aW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYpIHtcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmVhZFU4KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFUxNigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1Zi5yZWFkVUludDE2TEUodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJlYWRVMzIoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTY0KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoOCk7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUxMjgoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcigxNik7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUyNTYoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcigzMik7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFU1MTIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcig2NCk7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZEJ1ZmZlcihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0ICsgbGVuID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXhwZWN0ZWQgYnVmZmVyIGxlbmd0aCAke2xlbn0gaXNuJ3Qgd2l0aGluIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVhZFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcihsZW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTk9URTogVXNpbmcgVGV4dERlY29kZXIgdG8gZmFpbCBvbiBpbnZhbGlkIFVURi04XG4gICAgICAgICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFcnJvciBkZWNvZGluZyBVVEYtOCBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkRml4ZWRBcnJheShsZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMucmVhZEJ1ZmZlcihsZW4pKTtcbiAgICB9XG4gICAgcmVhZEFycmF5KGZuKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVThcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUxNlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTMyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVNjRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUxMjhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUyNTZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFU1MTJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFN0cmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkRml4ZWRBcnJheVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkQXJyYXlcIiwgbnVsbCk7XG5leHBvcnRzLkJpbmFyeVJlYWRlciA9IEJpbmFyeVJlYWRlcjtcbmZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFR5cGUsIHdyaXRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBtaXNzaW5nIHZhbHVlcyBwcm9wZXJseSAobWFrZSBzdXJlIHRoZXkgbmV2ZXIgcmVzdWx0IGluIGp1c3Qgc2tpcHBlZCB3cml0ZSlcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHdyaXRlcltgd3JpdGUke2NhcGl0YWxpemVGaXJzdExldHRlcihmaWVsZFR5cGUpfWBdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBmaWVsZFR5cGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEV4cGVjdGluZyBieXRlIGFycmF5IG9mIGxlbmd0aCAke2ZpZWxkVHlwZVswXX0sIGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUZpeGVkQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgZmllbGRUeXBlWzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gZmllbGRUeXBlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFeHBlY3RpbmcgYnl0ZSBhcnJheSBvZiBsZW5ndGggJHtmaWVsZFR5cGVbMV19LCBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVHlwZVsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgbnVsbCwgdmFsdWVbaV0sIGZpZWxkVHlwZVswXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVBcnJheSh2YWx1ZSwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGl0ZW0sIGZpZWxkVHlwZVswXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUua2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOCgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFR5cGUudHlwZSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBrZXksIGZpZWxkVHlwZS5rZXksIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgdmFsLCBmaWVsZFR5cGUudmFsdWUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEZpZWxkVHlwZSAke2ZpZWxkVHlwZX0gdW5yZWNvZ25pemVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCB2YWx1ZSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQm9yc2hFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuYWRkVG9GaWVsZFBhdGgoZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBvYmosIHdyaXRlcikge1xuICAgIGlmICh0eXBlb2Ygb2JqLmJvcnNoU2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqLmJvcnNoU2VyaWFsaXplKHdyaXRlcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0U2NoZW1hID0gc2NoZW1hLmdldChvYmouY29uc3RydWN0b3IpO1xuICAgIGlmICghc3RydWN0U2NoZW1hKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBDbGFzcyAke29iai5jb25zdHJ1Y3Rvci5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwic3RydWN0XCIpIHtcbiAgICAgICAgc3RydWN0U2NoZW1hLmZpZWxkcy5tYXAoKFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0pID0+IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBvYmpbZmllbGROYW1lXSwgZmllbGRUeXBlLCB3cml0ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmpbc3RydWN0U2NoZW1hLmZpZWxkXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3RydWN0U2NoZW1hLnZhbHVlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gc3RydWN0U2NoZW1hLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KGlkeCk7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIG9ialtmaWVsZE5hbWVdLCBmaWVsZFR5cGUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBVbmV4cGVjdGVkIHNjaGVtYSBraW5kOiAke3N0cnVjdFNjaGVtYS5raW5kfSBmb3IgJHtvYmouY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICB9XG59XG4vLy8gU2VyaWFsaXplIGdpdmVuIG9iamVjdCB1c2luZyBzY2hlbWEgb2YgdGhlIGZvcm06XG4vLy8geyBjbGFzc19uYW1lIC0+IFsgW2ZpZWxkX25hbWUsIGZpZWxkX3R5cGVdLCAuLiBdLCAuLiB9XG5mdW5jdGlvbiBzZXJpYWxpemUoc2NoZW1hLCBvYmosIFdyaXRlciA9IEJpbmFyeVdyaXRlcikge1xuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBvYmosIHdyaXRlcik7XG4gICAgcmV0dXJuIHdyaXRlci50b0FycmF5KCk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkZXJbYHJlYWQke2NhcGl0YWxpemVGaXJzdExldHRlcihmaWVsZFR5cGUpfWBdKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVHlwZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkVHlwZVswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZpeGVkQXJyYXkoZmllbGRUeXBlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVHlwZVsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBudWxsLCBmaWVsZFR5cGVbMF0sIHJlYWRlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQXJyYXkoKCkgPT4gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlWzBdLCByZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRUeXBlLmtpbmQgPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLnR5cGUsIHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUua2luZCA9PT0gXCJtYXBcIikge1xuICAgICAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLmtleSwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUudmFsdWUsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJvcnNoRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcikge1xuICAgIGlmICh0eXBlb2YgY2xhc3NUeXBlLmJvcnNoRGVzZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2xhc3NUeXBlLmJvcnNoRGVzZXJpYWxpemUocmVhZGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0U2NoZW1hID0gc2NoZW1hLmdldChjbGFzc1R5cGUpO1xuICAgIGlmICghc3RydWN0U2NoZW1hKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBDbGFzcyAke2NsYXNzVHlwZS5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwic3RydWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSBvZiBzY2hlbWEuZ2V0KGNsYXNzVHlwZSkuZmllbGRzKSB7XG4gICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzVHlwZShyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgaWYgKGlkeCA+PSBzdHJ1Y3RTY2hlbWEudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEVudW0gaW5kZXg6ICR7aWR4fSBpcyBvdXQgb2YgcmFuZ2VgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gc3RydWN0U2NoZW1hLnZhbHVlc1tpZHhdO1xuICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLCByZWFkZXIpO1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzVHlwZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtzdHJ1Y3RTY2hlbWEua2luZH0gZm9yICR7Y2xhc3NUeXBlLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG59XG4vLy8gRGVzZXJpYWxpemVzIG9iamVjdCBmcm9tIGJ5dGVzIHVzaW5nIHNjaGVtYS5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNjaGVtYSwgY2xhc3NUeXBlLCBidWZmZXIsIFJlYWRlciA9IEJpbmFyeVJlYWRlcikge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKTtcbiAgICBpZiAocmVhZGVyLm9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYFVuZXhwZWN0ZWQgJHtidWZmZXIubGVuZ3RoIC0gcmVhZGVyLm9mZnNldH0gYnl0ZXMgYWZ0ZXIgZGVzZXJpYWxpemVkIGRhdGFgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbi8vLyBEZXNlcmlhbGl6ZXMgb2JqZWN0IGZyb20gYnl0ZXMgdXNpbmcgc2NoZW1hLCB3aXRob3V0IGNoZWNraW5nIHRoZSBsZW5ndGggcmVhZFxuZnVuY3Rpb24gZGVzZXJpYWxpemVVbmNoZWNrZWQoc2NoZW1hLCBjbGFzc1R5cGUsIGJ1ZmZlciwgUmVhZGVyID0gQmluYXJ5UmVhZGVyKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVVbmNoZWNrZWQgPSBkZXNlcmlhbGl6ZVVuY2hlY2tlZDtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZCIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImkiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJfX2VzTW9kdWxlIiwicmVzdWx0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsImRlc2VyaWFsaXplVW5jaGVja2VkIiwiZGVzZXJpYWxpemUiLCJzZXJpYWxpemUiLCJCaW5hcnlSZWFkZXIiLCJCaW5hcnlXcml0ZXIiLCJCb3JzaEVycm9yIiwiYmFzZURlY29kZSIsImJhc2VFbmNvZGUiLCJibl9qc18xIiwicmVxdWlyZSIsImJzNThfMSIsImVuY29kaW5nIiwiUmVzb2x2ZWRUZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwidGV4dERlY29kZXIiLCJmYXRhbCIsIkJ1ZmZlciIsImZyb20iLCJkZWZhdWx0IiwiZW5jb2RlIiwiZGVjb2RlIiwiSU5JVElBTF9MRU5HVEgiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImZpZWxkUGF0aCIsIm9yaWdpbmFsTWVzc2FnZSIsImFkZFRvRmllbGRQYXRoIiwiZmllbGROYW1lIiwic3BsaWNlIiwiam9pbiIsImJ1ZiIsImFsbG9jIiwibWF5YmVSZXNpemUiLCJjb25jYXQiLCJ3cml0ZVU4Iiwid3JpdGVVSW50OCIsIndyaXRlVTE2Iiwid3JpdGVVSW50MTZMRSIsIndyaXRlVTMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVTY0Iiwid3JpdGVCdWZmZXIiLCJ0b0FycmF5Iiwid3JpdGVVMTI4Iiwid3JpdGVVMjU2Iiwid3JpdGVVNTEyIiwiYnVmZmVyIiwic3ViYXJyYXkiLCJ3cml0ZVN0cmluZyIsInN0ciIsImIiLCJ3cml0ZUZpeGVkQXJyYXkiLCJhcnJheSIsIndyaXRlQXJyYXkiLCJmbiIsImVsZW0iLCJoYW5kbGluZ1JhbmdlRXJyb3IiLCJwcm9wZXJ0eUtleSIsInByb3BlcnR5RGVzY3JpcHRvciIsIm9yaWdpbmFsTWV0aG9kIiwiYXJncyIsImFwcGx5IiwiZSIsIlJhbmdlRXJyb3IiLCJjb2RlIiwiaW5kZXhPZiIsIm9mZnNldCIsInJlYWRVOCIsInJlYWRVSW50OCIsInJlYWRVMTYiLCJyZWFkVUludDE2TEUiLCJyZWFkVTMyIiwicmVhZFVJbnQzMkxFIiwicmVhZFU2NCIsInJlYWRCdWZmZXIiLCJyZWFkVTEyOCIsInJlYWRVMjU2IiwicmVhZFU1MTIiLCJsZW4iLCJzbGljZSIsInJlYWRTdHJpbmciLCJyZWFkRml4ZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJyZWFkQXJyYXkiLCJBcnJheSIsInB1c2giLCJwcm90b3R5cGUiLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJzdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNlcmlhbGl6ZUZpZWxkIiwic2NoZW1hIiwiZmllbGRUeXBlIiwid3JpdGVyIiwiaXRlbSIsImtpbmQiLCJ0eXBlIiwic2l6ZSIsImZvckVhY2giLCJ2YWwiLCJzZXJpYWxpemVTdHJ1Y3QiLCJlcnJvciIsIm9iaiIsImJvcnNoU2VyaWFsaXplIiwic3RydWN0U2NoZW1hIiwibmFtZSIsImZpZWxkcyIsIm1hcCIsImZpZWxkIiwiaWR4IiwidmFsdWVzIiwiV3JpdGVyIiwiZGVzZXJpYWxpemVGaWVsZCIsInJlYWRlciIsImFyciIsIm9wdGlvbiIsIk1hcCIsInNldCIsImRlc2VyaWFsaXplU3RydWN0IiwiY2xhc3NUeXBlIiwiYm9yc2hEZXNlcmlhbGl6ZSIsImZpZWxkVmFsdWUiLCJSZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/borsh/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/borsh/node_modules/bs58/index.js":
/*!********************************************************!*\
  !*** ../node_modules/borsh/node_modules/bs58/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(ssr)/../node_modules/base-x/src/index.js\");\nvar ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2JvcnNoL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVc7QUFFZkMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYm9yc2gvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/MGZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOlsiYmFzZXgiLCJyZXF1aXJlIiwiQUxQSEFCRVQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/borsh/node_modules/bs58/index.js\n");

/***/ })

};
;